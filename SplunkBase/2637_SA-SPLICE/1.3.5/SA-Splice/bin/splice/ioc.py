#!/usr/bin/env python
import re
import sys
import time
import iptools

from StringIO import StringIO
from bson.objectid import ObjectId

from stix.core import STIXPackage
from stix.indicator import Indicator
from cybox.core import Object, Observable, Observables
from cybox.bindings import address_object
from stix.utils.parser import UnsupportedVersionError, UnknownVersionError
import cybox.bindings.cybox_core as cybox_core_binding

from splunklib.modularinput.event_writer import EventWriter
from lxml import etree

from splindicator import SPLIndicator
from parsers import *
from errors import *
import common as splcom

class IOC:
    """
    This is very lightweight view of what IOCs are, but enough to 
    use them properly in Splunk.
    """

    def load_from_file(self):
	try:
		f = open(self.path, "rb")
		self.content = f.read()
		f.close()
	except Exception, e:
		raise e

    def __init__(self, type="auto", path=None, path_size=0, path_mtime=None, content=None, parse_flag=True, 
			creation_time=None, revision=0, modification_time=None, stanza_name=None):

	self.raw_id = None # the one generated by Mongo when inserting the IOC File ('_id')
	self.ioc_id = None # the one found in the IOC File, or None if not present.

	self.type = type
	self.path = path
	self.path_size = path_size
	self.path_mtime= path_mtime # ioc file modification time
	self.content = content # will be erase if a file is provided

	self.parse_flag = parse_flag
	self.creation_time = creation_time
	self.revision = revision
	self.modification_time = modification_time # ioc modification time
	self.stanza_name = stanza_name # Name of the stanza like "ioc://My Repo"

	self.ew = EventWriter() # ew.log("INFO", "Hello !")

	if self.path :
		self.load_from_file()
	if creation_time == None:
		self.creation_time = time.time()

    # eof __init__

    def set_ioc_id(self, id):
	self.ioc_id = id

    def content_is_none(self):
	return (self.content == None)

    def set_revision(self, i):
	j = int(i)
	if j < 0 :
		raise ValueError(' a negative number for a revision number ? uh oh...')
	self.revision = j

    def set_modification_time(self, t):
	self.modification_time = t

    def set_parse_flag(self, b):
	if not isinstance(b, bool):
		raise ValueError(' parse_flag must be a boolean')
	self.parse_flag = b

    def from_dict(self, dict):
	"""
	build a IOC object from the provided dict. No args check.
	"""
	for (k,v) in dict.iteritems():
		if k == "_id" :
			self.__dict__['raw_id'] = v
		else:
			self.__dict__[k] = v

    def set_raw_id(self, id):
	if isinstance(id, basestring) :
		self.raw_id = ObjectId(id)
	else:
		self.raw_id = id

    def get_raw_id(self):
	return self.raw_id

    def get_ioc_id(self):
	return self.ioc_id

    def to_dict(self):
	o = {}
	for (k,v) in self.__dict__.iteritems():
		o[ k ] = v

	o.pop('ew', None) # don't store the logger!
	o.pop('raw_id', None) # don't store raw_id as its an alias name for _id

	return o
    # eof to_dict()

    def add_key(self, key, value):
	if key in self.__dict__ :
		raise ValueError(' key %s already exists in IOC definition' % key)
	self.__dict__[key] = value

    def get_path(self):
	return self.path

    def identify_ioc_format(self, ioc_content):
	"""
	Try to identify the IOC format based on the XMLNS.
	Return None when the format is unknown.
	"""
	reg_cybox = "xmlns:cybox=\"http://cybox\.mitre\.org/cybox-\d\""
	reg_stix  = "xmlns:stix=\"http://stix\.mitre\.org/stix-\d\""
	reg_openioc="xmlns=\"http://schemas\.mandiant\.com/\d+/ioc\""

	if re.search(reg_stix, ioc_content) :
		return "stix"
	if re.search(reg_cybox, ioc_content):
		return "cybox"
	if re.search(reg_openioc, ioc_content):
		return "openioc"
	return None


    def _split_cybox_list(self, value, delimiter='##comma##'):
	r = re.split(delimiter, value)
	return r

    def _parse_cybox_object(self, object_id, properties):
        """wrapper for CybOX Objects used by cybox and stix functions"""

        try:
                obj_type = properties['xsi:type']
        except:
                self.ew.log("ERROR", "no xsi:type in the properties=\"%s\"" % properties)
                return []

	# dynamically load the modules from parsers directory
	try:
		# ex: obj_type == AddressObjectType
		# ex: AddressObjectType.AddressObjectType(object_id, properties)
		module_name = 'splice.parsers.%s' % obj_type
		module      = sys.modules[ module_name ]
		obj         = getattr(module, obj_type)(object_id, properties)

		ret = obj.parse()

		if len(ret) == 0 :
			self.ew.log("WARN", "no atomic indicator extracted from object %s (object_id=%s)" % (module_name, object_id))

		# print out log messages
		for i in range(0, obj.number_of_log_messages):
			msg = obj.log_messages[i]
			self.ew.log(msg[0], msg[1])

	except KeyError, e:
		self.ew.log("WARN", "parser not found: %s" % module_name)
		return []
	except SpliceError, e:
		self.ew.log("ERROR", "caught a SpliceError: %s" % e)
		raise e
	except Exception, e:
		self.ew.log("ERROR", e)
		raise e
	return ret


    def _extract_atomic_indicators_stix(self):
	"""
	Extract atomic indicators from STIX (compatible with STIX 1.1, 1.1.1).
	will raise: "Your python-stix library supports STIX 1.1.1. Document version was 1.0"

	Encoding is painful. 
	 When the string (type('<str>')) is stored in the mongo db, the string becomes 
	 unicode (type('<unicode>')). If the STIX file contains 'encoding="UTF-8"' in 
	 it's headers and we don't convert the unicode string to UTF, lxml will raise 
	 the following error:
	     "ValueError: Unicode strings with encoding declaration are not supported.
	     Please use bytes input or XML fragments without declaration."
	"""

	try:
		stix_package = STIXPackage.from_xml( StringIO(self.content.encode('utf16')) )
	except Exception, e:
		raise e
	
	# getting the IOC id
	d = stix_package.to_dict()
	ioc_id = None
	if not 'id' in d :
		self.ew.log("WARN", "this IOC has no ID in its definition, that's a _bad_ practice.")
	else:
		ioc_id = d['id']
		self.set_ioc_id(d['id'])

	# Get CybOX Objects
	splunk_objects = []
	for child in stix_package.walk():
	
		# cybox.core.observable.Observables
		if not isinstance(child, Object):
			continue
		# {'properties': {'file_name': '1.rar', 'xsi:type': 'FileObjectType'}}
		c = child.to_dict()

		# we skip 'idref' objects as they only are relation objects.
		if 'idref' in c:
			self.ew.log("INFO", "ignoring relation object with idref=\"%s\"" %c['idref'])
			continue

		# the 'id' field is optional, great...
		try:
			indicator_id = c['id']
		except:
			indicator_id = None
			self.ew.log("WARN", "Found indicator with no id. Improper IOC definition (%s)." % ioc_id)

		# the real content is in the properties key.
		if not 'properties' in c:
			self.ew.log("WARN", "no \"properties\" attributes in this cybox object.")
			continue

		splunk_objects += self._parse_cybox_object(indicator_id, c['properties'])

	return splunk_objects


    def _extract_atomic_indicators_cybox(self):
	"""
	Extract atomic indicators from CybOX
	"""
	try:
		cybox_package = cybox_core_binding.parse( StringIO(self.content.encode('utf16')) )
		observables = Observables.from_obj( cybox_package )
		observables_dict = observables.to_dict()
	except Exception, e:
		raise e

	if not 'observables' in observables_dict:
		self.ew.log("WARNING", "no obseravles in this CybOX package")
		return []

	splunk_objects = []
	for child in observables_dict['observables']:
		if not 'object' in child:
			try:
				i = child['id']
			except:
				i = None
			self.ew.log("INFO", "skipping this child because it does not contains any object (id=\"%s\")" % i)
			continue

		o = Object.from_dict(child['object']).to_dict()

		if not 'properties' in o:
			self.ew.log("INFO", "skipping this child because it does not contains properties")
			continue

		try:
			object_id = o['id']
		except:
			object_id = None
		splunk_objects += self._parse_cybox_object(object_id, o['properties'] )

	return splunk_objects


    def _parse_openioc_indicator_item(self, object_id, indicator_item, context, content):
	ret = []
	
	if isinstance(context['attr'], type(None)) :
		self.ew.log("WARN", "unrecognized event for object_id=\"%s\"" % object_id)
		return []

	document = splcom.get_value_from_dict(context['attr'], 'document')
	if document == None :
		self.ew.log("WARN", "invalid parser for object_id=\"%s\"" % object_id)
		return []

	# dynamically load the modules from parsers directory
	try:
		# 'splice.parsers.FileItem'
		module_name = 'splice.parsers.%s' % document
		module      = sys.modules[ module_name ]
		obj         = getattr(module, document)(object_id, indicator_item, content, context)

		ret = obj.parse()

		if len(ret) == 0 :
			self.ew.log("WARN", "no atomic indicator extracted from object %s (object_id=%s)" % (module_name, object_id))

		# print out log messages
		for i in range(0, obj.number_of_log_messages):
			msg = obj.log_messages[i]
			self.ew.log(msg[0], msg[1])

	except KeyError, e:
		self.ew.log("WARN", "parser not found: %s" % module_name)
		return []
	except SpliceError, e:
		self.ew.log("ERROR", "caught a SpliceError: %s" % e)
		raise e
	except Exception, e:
		self.ew.log("ERROR", e)
		raise e
	return ret


    def _extract_atomic_indicators_openioc(self):
	"""
	Extract atomic indicators from OpenIOC
	"""
	try:
		doc  = etree.parse( StringIO(self.content.encode('utf8')) )
		root = doc.getroot()
	except Exception, e:
		raise ValueError(' failed to parse the OpenIOC with error: %s' % e)

	# TODO: extract id from the header

	# extract all atomic indicators
	splunk_objects = []
	for r in root.xpath("//*[local-name()='IndicatorItem']"):

		indicator_item = r.attrib
		object_id = splcom.get_value_from_dict(indicator_item, 'id')

		content = {'attr':None, 'text':None}
		context = {'attr':None, 'text':None}

		for c in r.iterchildren():
			reg  = re.search("^{[^}]+}(\S+)", c.tag)
			item = reg.group(1).lower()

			if item == "content" :
				content['attr'] = c.attrib
				content['text'] = c.text
			elif item == "context" :
				context['attr'] = c.attrib
				context['text'] = c.text
			elif item == "comment" :
				# maybe we should do something with this?
				self.ew.log("INFO", "found comments in openioc file - ignoring.")
			else:
				self.ew.log("WARN", "ignoring unrecognized tag %s" % c.tag)

		splunk_objects += self._parse_openioc_indicator_item(object_id, indicator_item, context, content)

	return splunk_objects


    def extract_contextual_information(self):
	return 0

    def extract_atomic_indicators(self, spldb):
	"""
	Extract atomic indicators composing the IOC
	"""
	fct = {
	'stix'    : self._extract_atomic_indicators_stix,
	'openioc' : self._extract_atomic_indicators_openioc,
	'cybox'   : self._extract_atomic_indicators_cybox
	}

	# First try to identify the IOC format
	if not self.type in fct :
		fmt = self.identify_ioc_format(self.content)
		if fmt == None :
			extra_info = ""
			if self.path != None :
				extra_info = "path=\"%s\"" % self.path
			raise UnrecognizedIOCFormatError('Failed to recognize the IOC format (%s).' % extra_info)
		self.type = fmt

	try:
		indicators = fct[self.type]()

		ioc_id = self.get_ioc_id() # None or id
		raw_id = self.get_raw_id() # Mongo ObjectId()

		spldb.update_ioc_id(raw_id, ioc_id)
		spldb.store_splindicator(raw_id, ioc_id, indicators)
	except Exception, e:
		raise e

	return len(indicators)

