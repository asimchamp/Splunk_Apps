<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<script src="/static/app/multidimensionalsearchapp/d3.v2.js"> </script>
<script src="/static/app/multidimensionalsearchapp/coffee-script.js"></script>

<style>
svg {
  width: 100%;
  height: 300px;
  border: solid 1px #ccc;
  background: #fff;
}

#background {
  fill: #fff;
}

.axis {
  shape-rendering: crispEdges;
}

.axis path, .axis line {
  stroke-width: 1px;
  fill: none;
  stroke: #000;
}
</style>


</head>
<body>

<table style="width:100%">
<tr>
  <td colspan="2">
    size: <select id="size-select"></select>
    color: <select id="color-select"></select>
    y: <select id="y-select"></select>
    x: <select id="x-select"></select>
    <span id="dimensions"></span>
    <button id="add-dimension">+</button>
    <button id="reset-dimensions">Reset</button>
  </td>
</tr>
<tr>
  <td style="width:33%">
    <div id="content"></div>
  </td>
  <td style="width:66%">
    <div id="pcoords"></div>
  </td>
</tr>
</table>
<script type="text/coffeescript">

# ------------------------------------------------------------------------
class MultidimensionalSearch
  constructor: (@content, @pcoords, @xselect, @yselect, @sizeselect, @colorselect, @dimensions, @adddim, @resetdim) ->
    @pause = true
    @svg = d3.select(@content).append("svg")
    @pcsvg = d3.select(@pcoords).append("svg")
    @padding = 50
    @paddingtop = 20
    @selects = @xselect + ',' + @yselect + ',' + @sizeselect + ',' + @colorselect
    @dimselects = @dimensions + ' select'

    $(@adddim).click =>
      dim = $('<select></select>')
      $(@dimensions).append(dim)
      @processData(@rows)
    $(@resetdim).click =>
      $(@dimensions).empty()
      @processData(@rows)

    $(@dimselects).change =>
      @processData(@rows)
    $(@selects).change =>
      @processData(@rows)

  start: ->
    # Start things rolling
    @pause = false
    setTimeout (=> @tick()), 1000

  stop: ->
    @pause = true

  computeDomain: (field, visfield) ->
    domain = {}
    if @types[field] == 'number'
      domain.min = @rows[0][field]
      domain.max = @rows[0][field]
      for d in @rows
        if typeof d[field] == 'number'
          d.vis[visfield] = d[field]
          domain.min = Math.min(domain.min, d[field])
          domain.max = Math.max(domain.max, d[field])
        else
          d.vis[visfield] = 0
      if !isFinite(domain.min)
        domain.min = 0
      if !isFinite(domain.max) or domain.min == domain.max
        domain.min = domain.min - 0.5
        domain.max = domain.min + 1
    else
      domain.values = []
      valueset = {}
      for d in @rows
        if valueset[d[field]] == undefined
          valueset[d[field]] = domain.values.length
          domain.values.push(d[field])
        d.vis[visfield] = d[field]
    return domain

  processData: (@rows) ->
    @svg.selectAll('circle').remove()
    @svg.selectAll('line').remove()
    @svg.selectAll('text').remove()
    @svg.selectAll('g').remove()
    @pcsvg.selectAll('line').remove()
    @pcsvg.selectAll('text').remove()
    @pcsvg.selectAll('g').remove()

    if !@rows? or @rows.length == 0
      return

    fields = []
    for key of @rows[0]
      if key != 'vis'
        fields.push(key)
    d3.selectAll(@selects).selectAll('option')
      .data(fields)
      .enter().append('option')
      .text((d) -> d.substring(0, 20))
      .attr("value", (d) -> d)
    d3.selectAll(@dimselects).selectAll('option')
      .data(fields)
      .enter().append('option')
      .text((d) -> d.substring(0, 20))
      .attr("value", (d) -> d)

    @types = {}
    for d in @rows
      d.vis = {}
      for key of d
        if key == 'vis'
          continue
        parsedNumber = parseFloat(d[key])
        if isFinite(parsedNumber)
          d[key] = parsedNumber
          @types[key] = 'number'
        else
          @types[key] = 'string'

    dims = []
    ydim = {}
    ydim.field = $(@yselect).val()
    ydim.domain = @computeDomain(ydim.field, 'dim0')
    ydim.range = [$(@content).height() - @padding, @paddingtop]
    if @types[ydim.field] == 'number'
      ydim.scale = d3.scale.linear()
        .domain([ydim.domain.min, ydim.domain.max])
        .range(ydim.range)
    else
      ydim.scale = d3.scale.ordinal()
        .domain(ydim.domain.values)
        .rangePoints(ydim.range, 1.0)
    dims.push(ydim)

    xdim = {}
    xdim.field = $(@xselect).val()
    xdim.domain = @computeDomain(xdim.field, 'dim1')
    xdim.range = [@padding, $(@content).width() - @paddingtop]
    if @types[xdim.field] == 'number'
      xdim.scale = d3.scale.linear()
        .domain([xdim.domain.min, xdim.domain.max])
        .range(xdim.range)
    else
      xdim.scale = d3.scale.ordinal()
        .domain(xdim.domain.values)
        .rangePoints(xdim.range, 1.0)
    dims.push(xdim)

    that = this
    d3.selectAll(@dimselects).each (d, i) ->
      dim = {}
      dim.field = $(this).val()
      dim.domain = that.computeDomain(dim.field, 'dim'+(i+2))
      dim.range = [$(that.content).height() - that.padding, that.paddingtop]
      if that.types[dim.field] == 'number'
        dim.scale = d3.scale.linear()
          .domain([dim.domain.min, dim.domain.max])
          .range(dim.range)
      else
        dim.scale = d3.scale.ordinal()
          .domain(dim.domain.values)
          .rangePoints(dim.range, 1.0)
      dims.push(dim)

    sizefield = $(@sizeselect).val()
    sizedomain = @computeDomain(sizefield, 'size')
    if @types[sizefield] == 'number'
      sizescale = d3.scale.linear()
        .domain([sizedomain.min, sizedomain.max])
        .range([5, 20])
    else
      sizescale = d3.scale.ordinal()
        .domain(sizedomain.values)
        .rangePoints([5, 20])

    colorfield = $(@colorselect).val()
    colordomain = @computeDomain(colorfield, 'color')
    if @types[colorfield] == 'number'
      colormid = (colordomain.min + colordomain.max) / 2
      colorscale = d3.scale.linear()
        .domain([colordomain.min, colormid, colordomain.max])
        .range(['#7f3b08', '#f7f7f7', '#2d004b'])
    else
      colors = [
        '#1b9e77',
        '#d95f02',
        '#7570b3',
        '#e7298a',
        '#66a61e',
        '#e6ab02',
        '#a6761d',
        '#666666'
      ]
      colorscale = d3.scale.ordinal().range(colors)
      for d in colordomain.values
        colorscale(d)

    xaxis = d3.svg.axis()
      .orient('bottom')
      .scale(xdim.scale)
      .ticks(10)
    @svg.append('g')
      .attr('class', 'axis')
      .attr('transform', 'translate(0,'+ydim.range[0]+')')
      .call(xaxis)
    @svg.append('text')
      .text(xdim.field.substring(0, 20))
      .attr('x', (xdim.range[0] + xdim.range[1])/2)
      .attr('y', ydim.range[0] + @padding - 15)
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('font-weight', 'bold')

    yaxis = d3.svg.axis()
      .orient('left')
      .scale(ydim.scale)
      .ticks(10)
    @svg.append('g')
      .attr('class', 'axis')
      .attr('transform', 'translate('+xdim.range[0]+',0)')
      .call(yaxis)
    ylabelx = xdim.range[0] - @padding + 15
    ylabely = (ydim.range[0] + ydim.range[1])/2
    @svg.append('text')
      .text(ydim.field.substring(0, 20))
      .attr('x', ylabelx)
      .attr('y', ylabely)
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('transform', "rotate(-90 #{ylabelx},#{ylabely})")
      .attr('font-weight', 'bold')

    @svg.selectAll('circle')
      .data(@rows)
      .enter().append('circle')
        .attr('cx', (d) => xdim.scale(d.vis.dim1))
        .attr('cy', (d) => ydim.scale(d.vis.dim0))
        .attr('r', (d) => sizescale(d.vis.size))
        .style('stroke', 'none')
        .style('fill', (d) => colorscale(d.vis.color))
        .style('fill-opacity', 0.75)
      .append('title')
        .text((d) =>
          return """
                 #{xdim.field.substring(0,20)} (x): #{d[xdim.field]}
                 #{ydim.field.substring(0,20)} (y): #{d[ydim.field]}
                 #{sizefield.substring(0,20)} (size): #{d[sizefield]}
                 #{colorfield.substring(0,20)} (color): #{d[colorfield]}
                 """)

    # Parallel coordinates

    xdim.range = ydim.range
    if @types[xdim.field] == 'number'
      xdim.scale.range(ydim.range)
    else
      xdim.scale.rangePoints(ydim.range, 1.0)
    workingarea = $(@pcoords).width() - 2*@padding
    for dim, i in dims
      dim.location = @padding + i*workingarea/(dims.length-1)

    @pcsvg.selectAll('text')
      .data(dims).enter().append('text')
      .text((d) -> d.field.substring(0,20))
      .attr('x', (d) -> d.location)
      .attr('y', @paddingtop - 5)
      .attr('text-anchor', 'middle')
      .style('font-weight', (d, i) -> if i < 2 then 'bold' else 'normal')

    for dim, i in dims
      if i == 0
        continue
      prevdim = dims[i-1]
      @pcsvg.selectAll('.segment'+i)
        .data(@rows)
        .enter().append('line')
          .attr('class', 'segment'+i)
          .attr('x1', prevdim.location)
          .attr('y1', (d) => prevdim.scale(d.vis['dim'+(i-1)]))
          .attr('x2', dim.location)
          .attr('y2', (d) => dim.scale(d.vis['dim'+i]))
          .style('stroke-width', (d) => sizescale(d.vis.size)/4)
          .style('stroke', (d) => colorscale(d.vis.color))
          .style('stroke-opacity', 0.75)
        .append('title')
          .text((d) =>
            return """
                   #{prevdim.field.substring(0,20)}: #{d[prevdim.field]}
                   #{dim.field.substring(0,20)}: #{d[dim.field]}
                   #{sizefield.substring(0,20)} (size): #{d[sizefield]}
                   #{colorfield.substring(0,20)} (color): #{d[colorfield]}
                   """)

    for dim in dims
      axis = d3.svg.axis()
        .orient('left')
        .scale(dim.scale)
        .ticks(10)
      @pcsvg.append('g')
        .attr('class', 'axis')
        .attr('transform', 'translate('+dim.location+',0)')
        .call(axis)


  tick: ->
    console.log "tick"
    if @pause
      return

    setTimeout (=> @tick()), 5000

    # Get new data
    if !@searchURL?
      console.log "no search url yet"
      return

    d3.json @searchURL, (data) => @processData(data)

# ------------------------------------------------------------------------
# Main routine

vis = new MultidimensionalSearch('#content', '#pcoords', '#x-select', '#y-select', '#size-select', '#color-select', '#dimensions', '#add-dimension', '#reset-dimensions')
vis.start()

# Splunk will call this when the query is ready
window.setSearchURL = (url) ->
  console.log "set searchURL"
  # Limit to 200 results
  vis.searchURL = url+"outputMode=json&count=200"

    </script>
  </body>
</html>
