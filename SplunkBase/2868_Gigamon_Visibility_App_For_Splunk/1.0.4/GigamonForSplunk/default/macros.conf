[giga_IDX]
definition = index=main

[giga_service(1)]
args = svcname
definition = eventtype=giga_idx sourcetype=gigamon:api:service:$svcname$

[giga_traffic(1)]
args = type
definition = `giga_service("traffic")` type=$type$

[calc_mb]
definition = eval megabytes = round(bytes/1024/1024,2)

[calc_gb]
definition = eval gigabytes = round(bytes/1024/1024/1024,2)

[calc_tb]
definition = eval terabytes = round(bytes/1024/1024/1024/1024,2)

[calc_bytes_deriv]
definition = `calc_mb`| `calc_gb` | `calc_tb`
 
[top_conversations(2)]
args = val,num
definition = `giga_traffic("conversation")` | `calc_bytes_deriv`|eval txnid = src_ip.":".dest_ip|stats max($val$) as $val$ by txnid | sort - $val$ | head $num$ | eval d=split(txnid,":")|eval src_ip = mvindex(d,0)|eval dest_ip = mvindex(d,1)| fields - d txnid | fields src_ip dest_ip $val$ | rename $val$ AS "Value ($val$)"

[top_apps(2)]
args = val, num
definition = `giga_traffic("app")` | `calc_bytes_deriv`|stats max($val$) as $val$ values(scope.portName) as portname by src_port | sort - $val$ | head $num$  | fields src_port portname $val$ | rename $val$ AS "Value ($val$)"

[top_protocols(2)]
args = val,num
definition = `giga_traffic("protocol")`| `calc_bytes_deriv`|stats max($val$) as $val$ values(protocol_number) as protocol_number by protocol | sort - $val$ | head $num$  | fields protocol protocol_number $val$ | rename $val$ AS "Value ($val$)"

[top_endpoints(2)]
args = val, num
definition =  `giga_traffic("endpoint")`|`calc_bytes_deriv`| stats max($val$) as $val$ values(src) as src_name by src_ip| sort - $val$ | head $num$ | fields src_ip src_name $val$ | rename $val$ AS "Value ($val$)"

[trafficAnalyzer(3)]
args = endpoint, val, num
definition = `top_$endpoint$($val$,$num$)`

[giga_service_domain_extract_member_info]
definition = rename members{}.boxId as box_id members{}.deviceIps{} as device_ips members{}.hostname as membername  members{}.healthState as health members{}.licensed as licensed members{}.lastConnectedTime as last_seen members{}.swVersion as version members{}.model as vendor_product members{}.deviceIp as ip members{}.masterPref as master_pref members{}.clusterMode as cluster_mode host as fmhost

[giga_service_domain_kv_extract]
definition =eval a=mvzip(clusterId,box_id)|eval b=mvzip(a,membername)|eval c=mvzip(b,health)|eval d=mvzip(c,licensed)|eval e=mvzip(d,last_seen)|eval f=mvzip(e,version)|eval g=mvzip(f,vendor_product)|eval h=mvzip(g,master_pref)|eval i=mvzip(h,cluster_mode)|eval device_ips=mvjoin(device_ips,":")|eval dips=device_ips|eval j=mvzip(i,dips)|eval ak=mvzip(j,fmhost)|eval l=mvzip(ak,ip)|eval k=mvzip(l,family)|table _time k|mvexpand k|eval k=split(k,",")|eval clusterId=mvindex(k,0)|eval box_id=mvindex(k,1)|eval membername=mvindex(k,2)|eval health=mvindex(k,3)|eval licensed=mvindex(k,4)|eval last_seen=mvindex(k,5)|eval version=mvindex(k,6)|eval vendor_product=mvindex(k,7)|eval master_pref=mvindex(k,8)|eval cluster_mode=mvindex(k,9)|eval device_ips=mvindex(k,10)|eval fmhost=mvindex(k,11)|eval src_ip=mvindex(k,12)|eval family=mvindex(k,13) |fields - k
### Master Pref - if set to 0, node is not eligible for the Master Role. 1-100 is how likely the node is to claim the Master role. 100 will always claim Master.

[giga_port_status]
definition = (`giga_service("port")` NOT tag=error  interfaceType=port)| stats latest(adminStatus) as adminStatus latest(operStatus) as operStatus  latest(configSpeed) as configSpeed latest(portType) as portType latest(timestamp) as timestamp latest(port_*) as * by clusterId portId | fields clusterId portId adminStatus operStatus configSpeed portType timestamp

[giga_port_sta]
definition =  (`giga_service("stats")`) | eval port_{metric} = value | stats latest(timestamp) as timestamp latest(port_*) as * by clusterId portId | fields port.* clusterId portId timestamp | rename port.* as *

[giga_port_stats_kv(2)]
args = clusterId, portId
definition = `giga_service("stats")` clusterId=$clusterId$ portId=$portId$ | head 1 | stats latest(*) as * | `port_fields` 

[giga_lookup_reset]
definition = inputlookup giga_clusters | search host=TheDoctor | outputlookup giga_fms |outputlookup giga_clusters | outputlookup giga_ports

[giga_port_status(2)]
args = clusterId, portId
definition = (`giga_service("port")`) OR (`giga_service("stats")`) OR (`giga_service("maps")`) NOT tag=error $portId$ clusterId=$clusterId$ 

[giga_cluster_status(1)]
args = clusterId
definition = (`giga_service("port")`) OR (`giga_service("node")`) OR (`giga_service("maps")`)  cluster=$clusterId$ OR clusterId=$clusterId$ | lookup giga_clusters clusterId 

[giga_port_summary_counts]
definition = `giga_psc_total`|`giga_psc_admin_status`|`giga_psc_oper_status` |`giga_psc_port_types`| stats values(item_*) as item_* by headline | fillnull value="no_display"

[giga_psc_admin_status]
definition = appendpipe [ stats count by adminStatus | `giga_headline("Administrative Status")` |eval item_{adminStatus} = adminStatus."|".count ]
[giga_psc_total]
definition = appendpipe [ stats count | `giga_headline("Total Ports")` | eval item_total = "&nbsp; |".count ]
[giga_psc_oper_status]
definition = appendpipe [ stats count by operStatus | `giga_headline("Operational Status")`|eval item_{operStatus} = operStatus."|".count ]
[giga_psc_port_types]
definition = appendpipe [ stats count by portType | `giga_headline("Port Types")`|eval item_{portType} = portType."|".count ]

[giga_port_extraction]
definition = rename chassisList{}.ports{}.* AS *

### KV Store Generator
[giga_cluster_kvstore_gen]
definition = `giga_service("node")` | `giga_service_domain_extract_member_info` | `giga_service_domain_kv_extract`|stats latest(*) as * by  membername clusterId |eval counter=3|inputlookup append=t giga_clusters | dedup membername clusterId sortby counter|eval counter=1|outputlookup giga_clusters

###KV Store Generator.
[giga_fms_kvstore_gen]
definition = (`giga_service("license")`) OR (`giga_service("users")`) NOT tag=error | eval counter = 0 |rename roles{} as roles|eval clusterUser = deviceAddress.":".httpUsername|eval fmuser = username.":".mvjoin(roles,";").":".enabled.":".fullName| eventstats values(fmuser) as fmusers values(clusterUser) as clusterUser by host | eval fmusers = mvjoin(fmusers,"|")|eval cus = mvjoin(clusterUser,"|")|stats latest(cus) as clusterUsers latest(fmusers) as fmusers  latest(hostMac) as mac_address latest(licensedVms) as licensedVms latest(vmDemoMode) as vmDemoMode latest(counter) as counter latest(timestamp) as timestamp latest(licensingSummary.baseBundle.sku) as license_sku latest(licensingSummary.baseBundle.type) as license_type by host |inputlookup giga_fms append=t | dedup host sortby counter | eventstats max(counter) as counter | eval counter=counter+1 | outputlookup giga_fms

[giga_ports_kvstore_gen]
definition = `giga_port_status` | eval counter = 0| inputlookup giga_ports append=t | dedup clusterId portId sortby counter | eval counter = 1 | outputlookup giga_ports

[giga_ports_sta_kvstore_gen]
definition = `giga_port_sta` | eval counter = 0| inputlookup giga_port append=t | dedup clusterId portId sortby counter | eval counter = 1 | outputlookup giga_port


[giga_cards_kvstore_gen]
definition = `giga_service("port")` interfaceType=card | inputlookup giga_cards append=t | dedup serialNumber | stats latest(*) as * by serialNumber clusterId| fields clusterId, healthState,host,hwRevision, hwType,operStatus, productCode, serialNumber, slotId, timestmap | outputlookup giga_cards

[giga_maps_kvstore_gen]
definition = `giga_service("maps")` | eval counter = 0 | stats values(dstPorts{}) as dstPorts values(srcPorts{}) as srcPorts latest(deviceIp) as deviceIp  latest(type) as type  latest(subType) as subType  latest(timestamp) as timestamp latest(_raw) as json by counter clusterId alias |inputlookup giga_maps append=t | dedup clusterId alias sortby counter |eval counter = 1| outputlookup giga_maps

[giga_smart_kvstore_gen]
definition = `giga_service("node")` interfaceType=gsGroup |foreach params.*.*  matchseg1="#matchseg1#" matchseg2="#matchseg2#" [ eval prms = mvappend(prms,"#matchseg1#")|eval prms_val = mvappend(prms_val,"#matchseg1#:#matchseg2#:".'<<FIELD>>' )] |append [ search `giga_service("node")` interfaceType=gsop | rename alias as gsop_alias |rename gsGroup as alias | foreach gsApps.*.*  matchseg1="#matchseg1#" matchseg2="#matchseg2#" [eval gsop_prms = mvappend(gsop_prms,"#matchseg1#") | eval gsop_prms_val = mvappend(gsop_prms_val,"#matchseg1#:#matchseg2#:".'<<FIELD>>')] ]|transaction alias clusterId |  stats latest(timestamp) as timestamp values(prms) as params values(prms_val) as params_attr values(ports{}) as ports values(gsop_prms) as gsop_gsApps values(gsop_prms_val) as gsop_gsApps_attr by clusterId alias gsop_alias | eval counter = 1 | inputlookup append=t | dedup clusterId alias gsop_alias counter | eval counter = 0 | outputlookup giga_smart

[lookup_maps]
definition = inputlookup giga_maps | fields "alias","clusterId","counter","json", deviceIp,dstPorts,srcPorts,subType,type,timestamp| fillnull value="none"

[giga_users_kvstore_gen]

[giga_error]
definition = eventtype=giga_error

[giga_syslogs]
definition = `giga_IDX` sourcetype=syslog

[giga_api]
definition = `giga_IDX` tag::sourcetype=gigamon_api

[giga_overview_api_events]
definition = metasearch `giga_api` NOT sourcetype=gigamonforsplunk:error 

[giga_overview_api_errors]
definition = metasearch `giga_api` sourcetype=GigamonForSplunk:error

[giga_unknown_errors]
definition = `giga_error` NOT eventtype=*

[giga_ports_base]
definition = inputlookup giga_ports |  fields - counter | lookup giga_clusters clusterId  OUTPUT _key as clusterKey cluster_mode family fmhost health

[giga_vue_health_base]
definition = inputlookup giga_fms | rename _key as fmkey |lookup giga_clusters fmhost AS host | rename fmkey as _key 

[giga_vue_health_fms]
definition = `giga_vue_health_base` |  eval cd = "{ \"t\":\"".now()."\" "| foreach clusterId last_seen [ eval cd = cd .", \"<<FIELD>>\":\"".<<FIELD>>."\"" ] | eval cd = cd." }"|stats values(cd) as clusterdetails last(mac_address) as mac_address last(vmDemoMode) as vmDemoMode values(last_seen) as last_seen values(clusterId) as clusterId last(licensedVms) as licensedVms last(_key) as _key last(clusterUsers) as clusterUsers last(fmusers) as fmusers last(license_sku) as license_sku last(license_type) as license_type by host

[giga_vue_fm_users]
definition = `giga_service("users")` |eval type = if(isnotnull(deviceAddress),"cluster","fm")| eval user = coalesce(username, httpUsername) | eval address=coalesce(deviceAddress,host) | stats latest(fullName) as fullName latest(enabled) as enabled values(roles{}) as roles latest(type) as type by user address host

[giga_vue_health_summary]
definition = `giga_vue_health_base`| `giga_vue_health_summary_clusters` |  `giga_vue_health_summary_hwsw`|`giga_vue_health_summary_fms`|`giga_vue_health_summary_health`|stats last(item_*) as item_* by headline |fillnull value="no_display"

[giga_vue_health_summary_clusters]
definition = appendpipe [ stats count by cluster_mode |appendpipe[eval cluster_mode="Total"| stats sum(count) as count by cluster_mode]|eval item_{cluster_mode} = cluster_mode."|".count | `giga_headline("Clusters")` |stats values(item_*) as item_* by headline]

[giga_vue_health_summary_fms]
definition = appendpipe[ stats sum(eval(if(vmDemoMode=="true",1,0))) as value1 sum(licensedVms) as value3 sum(eval(if(licensed=="false",1,0))) as value4 | `giga_headline("Fabric Managers")`|eval item_1="VM Demos|".value1|eval item_3="Licensed VMs|".value3|eval item_4="FM Invalid License|".value4]

[giga_vue_health_summary_hwsw]
definition = appendpipe [ stats dc(vendor_product) as value1 dc(version) as value2 dc(family) as value3 |`giga_headline("Hardware and Software")`|eval item_1="Models|".value1 |eval item_2="SW Versions|".value2|eval item_3="HW Series|".value3] 

[giga_vue_health_summary_health]
definition = appendpipe [ stats count as hlthCnt by health |eval health=case(health=="green","Normal",health=="red","Critical",health=="yellow","Warning",1==1,"Unknown")|eval item_{health} = health."|".hlthCnt |`giga_headline("Cluster Health")`| stats values(item_*) as item_* by headline]

[giga_headline(1)]
args = str
definition = eval headline="$str$"

[lookup_clusters]
definition = inputlookup giga_clusters

[giga_system_events]
definition =  `giga_IDX` `giga_service("event")` NOT tag=error

[giga_system_audit]
definition = `giga_IDX` `giga_service("audit")` NOT tag=error

[giga_system_audit_failures]
definition = `giga_system_audit` result=false

[giga_bundle_maps(4)]
args = clusterId, alias, type, subType
definition = `lookup_maps` |search clusterId=$clusterId$ alias=$alias$ type=$type$ subType=$subType$| eval clusterId = "gigamon.cid.cid_".replace(clusterId,"\.","_")| eval alias = "gigamon.map.map_".alias |appendpipe [`giga_bundle_maps_types`]|appendpipe [`giga_bundle_maps_ports`]|appendpipe [`giga_bundle_maps_maps`] |appendpipe [`giga_bundle_maps_clusters`]|fields json counter| where isnotnull(json) and isnull(counter)| mvcombine json | eval json = "[".mvjoin(json, ",")."]" |fields - counter

[giga_bundle_maps_types]
definition = stats count(type) as typeCnt count(subType) as subTypeCnt last(clusterId) as clusterId by type subType alias| appendpipe [ stats sum(typeCnt) as count values(alias) as imports last(clusterId) as clusterId by type | eval name = "gigamon.type.type_".type] |appendpipe [ stats sum(subTypeCnt) as count values(alias) as imports last(clusterId) as clusterId by subType  | eval name="gigamon.subtype.subType_".subType] |  where isnotnull(name) |eval json = "{\"name\":\"".name."\",\"imports\":[\"".mvjoin(imports,"\",\"")."\",\"".clusterId."\"]}" | fields json

[giga_bundle_maps_clusters]
definition = stats count values(alias) as alias by clusterId | eval json = "{\"name\":\"".clusterId."\",\"imports\":[\"".mvjoin(alias,"\",\"")."\"] }" |fields json

[giga_bundle_maps_maps]
definition = foreach srcPorts [ eval imports = mvappend(imports,"\"gigamon.src.srcPort_".replace('<<FIELD>>',"/","_")."\"") ] | foreach dstPorts [ eval imports = mvappend(imports,"\"gigamon.dst.dstPort_".replace('<<FIELD>>',"/","_")."\"") ] |eval imports = mvappend(imports,"\"gigamon.type.type_".type."\"")|eval imports = mvappend(imports,"\"gigamon.subtype.subType_".subType."\"")| stats values(imports) as imports count last(clusterId) as clusterId by alias | eval json = "{\"name\":\"".alias."\",\"imports\":[".mvjoin(imports,",").",\"".clusterId."\"]}" | fields json

[giga_bundle_maps_ports]
definition = stats count by dstPorts srcPorts alias clusterId | appendpipe [ stats sum(count) as count values(alias) as imports last(clusterId) as clusterId by dstPorts | rename dstPorts as name |eval name="gigamon.dst.dstPort_".replace(name,"/","_")] | appendpipe [ stats sum(count) as count values(alias) as imports last(clusterId) as clusterId by srcPorts|rename srcPorts as name | eval name="gigamon.src.srcPort_".replace(name,"/","_") ] |where isnotnull(name) |eval json = "{\"name\":\"".name."\",\"imports\":[\"".mvjoin(imports,"\",\"")."\",\"".clusterId."\"]}" | fields json
###ADD LOOKUP FOR CURRENT PORT STATUS

[giga_cubism_port_stats(2)]
args = clusterId, portId
definition = datamodel Gigamon Ports search | rename Statistics.* AS * |search metric=port.utilztn clusterId=$clusterId$ portId=$portId$ | rename value as utilization |bin _time bins=1300 | stats avg(utilization) as value min(eval(_time*1000)) as start by portId _time|streamstats window=2 current=f latest(start) as ls by portId | eval step = start - ls | rename start as stop ls as start portId as item| rename _time as time| sort item time | fillnull value=0 | eventstats max(value) as mxv min(value) as mnv by item | eval mnv = if(mnv<0,0,mnv)|eval isd = if(mnv==mxv,"Yes","No") | search isd="No" | fields - mxv mnv isd

[do_bin(1)]
args = myBins
definition = eval myBin = "$myBins$" | bin _time span="$myBins$"

[giga_cubism_port_stats_single(2)]
args = clusterId, portId
definition = datamodel Gigamon Ports search | rename Statistics.* AS * | search clusterId=$clusterId$ portId=$portId$ |`port_fields` | bin _time span=15m | eval time = (_time * 1000)  |stats avg(value) as value by metric time | eval start = time | eval item = replace(metric,"port.","") | lookup psd field as item  | streamstats window=2 global=f current=f first(value) as p_value first(time) as p_time by item| eval value=if(match(item,"utilztn"),value,value - p_value) |eval step = start - p_time |eval stop = start + step|fillnull value=0 | eventstats max(value) as mxv min(value) as mnv by item | eval mnv = if(mnv<0,0,mnv)|eval isd = if(mnv==mxv,"Yes","No") | search isd="No" |fields item,time,value,stop,start,step,description,excludes,units

[giga_cubism_map_stats_single(2)]
args = clusterId, mapName
definition = datamodel Gigamon Maps search | rename Statistics.* AS *|search clusterId=$clusterId$ mapName=$mapName$ | append [ |datamodel Gigamon Ports search | rename Statistics.* AS * |search clusterId=$clusterId$ [|noop |inputlookup giga_maps   | eval ports = mvappend(ports,srcPorts) | eval portId = mvappend(ports,dstPorts) | mvexpand portId|fields clusterId portId] ]|`giga_cubism_transform_short` 

[giga_cubism_stats_gsgroup(2)]
args = clusterId, alias
definition = clusterId=$clusterId$ context.gsGroup=$alias$ NOT context.gsop=* `giga_service("stats")`|rename context.gsGroup AS pmtype|`giga_cubism_transform_short`

[giga_cubism_stats_gsop(2)]
args = clusterId, alias
definition = clusterId=$clusterId$ context.gsGroup=$alias$ context.gsop=* `giga_service("stats")`|rename context.gsop AS pmtype|`giga_cubism_transform_short`

[giga_cubism_transform_short]
definition = eval pmtype = coalesce(pmtype,portId,mapName)|bin _time span=15m | eval time = (_time * 1000)|stats avg(value) as value by pmtype metric time |eval start = time | eval item = replace(metric,"(?:port|gsop|gsGroup)\.","")| lookup psd field as item  | eval item = pmtype." ".coalesce(description, item)|streamstats window=2 global=f current=f first(value) as p_value first(time) as p_time by item|eval step = start - p_time |eval stop = start + step |eval value=if(match(metric,".*utilztn.*"),value,value - p_value)|eval description = item|eventstats max(value) as mxv min(value) as mnv avg(step) as ast max(step) as step by item |eval mnv = if(mnv<0,0,mnv)| eval isd = if(mnv==mxv,"Yes","No") |search isd="No"|fields item,time,value,stop,start,step,description,excludes,units

[port_fields]
definition = fields metric port.* clusterId portId value

[gigamon_port_summary_gen_five_minutes]
definition = `giga_service("stats")` | stats min(*.rate) as per_five_m_min_*_rate max(*.rate) as per_five_m_max_*_rate avg(*.rate) as per_five_m_avg_*_rate by clusterId portId | eval interval = "perfivemin" | collect index=summary

[gigamon_port_summary_gen_one_hour]
definition = index=summary interval = "perfivemin" source = "Gigamon - 5 minute - Port Summary Gen" | stats min(per_five_m_avg_*) as per_hour_min_* max(per_five_m_avg_*) as per_hour_max_* avg(per_five_m_avg_*) as per_hour_avg_* stdevp(per_five_m_avg_*) as per_hour_stdevp_* by clusterId portId | eval interval="perhour" | collect index=summary

[gigamon_port_summary_gen_one_day]
definition = index=summary interval = "perhour" source = "Gigamon - 1 hour - Port Summary Gen" | stats min(per_hour_avg_*) as per_day_min_* max(per_hour_avg_*) as per_day_max_* avg(per_hour_avg_*) as per_day_avg_* stdevp(per_hour_avg_*) as per_day_stdevp_* by clusterId portId | eval interval="perday" | collect index=summary

[gigamon_backup_kvstores]
definition = index=*|head 1| eval lookups="giga_fms;giga_clusters;giga_ports;giga_maps;giga_cards"|eval lks=split(lookups,";") | stats count by lks |fields lks|map [| inputlookup $lks$ |outputlookup $lks$.csv ]

[gigamon_restore_kvstores]
definition = index=*|head 1| eval lookups="giga_fms;giga_clusters;giga_ports;giga_maps;giga_cards"|eval lks=split(lookups,";") | stats count by lks |fields lks|map [| inputlookup $lks$.csv |outputlookup $lks$ ]

[giga_map_rules(2)]
args = clusterId, alias
definition = `giga_service("maps")` clusterId=$clusterId$ alias=$alias$ | foreach rules.passRules{}.matches{}* [ eval passRules=mvappend(passRules,mvzip('rules.passRules{}.matches{}.type','rules.passRules{}.matches{}.value'))]|foreach rules.dropRules{}.matches{}* [ eval dropRules=mvappend(dropRules,mvzip('rules.dropRules{}.matches{}.type','rules.dropRules{}.matches{}.value'))] | fillnull value=na|stats count by alias dropRules passRules dstPorts{} clusterId | rename dstPorts{} AS dst_port |eval pr=split(passRules,",")|eval pr_type=mvindex(pr,0)|eval pr_value=mvindex(pr,1)|eval dr=split(dropRules,",")|eval dr_type=mvindex(dr,0)|eval dr_value=mvindex(dr,1)|fields - passRules dropRules pr dr|lookup giga_ports clusterId portId as dst_port OUTPUT operStatus portType

[accepted_eula]
definition = 0
iseval = true
