/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.15 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.15',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i == 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue,
                           [defQueue.length, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return  getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if(args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation that a build has been done so that
                //only one script needs to be loaded anyway. This may need to be
                //reevaluated if other use cases become common.
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one.
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                 //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

define("contrib/require", function(){});

// reference this from another build profile with mainConfigFile: './shared.build.profile.js'
require.config({
    baseUrl: '../',
    preserveLicenseComments: false,
    stubModules: ['contrib/text'],
    map: {
        "*": {
            css: "splunkjs/contrib/require-css/css"
        }
    },
    paths: {
        // paths outside of baseUrl
        'templates': '../../templates',

        // jQuery and contrib plugins
        'jquery': 'contrib/jquery-2.1.0',
        'jquery.history': 'contrib/jquery.history',
        'jquery.bgiframe': 'contrib/jquery.bgiframe-3.0.0',
        'jquery.cookie': 'contrib/jquery.cookie',
        'jquery.deparam': 'contrib/jquery.deparam',
        'jquery.fileupload': 'contrib/jquery.fileupload',
        'jquery.iframe-transport': 'contrib/jquery.iframe-transport',

        // internal jQuery plugins
        'splunk.jquery.csrf': 'splunk.jquery.csrf_protection',

        // jQuery UI plugins
        'jquery.ui.core': 'contrib/jquery-ui-1.10.4/jquery.ui.core',
        'jquery.ui.widget': 'contrib/jquery-ui-1.10.4/jquery.ui.widget',
        'jquery.ui.datepicker': 'contrib/jquery-ui-1.10.4/jquery.ui.datepicker',
        'jquery.ui.position': 'contrib/jquery-ui-1.10.4/jquery.ui.position',
        'jquery.ui.mouse': 'contrib/jquery-ui-1.10.4/jquery.ui.mouse',
        'jquery.ui.draggable': 'contrib/jquery-ui-1.10.4/jquery.ui.draggable',
        'jquery.ui.droppable': 'contrib/jquery-ui-1.10.4/jquery.ui.droppable',
        'jquery.ui.sortable': 'contrib/jquery-ui-1.10.4/jquery.ui.sortable',
        'jquery.ui.resizable': 'contrib/jquery-ui-1.10.4/jquery.ui.resizable',
        'jquery.ui.button': 'contrib/jquery-ui-1.10.4/jquery.ui.button',
        'jquery.ui.spinner': 'contrib/jquery-ui-1.10.4/jquery.ui.spinner',
        'jquery.ui.effect': 'contrib/jquery-ui-1.10.4/jquery.ui.effect',
        'jquery.ui.effect-slide': 'contrib/jquery-ui-1.10.4/jquery.ui.effect-slide',
        'tree.jquery': 'contrib/jqTree/tree.jquery',
        'jquery.resize': 'contrib/jquery-resize',

        // bootstrap components
        // FIXME: bootstrap.button collides with jquery.ui.button on the jQuery prototype !!
        'bootstrap.affix': 'contrib/bootstrap-2.3.1/bootstrap-affix',
        'bootstrap.alert': 'contrib/bootstrap-2.3.1/bootstrap-alert',
        'bootstrap.button': 'contrib/bootstrap-2.3.1/bootstrap-button',
        'bootstrap.carousel': 'contrib/bootstrap-2.3.1/bootstrap-carousel',
        'bootstrap.collapse': 'contrib/bootstrap-2.3.1/bootstrap-collapse',
        'bootstrap.dropdown': 'contrib/bootstrap-2.3.1/bootstrap-dropdown',
        'bootstrap.modal': 'contrib/bootstrap-2.3.1/bootstrap-modal',
        'bootstrap.popover': 'contrib/bootstrap-2.3.1/bootstrap-popover',
        'bootstrap.scrollspy': 'contrib/bootstrap-2.3.1/bootstrap-scrollspy',
        'bootstrap.tab': 'contrib/bootstrap-2.3.1/bootstrap-tab',
        'bootstrap.tooltip': 'contrib/bootstrap-2.3.1/bootstrap-tooltip',
        'bootstrap.transition': 'contrib/bootstrap-2.3.1/bootstrap-transition',
        'bootstrap.typeahead': 'contrib/bootstrap-2.3.1/bootstrap-typeahead',

        // other contrib libraries
        'moment': 'contrib/moment',
        'numeral': 'contrib/numeral',
        'underscore': 'contrib/underscore',
        'backbone': 'require/backbone',
        'highcharts': 'contrib/highcharts-4.0.4/highcharts',
        'highcharts.runtime_patches': 'contrib/highcharts-4.0.4/runtime_patches',
        'backbone_validation': 'contrib/backbone-validation-amd',
        'prettify': 'contrib/google-code-prettify/prettify',
        'intro': 'contrib/intro',

        /* augments builtin prototype */
        'strftime': 'contrib/strftime',
        'leaflet': 'contrib/leaflet/leaflet',
        'jg_global': 'contrib/jg_global',
        'jgatt': 'contrib/jg_library',
        'lowpro': 'contrib/lowpro_for_jquery',
        'spin': 'contrib/spin',
        'd3': 'require/d3_no_conflict',

        // Splunk legacy
        'splunk': 'splunk',
        'splunk.legend': 'legend',
        'splunk.logger': 'logger',
        'splunk.error': 'error',
        'splunk.util': 'util',
        'splunk.pdf': 'pdf',
        'splunk.i18n': 'stubs/i18n',
        'splunk.config': 'stubs/splunk.config',
        'splunk.paginator': 'paginator',
        'splunk.messenger': 'messenger',
        'splunk.time': 'splunk_time',
        'splunk.timerange': 'time_range',
        'splunk.window': 'window',
        'splunk.jabridge': 'ja_bridge',
        'splunk.print': 'print',
        'splunk.session': 'session',

        // splunkjs
        "async": "splunkjs/contrib/requirejs-plugins/async",
        "select2": "contrib/select2-3.4.6",

        // paths for deprecated versions of jquery
        'contrib/jquery-1.8.2': 'contrib/deprecated/jquery-1.8.2',
        'contrib/jquery-1.8.3': 'contrib/deprecated/jquery-1.8.3',
        'contrib/jquery-1.10.2': 'contrib/deprecated/jquery-1.10.2'
    },
    shim: {

        /* START splunkjs */
        'splunkjs/splunk': {
            deps: ['jquery'],
            exports: 'splunkjs'
        },

        /* Select2*/
        "select2/select2": {
            deps: ["jquery"],
            exports: "Select2",
            init: function($) {
                var Select2 = this.Select2;
                Select2.class.single.prototype.getPlaceholder = function() {
                    // if a placeholder is specified on a single select without a valid placeholder option ignore it
                    if (this.select) {
                        if (this.getPlaceholderOption() === undefined) {
                            return undefined;
                        }
                    }

                    return Select2.class.abstract.prototype.getPlaceholder.apply(this, arguments);

                }
                return Select2
            }
        },

        /* START contrib jQuery plugins */
        'jquery.cookie': {
            deps: ['jquery']
        },
         'jquery.fileupload': {
            deps: ['jquery']
        },
        'jquery.iframe-transport': {
        	deps: ['jquery']
        },
        'jquery.history': {
            deps: ['jquery'],
                exports: 'History'
        },
        'jquery.bgiframe': {
            deps: ['jquery']
        },

        "jquery.attributes": {
            deps: ['jquery']
        },

        "jquery.spin": {
            deps: ['jquery']
        },

        "jquery.sparkline": {
            deps: ['jquery']
        },

        "jquery.deparam": {
            deps: ['jquery'],
            exports: "jQuery.fn.deparam"
        },

        /* START internal jQuery plugins */
        'splunk.jquery.csrf_protection': {
            deps: ['jquery.cookie', 'splunk.util']
        },

        /* START jQuery UI plugins */
        'jquery.ui.core': {
            deps: ['jquery']
        },
        'jquery.ui.widget': {
            deps: ['jquery.ui.core']
        },
        'jquery.ui.position': {
            deps: ['jquery.ui.widget']
        },
        'jquery.ui.mouse': {
            deps: ['jquery.ui.widget']
        },
        'jquery.ui.sortable': {
            deps: ['jquery.ui.widget', 'jquery.ui.mouse', 'jquery.ui.draggable', 'jquery.ui.droppable']
        },
        'jquery.ui.draggable': {
            deps: ['jquery.ui.widget', 'jquery.ui.mouse']
        },
        'jquery.ui.droppable': {
            deps: ['jquery.ui.widget', 'jquery.ui.mouse']
        },
        'jquery.ui.resizable': {
            deps: ['jquery.ui.widget', 'jquery.ui.mouse']
        },
        'jquery.ui.datepicker': {
            deps: ['jquery', 'jquery.ui.widget', 'splunk.i18n'],
            exports: 'jquery.ui.datepicker',
            init: function(jQuery, widget, i18n) {
                var initFn = i18n.jQuery_ui_datepicker_install;
                if (typeof initFn === 'function') {
                    initFn(jQuery);
                }
                return jQuery.ui.datepicker;
            }
        },
        'jquery.ui.button': {
            deps: ['jquery.ui.widget', 'jquery.ui.core']
        },
        'jquery.ui.spinner': {
            deps: ['jquery.ui.widget', 'jquery.ui.core', 'jquery.ui.button']
        },
        'jquery.ui.effect': {
            deps: ['jquery.ui.core']
        },        
        'jquery.ui.effect-slide': {
            deps: ['jquery.ui.core', 'jquery.ui.effect']
        },
        'tree.jquery': {
            deps: ['jquery']
        },
        'jquery.resize': {
            deps: ['jquery'],
            init: function($) {
                // The plugin itself does not prevent bubbling of the resize events, add that here.
                $.event.special.elementResize.noBubble = true;
            }
        },
        
        // bootstrap components
        'bootstrap.affix': {
            deps: ['jquery']
        },
        'bootstrap.alert': {
            deps: ['jquery']
        },
        'bootstrap.button': {
            deps: ['jquery']
        },
        'bootstrap.carousel': {
            deps: ['jquery']
        },
        'bootstrap.collapse': {
            deps: ['jquery', 'bootstrap.transition']
        },
        'bootstrap.dropdown': {
            deps: ['jquery']
        },
        'bootstrap.modal': {
            deps: ['jquery']
        },
        'bootstrap.popover': {
            deps: ['jquery', 'bootstrap.tooltip']
        },
        'bootstrap.scrollspy': {
            deps: ['jquery']
        },
        'bootstrap.tab': {
            deps: ['jquery']
        },
        'bootstrap.tooltip': {
            deps: ['jquery']
        },
        'bootstrap.transition': {
            deps: ['jquery']
        },
        'bootstrap.typeahead': {
            deps: ['jquery']
        },

        /* START other contrib libraries */
        "backbone.nested": {
            // Not sure if needed
            deps: ['backbone'],
            exports: 'Backbone.NestedModel'
        },
        highcharts: {
            deps: ['jquery', 'highcharts.runtime_patches'],
            exports: 'Highcharts',
            init: function($, runtimePatches) {
                runtimePatches.applyPatches(this.Highcharts);
                return this.Highcharts;
            }
        },
        prettify: {
            exports: 'prettyPrint'
        },
        leaflet: {
            deps: ['jquery', 'splunk.util', 'splunk.config', 'helpers/user_agent', 'contrib/text!contrib/leaflet/leaflet.css'],
            exports: 'L',
            init: function($, SplunkUtil, splunkConfig, userAgent, css) {
                if (splunkConfig.INDEPENDENT_MODE) {
                    var imageUrl = require.toUrl('') + 'splunkjs/contrib/leaflet/images';
                    css = css.replace(/url\(images/g, 'url(' + imageUrl);
                }
                else {
                    // resolve image urls
                    css = css.replace(/url\(images/g, "url(" + SplunkUtil.make_url("/static/js/contrib/leaflet/images"));
                }
                // inject css into head
                $("head").append("<style type=\"text/css\">" + css + "</style>");

                // SPL-98647: monkey patch the getParamString method to avoid an XSS vulnerability in our
                // version of Leaflet.
                // See https://github.com/Leaflet/Leaflet/pull/1317/files
                if (this.L && this.L.Util) {
                    this.L.Util.getParamString = function(obj, existingUrl) {
                        var params = [];
                        for(var i in obj) {
                            if (obj.hasOwnProperty(i)) {
                                params.push(encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]));
                            }
                        }
                        return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
                    };
                }
            }
        },
        jg_global: {
            // export the dictionary of functions to a different variable, since in "wrapShim" mode require will
            // assign the return value from init to that global.
            exports: 'jg_globals',
            init: function() {
                this.jg_globals = {
                    jg_namespace: this.jg_namespace,
                    jg_extend: this.jg_extend,
                    jg_static: this.jg_static,
                    jg_mixin: this.jg_mixin,
                    jg_has_mixin: this.jg_has_mixin
                };
                return this.jg_globals;
            }
        },
        jgatt: {
            deps: ['jg_global'],
            exports: 'jgatt'
        },
        lowpro: {
            deps: ['jquery']
        },
        'contrib/d3': {
            deps: ['require/d3_pre_init'],
            exports: 'd3'
        },

        /* Start Splunk legacy */
        splunk: {
            exports: 'Splunk'
        },
        'splunk.util': {
            deps: ['jquery', 'splunk', 'splunk.config'],
            exports: 'Splunk.util',
            init: function($, Splunk, config) {
                return $.extend({ sprintf: this.sprintf }, Splunk.util);
            }
        },
        'splunk.legend': {
            deps: ['splunk'],
                exports: 'Splunk.Legend'
        },
        'splunk.logger': {
            deps: ['splunk', 'splunk.util'],
                exports: 'Splunk.Logger'
        },
        'splunk.error': {
            deps: ['jquery', 'splunk', 'splunk.logger'],
            exports: 'Splunk.Error'
        },
        'splunk.pdf': {
            deps: ['splunk', 'splunk.util', 'jquery'],
            exports: 'Splunk.pdf'
        },
        strftime: {
            deps: []
        },
        'splunk.paginator': {
            deps: ['splunk'],
                exports: 'Splunk.paginator'
        },
        'splunk.jquery.csrf': {
            deps: ['jquery', 'jquery.cookie', 'splunk.util']
        },
        'splunk.messenger': {
            deps: ['splunk', 'splunk.util', 'splunk.logger', 'splunk.i18n', 'lowpro'],
            exports: 'Splunk.Messenger'
        },
        'splunk.time': {
            deps: ['jg_global', 'jgatt'],
            exports: 'splunk.time'
        },
        'splunk.timerange': {
            deps: ['splunk', 'splunk.util', 'splunk.logger', 'splunk.i18n', 'splunk.time', 'lowpro'],
            exports: 'Splunk.Timerange',
            init: function(Splunk) {
                Splunk.namespace("Globals");
                if (!Splunk.Globals.timeZone) {
                    Splunk.Globals.timeZone = new Splunk.TimeZone(Splunk.util.getConfigValue('SERVER_ZONEINFO'));
                }
                return Splunk.TimeRange;
            }
        },
        'splunk.window': {
            deps: ['splunk', 'splunk.util', 'splunk.i18n'],
            exports: 'Splunk.window'
        },
        'splunk.jabridge': {
            deps: ['splunk'],
            exports: 'Splunk.JABridge'
        },
        'splunk.print': {
            deps: ['jquery', 'lowpro', 'splunk', 'splunk.logger'],
            exports: 'Splunk.Print'
        },
        'splunk.session': {
            deps: ['lowpro', 'splunk', 'jquery', 'splunk.logger', 'splunk.util'],
            exports: 'Splunk.Session'
        },

        // shim handlers for the various versions of jquery
        
        'contrib/jquery-2.1.0': {
            exports: 'jQuery'
        },
        'contrib/jquery-1.10.2': {
            exports: 'jQuery',
            init: function() {
                if(this.console && typeof this.console.warn === 'function') {
                    this.console.warn('You are using a deprecated version of jQuery, please upgrade to the latest version');
                }
                return this.jQuery;
            }
        },
        'contrib/jquery-1.8.2': {
            exports: 'jQuery',
            init: function() {
                if(this.console && typeof this.console.warn === 'function') {
                    this.console.warn('You are using a deprecated version of jQuery, please upgrade to the latest version');
                }
                return this.jQuery;
            }
        },
        'contrib/jquery-1.8.3': {
            exports: 'jQuery',
            init: function() {
                if(this.console && typeof this.console.warn === 'function') {
                    this.console.warn('You are using a deprecated version of jQuery, please upgrade to the latest version');
                }
                return this.jQuery;
            }
        }
    }
})


;
define("profiles/shared", function(){});

/*!
 * jQuery JavaScript Library v2.1.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-23T21:10Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var trim = "".trim;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return a 'clean' array
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return just the object
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return obj - parseFloat( obj ) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Support: Firefox <20
		// The try/catch suppresses exceptions thrown when attempting to access
		// the "constructor" property of certain host objects, ie. |window.location|
		// https://bugzilla.mozilla.org/show_bug.cgi?id=814622
		try {
			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}
		} catch ( e ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android < 4.0, iOS < 6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	trim: function( text ) {
		return text == null ? "" : trim.call( text );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.16
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-13
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select t=''><option selected=''></option></select>";

			// Support: IE8, Opera 10-12
			// Nothing should be selected when empty strings follow ^= or $= or *=
			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
				}
				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android < 4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Math.random();
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android < 4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



/*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {
						name = attrs[ i ].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.slice(5) );
							dataAttr( elem, name, data[ name ] );
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) );

	// #11217 - WebKit loses check when the name is after the checked attribute
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE9-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome < 28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				// Support: Android < 4.0
				src.defaultPrevented === undefined &&
				src.getPreventDefault && src.getPreventDefault() ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE 9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE 9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Support: IE >= 9
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Support: IE >= 9
		// Fix Cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Fixes #12346
					// Support: Webkit, IE
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, events, type, key, j,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					events = Object.keys( data.events || {} );
					if ( events.length ) {
						for ( j = 0; (type = events[j]) !== undefined; j++ ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') in IE9, see #12537
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
		divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;" +
			"-moz-box-sizing:content-box;box-sizing:content-box",
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;" +
		"margin-top:1px";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
		div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;" +
			"position:absolute;top:1%";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Use window.getComputedStyle because jsdom on node.js will break without it.
	if ( window.getComputedStyle ) {
		jQuery.extend(support, {
			pixelPosition: function() {
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );
				marginDiv.style.cssText = div.style.cssText = divReset;
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );

				// Clean up the div for other support tests.
				div.innerHTML = "";

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css(elem, "display") );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Support: Chrome, Safari
				// Setting style to blank string required to delete "style: x !important;"
				style[ name ] = "";
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );
		// Get default display if display is currently "none"
		if ( display === "none" ) {
			display = defaultDisplay( elem.nodeName );
		}
		if ( display === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS 5.1, Android 4.x, Android 2.3
	// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
	support.checkOn = input.value !== "";

	// Must access the parent to make an option select properly
	// Support: IE9, IE10
	support.optSelected = opt.selected;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Check if an input maintains its value after becoming a radio
	// Support: IE9, IE10
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				// Do send the request
				// This may raise an exception which is actually
				// handled in jQuery.ajax (so no try/catch here)
				xhr.send( options.hasContent && options.data || null );
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// We assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate, context) {
    predicate = lookupIterator(predicate);
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate.call(context, elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define('contrib/backbone',['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

/* version 0.1: http://dren.ch/ */

Number.prototype.pad =
	function (n,p) {
		var s = '' + this;
		p = p || '0';
		while (s.length < n) s = p + s;
		return s;
	};

Date.prototype.months = [
		'January', 'February', 'March', 'April', 'May', 'June', 'July',
		'August', 'September', 'October', 'November', 'December'
	];
Date.prototype.weekdays = [
		'Sunday', 'Monday', 'Tuesday', 'Wednesday',
		'Thursday', 'Friday', 'Saturday'
	];
Date.prototype.dpm = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];

Date.prototype.strftime_f = {
		A: function (d) { return d.weekdays[d.getDay()] },
		a: function (d) { return d.weekdays[d.getDay()].substring(0,3) },
		B: function (d) { return d.months[d.getMonth()] },
		b: function (d) { return d.months[d.getMonth()].substring(0,3) },
		C: function (d) { return Math.floor(d.getFullYear()/100); },
		c: function (d) { return d.toString() },
		D: function (d) {
				return d.strftime_f.m(d) + '/' +
					d.strftime_f.d(d) + '/' + d.strftime_f.y(d);
			},
		d: function (d) { return d.getDate().pad(2,'0') },
		e: function (d) { return d.getDate()},
		F: function (d) {
				return d.strftime_f.Y(d) + '-' + d.strftime_f.m(d) + '-' +
					d.strftime_f.d(d);
			},
		H: function (d) { return d.getHours().pad(2,'0') },
		I: function (d) { return ((d.getHours() % 12 || 12).pad(2)) },
		j: function (d) {
				var t = d.getDate();
				var m = d.getMonth() - 1;
				if (m > 1) {
					var y = d.getYear();
					if (((y % 100) == 0) && ((y % 400) == 0)) ++t;
					else if ((y % 4) == 0) ++t;
				}
				while (m > -1) t += d.dpm[m--];
				return t.pad(3,'0');
			},
		k: function (d) { return d.getHours().pad(2,' ') },
		l: function (d) { return ((d.getHours() % 12 || 12)) },
		M: function (d) { return d.getMinutes().pad(2,'0') },
		m: function (d) { return (d.getMonth()+1).pad(2,'0') },
		n: function (d) { return "\n" },
		p: function (d) { return (d.getHours() > 11) ? 'PM' : 'AM' },
		
		Q: function (d) { return (d.getMilliseconds()==0) ? "000" : d.getMilliseconds().pad(3,'0')},
		
		R: function (d) { return d.strftime_f.H(d) + ':' + d.strftime_f.M(d) },
		r: function (d) {
				return d.strftime_f.I(d) + ':' + d.strftime_f.M(d) + ':' +
					d.strftime_f.S(d) + ' ' + d.strftime_f.p(d);
			},
		S: function (d) { return d.getSeconds().pad(2,'0') },
		s: function (d) { return Math.floor(d.getTime()/1000) },
		T: function (d) {
				return d.strftime_f.H(d) + ':' + d.strftime_f.M(d) + ':' +
					d.strftime_f.S(d);
			},
		t: function (d) { return "\t" },
/*		U: function (d) { return false }, */
		u: function (d) { return(d.getDay() || 7) },
/*		V: function (d) { return false }, */
		v: function (d) {
				return d.strftime_f.e(d) + '-' + d.strftime_f.b(d) + '-' +
					d.strftime_f.Y(d);
			},
/*		W: function (d) { return false }, */
		w: function (d) { return d.getDay() },
		X: function (d) { return d.toTimeString() }, // wrong?
		x: function (d) { return d.toDateString() }, // wrong?
		Y: function (d) { return d.getFullYear() },
		y: function (d) { return (d.getYear() % 100).pad(2) },
		z: function (d) { return '' }, // don't support time offset rendering
		Z: function (d) { return '' }, // don't support time offset rendering
		'%': function (d) { return '%' }
	};

Date.prototype.strftime_f['+'] = Date.prototype.strftime_f.c;
Date.prototype.strftime_f.h = Date.prototype.strftime_f.b;


Date.prototype.strftime = // revised 1/23/08 jthane for performance
	function (fmt) {
    var rv;
    if (rv = this[fmt]) return rv;  // caching reduces avg. time from .32ms to .06ms for typical actions
    
		var r = []; // '';
		var n = 0;
		while(n < fmt.length) {
			var c = fmt.charAt(n);
			if (c == '%') {
				c = fmt.charAt(++n);
				r.push((this.strftime_f[c]) ? this.strftime_f[c](this) : c);
			} else r.push(c);
			++n;
		}
    return this[fmt] = r.join('');
	};
define("strftime", function(){});

(function(global) {

if (typeof global.Splunk=="undefined" || !global.Splunk) {
    /**
     * The Splunk global namespace object.  If Splunk is defined, the
     * existing Splunk object will not be overwritten so that existing
     * namespaces are preserved.
     */
    global.Splunk = {};
}
/**
 * Returns the namespace specified and creates it if it doesn't exist
 * <pre>
 * Splunk.namespace("property.package");
 * Splunk.namespace("Splunk.property.package");
 * </pre>
 * Either of the above would create Splunk.property, then
 * Splunk.property.package
 *
 * @method namespace
 * @static
 * @param  {String} name A "." delimited namespace to create
 * @return {Object} A reference to the last namespace object created
 */
global.Splunk.namespace = function(name) {
    var parts = name.split(".");
    var obj = Splunk;
    for (var i=(parts[0]=="Splunk")?1:0; i<parts.length; i=i+1) {
        obj[parts[i]] = obj[parts[i]] || {};
        obj = obj[parts[i]];
    }
    return obj;
};

})(this);

define("splunk", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Splunk;
    };
}(this)));

define('splunk.config',[],function() {
    return window.$C;
});
(function(global) {

Splunk.namespace("util");

Splunk.util = {


    /**
     * Assign empty handlers for logger calls. Overriden by Splunk.Logger if it is imported.
     */
    logger : {
        "info":function(){},
        "log":function(){},
        "debug":function(){},
        "warn":function(){},
        "error":function(){}
    },

    /**
     * Converts an object literal to an encoded querystring key/value string.
     *
     */
    propToQueryString: function(dictionary) {
        var o = [];
        var val;
        for (var prop in dictionary) {
            val = dictionary[prop];
            o.push(encodeURIComponent(prop) + '=' + encodeURIComponent(val));
        }
        return o.join('&');
    },

    /**
     * Converts a flat querystring into an object literal
     *
     */
    queryStringToProp: function(args) {
        args = this.trim(args, '&\?#');
        if (!args || args.length == 0) {
            return {};
        }    
        
        var parts = args.split('&');
        var output = {};
        
        var key;
        var value;
        var equalsSegments;
        var lim = parts.length;
        for (var i=0,l=lim; i<l; i++) {
            equalsSegments = parts[i].split('=');
            key = decodeURIComponent(equalsSegments.shift());
            value = equalsSegments.join("=");
            output[key] = decodeURIComponent(value.replace(/\+/g, ' '));
        }
        return output;
    },

    /**
     * Extracts the fragment identifier value.
     */
    getHash: function(){
    var hashPos = window.location.href.indexOf('#');

    if (hashPos == -1) {
        return "";
    }

    var qPos = window.location.href.indexOf('?', hashPos);

    if (qPos != -1)
        return window.location.href.substr(qPos);

    return window.location.href.substr(hashPos);
    },

    /**
     * This was ported, rewritten a bit and greatly simplified from the
     * same method in the old Calendar object we used to use.
     * TODO - it is only here temporarily, and we should continue trying to
     * kill it.
     */
    parseDate : function(str, fmt) {

        if ((!str) || (!str.indexOf) || (str.indexOf("mm")==0)) return null;

        var y = 0;
        var m = -1;
        var d = 0;
        var a = str.split(/\W+/);
        var b = fmt.match(/%./g);
        var i = 0, j = 0;
        var hr = 0;
        var min = 0;
        var sec = 0;

        for (i = 0; i < a.length; ++i) {
            if (!a[i])
                continue;
            switch (b[i]) {
                case "%d":
                    d = parseInt(a[i], 10);
                    break;

                case "%m":
                    m = parseInt(a[i], 10) - 1;
                    break;

                case "%Y":
                case "%y":
                    y = parseInt(a[i], 10);
                    (y < 100) && (y += (y > 29) ? 1900 : 2000);
                    break;

                case "%H":
                    hr = parseInt(a[i], 10);
                    break;

                case "%M":
                    min = parseInt(a[i], 10);
                    break;

                case "%S":
                    sec = parseInt(a[i], 10);
                    break;

                default:
                    break;
            }
        }
        if (y != 0 && m != -1 && d != 0) {
            var ourDate = new Date(y, m, d, hr, min, sec);
            return ourDate;
        } else {
            //this.logger.warn('unable to parse date "' + str + '" into "' + fmt + '"');
            return false;
        }
    },
    /**
     * Given a timezone offset in minutes, and  a JS Date object,
     * returns the delta in milliseconds, of the two timezones.
     * Note that this will include the offset contributions from DST for both.
     */
    getTimezoneOffsetDelta: function(serverOffsetThen, d) {
        if (!Splunk.util.isInt(serverOffsetThen)) {
            return 0;
        }
        // what JS thinks the timezone offset is at the time given by d. This WILL INCLUDE DST
        var clientOffsetThen = d.getTimezoneOffset() * 60;
        // what splunkd told is the actual timezone offset.
        serverOffsetThen     = serverOffsetThen * -60;

        return 1000 * (serverOffsetThen - clientOffsetThen);
    },

    getEpochTimeFromISO: function(isoStr) {
        // lazily init the regex so we only do it only if necessary and only once.
        if (!this._isoTimeRegex) {
            // Nobody doesnt like ISO.
            this._isoTimeRegex = /([\+\-])?(\d{4,})(?:(?:\-(\d{2}))(?:(?:\-(\d{2}))(?:(?:[T ](\d{2}))(?:(?:\:(\d{2}))(?:(?:\:(\d{2}(?:\.\d+)?)))?)?(?:(Z)|([\+\-])(\d{2})[:]*(\d{2})?)?)?)?)?/;
        }
        var m = this._isoTimeRegex.exec(isoStr);
        // put it into a string form that JS Date constructors can actually deal with.

        // Being Super Careful: calling substring on undefined variable
        // here throws an exception that kills the stack but doesnt
        // appear in firebug nor even in the Error Console.
        var seconds, millisecondsStr;
        if (m[7]) {
            seconds = m[7].substring(0,2);
            // Note this includes the period.  ie ".003"
            millisecondsStr = m[7].substring(2);
        } else {
            millisecondsStr = "";
        }
        /*jshint -W061:false */
        // If m[11] is undefined, use 0 instead.
        var offset = eval(m[9] + (60*m[10] + parseInt(m[11] || 0, 10)));
        /*jshint -W061:true */

        var str = sprintf("%s/%s/%s %s:%s:%s", m[3], m[4], m[2], m[5], m[6], seconds);
        // its still wrong, because JS will interpret this time in localtime,
        // AND if you give IE the timezone part of the string, it passes out in its own vomit.
        var t = new Date(str);

        // so we patch it.
        t.setTime(t.getTime() + this.getTimezoneOffsetDelta(offset, t));
        var startTime = t.getTime() / 1000;

        return startTime + millisecondsStr;
    },

    getConfigValue: function(configKey, optionalDefault) {
        if (window.$C && window.$C.hasOwnProperty(configKey)) return window.$C[configKey];
        else if (configKey === 'FORM_KEY') {
            // maintain backwards compatibility now that we've moved the form_key from config endpoint to cookie
            return this.getFormKey();
        } else {
            if (typeof optionalDefault != 'undefined') { // ensure optionalDefault can be set to 'false'
                // util.logger will have been swapped out by the Logger when Logger
                // has already been setup, but still works when its not.

                //this.logger.debug('getConfigValue - ' + configKey + ' not set, defaulting to ' + optionalDefault);
                return optionalDefault;
            }

            throw new Error('getConfigValue - ' + configKey + ' not set, no default provided');
        }
    },

    getCookie: function(name) {
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = $.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    },

    getFormKey: function() {
        var cookieName = "splunkweb_csrf_token_" + Splunk.util.getConfigValue('MRSPARKLE_PORT_NUMBER', '');
        var cookieValue = Splunk.util.getCookie(cookieName);
        if (cookieValue) {
            return cookieValue;
        }
        return "";
    },

    /**
     * Returns a proper path that is relative to the current appserver location.
     * This is critical to ensure that we are proxy compatible. This method
     * takes 1 or more arguments, which will all be stiched together in sequence.
     *
     * Ex: make_url('search/job'); // "/splunk/search/job"
     * Ex: make_url('/search/job'); // "/splunk/search/job"
     * Ex: make_url('/search', '/job'); // "/splunk/search/job"
     * Ex: make_url('/search', '/job', 1234); // "/splunk/search/job/1234"
     *
     * Static paths are augmented with a cache defeater
     *
     * Ex: make_url('/static/js/foo.js'); // "/splunk/static/@12345/js/foo.js"
     * Ex: make_url('/static/js/foo.js'); // "/splunk/static/@12345.1/js/foo.js"
     *
     * @param path {String} The relative path to extend
     */
    make_url: function() {
        var output = '', seg, len;
        for (var i=0,l=arguments.length; i<l; i++) {
            seg = arguments[i].toString();
            len = seg.length;
            if (len > 1 && seg.charAt(len-1) == '/') {
                seg = seg.substring(0, len-1);
            }
            if (seg.charAt(0) != '/') {
                output += '/' + seg;
            } else {
                output += seg;
            }
        }

        // augment static dirs with build number
        if (output!='/') {
            var segments = output.split('/');
            var firstseg = segments[1];
            if (firstseg=='static' || firstseg=='modules') {
                var postfix = output.substring(firstseg.length+2, output.length);
                output = '/'+firstseg+'/@' + window.$C['BUILD_NUMBER'];
                if (window.$C['BUILD_PUSH_NUMBER']) output += '.' + window.$C['BUILD_PUSH_NUMBER'];
                if (segments[2] == 'app')
                    output += ':'+this.getConfigValue('APP_BUILD', 0);
                output += '/' + postfix;
            }
        }

        var root = Splunk.util.getConfigValue('MRSPARKLE_ROOT_PATH', '/');
        var djangoRoot = Splunk.util.getConfigValue('DJANGO_ROOT_PATH', '');
        var locale = Splunk.util.getConfigValue('LOCALE', 'en-US');
        
        var combinedPath = "";
        if (djangoRoot && output.substring(0, djangoRoot.length) === djangoRoot) {
            combinedPath = output.replace(djangoRoot, djangoRoot + "/" + locale.toLowerCase());
        } else {
            combinedPath = "/" + locale + output;
        }
        
        if (root == '' || root == '/') {
            return combinedPath;
        } else {
            return root + combinedPath;
        }
    },

    /**
     * Given a path and a dictionary of options, builds a qualified query string.
     *
     * @param uri {String} required; path to endpoint. eg. "search/jobs"
     * @param options {Object} key / value par of query params eg. {'foo': 'bar'}
     */
    make_full_url: function(url, options) {
        url = this.make_url(url);
        if (options) url = url + '?' + this.propToQueryString(options);
        return url;
    },

    /**
     * Redirects user to a new page.
     *
     * @param uri {String} required
     * @param options {Object} containing parameters like:
     *         sid => attaches optional sid in valid format
     *         s => attaches optional saved search name
     *         q => attaches optional search string in valid format
     *
     *         Example:
     *             util.redirect_to('app/core/search', {
     *                 'sid' : 1234,
     *                 'foo' : 'bar'
     *             });
     *
     *             redirects to 'splunk/app/core/search?sid=1234&foo=bar'
     * @param windowObj {Window Object} an optional window object to target the location change
     * @param focus {Boolean} if true, focus is called on windowObj
     */
    redirect_to: function(uri, options, windowObj, focus) {
        uri = this.make_full_url(uri, options);
        if (!windowObj) windowObj = window;
        windowObj.document.location = uri;
        if (focus && windowObj.focus) windowObj.focus();
        return;
    },

    /**
     * Returns the current app name (not label).
     */
    getCurrentApp: function() {
        return $(document.body).attr("s:app") || 'UNKNOWN_APP';
    },

    /**
     * Returns the current view name (not label).
     */
    getCurrentView: function() {
        return $(document.body).attr("s:view") || 'UNKNOWN_VIEW';
    },
    /**
     * Returns the current 'displayView' name if it differs from the view name, else returns the current view name.
     */
    getCurrentDisplayView: function() {
        return $(document.body).attr("s:displayview") || this.getCurrentView();
    },
    getAutoCancelInterval: function() {
        var interval = $(document.body).attr("s:autoCancelInterval");
        if (!interval) {
            this.logger.error("no autoCancelInterval found. Returning 0");
            interval = 0;
        }
        return interval;
    },
    /**
     * Returns the current viewstate ID as requested via the URI parameter
     * 'vs'.  This is embedded in the <body> tag.
     *
     * If no viewstate has been requested, then all parameter writes will
     * go to the default sticky state, keyed by the reserved token '_current'.
     *
     * NOTE: viewstate is also provided to the modules through context resurrection,
     * And that being the case, the value of this is marginal.
     */
    //getCurrentViewState: function() {
    //    return $(document.body).attr("s:viewstateid") || null;
    //},

    /**
     * Returns a dictionary of all the app, view, and saved search config
     * data that is specified in the current view.  Ex:
     * {
     *    'view': {"template": "builder.html", "displayView": "report_builder_display", "refresh": null, "label": "Display Report", "viewstateId": "*:ft10i02z", "onunloadCancelJobs": false, "id": "report_builder_display"},
     *    'app': {"id": "search", "label": "Search"},
     *    'savedSearch': {"search": "johnvey | timechart count", "name": "jvreport3", "vsid": "*:ft10i02z", "qualifiedSearch": "search  johnvey | timechart count"}
     * }
     */
    getCurrentViewConfig: function() {
        return $.extend({}, Splunk.ViewConfig);
    },

    /**
     * Return the path without the localization segment.
     */
    getPath: function(path) {
        if (path === undefined) {
            path = document.location.pathname;
        }
        var locale = this.getConfigValue('LOCALE').toString();

        // if there is no way to figure out the locale, just return pathname
        if (!this.getConfigValue('LOCALE') || path.indexOf(locale) == -1) {
            return path;
        }
        var start = locale.length + path.indexOf(locale);
        return path.slice(start);
    },

    /**
     * Get the cumulative offsetTop for an element.
     *
     * @param {Object} element A DOM element.
     */
    getCumlativeOffsetTop: function(element){
        if(!element) return 0;
        return element.offsetTop + this.getCumlativeOffsetTop(element.offsetParent);
    },

    /**
     * Get the cumulative offsetLeft for an element.
     *
     * @param {Object} element A DOM element.
     */
    getCumlativeOffsetLeft: function(element){
        if(!element) return 0;
        return element.offsetLeft + this.getCumlativeOffsetLeft(element.offsetParent);
    },

    /**
     * Retrieve the amount of content that has been hidden by scrolling down.
     *
     * @type Number
     * @return 0-n value.
     */
    getPageYOffset: function(){
        var pageYOffset = 0;
        if(window.pageYOffset){
            pageYOffset = window.pageYOffset;
        }else if(document.documentElement && document.documentElement.scrollTop){
            pageYOffset = document.documentElement.scrollTop;
        }
        return pageYOffset;
    },

    /**
     * Retrieve the inner dimensions of the window. This does not work in jQuery.
     *
     * @type Object
     * @return An object literal having width and height attributes.
     */
    getWindowDimensions: function(){
        return {
            width:(!isNaN(window.innerWidth))?window.innerWidth:document.documentElement.clientWidth||0,
            height:(!isNaN(window.innerHeight))?window.innerHeight:document.documentElement.clientHeight||0
        };
    },

    /**
     * Retrieve the computed style from a specified element.
     *
     * @param el
     * @param styleProperty
     * @return The computed style value.
     * @type String
     */
    getComputedStyleHelper: function(el, styleProperty){
        if(el.currentStyle){
            return el.currentStyle[styleProperty];
        }else if(window.getComputedStyle){
            var cssProperty = styleProperty.replace(/([A-Z])/g, "-$1").toLowerCase();
            var computedStyle = window.getComputedStyle(el, "");
            return computedStyle.getPropertyValue(cssProperty);
        }else{
            return "";
        }
    },

    /**
     * Retrieve a GET parameter from the window.location. Type casting is not performed.
     * @param {String} p The param value to retrieve.
     * @param {String} s Optional string to search through instead of window.location.search
     * @return {String || null} The string value or null if it does not exist.
     */
    getParameter: function(p, s){
        s = s || window.location.search;
        if(!s){
            return null;
        }
        if(!(s.indexOf(p+'=')+1)){
            return null;
        }
        return s.split(p+'=')[1].split('&')[0];
    },

    /**
     * Take an RGB value and convert to HEX equivalent.
     *
     * @param {String} rgb A RGB value following rgb(XXX, XXX, XXX) convention.
     * @type String
     * @return A HEX equivalent for a given RGB value with a leading '#' character.
     */
    getHEX: function(rgb){
        var parts = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        var hex = (parts[1]<<16|parts[2]<<8|parts[3]).toString(16);
        return "#"+Array(6-hex.length).concat([hex]).toString().replace(/,/g, 0);
    },

    /**
     * Take an arbitrary RGB or HEX in long or shorthand notation and normalize to standard long HEX form with leading '#' character.
     *
     * @param {String} color A RGB or HEX color value in long or short notation.
     * @type String or null
     * @return A fully qualified 6 character hexadecimal value or with leading '#' character or null if it can't be processed.
     */
    normalizeColor: function(color){
        normalizedColor = null;
        if(color.charAt(0)==="#"){
            if(color.length===4){
                normalizedColor = color + color.charAt(1) + color.charAt(2) + color.charAt(3);
            }else{
                normalizedColor = color;
            }
        }else{
            try{
                normalizedColor = this.getHEX(color);
            }catch(e){}
        }
        return normalizedColor;
    },

    // ** 
    // * validate a cron string
    // * returns true if the cron string has five elements and each element contains one or more values (comma separated) from the following list
    // * [X, *, */X, X/Y, X-Y, X-Y/Z and X,Y]
    // * the allowed range of values for every field is as follows:
    // * [MINUTES HOURS DAY_OF_MONTH MONTH DAY_OF_WEEK] = [0-59 0-23 1-31 1-12 0-7]
    // */
    // p.s. need to comment the header different to not exit the comment block for the */X case
    validateCronString: function(cronString) {
        var cronRegEx = /^((0*([0-9]|[1-5][0-9])|\*)(-0*([0-9]|[1-5][0-9]))?(\/\d+)?,)*(0*([0-9]|[1-5][0-9])|\*)(-0*([0-9]|[1-5][0-9]))?(\/\d+)?\s((0*([0-9]|1[0-9]|2[0-3])|\*)(-0*([0-9]|1[0-9]|2[0-3]))?(\/\d+)?,)*(0*([0-9]|1[0-9]|2[0-3])|\*)(-0*([0-9]|1[0-9]|2[0-3]))?(\/\d+)?\s((0*([1-9]|[1-2][0-9]|3[0-1])|\*)(-0*([1-9]|[1-2][0-9]|3[0-1]))?(\/\d+)?,)*(0*([1-9]|[1-2][0-9]|3[0-1])|\*)(-0*([1-9]|[1-2][0-9]|3[0-1]))?(\/\d+)?\s((0*([1-9]|1[0-2])|\*)(-0*([1-9]|1[0-2]))?(\/\d+)?,)*(0*([1-9]|1[0-2])|\*)(-0*([1-9]|1[0-2]))?(\/\d+)?\s((0*[0-7]|\*)(-0*[0-7])?(\/\d+)?,)*(0*[0-7]|\*)(-0*[0-7])?(\/\d+)?$/;
        if (!cronRegEx.test(cronString)) {
            return false;
        }
        return true;
    },

    /**
     * innerHTML substitute when it is not fast enough.
     * @param {HTMLObject} target The target DOM element to replace innerHTML content with.
     * @param {String} innerHTML The innerHTML string to add.
     * @return {HTMLObject} The reference to the target DOM element as it may have been cloned and removed.
     */
    turboInnerHTML: function(target, innerHTML) {
        /*@cc_on //innerHTML is faster for IE
            target.innerHTML = innerHTML;
            return target;
        @*/
        var targetClone = target.cloneNode(false);
        targetClone.innerHTML = innerHTML;
        target.parentNode.replaceChild(targetClone, target);
        return targetClone;
    },
    normalizeBoolean: function(test, strictMode) {

        if (typeof(test) == 'string') {
            test = test.toLowerCase();
        }

        switch (test) {
            case true:
            case 1:
            case '1':
            case 'yes':
            case 'on':
            case 'true':
                return true;

            case false:
            case 0:
            case '0':
            case 'no':
            case 'off':
            case 'false':
                return false;

            default:
                if (strictMode) throw TypeError("Unable to cast value into boolean: " + test);
                return test;
        }
    },
    getCommaFormattedNumber: function(nStr) {
        nStr += '';
        var x = nStr.split('.');
        var x1 = x[0];
        var x2 = x.length > 1 ? '.' + x[1] : '';
        var rgx = /(\d+)(\d{3})/;
        while (rgx.test(x1)) {
            x1 = x1.replace(rgx, '$1' + ',' + '$2');
        }
        return x1 + x2;
    },


    reLTrim: /^[\s\t\r\n]+/,
    reLTrimCommand: /^[\s\t\r\n\|]+/,
    reRNormalize: /[\s\t\r\n]+$/,

    /**
     * Returns a fully qualified search string by prepending the 'search'
     * command of unqualified searches.  This method deems strings as unqualified
     * if it does not start with a | or 'search '
     *
     * @param {boolean} isUserEntered Indicates if 'q' is expected to be unqualified
     */
    addLeadingSearchCommand: function(q, isUserEntered) {
        var workingQ = '' + q;
        workingQ = workingQ.replace(this.reLTrim, '').replace(this.reRNormalize, ' ');
        if (workingQ.substring(0, 1) == '|') {
            return q;
        }

        // this is specific to the case where searchstring = 'search ',
        // which we conservatively assume does not constitute a search command
        if (!isUserEntered
            && (workingQ.substring(0, 7) == 'search ' && workingQ.length > 7))
        {
            return q;
        }
        return 'search ' + workingQ;
    },

    /**
     * Returns an unqualified search string by removing any leading 'search '
     * command.  This method does a simple search at the beginning of the
     * search.
     */
    stripLeadingSearchCommand: function(q) {
        var workingQ = '' + q;
        workingQ = workingQ.replace(this.reLTrimCommand, '');
        if (workingQ.substring(0, 7) == 'search ') {
            return workingQ.substring(7).replace(this.reLTrimCommand, '');
        }
        return q;
    },

    /**
     * Deserializes a string into a field list.
     */
    stringToFieldList: function(strList) {
        if (typeof(strList) != 'string' || !strList) return [];
        var items = [];
        var field_name_buffer = [];
        var inquote = false;
        var str = $.trim(strList);
        for (var i=0,j=str.length; i<j; i++) {
            if (str.charAt(i) == '\\') {
                var nextidx = i+1;
                if (j > nextidx && (str.charAt(nextidx) == '\\' || str.charAt(nextidx) == '"')) {
                    field_name_buffer.push(str.charAt(nextidx));
                    i++;
                    continue;
                } else {
                    field_name_buffer.push(str.charAt(i));
                    continue;
                }
            }

            if (str.charAt(i) == '"') {
                if (!inquote) {
                    inquote = true;
                    continue;
                } else {
                    inquote = false;
                    items.push(field_name_buffer.join(''));
                    field_name_buffer = [];
                    continue;
                }
            }

            if ((str.charAt(i) == ' ' || str.charAt(i) == ',') && !inquote) {
                if (field_name_buffer.length > 0) {
                    items.push(field_name_buffer.join(''));
                }
                field_name_buffer = [];
                continue;
            }
            field_name_buffer.push(str.charAt(i));
        }
        if (field_name_buffer.length > 0) items.push(field_name_buffer.join(''));
        return items;
    },


    /**
     * Serializes a field list array into a string.
     */
    _sflQuotable: /([\\",\s])/,
    _sflEscapable: /([\\"])/g,
    fieldListToString: function(fieldArray) {
        if (!fieldArray) return '';
        var output = [];
        for (var i=0,L=fieldArray.length; i<L; i++) {
            var v = $.trim(fieldArray[i]);
            if (v != '') {
                // Escape any char with the backslash.
                if (v.search(this._sflEscapable) > -1) {
                    v = v.replace(this._sflEscapable, "\\$1");
                }

                // Quote the entire string if a backslash, comma, space
                // or double quote is present.
                if (v.search(this._sflQuotable) > -1) {
                    v = ['"', v, '"'].join('');
                }

                output.push(v);
            }
        }
        return output.join(',');
    },
    /**
     * Escapes a string for use in the search language.
     *
     * @param str {String} string to escape
     * @param options {Object} {
     *     forceQuotes {Boolean, default false} adds quotes around the string even if it doesn't contain special characters,
     *                 useful if the result is being used as a string literal in the search language.
     * }
     * @returns {string}
     */
    searchEscape: function(str, options) {
        if (!str.match(/[\s\,=|\[\]\"]/))
            return options && options.forceQuotes ? '"' + str + '"' : str;

        return '"' + str.replace(/(\"|\\)/g, "\\$1") + '"';
    },

    /**
     * Compare the likeness of two objects. Please use with discretion.
     */
    objectSimilarity: function(obj1, obj2){
            if(obj1 instanceof Array && obj2 instanceof Array){
                    if(obj1.length!==obj2.length){
                       return false;
                    }else{
                        for(var i=0; i<obj1.length; i++){
                            if(!this.objectSimilarity(obj1[i], obj2[i])){
                                return false;
                            }
                        }
                    }
            }else if(obj1 instanceof Object && obj2 instanceof Object){
                if(obj1!=obj2){
                    for(var j in obj2){
                        if(!obj1.hasOwnProperty(j)){
                            return false;
                        }
                    }
                    for(var k in obj1){
                        if(obj1.hasOwnProperty(k)){
                            if(obj2.hasOwnProperty(k)){
                                if(!this.objectSimilarity(obj1[k], obj2[k])){
                                    return false;
                                }
                            }else{
                                return false;
                            }
                        }
                    }
                }
            }else if(typeof(obj1)==="function" && typeof(obj2)==="function"){
                if(obj1.toString()!==obj2.toString()){
                    return false;
                }
            }else if(obj1!==obj2){
                return false;
            }
            return true;
    },
    /**
     * Stop watch class.
     */
    StopWatch: function(){
        var self = this,
            startTime = null,
            stopTime = null,
            times = [];
        var isSet = function(prop){
            return (prop==null)?false:true;
        };
        var isStarted = function(){
            return isSet(startTime);
        };
        var isStopped = function(){
            return isSet(stopTime);
        };
        var softReset = function(){
            startTime = null;
            stopTime = null;
        };
        self.start = function(){
            if(isStarted()){
               throw new Error("cannot call start, start already invoked.");
            }
            startTime = new Date();
        };
        self.stop = function(){
           if(!isStarted()){
               throw new Error("cannot call stop, start not invoked.");
           }
           if(isStopped()){
               throw new Error("cannot call stop, stop already invoked.");
           }
           stopTime = new Date();
           time = stopTime - startTime;
           times.push(time);
        };
        self.pause = function(){
            if(!isStarted()){
               throw new Error("cannot call pause, start not invoked.");
            }
            if(isStopped()){
               throw new Error("cannot call pause, stop already invoked.");
            }
            self.stop();
            softReset();
        };
        self.reset = function(){
            softReset();
            times = [];
        };
        self.time = function(){
            var total = 0;
            for(i=0; i<times.length; i++){
                total += times[i];
            }
            if(isStarted() && !isStopped()){
                total += (new Date() - startTime);
            }
            return total/1000;
        };
    },

    isInt: function(num) {
        return num!=='' && !isNaN(parseInt(num, 10)) && parseInt(num, 10)==(num/1);
    },

    /**
     * Returns a string trimmed to maxLength by removing characters from the
     * middle of the string and replacing with ellipses.
     *
     * Ex: Splunk.util.smartTrim('1234567890', 5) ==> '12...890'
     *
     */
    smartTrim: function(string, maxLength) {
        if (!string) return string;
        if (maxLength < 1) return string;
        if (string.length <= maxLength) return string;
        if (maxLength == 1) return string.substring(0,1) + '...';

        var midpoint = Math.ceil(string.length / 2);
        var toremove = string.length - maxLength;
        var lstrip = Math.ceil(toremove/2);
        var rstrip = toremove - lstrip;
        return string.substring(0, midpoint-lstrip) + '...' + string.substring(midpoint+rstrip);
    },
    _tokenDiscoverer : /\$([^$]+)\$/g,

    /**
     * Finds all instances of any string looking like "$foo$" anywhere in the given object literal.
     * returns an array of all the distinct values it found, eg 'foo'.
     * if a single string value in the struct has two, like "$foo$ $bar$", duplicates are removed.
     * This will also discover any number of "$foo$" substrings that are found within the
     * keys of object literals, not just the values.
     */
    discoverReplacementTokens: function(fragment) {
        var keys = [];
        var tokenDiscoverer = Splunk.util._tokenDiscoverer;
        var keysToAdd;

        if (typeof fragment == 'string') {
            if (fragment.match(tokenDiscoverer)) {
                keysToAdd = fragment.match(tokenDiscoverer);
                // TODO - im sure there's a way to write the re so that it doesnt include the '$' chars but im moving on.
                for (var i=0; i<keysToAdd.length; i++ ) {
                    keysToAdd[i] = keysToAdd[i].substring(1, keysToAdd[i].length-1);
                }
                return keysToAdd;
            }
            return [];
        }
        else if (typeof fragment == "function") {
            return [];
        }

        // then fragment is not a string.
        for (var key in fragment) {
            keysToAdd = [];
            keysToAdd = Splunk.util.discoverReplacementTokens(fragment[key]);

            // up until now we've only looked at values. We have to also discover keys in the key itself..
            var matchesInTheKeyItself = key.match(tokenDiscoverer) || [];
            for (var j=0; j<matchesInTheKeyItself.length; j++) {
                // TODO - im sure there's a way to write the re so that it doesnt include the '$' chars but im moving on.
                keysToAdd.push(matchesInTheKeyItself[j].substring(1, matchesInTheKeyItself[j].length-1));
            }
            // check against duplicates.
            for (var k=0; k<keysToAdd.length; k++) {
                if (keys.indexOf(keysToAdd[k]) ==-1) {
                    keys.push(keysToAdd[k]);
                }
            }
        }
        return keys;
    },

    /**
     * walked through the entirety of fragment to all levels of nesting
     *  and will replace all matches of the given single regex with the given
     *  single value.
     *  replacement will occur in both keys and values.
     */
    replaceTokens: function(fragment, reg, value) {
        if (typeof fragment == 'string') {
            if (fragment.match(reg)) {
                fragment = fragment.replace(reg, value);
            }
            return fragment;
        }
        else if (typeof fragment == "function") {
            return fragment;
        }
        // watch out for infinite loops.  We make all changes to the array after iteration.

        var keysToRename = {};
        for (var key in fragment) {
            // recurse
            if (typeof fragment[key] == 'object') {
                Splunk.util.replaceTokens(fragment[key], reg, value);
            }
            // we have hit a string value.
            else if (typeof fragment[key] == 'string' && fragment[key].match(reg)) {
                fragment[key] = fragment[key].replace(reg, value);
            }
            // now that the value is changed we check the key itself
            if (key.match(reg)) {
                // mark this to be changed after we're out of the iterator
                keysToRename[key] = key.replace(reg, value);
            }
        }
        for (var oldKey in keysToRename) {
            var newKey = keysToRename[oldKey];
            fragment[newKey] = fragment[oldKey];
            delete(fragment[oldKey]);
        }
        return fragment;
    },


    getServerTimezoneOffset: function() {
        return Splunk.util.getConfigValue('SERVER_TIMEZONE_OFFSET');
    },

    // constants used by Modules as well as ModuleLoader, to denote runtime states
    // WAITING_FOR_INITIALIZATION and WAITING_FOR_HIERARCHY mean that the Modules
    // are still being loaded by ModuleLoader.
    // the remaining two states are relevant BOTH during page load, and in general
    // at runtime thereafter.
    // whether or not the page is still loading is an orthogonal piece of information,
    // and modules can check it on demand by calling Module.isPageLoadComplete().
    moduleLoadStates: {
        WAITING_FOR_INITIALIZATION   : 1,  // waiting for INITIALIZATION
        WAITING_FOR_HIERARCHY   : 2,  // waiting for HIERARCHY
        WAITING_FOR_CONTEXT: 6,
        HAS_CONTEXT         : 7
    },

    /**
     * Returns a wait time (sec) based on the current time elapsed, as mapped
     * onto a cubic easing function.
     *
     * elapsed_time: number of seconds that have elapsed since the first
     *     call to getRetryInterval()
     *
     * min_interval: minimum return value of this method; also the interval
     *     returned when elapsed_time = 0
     *
     * max_interval: maximum return value of this method; also the interval
     *     returned when elapsed_time >= clamp_time
     *
     * clamp_time: total duration over which to calculate a wait time; while
     *     elapsed_time < clamp_time, the return value will be less than
     *     max_interval; when elapsed_time >= clamp_time, the return value will
     *     always be max_interval
     *
     */
    getRetryInterval: function(elapsed_time, min_interval, max_interval, clamp_time) {
        if (elapsed_time >= clamp_time) return parseFloat(max_interval);
        return Math.min(max_interval * Math.pow(elapsed_time/parseFloat(clamp_time), 3) + min_interval, max_interval);
    },


    /**
     * Returns a string with HTML entities escaped.
     * NOTE: IE will not interpret ""&apos;", opting to just render it encoded
     *      we use the alternate decimal version instead
     *
     */
    escapeHtml: function(input) {
        return (""+input).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    },

    /**
     * Returns a string with backslashes escaped
     */
    escapeBackslash: function(input) {
        return (""+input).replace(/\\/g, '\\\\');
    },

    /**
     * Returns a string with regex characters escaped
     * http://stackoverflow.com/questions/2593637
     */
    escapeRegex: function(input) {
        return (input+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    },

    /**
     * Escapes any special characters for use in a jQuery selector
     */
    escapeSelector: function(input) {
        return (""+input).replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
    },

    /**
     * Trim out any special characters, leaving alphanumeric and -_{}?
     *
     * @param input
     * @return {*}
     */
    trimToAlphaNumeric: function(input) {
        return (""+input).replace(/([\s;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=<>`\/\|\\])/g, '');
    },

    /**
     * From http://blog.stevenlevithan.com/archives/faster-trim-javascript
     * profiler shows this is much faster than the previous implementation in both IE and Firefox.
     *
     * @param {String} str The string to trim.
     * @param {String} (Optional) delim The characters to remove from the start/end of the string.
     *
     * @type String
     * @return A trimmed string.
     */
    trim: function(str, delim) {
        if (delim) return str.replace(new RegExp("^[\\s" + delim + "]+"),'').replace(new RegExp("[\\s" + delim + "]+$"), '');
        else return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },

    /**
     * Simple normalization for user input: trims whitespaces and lowercases string
     *
     * @param str {String} input string
     * @param defValue {String} (optional) default value if str is null
     * @return {String} cleansed string
     */
    lowerTrimStr: function(str, defValue) {
        if (!str) {
            return defValue ? defValue : str;
        }
        return this.trim(str).toLowerCase();
    },

    focusFirstField: function(popup){ //this puts the focus on the first form element whether an input or select dropdown
        var firstInput = $(":input:visible:enabled:first",popup),
        firstSelect = $("select:visible:enabled:first",popup);

        if(firstInput.is(":button") && firstInput.hasClass('splButton-secondary')) {
            if($(":input:button.splButton-primary:first", popup).length) {
                firstInput = $(":input:button.splButton-primary:first", popup);
            }
        }

        var firstInputOffset = (firstInput.length) ? firstInput.offset().top : false,
        firstSelectOffset = (firstSelect.length) ? firstSelect.offset().top : false,
        firstElem = firstInput;

        if(firstInputOffset && firstSelectOffset && (firstSelectOffset < firstInputOffset)){
            firstElem = firstSelect;
        }
        firstElem.focus();
        var isFirstElemFocused = firstElem.is(":focus");

        //Fix for IE8
        if(!isFirstElemFocused) {
            setTimeout(function() {
                firstElem.focus();
            }, 10);
        }
    },

    /**
     * Transform a string against wiki formatting rules.
     *
     * @param {String} str The string to format.
     *
     * @type String
     * @return A HTML formatted string.
     */
    getWikiTransform: function(str) {
        var text = Splunk.util.escapeHtml(str);
        // we tokenize the conditional '!' prefix and replace it after
        text = text.replace(/\[(\!?)(\w+\:\/\/[^\s]+)\s+([^\]]+)\]/g, '<a href="$2" #~#$1#~#>$3</a>');
        text = text.replace(/\[\[(\!?)([^\|]+)\|([^\]]+)\]\]/g, Splunk.util._generateInternalLink);
        text = text.replace(/#~#!#~#/g, 'target="_blank"');
        text = text.replace(/\s*#~##~#/g, '');
        return text;
    },

    _generateInternalLink: function(str, blank_token, url, text) {
        url = Splunk.util.make_url(url);
        return '<a href="'+url+'"#~#'+blank_token+'#~#>'+text+'</a>';
    },

    /**
     * Utility to get the indices of all regular expression matches
     *
     * @param rex {RegExp} regular expression to match on
     * @param source {string} the text on which to find matches
     * @return {Array} all of the matches
     *             {Object}
     *                 match {string} the substring match found in the source
     *                 start {number} the index in the source for the start of the match
     *                 end {number} the index in the source for the end of the match
     */
    findMatchIndices: function(rex, source) {
        var matches = source.match(rex);
        var index = 0;
        var results = [];
        var length = matches.length;

        for (var i = 0; i < length; i++) {
            var match = matches[i];
            index = source.indexOf(match, index);
            if (index != -1) {
                results.push({match: match, start: index, end: index + match.length - 1});
            }
            index++;
        }

        return results;
    },
    
    /**
     * Returns IE version or -1 if it's not IE
     *
     */    
     getIEVersion: function() {
        var myNav = navigator.userAgent.toLowerCase();
        if (myNav.indexOf('msie') != -1) {
            return parseInt(myNav.split('msie')[1], 10);
        }
        // Check IE > 10
        if (myNav.indexOf('trident') != -1) {
            return parseInt(myNav.split(' rv:')[1], 10);
        }
        return -1;
    },

    /**
    * Restart splunkd/splunkweb and udpate the UI with progress
    */
    restart_server: function(return_to) {
        var start_time;
        var restart_timeout = false;
        var restart_tries = 0;
        var restart_url_base;
        var restart_url_proto;
        var restart_done = false;
        var restart_notified = false;
        var img_list = [];
        var RESTART_MAX_TRIES = 180; // Wait max of 3 minutes for restart
        var PING_INTERVAL = 2000;

        var restart_fail = function(msg) {
            Splunk.Messenger.System.getInstance().send('error', 'restart_server', msg);
            $(document).trigger('restart_failed');
        };

        var restart_succeeded = function() {
            if (!restart_notified) {
                restart_notified = true;
                alert(_('Restart successful - click OK to log back into Splunk'));
                var bounce_url;
                if (return_to) {
                    bounce_url = restart_url_base + this.make_full_url('/account/login', { return_to: return_to });
                } else {
                    bounce_url = restart_url_base + this.make_url('/');
                }
                window.location.href = bounce_url;
            }
        }.bind(this);

        /**
        * Track when the current instance of the appserver was started; if it changes then
        * the restart has finished.
        */
        var restart_check_status = function () {
            if (restart_done)
                return;

            if(restart_tries++ >= RESTART_MAX_TRIES) {
                restart_fail(_('Timed out waiting for restart'));
                return;
            }

            $.ajax({
                type: 'GET',
                dataType: 'json',
                cache: false,
                url: restart_url_base + this.make_url('/api/config/UI_UNIX_START_TIME'),
                success: function(data) {
                    if (data.start_time > start_time) {
                        restart_done = true;
                        clearTimeout(restart_timeout);
                        restart_succeeded();
                    }
                }
            });
            // if the script fails to load (ie. because splunkweb is still down)
            // jquery won't give us an error; instead nothing will happen hence we
            // need to refire the poll
            restart_timeout = setTimeout(restart_check_status, PING_INTERVAL);
        }.bind(this);

        var restart_img_loaded = function() {
            restart_done = true;
            clearTimeout(restart_timeout);
            restart_succeeded();
        };

        /**
        * Img checking works better than timestamp checking if the protocol has been changed
        */
        var restart_check_status_img = function() {
            if (restart_done) {
                return;
            }
            var im = new Image();
            im.onload = restart_img_loaded;
            im.src = restart_url_base + this.make_url('/config/img?proto='+restart_url_proto+'&_='+ Math.random());
            img_list.push(im);
            restart_timeout = setTimeout(restart_check_status_img, PING_INTERVAL);
        }.bind(this);

        $.post(this.make_url('/api/manager/control'), {operation: 'restart_server'}, function(data) {
            if (data.status=='OK') {
                start_time = data.start_time;

                if (data.ssl == 'window') data.ssl = window.location.protocol == 'https:';

                restart_url_proto = data.ssl ? 'https' : 'http';
                restart_url_base = (data.ssl ? 'https://' : 'http://') + window.location.hostname + (data.port==80 || (data.ssl && data.port==443) ? '' : ':'+data.port);

                // Turn off stuff that continues to try to communicate with the appserver
                Splunk.Logger.mode.Default = Splunk.Logger.mode.None;
                Splunk.Messenger.System.getInstance().abortRequests = true;

                // Send a signal to stop all the pollers
                Splunk.Session.getInstance().signalRestart();

                restart_tries = 0;
                var current_port = window.location.port || (window.location.protocol=='http:' ? 80 : 443);
                var current_ssl = window.location.protocol == 'https:';
                if ((!current_ssl && data.ssl) || (data.ssl && current_port!=data.port)) {
                    // Switching into SSL or changing ports with SSL enabled can cause problems if the browser doesn't accept the new cert
                    // (ie. a self signed, or untrusted cert is in use which is a common case)
                    $(document).trigger({ type: 'restart_ssl', sslBase: restart_url_base });
                    return;
                }
                if (data.ssl!=current_ssl || current_port!=data.port) {
                    restart_check_status_img();
                } else {
                    restart_check_status();
                }
            } else if (data.status == 'PERMS') {
                restart_fail(_('Permission Denied - You are not authorized to restart the server'));
            } else if (data.status == 'AUTH') {
                restart_fail(_('Restart failed'));
            } else if (data.status == 'FAIL') {
                restart_fail(_('Restart failed: '+data.reason));
            } else {
                restart_fail(_('Restart failed'));
            }
        }.bind(this), 'json');
    }
};

/**
 * ----------------------
 * Black magic for Prototype's bind() method which we're still using.
 *
 */

if(!Function.prototype.bind) {
  var $A = function(iterable) {
    if (!iterable) return [];
    if (iterable.toArray) {
      return iterable.toArray();
    } else {
      var results = [];
      for (var i = 0, length = iterable.length; i < length; i++)
        results.push(iterable[i]);
      return results;
    }
  };
  Function.prototype.bind = function() {
    var __method = this, args = $A(arguments), object = args.shift();
    return function() {
      return __method.apply(object, args.concat($A(arguments)));
    };
  };
}
/**
 * ----------------------
 * Prototype augmentation.
 * TODO - find another way.
 *
 */

if (!String.prototype.repeat) {
    String.prototype.repeat = function(count) {
        return new Array(count+1).join(this);
    };
}

if (!String.prototype.reverse) {
    String.prototype.reverse = function() {
        return this.split('').reverse().join('');
    };
}

if (!String.prototype.rsplit) {
    String.prototype.rsplit = function(sep, limit) {
        var sp = this.split(sep);
        if (limit && sp.length > limit) {
            var r = [];
            for(var i=0; i<limit; i++)
                r[i] = sp[sp.length-limit+i];
            return r;
        }
        return sp;
    };
}

if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(search, fromIndex) {
        if (!fromIndex) fromIndex = 0;
        for(var i=0; i<this.length; i++) {
            if (this[i] === search)
                return i;
        }
        return -1;
    };
}

if (!Array.prototype.extend) {
    Array.prototype.extend = function(arr) {
        for(var i=0; i<arr.length; i++)
            this.push(arr[i]);
    };
}

/**
* sprintf routine borrowed from http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_sprintf/
* Licensed under GPL and MIT licenses
*
* Modified by Gareth to add support for Python style argument specifiers:
* sprintf("Hi %(name)s, welcome to %(application)s", { name: 'Gareth', app: 'Splunk })
* Objects holding named arguments can also implement a python style __getitem__ method to return dynamic values
*/
var sprintf = global.sprintf = function( ) {
    // Return a formatted string
    //
    // +    discuss at: http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_sprintf/
    // +       version: 810.1015
    // +   original by: Ash Searle (http://hexmen.com/blog/)
    // + namespaced by: Michael White (http://getsprink.com)
    // +    tweaked by: Jack
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // *     example 1: sprintf("%01.2f", 123.1);
    // *     returns 1: 123.10

    var regex = /%%|%(\d+\$)?(\([^)]+\))?([-+#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuidfegEG])/g;
    var a = arguments;
    var i = 0;
    var format = a[i];
    i++;

    // pad()
    var pad = function(str, len, chr, leftJustify) {
        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
        return leftJustify ? str + padding : padding + str;
    };

    // justify()
    var justify = function(value, prefix, leftJustify, minWidth, zeroPad) {
        var diff = minWidth - value.length;
        if (diff > 0) {
            if (leftJustify || !zeroPad) {
                value = pad(value, minWidth, ' ', leftJustify);
            } else {
                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
            }
        }
        return value;
    };

    // formatBaseX()
    var formatBaseX = function(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
        // Note: casts negative numbers to positive ones
        var number = value >>> 0;
        prefix = prefix && number && {'2': '0b', '8': '0', '16': '0x'}[base] || '';
        value = prefix + pad(number.toString(base), precision || 0, '0', false);
        return justify(value, prefix, leftJustify, minWidth, zeroPad);
    };

    // formatString()
    var formatString = function(value, leftJustify, minWidth, precision, zeroPad) {
        if (precision != null) {
            value = value.slice(0, precision);
        }
        return justify(value, '', leftJustify, minWidth, zeroPad);
    };

    // finalFormat()
    var doFormat = function(substring, valueIndex, valueName, flags, minWidth, _, precision, type) {
        if (substring == '%%') return '%';

        // parse flags
        var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false;
        var flagsl = flags.length;
        for (var j = 0; flags && j < flagsl; j++) switch (flags.charAt(j)) {
            case ' ': positivePrefix = ' '; break;
            case '+': positivePrefix = '+'; break;
            case '-': leftJustify = true; break;
            case '0': zeroPad = true; break;
            case '#': prefixBaseX = true; break;
            default: break;
        }

        // parameters may be null, undefined, empty-string or real valued
        // we want to ignore null, undefined and empty-string values
        if (!minWidth) {
            minWidth = 0;
        } else if (minWidth == '*') {
            minWidth = +a[i];
            i++;
        } else if (minWidth.charAt(0) == '*') {
            minWidth = +a[minWidth.slice(1, -1)];
        } else {
            minWidth = +minWidth;
        }

        // Note: undocumented perl feature:
        if (minWidth < 0) {
            minWidth = -minWidth;
            leftJustify = true;
        }

        if (!isFinite(minWidth)) {
            throw new Error('sprintf: (minimum-)width must be finite');
        }

        if (!precision) {
            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : void(0);
        } else if (precision == '*') {
            precision = +a[i];
            i++;
        } else if (precision.charAt(0) == '*') {
            precision = +a[precision.slice(1, -1)];
        } else {
            precision = +precision;
        }

        // grab value using valueIndex if required?
        var value;
        if (valueName) {
            valueName = valueName.substr(1, valueName.length-2);
            value = a[1].__getitem__ ? a[1].__getitem__(valueName) : a[1][valueName];
        } else {
            if (valueIndex){
                value = a[valueIndex.slice(0, -1)];
            }
            else
            {
                value = a[i];
                i++;
            }
        }

        var number;
        var prefix;
        switch (type) {
            case 's': return formatString(String(value), leftJustify, minWidth, precision, zeroPad);
            case 'c': return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
            case 'b': return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'o': return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'x': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'X': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
            case 'u': return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'i':
            case 'd': {
                        number = parseInt(+value, 10);
                        prefix = number < 0 ? '-' : positivePrefix;
                        value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                        return justify(value, prefix, leftJustify, minWidth, zeroPad);
                    }
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                        {
                        number = +value;
                        prefix = number < 0 ? '-' : positivePrefix;
                        var method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                        var textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                        value = prefix + Math.abs(number)[method](precision);
                        return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
                    }
            default: return substring;
        }
    };

    return format.replace(regex, doFormat);
};// }}}

})(this);

define("splunk.util", ["jquery","splunk","splunk.config"], (function (global) {
    return function () {
        var ret, fn;
       fn = function ($, Splunk, config) {
                return $.extend({ sprintf: this.sprintf }, Splunk.util);
            };
        ret = fn.apply(global, arguments);
        return ret || global.Splunk.util;
    };
}(this)));

define('splunk.i18n',['strftime', 'splunk.util'], function() {

    /*
     * monkey patches to the i18n library
     * see SPL-75565
     */

    // NOTE: this code block is duplicated in the util/test_i18n_patches.html unit test.
    //       any changes made here must also be reflected there.
    if(window.locale_name() in { ko_KR: true, zh_CN: true, zh_TW: true }) {
        window._i18n_locale.date_formats['short'] = { "pattern": "yy/MM/dd", "format": "%(yy)s/%(MM)s/%(dd)s" };
        window._i18n_locale.date_formats['medium'] = {"pattern": "yyyy/MM/dd", "format": "%(yyyy)s/%(MM)s/%(dd)s"};
        window._i18n_locale.time_formats['short'] = { "pattern": "H:mm", "format": "%(H)s:%(mm)s" };
        window._i18n_locale.time_formats['medium'] = { "pattern": "H:mm:ss", "format": "%(H)s:%(mm)s:%(ss)s" };
    }

    var asianLanguageDateReplacements = [
        [/^ccc MMM d$/, 'M/d (ccc)'],
        [/^YYYY-MM/, 'YYYY/MM'],
        [/MM-dd/, 'MM/dd']
    ];

    // maintain a hash of locales where custom string replacements are needed to get correct translation
    var FORMAT_DATE_REPLACEMENTS = {
        'ja_JP': asianLanguageDateReplacements,
        'ko_KR': asianLanguageDateReplacements,
        'zh_CN': asianLanguageDateReplacements,
        'zh_TW': asianLanguageDateReplacements
    };

    // maintain a list of replacements needed when a locale specifies that day comes before month
    var DAY_FIRST_FORMATS = [
        ['MMM d', 'd MMM']
    ];

    var oldFormatDate = window.format_date;
    window.format_date = function(date, format) {
        format = format || 'medium';
        var i, replacements,
            locale = window.locale_name();

        if(format && (typeof format === 'string') && window.locale_uses_day_before_month()) {
            replacements = DAY_FIRST_FORMATS;
            for(i = 0; i < replacements.length; i++) {
                format = format.replace(replacements[i][0], replacements[i][1]);
            }
        }
        if(format && (typeof format === 'string') && locale in FORMAT_DATE_REPLACEMENTS) {
            replacements = FORMAT_DATE_REPLACEMENTS[locale];

            for(i = 0; i < replacements.length; i++) {
                var replacement = replacements[i];
                format = format.replace(replacement[0], replacement[1]);
            }
        }
        return oldFormatDate(date, format);
    };
    
    return ({
        _: window.gettext,
        ungettext: window.ungettext,
        format_decimal: window.format_decimal,
        format_number: window.format_number,
        format_percent: window.format_percent,
        format_scientific: window.format_scientific,
        format_date: window.format_date,
        format_datetime: window.format_datetime,
        format_time: window.format_time,
        format_datetime_microseconds: window.format_datetime_microseconds,
        format_time_microseconds: window.format_time_microseconds,
        locale_uses_day_before_month: window.locale_uses_day_before_month,
        format_datetime_range: window.format_datetime_range,
        locale_name: window.locale_name,
        DateTime: window.DateTime,
        moment_install: window.moment_install,
        numeral_install: window.numeral_install,
        jQuery_ui_datepicker_install: window.jQuery_ui_datepicker_install
    });
});

define('backbone',['jquery', 'underscore', 'contrib/backbone', 'splunk.i18n'], function($, _, Backbone, i18n) {
    // use underscore's mixin functionality to add the ability to localize a string
    _.mixin({
        t: function(string) {
            return i18n._(string);
        }
    });
    
    // now that Backbone has a reference to underscore, we need to give the '_' back to i18n
    _.noConflict();

    // inject a reference to jquery in case we ever run it in no conflict mode
    Backbone.$ = $;
    return Backbone.noConflict();
});
define('contrib/text',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define('helpers/user_agent',['underscore'], function(_) {

    /*
     * Based on following browsers supported by Splunk and sample user agent strings:
     *
     * Chrome 26 - "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31"
     * Firefox 21 - "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:21.0) Gecko/20100101 Firefox/21.0"
     * Safari 6 - "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8) AppleWebKit/536.25 (KHTML, like Gecko) Version/6.0 Safari/536.25"
     * IE 10 - "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)"
     * IE 9 - "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)"
     * IE 8 - "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)"
     * IE 7 - "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)"
     *
     * (not officially supported)
     *
     * Safari (iOS iPhone) - "Mozilla/5.0 (iPhone; CPU iPhone OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A5376e Safari/8536.25"
     * Safari (iOS iPad) - "Mozilla/5.0 (iPad; CPU OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A5376e Safari/8536.25"
     */

    var TESTS = {
        Chrome: /chrome/i,
        Firefox: /firefox/i,
        Safari: /safari/i,
        //User-agent string has been changed for IE11
        //Here is the sample user-agent string: "Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko"
        IE: /(?=.*msie ([\d.]+))|(?=.*trident)(?=.*rv\:([\d.]+))/i,
        IE11: /(?=.*trident)(?=.*rv\:11)/i,
        IE10: /msie 10\.0/i,
        IE9: /msie 9\.0/i,
        IE8: /msie 8\.0/i,
        IE7: /msie 7\.0/i,
        SafariiPhone: /iPhone/,
        SafariiPad: /iPad/
    };

    var IE_URL_LIMIT = 2048;

    var helper = {

        // put this here so it can be mocked in unit tests
        agentString: window.navigator.userAgent,

        // add methods for each of the test regexes
        isChrome: function() { return TESTS.Chrome.test(helper.agentString); },
        isFirefox: function() { return TESTS.Firefox.test(helper.agentString); },
        isIE: function() { return TESTS.IE.test(helper.agentString); },
        isIE11: function() { return TESTS.IE11.test(helper.agentString); },
        isIE10: function() { return TESTS.IE10.test(helper.agentString); },
        isIE9: function() { return TESTS.IE9.test(helper.agentString); },
        isIE8: function() { return TESTS.IE8.test(helper.agentString); },
        isIE7: function() { return TESTS.IE7.test(helper.agentString); },
        // Safari is a little more complicated
        isSafari: function() { return !helper.isChrome() && !helper.isSafariiPhone() && !helper.isSafariiPad() && TESTS.Safari.test(helper.agentString); },
        isSafariiPhone: function() { return TESTS.SafariiPhone.test(helper.agentString); },
        isSafariiPad: function() { return TESTS.SafariiPad.test(helper.agentString); },
        isiOS: function() { return helper.isSafariiPhone() || helper.isSafariiPad(); },

        isIELessThan: function(testVersion) {
            return helper.isIE() && parseFloat((TESTS.IE.exec(helper.agentString).sort(function(a, b) {return b - a;}))[0]) < testVersion;
        },

        isInIE7DocumentMode: function() {
            return document.documentMode == 7 ? true : false;
        },

        hasUrlLimit: function() {
            return helper.isIE() ? true : false;
        },
        getUrlLimit: function() {
            return helper.hasUrlLimit() ? IE_URL_LIMIT : Infinity;
        }

    };

    // memoize all of the things
    _(_.functions(helper)).chain().each(function(fnName) { helper[fnName] = _(helper[fnName]).memoize(); });

    return helper;

});

define('util/Ticker',['underscore', 'backbone'], function(_, Backbone) {
    var Ticker = function(options) {
        options || (options = {});
        this.interval = options.interval || 1000;
        this.cid = _.uniqueId('ticker');
        if (options.params) {
            this.params = options.params;
        }
        if (options.tick) {
            this.tick();
        }
        if (options.start) {
            this.start();
        }
    };
    _.extend(Ticker.prototype, Backbone.Events, {
        start: function(tick) {
            if (this._intervalId) {
                return false;
            }
            if (tick) {
                this.tick();
            }
            this._intervalId = setInterval(
                _.bind(this.tick, this),
                this.interval
            );
            return true;
        },
        stop: function(tick) {
            if (this._intervalId) {
                if (tick) {
                    this.tick();
                }
                clearInterval(this._intervalId);
                delete this._intervalId;
                return true;
            }
            return false;
        },
        restart: function(options) {
            options || (options = {});
            this.stop();
            if (options.interval) {
                this.interval = options.interval;
            }
            if (options.params) {
                this.params = options.params;
            }
            this.start(options.tick);
        },
        tick: function(params) {
            params || (params=this.params);
            var args = _.isArray(params) ? params : [params];
            this.trigger.apply(this, ['tick'].concat(args));
        }
    });
    return Ticker;
});
(function($) {
  
  var addMethods = function(source) {
    var ancestor   = this.superclass && this.superclass.prototype;
    var properties = $.keys(source);

    if (!$.keys({ toString: true }).length) properties.push("toString", "valueOf");

    for (var i = 0, length = properties.length; i < length; i++) {
      var property = properties[i], value = source[property];
      if (ancestor && $.isFunction(value) && $.argumentNames(value)[0] == "$super") {
        
        var method = value, value = $.extend($.wrap((function(m) {
          return function() { return ancestor[m].apply(this, arguments) };
        })(property), method), {
          valueOf:  function() { return method },
          toString: function() { return method.toString() }
        });
      }
      this.prototype[property] = value;
    }

    return this;
  }
  
  $.extend({
    keys: function(obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    },

    argumentNames: function(func) {
      var names = func.toString().match(/^[\s\(]*function[^(]*\((.*?)\)/)[1].split(/, ?/);
      return names.length == 1 && !names[0] ? [] : names;
    },

    bind: function(func, scope) {
      return function() {
        return func.apply(scope, $.makeArray(arguments));
      }
    },

    wrap: function(func, wrapper) {
      var __method = func;
      return function() {
        return wrapper.apply(this, [$.bind(__method, this)].concat($.makeArray(arguments)));
      }
    },
    
    klass: function() {
      var parent = null, properties = $.makeArray(arguments);
      if ($.isFunction(properties[0])) parent = properties.shift();

      var klass = function() { 
        this.initialize.apply(this, arguments);
      };

      klass.superclass = parent;
      klass.subclasses = [];
      klass.addMethods = addMethods;

      if (parent) {
        var subclass = function() { };
        subclass.prototype = parent.prototype;
        klass.prototype = new subclass;
        parent.subclasses.push(klass);
      }

      for (var i = 0; i < properties.length; i++)
        klass.addMethods(properties[i]);

      if (!klass.prototype.initialize)
        klass.prototype.initialize = function() {};

      klass.prototype.constructor = klass;

      return klass;
    }/*,
    delegate: function(rules) {
      return function(e) {
        var target = $(e.target);
        for (var selector in rules) {
          if (target.is(selector) || ((target = target.parents(selector)) && target.length > 0)) 
            return rules[selector].apply(this, [target].concat($.makeArray(arguments)));
        }
      }
    }*/
  });
  
  var bindEvents = function(instance) {
    for (var member in instance) {
      if (member.match(/^on(.+)/) && typeof instance[member] == 'function') {
        instance.element.bind(RegExp.$1, $.bind(instance[member], instance));
      }
    }
  }
  
  var behaviorWrapper = function(behavior) {
    return $.klass(behavior, {
      initialize: function($super, element, args) {
        this.element = $(element);
        if ($super) $super.apply(this, args);
      }
    });
  }
  
  var attachBehavior = function(el, behavior, args) {
      var wrapper = behaviorWrapper(behavior);
      instance = new wrapper(el, args);

      bindEvents(instance);

      if (!behavior.instances) behavior.instances = [];

      behavior.instances.push(instance);
      
      return instance;
  };
  
  
  $.fn.extend({
    attach: function() {
      var args = $.makeArray(arguments), behavior = args.shift();
      
      if ($.livequery && this.selector) {
        return this.livequery(function() {
          attachBehavior(this, behavior, args);
        });
      } else {
        return this.each(function() {
          attachBehavior(this, behavior, args);
        });
      }
    },
    attachAndReturn: function() {
      var args = $.makeArray(arguments), behavior = args.shift();
      
      return $.map(this, function(el) {
        return attachBehavior(el, behavior, args);
      });
    },
    /*delegate: function(type, rules) {
      return this.bind(type, $.delegate(rules));
    },*/
    attached: function(behavior) {
      var instances = [];
      
      if (!behavior.instances) return instances;
      
      this.each(function(i, element) {
        $.each(behavior.instances, function(i, instance) {
          if (instance.element.get(0) == element) instances.push(instance);
        });
      });
      
      return instances;
    },
    firstAttached: function(behavior) {
      return this.attached(behavior)[0];
    }
  });
  
  var Remote = $.klass({
    initialize: function(options) {
      if (this.element.attr('nodeName') == 'FORM') this.element.attach(Remote.Form, options);
      else this.element.attach(Remote.Link, options);
    }
  });
  
  Remote.Base = $.klass({
    initialize : function(options) {
      this.options = $.extend({
        
      }, options || {});
    },
    _makeRequest : function(options) {
      $.ajax(options);
      return false;
    }
  });
  
  Remote.Link = $.klass(Remote.Base, {
    onclick: function() {
      var options = $.extend({ url: this.element.attr('href'), type: 'GET' }, this.options);
      return this._makeRequest(options);
    }
  });
  
  Remote.Form = $.klass(Remote.Base, {
    onclick: function(e) {
      var target = e.target;
      
      if ($.inArray(target.nodeName.toLowerCase(), ['input', 'button']) >= 0 && target.type.match(/submit|image/))
        this._submitButton = target;
    },
    onsubmit: function() {
      var data = this.element.serializeArray();
      
      if (this._submitButton) data.push({ name: this._submitButton.name, value: this._submitButton.value });
      
      var options = $.extend({
        url : this.element.attr('action'),
        type : this.element.attr('method') || 'GET',
        data : data
      }, this.options);
      
      this._makeRequest(options);
      
      return false;
    }
  });
  
  $.ajaxSetup({ 
    beforeSend: function(xhr) {
      xhr.setRequestHeader("Accept", "text/javascript, text/html, application/xml, text/xml, */*");
    } 
  });
  
})(jQuery);
define("lowpro", ["jquery"], function(){});

(function(global) {

Splunk.namespace("Splunk.Logger");
/**
 * The getLogger factory provides a standard interface for implementing a logger program mode. Dependency on utils.js
 *
 * var logger = Splunk.Logger.getLogger("logger.js");
 * logger.info("This is a log message at ", new Date(), "showing a log!");
 *
 *
 * @param {String} fileName The name of the source file to log.
 * @param {Function} mode (Optional) The logging programming interface you wish to implement, defaults to Splunk.Logger.mode.Default if not defined.
 */
Splunk.Logger.getLogger = function(fileName, mode){
    var self;
    mode = mode || Splunk.Logger.mode.Default;
    try {
        self = new (mode)(fileName);
    }catch(err){
        self = this;
        throw(new Error("Splunk.Logger mode is undefined, not callable or thrown an exception. mode=" + mode + " and fileName=" + fileName + ". Check to make sure the mode you are defining exist (see: web.conf js_logger_mode) and is a proper closure. Stack trace:" + err));
    }
    return self;
};

/**
 * Exposes if a browser has firebug installed or not.
 *
 * @method hasFirebug
 * @return Boolean
 */
Splunk.Logger.hasFirebug = function(){
    return (typeof(console)!="undefined" && console.firebug)?true:false;
};
/**
 * Exposes if a browser has a window console object.
 *
 * @method hasConsole
 * @return Boolean
 */
Splunk.Logger.hasConsole = function(){
    return (typeof(console)!="undefined")?true:false;
};
/**
 * Object to store logger program mode.
 */
Splunk.Logger.mode = {};
/**
 * A mode logger program that does nothing.
 */
Splunk.Logger.mode.None = function(){
    var self = this;
    self.info = self.log = self.debug = self.warn = self.error = self.trace = function(){};
};
/**
 * A mode logger program that calls a console object and a closure matching method if defined.
 */
Splunk.Logger.mode.Firebug = function(fileName){
    var self = this;
    var generateArguments = function(args){
        var arr = [];
        for(var i=0; i<args.length; i++){
            arr.push(args[i]);
        }
        arr.push(fileName);
        return arr;
    };
    var bindConsole = function(args, method){
        args = generateArguments(args);
        if(Splunk.Logger.hasConsole()){
            method = console[method] || console.info || function(){};
            //>=ie8 console object does not have an apply method (they are not instanceof functions!)
            if(method.apply){
                method.apply(console, args);
            }else{
                method(args.join(" "));
            }
        }
    };

    if (Splunk.Logger.hasFirebug() && console.firebug != '1.3.0') {
        self.log = console.log;
        self.info = console.info;
        self.debug = console.debug;
        self.warn = console.warn;
        self.error = console.error;
        self.trace = console.trace;
    }
    else {
        self.info = function(){
            bindConsole(arguments, "info");
        };
        self.log = function(){
            bindConsole(arguments, "log");
        };
        self.debug = function(){
            bindConsole(arguments, "debug");
        };
        self.warn = function(){
            bindConsole(arguments, "warn");
        };
        self.error = function(){
            bindConsole(arguments, "error");
        };
        self.trace = function(){
            bindConsole(arguments, "trace");
        };
    }
};
/**
 * A mode logger program that implements logging to a server/splunk. Dependency on contrib/swfobject.js
 */
Splunk.Logger.mode.Server = function(fileName){
    var self = this,
        buffer = Splunk.Logger.mode.Server.Buffer.getInstance();
    /**
     * Formats a console call and pushes it to buffer.
     *
     * @method bufferPush
     * @param {arguments} args The arguments object from the original closure handler.
     * @param {String} level The console level called.
     */
    var bufferPush = function(args, level){
        args = args || [];
        for(var i = 0; i < args.length; i++) {
            if(typeof args[i] === 'object') {
                try {
                    args[i] = JSON.stringify(args[i]);
                }
                catch(e) { }
            }
        }
        var message = Array.apply(null, args).join(" ");
        var data = {level: level, 'class': fileName, message: message};
        buffer.push(data);
    };
    /**
     * The handlers for (new Splunk.Logger(fileName, [mode]))[level](arguments) calls.
     */
    self.info = function(){
        bufferPush(arguments, "info");
    };
    self.log = function(){
        bufferPush(arguments, "log");
    };
    self.debug = function(){
        bufferPush(arguments, "debug");
    };
    self.warn = function(){
        bufferPush(arguments, "warn");
    };
    self.error = function(){
        bufferPush(arguments, "error");
    };
    self.trace = function(){
        // try to generate a stack trace that can be sent to the server with log-level DEBUG
        // this will not actually give any meaningful information in IE, in which case this is a no-op
        var trace = '';
        try {
            var err = new Error();
            trace = err.stack.replace(/^Error/, '');
        }
        catch(e) { }
        if(trace) {
            bufferPush([trace], "debug");
        }
    };
};
/**
 * A buffer class to take care of purging and posting of logged messages.
 */
Splunk.Logger.mode.Server.Buffer = function(){
    var self = this,
        thread,
        buffer = [];
    /**
     * Posts buffer asynchronously to Splunk.Logger.Mode.Server.END_POINT,
     *
     * @method serverPost
     */
    var serverPost = function(){
        var data = JSON.stringify(buffer);
        $.post(Splunk.Logger.mode.Server.END_POINT, {"data":data});
    };
    /**
     * Posts and purges the existing buffer.
     *
     * @method purge
     */
    var purge = function(){
        serverPost();
        buffer = [];
    };
    /**
     * Checks the buffer, posts and purges if necessary.
     *
     * @method check
     */
    var check = function(){
        if(buffer.length>Splunk.Logger.mode.Server.MAX_BUFFER){
            purge();
        }
    };
    self.push = function(str){
        buffer.push(str);
        check();
    };
    /**
     * Checks the buffer at set interval and posts and purges if data exists.
     *
     * @method poller
     */
    self.poller = function(){
        if(buffer.length>0){
            purge();
        }
    };
    self.size = function(){
        return buffer.length;
    };
    self.Buffer = function(){
        thread = setInterval(self.poller, Splunk.Logger.mode.Server.POLL_BUFFER);
    }();
};
Splunk.Logger.mode.Server.Buffer.instance = null;
/**
 * Singleton reference to a shared buffer.
 *
 * @method getInstance
 */
Splunk.Logger.mode.Server.Buffer.getInstance = function(){
    if(Splunk.Logger.mode.Server.Buffer.instance==null){
        Splunk.Logger.mode.Server.Buffer.instance = new Splunk.Logger.mode.Server.Buffer();
    }
    return Splunk.Logger.mode.Server.Buffer.instance;
};
Splunk.Logger.mode.Server.END_POINT = Splunk.util.make_url(Splunk.util.getConfigValue("JS_LOGGER_MODE_SERVER_END_POINT", "util/log/js"));
Splunk.Logger.mode.Server.POLL_BUFFER = Splunk.util.getConfigValue("JS_LOGGER_MODE_SERVER_POLL_BUFFER", 1000);
Splunk.Logger.mode.Server.MAX_BUFFER = Splunk.util.getConfigValue("JS_LOGGER_MODE_SERVER_MAX_BUFFER", 100);
/**
 * The default system mode logger program, see web.conf js_logger_mode.
 */
Splunk.Logger.mode.Default = Splunk.Logger.mode[Splunk.util.getConfigValue("JS_LOGGER_MODE", "None")];
/**
 * Legacy Splunk.log compatibility
 */
Splunk.log = function(msg, category, src){
    Splunk.Logger.getLogger("logger.js").warn("WARNING! Splunk.log is now deprecated. See Splunk.Logger class for more details.", "Original Message:", msg, " Original Category:", category, "Original Source:", src);
};
/**
 * Legacy Backwards compatibility with 3.X
 */
var D = global.D = {};
D.logger = Splunk.Logger.getLogger("logger.js");
D.wrapper = function(str, level){
    D.logger.warn("WARNING! D.", level, "is now deprecated. See Splunk.Logger class for more details.", str);
};
D.debug = function(str){D.wrapper(str, "debug");};
D.error = function(str){D.wrapper(str, "error");};
D.warn = function(str){D.wrapper(str, "warn");};
/**
 * Augment util.logger to standard logger.
 */
Splunk.util.logger = Splunk.Logger.getLogger("util.js");

})(this);


define("splunk.logger", ["splunk","splunk.util"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Splunk.Logger;
    };
}(this)));

Splunk.namespace("Splunk.Session");
/**
 * A simple class that dispatches jQuery document events Splunk.Session.TIMEOUT_EVENT and Splunk.Session.START_EVENT.
 * Events triggered on UI activity/no-activity configuration setting POLLER_TIMEOUT_INTERVAL.
 */
Splunk.Session = $.klass({
    EVENT_BUFFER_TIMEOUT: 1000,//Never operate on many DOM events without a governor (ie., 1000ms governor cancels >30 scroll events).
    UI_INACTIVITY_TIMEOUT: 60,
    START_EVENT: "SessionStart",
    TIMEOUT_EVENT: "SessionTimeout",
    RESTART_EVENT: "HaltOnRestart", //Stop all the pollers when restart is initiated from the UI
    UI_EVENT_TYPES: ["click", "keydown", "mouseover", "scroll"],
    /**
     * Initializes Session.
     */
    initialize: function(){
        this.logger = Splunk.Logger.getLogger("session.js");
        this.eventBuffer = [];
        this.timeoutDelay = Splunk.util.getConfigValue("UI_INACTIVITY_TIMEOUT", this.UI_INACTIVITY_TIMEOUT);
        this.timeoutDelay *= 60000;

        // SPL-82672 if timeoutDelay is > 2147483647 they are most likely treating it as milliseconds.
        if(this.timeoutDelay > 2147483647) {
            this.logger.warn("ui_inactivity_timeout must be treated as minutes not milliseconds. Defaulting to 60 min");
            this.timeoutDelay = 3600000;
        }

        this.timeoutID = null;
        $(document).bind(this.START_EVENT, this.onSessionStart.bind(this));
        if(!this.timeoutDelay<1){
            $(document).bind(this.TIMEOUT_EVENT, this.onSessionTimeout.bind(this));
            $(document).bind(this.UI_EVENT_TYPES.join(" "), this.onUIEvent.bind(this));
            this.startTimeout();
        }
        $(document).trigger(this.START_EVENT, new Date());
    },
    /**
     * Top level UI event listener and dispatcher, triggers Splunk.Session.START_EVENT if timeoutID is null, resets the 
     * timer if timeoutID not null.
     *
     * @param {Object} event A DOM event.
     */
    onUIEvent: function(event){
        if(this.timeoutID){
            this.eventBuffer.push("");
            if(this.eventBuffer.length===1){
                this.resetTimeout();
                setTimeout(
                    function(){
                        this.eventBuffer = [];
                    }.bind(this),
                    this.EVENT_BUFFER_TIMEOUT
                );
            }
        }else{
            this.startTimeout();
            $(document).trigger(this.START_EVENT, new Date());
        }
    },
    /**
     * Start of new UI activity/session.
     * 
     * @param {Object) event The jQuery passed event.
     * @param {Date} date The time the event was fired.
     */
    onSessionStart: function(event, date){},
    /**
     * End of UI activity/session.
     * 
     * @param {Object) event The jQuery passed event.
     * @param {Date} date The time the event was fired.
     */
    onSessionTimeout: function(event, date){},
    /**
     * Reset timeout, stop and start again.
     */
    resetTimeout: function(){
        this.stopTimeout();
        this.startTimeout();
    },
    /**
     * Inform subscribers of server restart started
     */
    signalRestart: function(){
        $(document).trigger(this.RESTART_EVENT);
    },
    /**
     * Start timeout, set timeoutID.
     */
    startTimeout: function(){
        this.timeoutID = window.setTimeout(this.timeoutHandler.bind(this), this.timeoutDelay);
    },
    /**
     * Stop timeout, if timeoutID exists clear the previous delay and set timeoutID back to null.
     * 
     * Note: Passing an invalid ID to clearTimeout does not have any effect (and doesn't throw an exception).
     */
    stopTimeout: function(){
        if(this.timeoutID){
            window.clearTimeout(this.timeoutID);
            this.timeoutID = null;
        }
    },
    /**
     * Handler for successful timeout, set timeoutID back to null, trigger Splunk.Session.TIMEOUT_EVENT.
     */
    timeoutHandler: function(){
        this.stopTimeout();
        $(document).trigger(this.TIMEOUT_EVENT, new Date());
    }
});
Splunk.Session.instance = null;
/**
 * Singleton reference to Session object.
 *
 * @return A reference to a shared Session object.
 * @type Object
 */
Splunk.Session.getInstance = function(){
    if(!Splunk.Session.instance){
        Splunk.Session.instance = new Splunk.Session();
    }
    return Splunk.Session.instance;
};

define("splunk.session", ["lowpro","splunk","jquery","splunk.logger","splunk.util"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Splunk.Session;
    };
}(this)));

define('util/console_dev',[],function(){
    function bind(fn, context) {
        return function(){ fn.apply(context, arguments);  };
    }
    var orig = window.console, console = orig,
        CONSOLE_METHODS = ['log','trace','error','warn', 'info', 'debug'],
        EMPTY = function(){},i;
    try {
        console.DEBUG_ENABLED = true;
    } catch(e) {
        console = { DEBUG_ENABLED: true };
    }
    for (i = 0; i < CONSOLE_METHODS.length; i++) {
        var fn = CONSOLE_METHODS[i];
        if(typeof console[fn] !== 'function') {
            if(orig !== undefined && typeof orig[fn] == 'function') {
                console[fn] = bind(orig[fn], orig);
            } else {
                console[fn] = EMPTY;
            }
        }
    }
    return console;
});
define('util/console',[
            'jquery',
            'underscore',
            'util/console_dev',
            'splunk.logger',
            'splunk.util'
        ],
        function(
            $,
            _,
            devConsole,
            SplunkLogger,
            splunkUtils
        ) {

    var LOG_MODE = splunkUtils.getConfigValue("JS_LOGGER_MODE", "None"),
        LOG_LEVEL = splunkUtils.getConfigValue("JS_LOGGER_LEVEL", "INFO"),
        EMPTY = function() { };

    if(LOG_MODE === 'Firebug') {
        // if Function.prototype.bind is supported natively, we can use it to properly respect log levels
        // if not, it would result in log statements having incorrect source file names, so don't do it
        if(typeof devConsole.log.bind === 'function' && devConsole.log.bind.toString().indexOf('native code') > -1) {
            return ({
                trace: LOG_LEVEL === 'DEBUG' ? devConsole.trace.bind(devConsole) : EMPTY,
                debug: LOG_LEVEL === 'DEBUG' ? devConsole.debug.bind(devConsole) : EMPTY,
                log: LOG_LEVEL in { INFO: true, DEBUG: true } ? devConsole.log.bind(devConsole) : EMPTY,
                info: LOG_LEVEL in { INFO: true, DEBUG: true } ? devConsole.info.bind(devConsole) : EMPTY,
                warn: LOG_LEVEL !== 'ERROR' ? devConsole.warn.bind(devConsole) : EMPTY,
                error: devConsole.error.bind(devConsole)
            });
        }
        return devConsole;
    }
    return SplunkLogger.getLogger(splunkUtils.getConfigValue('USERNAME', '') + ':::' + window.location.href);

});
define(
    'helpers/Session',[ 
        'backbone', 
        'underscore',
        'splunk.session',
        'util/console',
        'splunk.util'
    ], function(Backbone, _, SplunkSession, console, splunkUtil){
    
    var Session = function() {
        this._session = SplunkSession.getInstance();
        this.cid = _.uniqueId();
        this.timeout = 'SessionTimeout.' + this.cid;
        this.start = 'SessionStart.' + this.cid;
        this.restart = 'HaltOnRestart.' + this.cid; //Stop all the pollers when restart is initiated from the UI

        $(document).on(this.timeout, function() {
            console.log("ui_inactivity_timeout occurred, current limit is: " + splunkUtil.getConfigValue("UI_INACTIVITY_TIMEOUT", this._session.UI_INACTIVITY_TIMEOUT) + ' minute(s)');
            this.trigger('timeout');
        }.bind(this));
        $(document).on(this.start, function() {
            this.trigger('start');
        }.bind(this));
        $(document).on(this.restart, function() {
            this.trigger('restart');
        }.bind(this));
    };

    _.extend(Session.prototype, Backbone.Events, {
        dispose: function() {
            $(document).off(this.timeout);
            $(document).off(this.start);
            $(document).off(this.restart);
        }
    });
    
    return new Session;
});

define('mixins/modelcollection',['underscore', 'util/Ticker', 'helpers/Session'], function(_, Ticker, Session) {
    return {
        safeFetch: function() {
            if (this.isFetching()) {
                this.touched = arguments;
                return;
            }
            delete this.touched;
            this.fetch.apply(this, arguments);
        },
        isFetching: function() {
            return this.fetchXhr && this.fetchXhr.state && this.fetchXhr.state()==='pending';
        },
        fetchAbort: function() {
            if (this.isFetching()) {
                delete this.touched;//fetch data will leak memory
                if(_.isFunction(this.fetchXhr.abort)) {
                    this.fetchXhr.abort();
                }
            }
        },
        deepOff: function() {
            this.fetchAbort();
            _(this.associated).each(function(associated) {
                if (_.isFunction(associated.deepOff)) {
                    associated.deepOff();
                }
            }, this);
            if (_.isFunction(this.fetchData.deepOff)) {
                this.fetchData.deepOff();
            } else {
                this.fetchData.off();
            }
            this.off();
        },

        DEFAULT_POLLING_DELAY: 1000,
        ticker: null,
        /**
         * Start polling the model/collection.
         * @param options {
         *     delay {Number}: time to wait after each fetch before fetching again, in milliseconds, default is 1000
         *     data: {Object}: the data that will be sent with each fetch
         *     stopOnError {Boolean}: stop polling if an error occurs on the model/collection, defaults to true
         *     uiInactivity {Boolean}: stop polling if a session timeout event occurs, defaults to false
         *     condition {Function}: callback to test if polling should continue
         *                           will be passed the model/collection and should return boolean indicating whether polling should continue
         *                           default behavior is to continue polling until cancelled for other reasons
         * }
         */
        startPolling: function(options) {
            options = options || {};
            if(this.ticker) {
                throw new Error('startPolling cannot be called while already polling');
            }

            this.ticker = new Ticker({interval: options.delay || this.DEFAULT_POLLING_DELAY});
            this.ticker.on('tick', function() {
                if(options.condition && !options.condition(this)) {
                    this.stopPolling();
                }
                else {
                    this.safeFetch({ data: options.data });
                }
            }, this);

            if(options.stopOnError !== false) {
                this.on('error', this.stopPolling, this);
            }

            if(options.uiInactivity) {
                Session.on('timeout', this.stopPolling, this);
            }

            this.ticker.start(true);
        },
        stopPolling: function() {
            if(this.ticker) {
                this.ticker.stop();
                this.ticker.off();
            }
            this.off('error', this.stopPolling, this);
            Session.off('timeout', this.stopPolling, this);
            this.ticker = null;
        }
    };
});
define('util/math_utils',[
       'underscore'
   ],
   function(_) {

    var DECIMAL_OR_SCIENTIFIC_REGEX = /(^[-+]?[0-9]*[.]?[0-9]*$)|(^[-+]?[0-9][.]?[0-9]*e[-+]?[1-9][0-9]*$)/;
    var MIN_SAFE_INTEGER = -9007199254740991; // Hard code Number.MIN_SAFE_INTEGER since it is not supported in IE, opera and safari
    var MAX_SAFE_INTEGER =  9007199254740991; // Hard code Number.MAX_SAFE_INTEGER since it is not supported in IE, opera and safari

    /**
     * @author sfishel
     *
     * A strict version of parseFloat that requires the entire input string to be valid decimal or scientific format
     *
     * @param {String} str - string to be parsed into a number
     * @return {Number or NaN}
     */

    var strictParseFloat = function(str) {
        // if the number is not in decimal or scientific format, return NaN explicitly
        // instead of letting JavaScript do its loose parsing
        if(!DECIMAL_OR_SCIENTIFIC_REGEX.test(str)) {
            return NaN;
        }
        return parseFloat(str);
    };

    /**
     * 
     * Rounds a number to a specifice exp base 10
     *
     * @param {Number} value - number to round
     * @param {Number} exp - exp of base 10 of the decimal palce to round to 
                            eg: exp=-1 rounds to the tenths place
                                exp=-2 rounds to the hundredth place
                                exp=0 rounds to the ones place
                                exp=1 rounds to the tens place
     * @return {Number or NaN}
     *
     * reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
     */
    var roundToDecimal = function(value, exp) {
        // If the exp is undefined or zero...
        if (typeof exp === 'undefined' || +exp === 0) {
            return Math.round(value);
        }
        value = +value;
        exp = +exp;
        // If the value is not a number or the exp is not an integer...
        if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
            return NaN;
        }
        // Shift
        value = value.toString().split('e');
        value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
        // Shift back
        value = value.toString().split('e');
        return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
    };

    /**
     *
     * Returns if an input is an integer
     *
     * @param {String} value
     * @return {Boolean}
     */
     var isInteger = function(value) {
        var parsedValue = strictParseFloat(value);
        return !isNaN(parsedValue) && parsedValue % 1 === 0;
     };
     
     var nearestMatchAndIndexInArray = function(valueToMatch, values) {         
         var closestValue, closestIndex;
         _.each(values, function(value, index){
             if (closestValue == null || (Math.abs(valueToMatch - value) < Math.abs(closestValue - valueToMatch))) {
                 closestValue = value;
                 closestIndex = index;
             }
         });
         return {value: closestValue, index: closestIndex};
     };

     /*
      * Returns the nearest whole power of ten to the given number, without exceeding that number
      * e.g.
      *
      * 10 -> 10
      * 11 -> 10
      * 99 -> 10
      * 100 -> 100
      * ...
      */
     var nearestPowerOfTen = function(number) {
         return Math.pow(10, Math.floor(Math.log(number) / Math.LN10));
     };

     var isLessThanMinSafeInt = function(number) {
        if(typeof number != 'number') return false;
        if(number <= MIN_SAFE_INTEGER) {
            return true;
        }
        return false;
     };

     var isGreaterThanMaxSafeInt = function(number) {
        if(typeof number != 'number') return false;
        if(number >= MAX_SAFE_INTEGER) {
            return true;
        }
        return false;
     };

     var stripFloatingPointErrors = function(number) {
         return (parseFloat(number.toPrecision(12)));
     };

    return ({
        strictParseFloat: strictParseFloat,
        roundToDecimal: roundToDecimal,
        isInteger: isInteger,
        nearestMatchAndIndexInArray: nearestMatchAndIndexInArray,
        nearestPowerOfTen: nearestPowerOfTen,
        isLessThanMinSafeInt: isLessThanMinSafeInt,
        isGreaterThanMaxSafeInt: isGreaterThanMaxSafeInt,
        stripFloatingPointErrors: stripFloatingPointErrors
    });

});
define(
    'util/general_utils',[
        'jquery',
        'underscore',
        'splunk.util',
        'util/math_utils'
    ],
    function($, _, SplunkUtils, mathUtils) {
        //returns an array of key:value pairs from the union of the values found in the
        //arrays with the key being the passed key
        var unionWithKey = function(arrayOne, arrayTwo, key) {
            var union = _.union(arrayOne, arrayTwo);
            return _.map(union, function(field) {
                var ret_hash = {};
                ret_hash[key] = field;
                return ret_hash;
            });
        };

        //returns an array of key:value pairs from the difference of the values found in the
        //arrays with the key being the passed key

        var differenceWithKey = function(arrayOne, arrayTwo, key) {
            var difference = _.difference(arrayOne, arrayTwo);
            return _.map(difference, function(field) {
                var ret_hash = {};
                ret_hash[key] = field;
                return ret_hash;
            });
        };

        /**
         * Filters the given object, omitting any key-value pairs where the key doesn't match at least one of the given
         * regular expressions
         *
         * @param obj {Object} the object to filter
         * @param regexes {Array<String or RegExp> or String or RegExp} a list of strings or regular expressions, strings will be converted
         *                                                              to regular expressions internally
         * @param options {Object} {
         *     strip {String or RegExp} optional, a pattern to strip from each key before comparing
         *     allowEmpty {Boolean} defaults to false, whether keys with empty values should be included in the return object
         *     allowObject {Boolean} defaults to false, whether keys with Object values should be included in the return object
         * }
         */

        var filterObjectByRegexes = function(obj, regexes, options) {
            options = options || {};
            if(!_(regexes).isArray()) {
                regexes = [regexes];
            }
            regexes = _.map(regexes, function(regex) {
                return (regex instanceof RegExp ? regex: new RegExp(regex));
            });

            var attrs = {}, strippedKey,
                strip = _.isString(options.strip) ? options.strip : '',
                allowEmpty = !!options.allowEmpty,
                allowObject = !!options.allowObject;

            // match for the wildcards on each key
            _.each(obj, function(value, key) {
                strippedKey = key.replace(strip, '');
                if (attrs[strippedKey]) {
                    return;
                }
                _.each(regexes, function(regex) {
                    if (regex.test(key)) {
                        if (!_.isUndefined(value)){
                            if ((_.isString(value) && value=='' && !allowEmpty) || (_.isObject(value) && !allowObject)) {
                                return;
                            }
                            attrs[strippedKey] = value;
                        }
                    }
                }, this);
            }, this);
            return attrs;
        };

        var deleteFromObjectByRegexes = function(obj, regexes) {
            if(!_(regexes).isArray()) {
                regexes = [regexes];
            }
            regexes = _.map(regexes, function(regex) {
                return (regex instanceof RegExp ? regex: new RegExp(regex));
            });

            var attrs = $.extend(true, {}, obj);

            // match for the wildcards on each key
            _.each(attrs, function(value, key) {
                _.each(regexes, function(regex) {
                    if (regex.test(key)) {
                        delete attrs[key];
                    }
                }, this);
            }, this);

            return attrs;
        };
        
        // Returns input as an array
        var asArray = function(obj) {
            if (obj == null) {
                return [];
            }
            return _.isArray(obj) ? obj : [obj];
        };

        /**
         * Converts a string with wildcard asterisks to the appropriate
         * regular expression object.
         *
         * Example Usage:
         * 
         * var foo = globber('te*st*');
         * // typeof foo is: RegExp
         * // foo's value is (without spaces): / ^ t e . * s t . * /
         *
         */
        var globber = function(str) {
            var rex, 
                chars = str.split('');

            if (_.first(chars) !== '*') {
                chars.unshift('^');
            }

            if (_.last(chars) !== '*') {
                chars.push('$');
            }
            str = chars.join('').replace(/\*/g, '.*');
            
            try { 
                rex = new RegExp(str); 
            } catch(e) {}

            return rex;
        };

        //takes two values and compares them returning the comparison inverted or not depending on
        //the sort direction boolean isAsc
        var compareWithDirection = function(value1, value2, isAsc) {
            var returnVal = 0;
            if (value1 == value2) {
                return returnVal;
            }
            if (value1 < value2){
                returnVal = -1;
            } else {
                returnVal = 1;
            }
            return (isAsc) ? returnVal : -returnVal;
        };

        /**
         * @author sfishel
         *
         * Checks if a list of values can be considered "numeric".
         *
         * Returns true if half or more of the non-null values can be parsed to a float.
         *
         * @param {Array} values
         * @return {Boolean}
         */

        var valuesAreNumeric = function(values) {
            var numericCount = 0,
                nonNullCount = 0;

            _(values).each(function(value) {
                // in the case of multivalue fields, use the first value
                if(_(value).isArray()) {
                    value = value.length > 0 ? value[0] : null;
                }
                if(_(value).isNull()) {
                    return;
                }
                nonNullCount++;
                var floatValue = mathUtils.strictParseFloat(value);
                if(!_(floatValue).isNaN()) {
                    numericCount++;
                }
            });
            if(nonNullCount === 0) {
                return false;
            }
            return (numericCount >= (nonNullCount / 2));
        };

        var valuesAreNumericAndFinite = function(values) {
            var areNumericAndFinite = true;
            _(values).each(function(value) {
                if (isNaN(value) || !isFinite(value)) {
                    areNumericAndFinite = false;
                }
            });
            return areNumericAndFinite;
        };

        /**
         * @author sfishel
         *
         * This is an approximation method for obtaining a pair of lower and upper percentile values from a list.
         *
         * Ported from //python-site/splunk/appserver/mrsparkle/lib/util.py
         *
         * @param {Array} orderedList, must be sorted before calling this method
         * @param {Number} lowerPercentile
         * @param {Number} upperPercentile
         *
         * @return {Object} an object with properties 'upper' and 'lower' corresponding to the upper and lower values.
         */

        var getPercentiles = function(orderedList, lowerPercentile, upperPercentile) {

            if(orderedList.length === 0) {
                return { upper: null, lower: null };
            }

            var f = function(p, ln) {
                var n = p * (ln - 1) + 1,
                    k = Math.floor(n),
                    d = n - k;

                return [n, k, d];
            };

            var v = function(percentile, oList) {
                var fArray = f(percentile, oList.length),
                    n = fArray[0],
                    k = fArray[1],
                    d = fArray[2];

                if(k === 0 || oList.length === 1) {
                    return oList[0];
                }
                else if(k === oList.length - 1) {
                    return oList[oList.length - 1];
                }
                else {
                    return (oList[k] + d * (oList[k + 1] - oList[k]));
                }
            };

            return ({
                lower: v(lowerPercentile, orderedList),
                upper: v(upperPercentile, orderedList)
            });

        };

        //take an object and replace a key with another key
        var transferKey = function(obj, oldKey, newKey) {
            if (!_.isUndefined(obj[oldKey])){
                obj[newKey] = obj[oldKey];
                delete obj[oldKey];
            }
        };

        /**
         *  @author jszeto
         *
         *  Returns a copy of the object where the keys have become the values and the values the keys.
         *  For this to work, all of your object's values should be unique and string serializable.
         *
         * @param obj
         * @return {Object}
         */
        var invert = function (obj) {

            // TODO [JCS] Create a version that resolves key conflicts by creating an array of values.
            // TODO [JCS] Underscore provides an invert function, but the values must be unique.
            var new_obj = {};

            for (var prop in obj) {
                if(obj.hasOwnProperty(prop)) {
                    new_obj[obj[prop]] = prop;
                }
            }

            return new_obj;
        };

        /**
         * Converts 13824237 to 13,824,237
         * @param num
         * @return {String}
         */
        var convertNumToString = function(num) {
            // adds a comma after each 3 digits
            if (!num) {
                return null;
            }
            return (num.toString()).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
        };

        /**
         * Not an exhaustive check that the search string can be parsed as a pivot search, but some simple checks
         * that the search starts with "| pivot" and doesn't pipe to any other search commands.
         *
         * @param searchString
         */
        var isValidPivotSearch = function(searchString) {
            if(!/^\s*\|\s*pivot\s+/.test(searchString)) {
                return false;
            }
            // now we need to check for a "|" to another search command,
            // but need to make sure we don't match a "|" inside a string
            // start by removing any escaped quotes
            searchString = searchString.replace(/(\\"|\\')/g, '');
            // then it is safe to remove any quoted contents
            searchString = searchString.replace(/".*"/g, '').replace(/'.*'/g, '');
            // now if there is more than one "|" left it is a search language pipe
            return searchString.split('|').length === 2;
        };

        /**
         * Returns the text currently selected with mouse or null
         */
        var getMouseSelection = function() {
            if (window.getSelection) {
                return window.getSelection().toString();
            } else if (document.selection) {
                return document.selection.createRange().text;
            }
            return null;
        };

        var isTrueEquivalent = function(value) {
            value = typeof(value) === 'string' ? value.toLowerCase() : value;
            return value === true || value === 1 ||
                value === 'true' || value === '1' || value === 'on' || value === 'yes';
        };

        var isFalseEquivalent = function(value) {
            value = typeof(value) === 'string' ? value.toLowerCase() : value;
            return value === false || value === 0 ||
                value === 'false' || value === '0' || value === 'off' || value === 'no';
        };

        /**
         * Checks if the given value can be normalized to a boolean value
         * @see normalizeBoolean
         * @param value {*} the value which
         * @returns {Boolean} true if the value can be normalized to a boolean value, otherwise false
         */
        var isBooleanEquivalent = function(value) {
            return isTrueEquivalent(value) || isFalseEquivalent(value);
        };

        /**
         * Strict normalization of a string to boolean which always returns a boolean value.
         * The following values are treated as true (see isTrue helper)
         *      - the strings "true", "on", "yes" or "1" (case-insensitive)
         *      - the integer 1
         *      - the boolean true
         * The following values are normalized to false (see isFalse helper)
         *      - the strings "false", "off", "no" or "0" (case-insensitive)
         *      - the integer 0
         *      - the boolean false
         * @param value {Boolean|Number|String} - a value to be normalized as a boolean
         * @param options {Object} - {
         *      default {Boolean|Number|String} - fallback value in case the string is not a valid boolean expression
         *  }
         * @returns {Boolean} the normalization result in case of a valid boolean expression, the default value if
         *                    specified and a valid boolean, otherwise the default value is normalized or if not
         *                    specified false is returned by default
         */
        var normalizeBoolean = function(value, options) {
            options || (options = {});
            if (isTrueEquivalent(value)) {
                return true;
            }
            if (isFalseEquivalent(value)) {
                return false;
            }
            return options.hasOwnProperty('default') ?
                (typeof(options['default']) === 'boolean' ? options['default'] : normalizeBoolean(options['default']))
                : false;
        };
        
        
        /**
         * This method is some nasty backwards compatibility for a GET param that used to be a boolean string, but has been migrated to int
         */
        var parseBooleanOrInt = function(val) {
            if (mathUtils.isInteger(val)) {
                return parseInt(val, 10);
            }
            return normalizeBoolean(val);
        };
        
        /**
        * Equality comparison that will deal with objects and Booleans.
        * If both params are Boolean or Boolean-equivalent
        * (see the the doc comment for normalizeBoolean)
        * convert them to Boolean and use === to compare.
        * Otherwise use Underscore isEqual to compare them.
        *
        * @param value1 {Boolean|Number|String|Object} - value to be compared.
        * @param value2 {Boolean|Number|String|Object} - value to be compared.
        * @returns {Boolean} - Returns true if the values are the same, false if they are different. 
        */
        var checkEquality = function(value1, value2) {
            if (isBooleanEquivalent(value1) && isBooleanEquivalent(value2)) {
                return (normalizeBoolean(value1) === normalizeBoolean(value2));
            } else {
                return _.isEqual(value1, value2);
            }
        };

        /**
         * Check if an array is a subset of another array, where the
         * needle array may contain wildcard characaters. An empty array
         * is always a subset of another array.
         *
         * NOTE: String comparison is always used, so [1] will be considered
         * a subset of ['1'].
         *
         * Example Usage:
         *
         * var isSubset = isFuzzySubset(['one', 't*e'], ['four', 'three', 'one', 'two']);
         * // isSubset's value is: true
         *
         */
        var isFuzzySubset = function(subset, superset) {
            superset.length || (superset = ['*']);  // Force superset to have at least one element
            var intersection = _(subset).filter(function(subsetElement) {
                var subsetElementPattern = globber(subsetElement.toString());
                return _(superset).find(function(supersetElement) {
                    return supersetElement.toString().match(subsetElementPattern) !== null;
                });
            });
            return intersection.length == subset.length;
        };


        /**
         * Genereate regular expression from filter string
         * 
         * Example Usage:
         * 
         * var foo = generateRegex("a bc d")
         * // typeof foo is: RegExp
         * // foo's value is (without spaces): /^(?=.*a)(?=.*bc)(?=.*d)/ 
         *
         */
        var VALUES_REGEX = /(\'.*?\')|(\".*?\")|([^\s]+)/g,
            QUOTES_REGEX = /^(\".*\")$|^(\'.*\')$/;
        var generateFilterRegex = function(value) {
            // Escape value to be treated as literal string
            value = SplunkUtils.escapeRegex(value);

            var values = (value) ? value.match(VALUES_REGEX): []; 
            if (values.length) {
                var parsed = _.chain(values)
                    .map(function(value) {
                        if (value.match(QUOTES_REGEX)) {
                            var len = value.length;
                            value = value.substring(1, len-1);
                        }
                        return ['(?=.*', value,')'].join('');
                    }) 
                    .join('')
                    .value();
                return new RegExp('^' + parsed, 'im'); // Added ignore case and multiline match flags
            } else {
                return new RegExp('.*');
            }
        };

        return {
            VALUES_REGEX: VALUES_REGEX,
            QUOTES_REGEX: QUOTES_REGEX,
            compareWithDirection: compareWithDirection,
            unionWithKey: unionWithKey,
            differenceWithKey: differenceWithKey,
            filterObjectByRegexes: filterObjectByRegexes,
            deleteFromObjectByRegexes: deleteFromObjectByRegexes,
            globber: globber,
            valuesAreNumeric: valuesAreNumeric,
            valuesAreNumericAndFinite: valuesAreNumericAndFinite,
            getPercentiles: getPercentiles,
            transferKey: transferKey,
            convertNumToString: convertNumToString,
            invert: invert,
            isValidPivotSearch: isValidPivotSearch,
            getMouseSelection: getMouseSelection,
            normalizeBoolean: normalizeBoolean,
            isBooleanEquivalent: isBooleanEquivalent,
            checkEquality: checkEquality,
            isFuzzySubset: isFuzzySubset,
            asArray: asArray,
            generateFilterRegex: generateFilterRegex,
            parseBooleanOrInt: parseBooleanOrInt
        };
    }
);

define(
    'util/splunkd_utils',[
        'jquery',
        'underscore',
        'splunk.util',
        'splunk.config',
        'util/general_utils'
    ],
    function($, _, splunkUtils, splunkConfig, generalUtils) {
        
        var SYSTEM = "system",
            GLOBAL = "global",
            APP = "app",
            USER = "user",
            NOBODY = "nobody",
            WILDCARD = "-",
            VERBOSE = "verbose",
            FAST = "fast",
            SMART = "smart",
            FATAL = 'fatal',
            ERROR = 'error',
            WARNING = 'warn',
            INFO = 'info',
            NETWORK_ERROR = 'network_error',
            NOT_FOUND = '404',
            DEFAULT_LOCALE = 'en-US';
        
        var fullpath = function(path, options) {
            options = options || {};
            var isServicesPath = /^\/services/.test(path),
                isAbsolute = /^\/.*/.test(path);

            //return if not a relative path
            if (isAbsolute && !isServicesPath){
                return path;
            } else if (isAbsolute && isServicesPath) {
                return splunkConfig.SPLUNKD_PATH + path;
            }

            // If we don't have an app name (explicitly or implicitly), we default to /services/
            if (!options.app && !options.owner) {
                return splunkConfig.SPLUNKD_PATH + "/services/" + path;
            }

            // Get the app and owner, first from the passed in namespace or
            // default to wild cards
            var owner = options.owner || WILDCARD;
            var app   = options.app || WILDCARD;

            options.sharing = (options.sharing || "").toLowerCase();
             
            // Modify the owner and app appropriately based on the sharing parameter
            if (options.sharing === APP || options.sharing === GLOBAL) {
                owner = NOBODY;
            } else if (options.sharing === SYSTEM) {
                owner = NOBODY;
                app = SYSTEM;
            }
            return splunkConfig.SPLUNKD_PATH + "/servicesNS/" + encodeURIComponent(owner) + "/" + encodeURIComponent(app) + "/" + path;
        };
        
        var xhrErrorResponseParser = function(response, id) {
            var responseData = {}, 
                isValidJSON = true,
                messages = [];
            id = id || _("object from SplunkD").t();
                        
            if(response.hasOwnProperty('responseText') && response.hasOwnProperty('getResponseHeader')) {
               var contentType = response.getResponseHeader('Content-Type');
               if (contentType && (contentType.indexOf('application/json') > -1) && response.responseText) {
                    try {
                        responseData = JSON.parse(response.responseText);
                    }
                    catch(e) {
                        isValidJSON = false;
                    }
                }
            }
                        
            // have to maintain compatibility with older models that have the response wrapped in a "data" attribute
            if(response.hasOwnProperty('data')) {
                responseData = responseData.data;
            }
            
            if (response.hasOwnProperty('status')) {
                if (response.status == 404 && $.isEmptyObject(responseData)) {
                    messages.push(createMessageObject(
                        NOT_FOUND,
                        splunkUtils.sprintf(
                            _('Could not retrieve %s. Make sure that this resource exists and has the correct permissions.').t(),
                            id
                        )
                    ));
                } else if (response.status == 0 || response.status == 12029) {
                    messages.push(createMessageObject(NETWORK_ERROR, _('Your network connection may have been lost or Splunk may be down.').t()));
                }
            }
            
            if (!isValidJSON) {
                messages.push(createMessageObject(ERROR, splunkUtils.sprintf(_('Invalid JSON from: %s.').t(), id)));
            } else if (responseData.messages) {
                messages = messages.concat(parseMessagesObject(responseData.messages));
            } else if (response.messages) {
                var responseMessages = parseMessagesObject(response.messages);
                if (responseMessages.length) {
                    messages = messages.concat(responseMessages);
                } else {
                    messages.push(createMessageObject(ERROR, _('Server error').t()));
                }
            } else if (_.isString(response)) {
                messages.push(createMessageObject(ERROR, response));
            }
            
            if (!messages.length) {
                messages.push(createMessageObject(ERROR, _('Server error').t()));
            }
            
            return messages;
        };

        var prepareSyncOptions = function(options, baseUrl) {
            var appOwner = {},
                defaults = {data: {output_mode: 'json'}};

            if (options && options.data){
                appOwner = $.extend(appOwner, { //JQuery purges undefined
                    app: options.data.app || undefined,
                    owner: options.data.owner || undefined,
                    sharing: options.data.sharing || undefined
                });
                delete options.data.app;
                delete options.data.owner;
                delete options.data.sharing;
            }
            defaults.url = fullpath(baseUrl, appOwner);
            return $.extend(true, defaults, options || {});
        };
        
        var nameFromString = function(str) {
            str = str || "";
            return str.toLowerCase().replace(/\s/g, "_").replace(/\W/g, "");
        };

        var createSearchFilterString = function(value, keys) {
            var values = (value) ? (value.match(generalUtils.VALUES_REGEX) || []): []; 
            return _(keys).map(function(key) {
                if (values.length) {
                    return '(' + _.chain(values)
                            .map(function(value) {
                                // if value has quote around it remove quotes
                                if (value.match(generalUtils.QUOTES_REGEX)) {
                                    var len = value.length;
                                    value = value.substring(1, len-1);
                                }
                                //escape quotes
                                return [key, '="*', value.replace(/'/g,"\\'").replace(/"/g,'\\"'), '*"'].join('');
                            },this)
                            .join(' AND ')
                            .value() + ')';
                } else {
                    return [key, '=*'].join('');
                }
            },this).join(' OR ');
        };

        var createSearchFilterObj = function(value, keys) {
            var values = (value) ? (value.match(generalUtils.VALUES_REGEX) || []): [],
            filterObj = {}; 

            if (values.length) {
                var matches = [];
                _(values).each(function(value){
                    if (value.match(generalUtils.QUOTES_REGEX)) {
                        var len = value.length;
                        value = value.substring(1, len-1);
                    }
                    matches.push(value.replace(/'/g,"\\'").replace(/"/g,'\"'));
                },this);   

                _(keys).each(function(key) {
                    filterObj[key] = matches;
                }, this);
            }
            return filterObj;
        };

        var parseError = function(error) {
            var passedErrors = {},
                parsedError;

            if (error.responseText) {
                try {
                    parsedError = JSON.parse(error.responseText);
                }
                catch(e) {
                    parsedError = {};
                }
                if (parsedError.messages) {
                    _.each(parsedError.messages, function(value) {
                        passedErrors['splunkD:' + value.type] = value.text;
                    });
                }
            } else {
                passedErrors = error;
            }
            return passedErrors;
        };

        var createMessageObject = function(type, message) {
            type = type.toLowerCase();

            var jsonStart = message.indexOf("~!~{");
            var jsonEnd = message.lastIndexOf("}~!~");
            var jsonMsg;
            var messageText = message;

            if (jsonStart != -1 && jsonEnd != -1) {
                try
                {
                    var jsonBlock = message.slice(jsonStart+3, jsonEnd+1);
                    jsonMsg = JSON.parse(jsonBlock);
                    messageText = jsonMsg.errorMessageEnglish;
                }
                catch (e) {
                }
            }
            // Handle structured message
            return ({
                key: _.uniqueId('splunkd_' + type),
                type: type,
                message: messageText,
                text: messageText
            });

        };
        
        var parseMessagesObject = function(messages) {
            if(!messages) {
                return [];
            }
            return _(messages).map(function(message) {
                return createMessageObject(message.type, message.text);
            });
        };

        
        var messagesContainsOneOfTypes = function(messages, types){
            if (messages) {
                for(var i = 0; i < messages.length; i++) {
                    if (_.indexOf(types, messages[i].type) != -1) {
                        return true;
                    }
                }
            }
            return false;
        };
        
        var filterMessagesByTypes = function(messages, types) {
            var filteredMessages = [];
            if (messages) {
                for(var i = 0; i < messages.length; i++) {
                    if (_.indexOf(types, messages[i].type) != -1) {
                        filteredMessages.push(messages[i]);
                    }
                }
            }
            return filteredMessages;
        };
        
        /**
         * Munge the difference between what splunkd outputs and what the renderer expects for message type.
         *
         * Namely splunkd has a 'fatal' type that we re-map to 'error', and splunkd uses 'warn' where the renderer
         * wants 'warning'.
         */
        var normalizeType = function(type) {
            if(type === FATAL) {
                return ERROR;
            }
            if(type === WARNING) {
                return 'warning';
            }
            return type;
        };
        
        var addAnchorsToWildcardArray = function(wildcardArray) {
            return _.map(wildcardArray, function(wildcard){
                if (!/^\^/.test(wildcard)){
                    return "^" + wildcard;
                }
                return wildcard;
            });
        };
        
        var createSplunkDMessage = function(type, text) {
            return {
                messages: [{
                    type: type,
                    text: text
                }]
            };
        };

        var getSharingLabel = function(sharing) {
            switch (sharing) {
                case USER:
                    return _("Private").t();
                case APP:
                    return _("App").t();
                case GLOBAL:
                    return _("Global").t();
                case SYSTEM:
                    return _("Global").t();
            }
        };

        var getPermissionLabel = function(sharing, owner) {
            switch (sharing) {
                case USER:
                    return splunkUtils.sprintf(_("Private. Owned by %s.").t(), owner);
                case APP:
                    return splunkUtils.sprintf(_("Shared in App. Owned by %s.").t(), owner);
                case GLOBAL:
                case SYSTEM:
                    return splunkUtils.sprintf(_("Shared Globally. Owned by %s.").t(), owner);
            }
            return "";
        };
        
        var normalizeValuesForPOST = function(values) {
            var valuesCopy = $.extend(true, {}, values);
            _.each(valuesCopy, function(value, key) {
                if (typeof(value) === "boolean") {
                    if (value) {
                        valuesCopy[key] = "1";
                    } else {
                        valuesCopy[key] = "0";
                    }
                }              
            });
            return valuesCopy;
        };
        
        var normalizeBooleanTo01String = function(value) {
            var bool = splunkUtils.normalizeBoolean(value);
            if (bool) {
                return "1";
            }
            return "0";
        };
        
        var isExistingEntity = function(payload) {
            if (
        		payload && 
        		payload.entry && 
        		_.isArray(payload.entry) && 
        		payload.entry[0].links && 
        		payload.entry[0].links.alternate && 
        		!/.\/_new$/.test(payload.entry[0].links.alternate)
            ) {
                return true;
            }
            return false;
        };
         
        return {
            // constants for splunkd message types
            FATAL: FATAL,
            ERROR: ERROR,
            WARNING: WARNING,
            INFO: INFO,
            NOT_FOUND: NOT_FOUND,
            NETWORK_ERROR: NETWORK_ERROR,
            
            //constants for ACL
            SYSTEM: SYSTEM,
            GLOBAL: GLOBAL,
            APP: APP,
            USER: USER,
            NOBODY: NOBODY,
            WILDCARD:  WILDCARD,
            
            //constants for the adhoc search level
            VERBOSE: VERBOSE,
            FAST: FAST,
            SMART: SMART,

            //constans for filters
            VALUES_REGEX: generalUtils.VALUES_REGEX,
            QUOTES_REGEX: generalUtils.QUOTES_REGEX,

            DEFAULT_LOCALE: DEFAULT_LOCALE,

            fullpath: fullpath,
            prepareSyncOptions: prepareSyncOptions,
            nameFromString: nameFromString,
            createSearchFilterString: createSearchFilterString,
            createSearchFilterObj: createSearchFilterObj,
            parseError: parseError,
            parseMessagesObject: parseMessagesObject,
            createMessageObject: createMessageObject,
            messagesContainsOneOfTypes: messagesContainsOneOfTypes,
            addAnchorsToWildcardArray: addAnchorsToWildcardArray,
            createSplunkDMessage: createSplunkDMessage,
            getSharingLabel: getSharingLabel,
            getPermissionLabel: getPermissionLabel,
            normalizeType: normalizeType,
            filterMessagesByTypes: filterMessagesByTypes,
            xhrErrorResponseParser: xhrErrorResponseParser,
            normalizeValuesForPOST: normalizeValuesForPOST,
            normalizeBooleanTo01String: normalizeBooleanTo01String,
            isExistingEntity: isExistingEntity
        };
    });

// Backbone.Validation v0.9.1
//
// Copyright (c) 2011-2014 Thomas Pedersen
// Distributed under MIT License
//
// Documentation and full license available at:
// http://thedersen.com/projects/backbone-validation
(function (factory) {
  if (typeof exports === 'object') {
    module.exports = factory(require('backbone'), require('underscore'));
  } else if (typeof define === 'function' && define.amd) {
    define('backbone_validation',['backbone', 'underscore'], factory);
  }
}(function (Backbone, _) {
  Backbone.Validation = (function(_){
    'use strict';
  
    // Default options
    // ---------------
  
    var defaultOptions = {
      forceUpdate: false,
      selector: 'name',
      labelFormatter: 'sentenceCase',
      valid: Function.prototype,
      invalid: Function.prototype
    };
  
  
    // Helper functions
    // ----------------
  
    // Formatting functions used for formatting error messages
    var formatFunctions = {
      // Uses the configured label formatter to format the attribute name
      // to make it more readable for the user
      formatLabel: function(attrName, model) {
        return defaultLabelFormatters[defaultOptions.labelFormatter](attrName, model);
      },
  
      // Replaces nummeric placeholders like {0} in a string with arguments
      // passed to the function
      format: function() {
        var args = Array.prototype.slice.call(arguments),
            text = args.shift();
        return text.replace(/\{(\d+)\}/g, function(match, number) {
          return typeof args[number] !== 'undefined' ? args[number] : match;
        });
      }
    };
  
    // Flattens an object
    // eg:
    //
    //     var o = {
    //       address: {
    //         street: 'Street',
    //         zip: 1234
    //       }
    //     };
    //
    // becomes:
    //
    //     var o = {
    //       'address.street': 'Street',
    //       'address.zip': 1234
    //     };
    var flatten = function (obj, into, prefix) {
      into = into || {};
      prefix = prefix || '';
  
      _.each(obj, function(val, key) {
        if(obj.hasOwnProperty(key)) {
          if (val && typeof val === 'object' && !(
            val instanceof Array ||
            val instanceof Date ||
            val instanceof RegExp ||
            val instanceof Backbone.Model ||
            val instanceof Backbone.Collection)
          ) {
            flatten(val, into, prefix + key + '.');
          }
          else {
            into[prefix + key] = val;
          }
        }
      });
  
      return into;
    };
  
    // Validation
    // ----------
  
    var Validation = (function(){
  
      // Returns an object with undefined properties for all
      // attributes on the model that has defined one or more
      // validation rules.
      var getValidatedAttrs = function(model) {
        return _.reduce(_.keys(_.result(model, 'validation') || {}), function(memo, key) {
          memo[key] = void 0;
          return memo;
        }, {});
      };
  
      // Looks on the model for validations for a specified
      // attribute. Returns an array of any validators defined,
      // or an empty array if none is defined.
      var getValidators = function(model, attr) {
        var attrValidationSet = model.validation ? _.result(model, 'validation')[attr] || {} : {};
  
        // If the validator is a function or a string, wrap it in a function validator
        if (_.isFunction(attrValidationSet) || _.isString(attrValidationSet)) {
          attrValidationSet = {
            fn: attrValidationSet
          };
        }
  
        // Stick the validator object into an array
        if(!_.isArray(attrValidationSet)) {
          attrValidationSet = [attrValidationSet];
        }
  
        // Reduces the array of validators into a new array with objects
        // with a validation method to call, the value to validate against
        // and the specified error message, if any
        return _.reduce(attrValidationSet, function(memo, attrValidation) {
          _.each(_.without(_.keys(attrValidation), 'msg'), function(validator) {
            memo.push({
              fn: defaultValidators[validator],
              val: attrValidation[validator],
              msg: attrValidation.msg
            });
          });
          return memo;
        }, []);
      };
  
      // Validates an attribute against all validators defined
      // for that attribute. If one or more errors are found,
      // the first error message is returned.
      // If the attribute is valid, an empty string is returned.
      var validateAttr = function(model, attr, value, computed) {
        // Reduces the array of validators to an error message by
        // applying all the validators and returning the first error
        // message, if any.
        return _.reduce(getValidators(model, attr), function(memo, validator){
          // Pass the format functions plus the default
          // validators as the context to the validator
          var ctx = _.extend({}, formatFunctions, defaultValidators),
              result = validator.fn.call(ctx, value, attr, validator.val, model, computed);
  
          if(result === false || memo === false) {
            return false;
          }
          if (result && !memo) {
            return _.result(validator, 'msg') || result;
          }
          return memo;
        }, '');
      };
  
      // Loops through the model's attributes and validates them all.
      // Returns and object containing names of invalid attributes
      // as well as error messages.
      var validateModel = function(model, attrs) {
        var error,
            invalidAttrs = {},
            isValid = true,
            computed = _.clone(attrs),
            flattened = flatten(attrs);
  
        _.each(flattened, function(val, attr) {
          error = validateAttr(model, attr, val, computed);
          if (error) {
            invalidAttrs[attr] = error;
            isValid = false;
          }
        });
  
        return {
          invalidAttrs: invalidAttrs,
          isValid: isValid
        };
      };
  
      // Contains the methods that are mixed in on the model when binding
      var mixin = function(view, options) {
        return {
  
          // Check whether or not a value, or a hash of values
          // passes validation without updating the model
          preValidate: function(attr, value) {
            var self = this,
                result = {},
                error;
  
            if(_.isObject(attr)){
              _.each(attr, function(value, key) {
                error = self.preValidate(key, value);
                if(error){
                  result[key] = error;
                }
              });
  
              return _.isEmpty(result) ? undefined : result;
            }
            else {
              return validateAttr(this, attr, value, _.extend({}, this.attributes));
            }
          },
  
          // Check to see if an attribute, an array of attributes or the
          // entire model is valid. Passing true will force a validation
          // of the model.
          isValid: function(option) {
            var flattened = flatten(this.attributes);
  
            if(_.isString(option)){
              return !validateAttr(this, option, flattened[option], _.extend({}, this.attributes));
            }
            if(_.isArray(option)){
              return _.reduce(option, function(memo, attr) {
                return memo && !validateAttr(this, attr, flattened[attr], _.extend({}, this.attributes));
              }, true, this);
            }
            if(option === true) {
              this.validate();
            }
            return this.validation ? this._isValid : true;
          },
  
          // This is called by Backbone when it needs to perform validation.
          // You can call it manually without any parameters to validate the
          // entire model.
          validate: function(attrs, setOptions){
            var model = this,
                validateAll = !attrs,
                opt = _.extend({}, options, setOptions),
                validatedAttrs = getValidatedAttrs(model),
                allAttrs = _.extend({}, validatedAttrs, model.attributes, attrs),
                changedAttrs = flatten(attrs || allAttrs),
  
                result = validateModel(model, allAttrs);
  
            model._isValid = result.isValid;
  
            // After validation is performed, loop through all validated attributes
            // and call the valid callbacks so the view is updated.
            _.each(validatedAttrs, function(val, attr){
              var invalid = result.invalidAttrs.hasOwnProperty(attr);
              if(!invalid){
                opt.valid(view, attr, opt.selector);
              }
            });
  
            // After validation is performed, loop through all validated and changed attributes
            // and call the invalid callback so the view is updated.
            _.each(validatedAttrs, function(val, attr){
              var invalid = result.invalidAttrs.hasOwnProperty(attr),
                  changed = changedAttrs.hasOwnProperty(attr);
  
              if(invalid && (changed || validateAll)){
                opt.invalid(view, attr, result.invalidAttrs[attr], opt.selector);
              }
            });
  
            // Trigger validated events.
            // Need to defer this so the model is actually updated before
            // the event is triggered.
            _.defer(function() {
              model.trigger('validated', model._isValid, model, result.invalidAttrs);
              model.trigger('validated:' + (model._isValid ? 'valid' : 'invalid'), model, result.invalidAttrs);
            });
  
            // Return any error messages to Backbone, unless the forceUpdate flag is set.
            // Then we do not return anything and fools Backbone to believe the validation was
            // a success. That way Backbone will update the model regardless.
            if (!opt.forceUpdate && _.intersection(_.keys(result.invalidAttrs), _.keys(changedAttrs)).length > 0) {
              return result.invalidAttrs;
            }
          }
        };
      };
  
      // Helper to mix in validation on a model
      var bindModel = function(view, model, options) {
        _.extend(model, mixin(view, options));
      };
  
      // Removes the methods added to a model
      var unbindModel = function(model) {
        delete model.validate;
        delete model.preValidate;
        delete model.isValid;
      };
  
      // Mix in validation on a model whenever a model is
      // added to a collection
      var collectionAdd = function(model) {
        bindModel(this.view, model, this.options);
      };
  
      // Remove validation from a model whenever a model is
      // removed from a collection
      var collectionRemove = function(model) {
        unbindModel(model);
      };
  
      // Returns the public methods on Backbone.Validation
      return {
  
        // Current version of the library
        version: '0.9.1',
  
        // Called to configure the default options
        configure: function(options) {
          _.extend(defaultOptions, options);
        },
  
        // Hooks up validation on a view with a model
        // or collection
        bind: function(view, options) {
          options = _.extend({}, defaultOptions, defaultCallbacks, options);
  
          var model = options.model || view.model,
              collection = options.collection || view.collection;
  
          if(typeof model === 'undefined' && typeof collection === 'undefined'){
            throw 'Before you execute the binding your view must have a model or a collection.\n' +
                  'See http://thedersen.com/projects/backbone-validation/#using-form-model-validation for more information.';
          }
  
          if(model) {
            bindModel(view, model, options);
          }
          else if(collection) {
            collection.each(function(model){
              bindModel(view, model, options);
            });
            collection.bind('add', collectionAdd, {view: view, options: options});
            collection.bind('remove', collectionRemove);
          }
        },
  
        // Removes validation from a view with a model
        // or collection
        unbind: function(view, options) {
          options = _.extend({}, options);
          var model = options.model || view.model,
              collection = options.collection || view.collection;
  
          if(model) {
            unbindModel(model);
          }
          else if(collection) {
            collection.each(function(model){
              unbindModel(model);
            });
            collection.unbind('add', collectionAdd);
            collection.unbind('remove', collectionRemove);
          }
        },
  
        // Used to extend the Backbone.Model.prototype
        // with validation
        mixin: mixin(null, defaultOptions)
      };
    }());
  
  
    // Callbacks
    // ---------
  
    var defaultCallbacks = Validation.callbacks = {
  
      // Gets called when a previously invalid field in the
      // view becomes valid. Removes any error message.
      // Should be overridden with custom functionality.
      valid: function(view, attr, selector) {
        view.$('[' + selector + '~="' + attr + '"]')
            .removeClass('invalid')
            .removeAttr('data-error');
      },
  
      // Gets called when a field in the view becomes invalid.
      // Adds a error message.
      // Should be overridden with custom functionality.
      invalid: function(view, attr, error, selector) {
        view.$('[' + selector + '~="' + attr + '"]')
            .addClass('invalid')
            .attr('data-error', error);
      }
    };
  
  
    // Patterns
    // --------
  
    var defaultPatterns = Validation.patterns = {
      // Matches any digit(s) (i.e. 0-9)
      digits: /^\d+$/,
  
      // Matches any number (e.g. 100.000)
      number: /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/,
  
      // Matches a valid email address (e.g. mail@example.com)
      email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,
  
      // Mathes any valid url (e.g. http://www.xample.com)
      url: /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
    };
  
  
    // Error messages
    // --------------
  
    // Error message for the build in validators.
    // {x} gets swapped out with arguments form the validator.
    var defaultMessages = Validation.messages = {
      required: '{0} is required',
      acceptance: '{0} must be accepted',
      min: '{0} must be greater than or equal to {1}',
      max: '{0} must be less than or equal to {1}',
      range: '{0} must be between {1} and {2}',
      length: '{0} must be {1} characters',
      minLength: '{0} must be at least {1} characters',
      maxLength: '{0} must be at most {1} characters',
      rangeLength: '{0} must be between {1} and {2} characters',
      oneOf: '{0} must be one of: {1}',
      equalTo: '{0} must be the same as {1}',
      digits: '{0} must only contain digits',
      number: '{0} must be a number',
      email: '{0} must be a valid email',
      url: '{0} must be a valid url',
      inlinePattern: '{0} is invalid'
    };
  
    // Label formatters
    // ----------------
  
    // Label formatters are used to convert the attribute name
    // to a more human friendly label when using the built in
    // error messages.
    // Configure which one to use with a call to
    //
    //     Backbone.Validation.configure({
    //       labelFormatter: 'label'
    //     });
    var defaultLabelFormatters = Validation.labelFormatters = {
  
      // Returns the attribute name with applying any formatting
      none: function(attrName) {
        return attrName;
      },
  
      // Converts attributeName or attribute_name to Attribute name
      sentenceCase: function(attrName) {
        return attrName.replace(/(?:^\w|[A-Z]|\b\w)/g, function(match, index) {
          return index === 0 ? match.toUpperCase() : ' ' + match.toLowerCase();
        }).replace(/_/g, ' ');
      },
  
      // Looks for a label configured on the model and returns it
      //
      //      var Model = Backbone.Model.extend({
      //        validation: {
      //          someAttribute: {
      //            required: true
      //          }
      //        },
      //
      //        labels: {
      //          someAttribute: 'Custom label'
      //        }
      //      });
      label: function(attrName, model) {
        return (model.labels && model.labels[attrName]) || defaultLabelFormatters.sentenceCase(attrName, model);
      }
    };
  
  
    // Built in validators
    // -------------------
  
    var defaultValidators = Validation.validators = (function(){
      // Use native trim when defined
      var trim = String.prototype.trim ?
        function(text) {
          return text === null ? '' : String.prototype.trim.call(text);
        } :
        function(text) {
          var trimLeft = /^\s+/,
              trimRight = /\s+$/;
  
          return text === null ? '' : text.toString().replace(trimLeft, '').replace(trimRight, '');
        };
  
      // Determines whether or not a value is a number
      var isNumber = function(value){
        return _.isNumber(value) || (_.isString(value) && value.match(defaultPatterns.number));
      };
  
      // Determines whether or not a value is empty
      var hasValue = function(value) {
        return !(_.isNull(value) || _.isUndefined(value) || (_.isString(value) && trim(value) === '') || (_.isArray(value) && _.isEmpty(value)));
      };
  
      return {
        // Function validator
        // Lets you implement a custom function used for validation
        fn: function(value, attr, fn, model, computed) {
          if(_.isString(fn)){
            fn = model[fn];
          }
          return fn.call(model, value, attr, computed);
        },
  
        // Required validator
        // Validates if the attribute is required or not
        // This can be specified as either a boolean value or a function that returns a boolean value
        required: function(value, attr, required, model, computed) {
          var isRequired = _.isFunction(required) ? required.call(model, value, attr, computed) : required;
          if(!isRequired && !hasValue(value)) {
            return false; // overrides all other validators
          }
          if (isRequired && !hasValue(value)) {
            return this.format(defaultMessages.required, this.formatLabel(attr, model));
          }
        },
  
        // Acceptance validator
        // Validates that something has to be accepted, e.g. terms of use
        // `true` or 'true' are valid
        acceptance: function(value, attr, accept, model) {
          if(value !== 'true' && (!_.isBoolean(value) || value === false)) {
            return this.format(defaultMessages.acceptance, this.formatLabel(attr, model));
          }
        },
  
        // Min validator
        // Validates that the value has to be a number and equal to or greater than
        // the min value specified
        min: function(value, attr, minValue, model) {
          if (!isNumber(value) || value < minValue) {
            return this.format(defaultMessages.min, this.formatLabel(attr, model), minValue);
          }
        },
  
        // Max validator
        // Validates that the value has to be a number and equal to or less than
        // the max value specified
        max: function(value, attr, maxValue, model) {
          if (!isNumber(value) || value > maxValue) {
            return this.format(defaultMessages.max, this.formatLabel(attr, model), maxValue);
          }
        },
  
        // Range validator
        // Validates that the value has to be a number and equal to or between
        // the two numbers specified
        range: function(value, attr, range, model) {
          if(!isNumber(value) || value < range[0] || value > range[1]) {
            return this.format(defaultMessages.range, this.formatLabel(attr, model), range[0], range[1]);
          }
        },
  
        // Length validator
        // Validates that the value has to be a string with length equal to
        // the length value specified
        length: function(value, attr, length, model) {
          if (!_.isString(value) || value.length !== length) {
            return this.format(defaultMessages.length, this.formatLabel(attr, model), length);
          }
        },
  
        // Min length validator
        // Validates that the value has to be a string with length equal to or greater than
        // the min length value specified
        minLength: function(value, attr, minLength, model) {
          if (!_.isString(value) || value.length < minLength) {
            return this.format(defaultMessages.minLength, this.formatLabel(attr, model), minLength);
          }
        },
  
        // Max length validator
        // Validates that the value has to be a string with length equal to or less than
        // the max length value specified
        maxLength: function(value, attr, maxLength, model) {
          if (!_.isString(value) || value.length > maxLength) {
            return this.format(defaultMessages.maxLength, this.formatLabel(attr, model), maxLength);
          }
        },
  
        // Range length validator
        // Validates that the value has to be a string and equal to or between
        // the two numbers specified
        rangeLength: function(value, attr, range, model) {
          if (!_.isString(value) || value.length < range[0] || value.length > range[1]) {
            return this.format(defaultMessages.rangeLength, this.formatLabel(attr, model), range[0], range[1]);
          }
        },
  
        // One of validator
        // Validates that the value has to be equal to one of the elements in
        // the specified array. Case sensitive matching
        oneOf: function(value, attr, values, model) {
          if(!_.include(values, value)){
            return this.format(defaultMessages.oneOf, this.formatLabel(attr, model), values.join(', '));
          }
        },
  
        // Equal to validator
        // Validates that the value has to be equal to the value of the attribute
        // with the name specified
        equalTo: function(value, attr, equalTo, model, computed) {
          if(value !== computed[equalTo]) {
            return this.format(defaultMessages.equalTo, this.formatLabel(attr, model), this.formatLabel(equalTo, model));
          }
        },
  
        // Pattern validator
        // Validates that the value has to match the pattern specified.
        // Can be a regular expression or the name of one of the built in patterns
        pattern: function(value, attr, pattern, model) {
          if (!hasValue(value) || !value.toString().match(defaultPatterns[pattern] || pattern)) {
            return this.format(defaultMessages[pattern] || defaultMessages.inlinePattern, this.formatLabel(attr, model), pattern);
          }
        }
      };
    }());
  
    // Set the correct context for all validators
    // when used from within a method validator
    _.each(defaultValidators, function(validator, key){
      defaultValidators[key] = _.bind(defaultValidators[key], _.extend({}, formatFunctions, defaultValidators));
    });
  
    return Validation;
  }(_));
  return Backbone.Validation;
}));
/**
 * @author jszeto
 * @date 12/7/12
 */
define('validation/ValidationMixin',[
    'underscore',
    'backbone',
    'backbone_validation'
],
    function(
        _,
        Backbone
        // backbone-validation
        ){

        //////////////////////////////////////////////////////////////////////
        // Custom Validators
        //////////////////////////////////////////////////////////////////////

        /* Example

        _.extend(Backbone.Validation.validators, {
            myValidator: function(value, attr, customValue, model) {
                if(value !== customValue){
                    return 'error';
                }
            }
        });*/

        //////////////////////////////////////////////////////////////////////
        // Custom Patterns
        //////////////////////////////////////////////////////////////////////

        /* Example

        _.extend(Backbone.Validation.patterns, {
            myPattern: /my-pattern/,
            email: /my-much-better-email-regex/
        });
        */

        //////////////////////////////////////////////////////////////////////
        // Custom Messages
        //////////////////////////////////////////////////////////////////////

        // Replace the existing error messages with ones that use the
        // ControlGroup's label as the placeholder instead of the model attribute name
        _.extend(Backbone.Validation.messages, {
            required: '{label} is required',
            acceptance: '{label} must be accepted',
            min: '{label} must be greater than or equal to {1}',
            max: '{label} must be less than or equal to {1}',
            range: '{label} must be between {1} and {2}',
            length: '{label} must be {1} characters',
            minLength: '{label} must be at least {1} characters',
            maxLength: '{label} must be at most {1} characters',
            rangeLength: '{label} must be between {1} and {2} characters',
            oneOf: '{label} must be one of: {1}',
            equalTo: '{label} must be the same as {1}',
            pattern: '{label} must be a valid {1}'
        });

        return Backbone.Validation.mixin;
});


/**
 * Base Model class for all our models.
 *
 * Events:
 *
 *      attributeValidate:attributeName - triggered when validation has been performed on the attributeName
 *          isValid - true if the attribute has passed validation
 *          attributeName - name of the attribute being validated
 *          errorMessage - if isValid is false, then this holds the error message. Otherwise, it is empty
 *
 *      serverValidated - triggered when we get messages from the server
 *          isValid - true if the model has no server errors
 *          model - a reference to the model itself
 *          messages - a list of message objects, each containing the message content and type
 */
define('models/Base',[
    'jquery',
    'underscore',
    'backbone',
    'mixins/modelcollection',
    'util/general_utils',
    'util/splunkd_utils',
    'validation/ValidationMixin'
],
function(
    $,
    _,
    Backbone,
    modelcollectionMixin,
    generalUtils,
    splunkDUtils,
    ValidationMixin
){
   var BaseModel = Backbone.Model.extend({
        initialize: function(attributes, options) {
            Backbone.Model.prototype.initialize.apply(this, arguments);

            this.error = new Backbone.Model();
            this.fetchData = (options && options.fetchData) ? options.fetchData : new Backbone.Model();
            this.associated = this.associated || {};
            this.associated.error = this.error;

            this.fetchData.on('change', _.debounce(function() { this.safeFetch(); }, 0), this);
            this.on('sync', this._onsync, this);
            this.on('error', this._onerror, this);
            this.on('validated', this._rebroadcastValidation, this);
        },
        fetch: function(options) {
            // merge the contents of the fetchData model into options.data
            var mergedOptions = $.extend(true, {}, {data: this.fetchData.toJSON()}, options);
            this.fetchXhr = Backbone.Model.prototype.fetch.call(this, mergedOptions);
            // on successful fetch, handle any calls to safeFetch that came in while we were in-flight
            var that = this;
            this.fetchXhr.done(function() {
                if (that.touched) {
                    that.safeFetch.apply(that, that.touched);
                }
            });
            return this.fetchXhr;
        },
        binaryPromiseFetch: function(options) {
            options || (options={});
            var deferred = $.Deferred(),
                success = options.success,
                error = options.error;
            options.success = function() {
                deferred.resolve(true);
                if (success) {
                    success.apply(this, arguments);
                }
            };
            options.error = function() {
                deferred.resolve(false);
                if (error) {
                    error.apply(this, arguments);
                }
            };
            this.fetch(options);
            return deferred;
        },
        clear: function(options) {
            options = options || {};
            
            _.each(this.associated, function(value){
                if (value instanceof Backbone.Model){
                    value.clear(options);
                } else if (value instanceof Backbone.Collection) {
                    value.reset(null, options);
                }
            });
            
            this.error.clear(options);
            Backbone.Model.prototype.clear.call(this, options);
            
            if (options.setDefaults) {
                var defaults = _.result(this, 'defaults');
                if (defaults) {
                    this.set(defaults, options);
                }
            }
            
            return this;
        },
        clone: function(){
            var clonedModel = Backbone.Model.prototype.clone.call(this);
            _.each(this.associated, function(value, key) {
                if (value instanceof Backbone.Model) {
                    var clonedAsscModel = value.clone();
                    clonedModel[key] = clonedAsscModel;
                    clonedModel.associated[key] = clonedAsscModel;
                } else if (value instanceof Backbone.Collection) {
                    var clonedAsscCollection = new value.constructor(
                        value.map(function(model) {
                            return model.clone();
                        })
                    );
                    clonedModel[key] = clonedAsscCollection;
                    clonedModel.associated[key] = clonedAsscCollection;
                }
            });
            return clonedModel;
        },
        associatedOff: function(events, callback, context) {
            _(this.associated).each(function(associated) {
                associated.off(events, callback, context);
                if (_.isFunction(associated.associatedOff)) {
                    associated.associatedOff(events, callback, context);
                }
            }, this);
            // fetchData is not part of the associated container, but should still be unbound
            this.fetchData.off(events, callback, context);
        },
        /**
         * Use this to announce to any listeners that the model is in a valid state. This is useful in cases where the
         * model is attached to a ControlGroup and you want that ControlGroup to no longer be in the error state.
         * Note that the next time you attempt to validate the model, it will still run through its validation rules.
         */
        clearErrors: function() {
            this.trigger('serverValidated', true, this, []);
            this.trigger('validated', true, this, []);
        },

        _rebroadcastValidation: function(validated, model, error_payload) {
            // doing this union will handle the case where a previously-undefined attribute is being set with an invalid value
            var allKeys = _.union(_.keys(this.attributes), _.keys(error_payload));
            _(allKeys).each(function(k){
                this.trigger('attributeValidated:' + k, !_.has(error_payload, k), k, error_payload[k]);
            },this);
        },
        _onerror: function(model, response, options) {
            model.error.clear();
            var messages = splunkDUtils.xhrErrorResponseParser(response, this.id);
            this.trigger('serverValidated', false, this, messages);
            model.error.set("messages", messages);
        },
        _onsync: function(model, response, options) {
            model.error.clear();
            var messages = this.parseSplunkDMessages(response),
                hasErrors = _(messages).any(function(message) {
                    return (message.type === splunkDUtils.ERROR || message.type === splunkDUtils.FATAL);
                });

            this.trigger('serverValidated', !hasErrors, this, messages);
            
            if (hasErrors) {
                model.error.set("messages", messages);
            }
        },
        parseSplunkDMessages: function(response) {
            if(!response) {
                return [];
            }
            return splunkDUtils.parseMessagesObject(response.messages);
        },
        filterByKeys: function(keys, options, fetchOptions /* optional */) {
            options = options || {};

            var attrs = {},
                strip = _.isString(options.strip) ? options.strip : '',
                allowEmpty = !!options.allowEmpty;

            _.each(this.toJSON(fetchOptions), function(value, key) {
                if(_.indexOf(keys, key) != -1) {
                    if (!_.isUndefined(value)){
                        if (!(value === "") || allowEmpty){
                            attrs[key.replace(strip, '')] = value;
                        }
                    }
                }
            }, this);
            return attrs;
        },
        filterByWildcards: function(wildcards, options, fetchOptions /* optional */) {
            return generalUtils.filterObjectByRegexes(this.toJSON(fetchOptions), wildcards, options);
        },
        filterChangedByWildcards: function(wildcards, options) {
            return generalUtils.filterObjectByRegexes(this.changedAttributes() || {}, wildcards, options);
        },
        toObject: function(attr) {
            var value = this.get(attr);
            try {
                value = JSON.parse(value);
            } catch (e) {}
            return value;
        },
        replace: function(attributes, options) {
            this.clear({silent: true});
            this.set(attributes, options);
        },
        /**
         * Restore the model to its default attributes.
         * CAVEAT EMPTOR: often fires two change events, both globally and per-attribute
         * CAVEAT EMPTOR: this has not been well tested yet
         */
        restoreDefaults: function(options) {
            var defaults = _.isFunction(this.defaults) ? this.defaults() : this.defaults;
            this.clear(options);
            this.set(defaults, options);
        }

    });
    _.extend(BaseModel.prototype, ValidationMixin);
    _.extend(BaseModel.prototype, modelcollectionMixin);
   
   return BaseModel;
});

define(
    'models/config',[
        'jquery',
        'splunk.config',
        'models/Base'
    ],
    function($, $C, BaseModel) {

        var Model = BaseModel.extend({
            initialize: function() {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            sync: function(method, model, options) {
                throw new Error('invalid method: ' + method);
            }
        });
        return new Model($.extend(true, {}, $C));
    }
);
define(
    'models/shared/Application',[
        'models/Base'
    ],
    function(BaseModel) {
        return BaseModel.extend({
            initialize: function() {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            getPermissions: function(permission){
                return {
                    app: this.get("app"),
                    owner: ((permission === 'private') ? this.get("owner") : 'nobody')
                };
            }
        });
    }
);
define(
    'models/SplunkDWhiteList',[
        'jquery',
        'backbone',
        'underscore',
        'models/Base',
        'util/splunkd_utils'
     ],
     function($, Backbone, _, BaseModel, splunkDUtils) {
        return BaseModel.extend({
            initialize: function(options) {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            concatOptionalRequired: function() {
                var optional = (this.get('optional') || []).slice(0),
                required = (this.get('required') || []).slice(0);
                return optional.concat(required);
            },
            url: '',
            sync: function(method, model, options) {
                var  defaults = {
                        data:{
                            output_mode: 'json'
                        },
                        url: _.isFunction(model.url) ? model.url() : model.url
                };
                switch(method) {
                    case 'read':
                        defaults.data = _.extend(defaults.data, options.data || {});
                        delete options.data;
                        defaults.url = splunkDUtils.fullpath(defaults.url);
                        break;
                    default:
                        throw new Error('invalid method: ' + method);
                }
                return Backbone.sync.call(this, method, model, $.extend(true, defaults, options));
            },
            parse: function(response){
                var entity = (response.entry ? $.extend(true, {}, response.entry[0]) : {}),
                data = entity.fields || {};
                
                if (data.wildcard) {
                    data.wildcard = splunkDUtils.addAnchorsToWildcardArray(data.wildcard);
                }
                
                return data;
            }
        });
    }
);

define(
    'models/services/ACL',[
     'jquery',
     'backbone',
     'models/Base',
     'util/splunkd_utils'
     ],
     function($, Backbone, BaseModel, splunkDUtils) {
        return BaseModel.extend({
            initialize: function(attributes, options) {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            sync: function(method, model, options) {
                var defaults = {
                    data: {
                        output_mode: 'json'
                    }
                };
                switch(method) {
                case 'update':
                    defaults.processData = true;
                    defaults.type = 'POST';
                    defaults.url = splunkDUtils.fullpath(model.id);
                    $.extend(true, defaults, options);
                    break;
                default:
                    throw new Error('invalid method: ' + method);
                }
                return Backbone.sync.call(this, method, model, defaults);
            }
        });
    }
);

define(
    'models/ACLReadOnly',[
         'jquery',
         'underscore',
         'backbone',
         'models/Base',
         'util/splunkd_utils'
     ],
     function($, _, Backbone, BaseModel, splunkd_utils) {
        return BaseModel.extend({
            initialize: function(attributes, options) {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            permsToObj: function() {
                var perms = $.extend(true, {}, this.get('perms'));
                perms.read = perms.read || [];
                perms.write = perms.write || [];
                return perms;
            },
            toDataPayload: function() {
                var perms = this.permsToObj(),
                    data = {
                        sharing: this.get('sharing'),
                        owner: this.get('owner')
                    };

                if (data.sharing !== splunkd_utils.USER && perms.read.length !== 0) {
                    if (_.indexOf(perms.read, '*') != -1) {
                        data['perms.read'] = '*';
                    } else {
                        data['perms.read'] = perms.read.join(',');
                    }
                }

                if (data.sharing !== splunkd_utils.USER && perms.write.length !== 0) {
                    if (_.indexOf(perms.write, '*') != -1) {
                        data['perms.write'] = '*';
                    } else {
                        data['perms.write'] = perms.write.join(',');
                    }
                }

                return data;
            },
            canWrite: function() {
                return this.get('can_write');
            }
        });
    }
);

define(
    'models/SplunkDBase',[
        'jquery',
        'underscore',
        'backbone',
        'models/Base',
        'models/SplunkDWhiteList',
        'models/services/ACL',
        'models/ACLReadOnly',
        'util/splunkd_utils',
        'util/console',
        'util/general_utils'
    ],
    function($, _, Backbone, BaseModel, SplunkDWhiteList, ACLModel, ACLReadOnlyModel, splunkd_utils, console, generalUtil) {

        //private sync CRUD methods
        var syncCreate = function(model, options){
            var bbXHR, splunkDWhiteListXHR, url,
	            deferredResponse = $.Deferred(),
	            defaults = {data: {output_mode: 'json'}};

            url = _.isFunction(model.url) ? model.url() : model.url;
            splunkDWhiteListXHR = this.splunkDWhiteList.fetch({
                url: splunkd_utils.fullpath(url, {}) + '/_new',
                success: function(splunkDWhiteListModel, response) {
                    var app_and_owner = {};
                    if (options.data){
                        app_and_owner = $.extend(app_and_owner, { //JQuery purges undefined
                            app: options.data.app || undefined,
                            owner: options.data.owner || undefined,
                            sharing: options.data.sharing || undefined
                        });
                    }
                    defaults.url = splunkd_utils.fullpath(url, app_and_owner);
                    
                    defaults.processData = true;
                    $.extend(true, defaults.data, model.whiteListAttributes());
                    $.extend(true, defaults, options);
                    
                    delete defaults.data.app;
                    delete defaults.data.owner;
                    delete defaults.data.sharing;
                    
                    defaults.data = splunkd_utils.normalizeValuesForPOST(defaults.data);

                    bbXHR = Backbone.sync.call(null, "create", model, defaults);
                    bbXHR.done(function() {
                        deferredResponse.resolve.apply(deferredResponse, arguments);
                    });
                    bbXHR.fail(function() {
                        deferredResponse.reject.apply(deferredResponse, arguments);
                    });
                }
            });
            splunkDWhiteListXHR.fail(function() {
                deferredResponse.reject.apply(deferredResponse, arguments);
            });
            return deferredResponse.promise();
        },
        syncRead = function(model, options){
            var bbXHR, url,
	            deferredResponse = $.Deferred(),
	            defaults = {data: {output_mode: 'json'}};

            if ((window.$C['SPLUNKD_FREE_LICENSE'] || options.isFreeLicense) && model.FREE_PAYLOAD) {
                if(options.success) {
                    options.success(model.FREE_PAYLOAD);
                }
                return deferredResponse.resolve.apply(deferredResponse, [model.FREE_PAYLOAD]);
            }

            if (model.isNew()){
                url = _.isFunction(model.url) ? model.url() : model.url;
                url += '/_new';
            } else if (model.urlRoot) {
                url = model.urlRoot +'/'+ model.id;
            } else {
                url = model.id;
            }
            
            var app_and_owner = {};
            if (options.data){
                app_and_owner = $.extend(app_and_owner, { //JQuery purges undefined
                    app: options.data.app || undefined,
                    owner: options.data.owner || undefined,
                    sharing: options.data.sharing || undefined
                });
            }
            defaults.url = splunkd_utils.fullpath(url, app_and_owner);
            
            $.extend(true, defaults, options);
            delete defaults.data.app;
            delete defaults.data.owner;
            delete defaults.data.sharing;

            bbXHR = Backbone.sync.call(this, "read", model, defaults);
            bbXHR.done(function() {
                deferredResponse.resolve.apply(deferredResponse, arguments);
            });
            bbXHR.fail(function() {
                deferredResponse.reject.apply(deferredResponse, arguments);
            });
            return deferredResponse.promise();
        },
        syncUpdate = function(model, options){
            var bbXHR, splunkDWhiteListXHR, url,
	            deferredResponse = $.Deferred(),
	            defaults = {data: {output_mode: 'json'}},
	            id = model.id;

            url = splunkd_utils.fullpath(id, {});
            var mergedOptions = $.extend(true, {}, options,
                {url: url,
                success: function(splunkDWhiteListModel) {
                    var fetchOptions = $.extend(true, {}, options);
                    $.extend(true, defaults.data, model.whiteListAttributes(fetchOptions));
                    $.extend(true, defaults, options);
                    defaults.processData = true;
                    defaults.type = 'POST';
                    defaults.url = url;

                    defaults.data = splunkd_utils.normalizeValuesForPOST(defaults.data);

                    bbXHR = Backbone.sync.call(null, "update", model, defaults);
                    bbXHR.done(function() {
                        deferredResponse.resolve.apply(deferredResponse, arguments);
                    });
                    bbXHR.fail(function() {
                        deferredResponse.reject.apply(deferredResponse, arguments);
                    });
                }
                });
            this.splunkDWhiteList.clear();
            splunkDWhiteListXHR = this.splunkDWhiteList.fetch(mergedOptions);
            splunkDWhiteListXHR.fail(function() {
                deferredResponse.reject.apply(deferredResponse, arguments);
            });
            return deferredResponse.promise();
        },
        syncPatch = function(model, options){
            var bbXHR, splunkDWhiteListXHR, url,
                deferredResponse = $.Deferred(),
                defaults = {data: {output_mode: 'json'}},
                id = model.id;

            // Use caution with Patch:
            // Unlike Update which sends complete representation of model to server,
            // Patch only sends attributes passed in attrs argument in Model.save(attrs, options).
            // Backbone Model.save behavior is to set passed-in attrs on the model itself.
            // These model attrs should be ignored or unset since SplunkDBase Model's persistable
            // attributes are stored in model.entry.content.

            url = splunkd_utils.fullpath(id, {});
            this.splunkDWhiteList.clear();
            splunkDWhiteListXHR = this.splunkDWhiteList.fetch({
                url: url,
                success: function(splunkDWhiteListModel) {
                    $.extend(true, defaults.data, (options.attrs && model.whiteListPassedInAttributes(options.attrs)) || {});
                    delete options.attrs;
                    $.extend(true, defaults, options);
                    defaults.processData = true;
                    defaults.type = 'POST';
                    defaults.url = url;
                    
                    defaults.data = splunkd_utils.normalizeValuesForPOST(defaults.data);

                    // beyond this point, patch is equivalent to update
                    bbXHR = Backbone.sync.call(null, "update", model, defaults);
                    bbXHR.done(function() {
                        deferredResponse.resolve.apply(deferredResponse, arguments);
                    });
                    bbXHR.fail(function() {
                        deferredResponse.reject.apply(deferredResponse, arguments);
                    });
                }
            });
            splunkDWhiteListXHR.fail(function() {
                deferredResponse.reject.apply(deferredResponse, arguments);
            });
            return deferredResponse.promise();
        },
        syncDelete = function(model, options){
            var bbXHR,
	            deferredResponse = $.Deferred(),
	            defaults = {data: {output_mode: 'json'}};

            if(options.data && options.data.output_mode){
                //add layering of url if specified by user
                defaults.url = splunkd_utils.fullpath(model.id, {}) + '?output_mode=' + encodeURIComponent(options.data.output_mode);
                delete options.data.output_mode;
            } else {
                //add layering of url if specified by user
                defaults.url = splunkd_utils.fullpath(model.id, {}) + '?output_mode=' + encodeURIComponent(defaults.data.output_mode);
                delete defaults.data.output_mode;
            }
            $.extend(true, defaults, options);
            defaults.processData = true;

            bbXHR = Backbone.sync.call(this, "delete", model, defaults);
            bbXHR.done(function() {
                deferredResponse.resolve.apply(deferredResponse, arguments);
            });
            bbXHR.fail(function() {
                deferredResponse.reject.apply(deferredResponse, arguments);
            });
            return deferredResponse.promise();
        };

        var Model = BaseModel.extend({
            initialize: function(attributes, options) {
                BaseModel.prototype.initialize.apply(this, arguments);
                this.splunkDWhiteList = options && options.splunkDWhiteList ?
                        options.splunkDWhiteList : new SplunkDWhiteList();
                
                this.initializeAssociated();
                
                this.on("change:id", function() {
                    var alt = this.id;
                    if (alt) {
                        alt = alt + "/acl";
                    }
                    this.acl.set(this.acl.idAttribute, alt);
                }, this);
                
                if (options && options.splunkDPayload){
                    this.setFromSplunkD(options.splunkDPayload, {silent: true});
                }
            },
            parseSplunkDMessages: function(response) {
                var messages = BaseModel.prototype.parseSplunkDMessages.call(this, response);
                if(response && response.entry && response.entry.length > 0) {
                    messages = _.union(messages, splunkd_utils.parseMessagesObject(response.entry[0].messages));
                }
                return messages;
            },
            initializeAssociated: function() {
                // do a dynamic lookup of the current constructor so that this method is inheritance-friendly
                var RootClass = this.constructor;
                this.associated = this.associated || {};

                //instance level models
                this.links = this.links || new RootClass.Links();
                this.associated.links = this.links;
                
                this.generator = this.generator || new RootClass.Generator();
                this.associated.generator = this.generator;
                
                this.paging = this.paging || new RootClass.Paging();
                this.associated.paging = this.paging;

                //nested instance level on entry
                if (!this.entry){
                    this.entry = new RootClass.Entry();
                    $.extend(this.entry, {
                        links: new RootClass.Entry.Links(),
                        acl: new RootClass.Entry.ACL(),
                        content: new RootClass.Entry.Content(),
                        fields: new RootClass.Entry.Fields()
                    });
                    this.entry.associated.links = this.entry.links;
                    this.entry.associated.acl = this.entry.acl;
                    this.entry.associated.content = this.entry.content;
                    this.entry.associated.fields = this.entry.fields;
                }
                this.associated.entry = this.entry;
                
                //associated EAI models
                this.acl = this.acl || new ACLModel();
                this.associated.acl = this.acl;
            },
            url: '',
            sync: function(method, model, options) {
                switch(method){
                    case 'create':
                        return syncCreate.call(this, model, options);
                    case 'read':
                        return syncRead.call(this, model, options);
                    case 'update':
                        return syncUpdate.call(this, model, options);
                    case 'patch':
                        return syncPatch.call(this, model, options);
                    case 'delete':
                        return syncDelete.call(this, model, options);
                    default:
                        throw new Error('invalid method: ' + method);
                }
            },
            parse: function(response, options) {
                options = options || {};
                // make a defensive copy of response since we are going to modify it (only if we want to)
                if (!options.skipClone) {
                    response = $.extend(true, {}, response);
                }
                
                //when called from the collection fetch we will need to ensure that our
                //associated models are initialized because parse is called before
                //initialize
                this.initializeAssociated();

                if (!response || !response.entry || response.entry.length === 0) {
                    console.log('Response has no content to parse');
                    return;
                }
                var response_entry = response.entry[0];

                //id
                //this needs to be the first thing so that people can get !isNew()
                if (splunkd_utils.isExistingEntity(response)) {
                    this.set(this.idAttribute, response_entry.links.alternate);
                    response.id = response_entry.links.alternate;
                    this.acl.set(this.acl.idAttribute, this.id + '/acl');
                }

                //top-level
                this.links.set(response.links);
                delete response.links;
                this.generator.set(response.generator);
                delete response.generator;
                this.paging.set(response.paging);
                delete response.paging;

                //sub-entry
                this.entry.links.set(response_entry.links);
                delete response_entry.links;
                this.entry.acl.set(response_entry.acl);
                delete response_entry.acl;
                this.entry.content.set(response_entry.content);
                delete response_entry.content;
                
                if (response_entry.fields && response_entry.fields.wildcard) {
                    response_entry.fields.wildcard = splunkd_utils.addAnchorsToWildcardArray(response_entry.fields.wildcard);
                }
                this.entry.fields.set(response_entry.fields);
                delete response_entry.fields;
                this.entry.set(response_entry);
                delete response.entry;
                return response;
            },
            whiteListAttributes: function(fetchOptions) {
                var whiteListOptAndReq = this.splunkDWhiteList.concatOptionalRequired(),
                    whiteListWild = this.splunkDWhiteList.get('wildcard') || [],
                    contentAttrs = this.entry.content.filterByKeys(whiteListOptAndReq,
                                                                   {allowEmpty: true},
                                                                   fetchOptions);

                return _.extend(contentAttrs, this.entry.content.filterByWildcards(whiteListWild, {allowEmpty: true}, fetchOptions));
            },
            whiteListPassedInAttributes: function(attrs) {
                if (!_.isObject(attrs) || _.isEmpty(attrs)) { return {}; }
                var whiteListOptAndReq = this.splunkDWhiteList.concatOptionalRequired(),
                    whiteListWild = this.splunkDWhiteList.get('wildcard') || [],
                    filterModel = new BaseModel(attrs),    // cast object into BaseModel
                    filteredAttrs = filterModel.filterByKeys(whiteListOptAndReq, {allowEmpty: true});

                return _.extend(filteredAttrs, filterModel.filterByWildcards(whiteListWild, {allowEmpty: true}));
            },

            /*
             * Override the native save to enable passing a payload to a SplunkDBase model and have it apply
             * the save transactionally onto the model's entry.content associative model.
             * Set nativeSave : true in order to call backbones native save function
             * This method signature is the same as the signature for Backbone's native save function
             */
            save: function(key, val, options) {
                var attributes = {},
                    originalModel = this;
                //Check format of inputs
                //Handle both "key", value and {key: value} -style arguments.
                if (key == null || _.isObject(key)) {
                    attributes = key;
                    options = val;
                } else {
                    attributes[key] = val;
                }
                options = options || {};

                //If native save is called, run Backbone native save
                if (options.nativeSave || !options.wait) {
                    return BaseModel.prototype.save.call(originalModel, attributes, options);
                }
                var clonedModel = originalModel.clone(),
                    cloneXHR,
                    deferredResponse = $.Deferred();

                //Wire up events that need to be passed to the original model
                clonedModel.error.on('change: messages', function(model, response, options){
                    originalModel.error.set({
                        'messages': model.get('messages')
                    });
                });
                clonedModel.on('error', function (model, response, options) {
                    originalModel._onerror(originalModel, response, options);
                });
                clonedModel.on('sync', function (model, response, options) {
                    originalModel._onsync(originalModel, response, options);
                });
                clonedModel.on('validated', function (model, response, options) {
                    originalModel._rebroadcastValidation(originalModel, response, options);
                });
                clonedModel.on('invalid', function (model, response, options) {
                    originalModel.trigger('invalid', originalModel, response, options);
                });
                clonedModel.on('request', function(model, response, options) {
                    originalModel.trigger('request', originalModel, response, options);
                });

                //Save original success method that is passed in
                var originalSuccess = options.success;
                var originalError = options.error;
                //Append new attributes to options
                options = _.extend({
                    validate: true,
                    wait: false
                }, options);

                options.success = function(model, response, opts){
                    var successOptions = {
                        skipClone: true
                    };

                    originalModel.setFromSplunkD(model.toSplunkD(), successOptions);
                    //Run user passed in success function
                    if (originalSuccess){
                        originalSuccess(originalModel, response, opts);
                    }
                };
                options.error = function(model, response, opts){
                    if (originalError){
                        originalError(originalModel, response, opts);
                    }
                };

                // Set attributes on the nestedModel which comes from the clone, so no change events are fired
                if (options.patch) {
                    cloneXHR =  BaseModel.prototype.save.call(clonedModel, attributes, options);

                } else {
                    clonedModel.entry.content.set(attributes, options);
                    cloneXHR =  BaseModel.prototype.save.call(clonedModel, null, options);

                }
                //Grab xhr and resolve for the original model
                cloneXHR.done(function() {
                    clonedModel.off();
                    deferredResponse.resolve.apply(deferredResponse, arguments);
                });
                cloneXHR.fail(function() {
                    clonedModel.off();
                    deferredResponse.reject.apply(deferredResponse, arguments);
                });
                return deferredResponse.promise();
            },

            setFromSplunkD: function(payload, options) {
                this.attributes = {};
                options = options || {};

                // make a defensive copy of response since we are going to modify it (only if we want to)
                if (!options.skipClone) {
                    payload = $.extend(true, {}, payload);
                }

                var oldId = this.id;
                //object assignment
                if (payload) {
                    if (payload.entry && payload.entry[0]) {
                        var payload_entry = payload.entry[0];

                        if(payload_entry.links){
                            //id
                            //this needs to be the first thing so that people can get !isNew()
                            if (splunkd_utils.isExistingEntity(payload)) {
                                this.set({id: payload_entry.links.alternate}, {silent: true});
                                this.acl.set({id: payload_entry.links.alternate + "/acl"}, options);
                            }

                            this.entry.links.set(payload_entry.links, options);
                            delete payload_entry.links;
                        }

                        if(payload_entry.acl){
                            this.entry.acl.set(payload_entry.acl, options);
                            delete payload_entry.acl;
                        }
                        if(payload_entry.content){
                            this.entry.content.set(payload_entry.content, options);
                            delete payload_entry.content;
                        }
                        if(payload_entry.fields){
                            if (payload_entry.fields.wildcard) {
                                payload_entry.fields.wildcard = splunkd_utils.addAnchorsToWildcardArray(payload_entry.fields.wildcard);
                            }
                            
                            this.entry.fields.set(payload_entry.fields, options);
                            delete payload_entry.fields;
                        }

                        this.entry.set(payload_entry, options);
                        delete payload.entry;
                    }

                    if(payload.links) {
                        this.links.set(payload.links, options);
                        delete payload.links;
                    }
                    if(payload.generator) {
                        this.generator.set(payload.generator, options);
                        delete payload.generator;
                    }
                    if(payload.paging) {
                        this.paging.set(payload.paging, options);
                        delete payload.paging;
                    }

                    //reset the internal root model due to pre-init routine
                    this.set(payload, options);
                    if(this.id !== oldId) {
                        this.trigger('change:' + this.idAttribute);
                    }
                }
            },
            toSplunkD: function(options) {
                var payload = {};
                options = options || {};

                payload = $.extend(true, {}, this.toJSON());

                payload.links = $.extend(true, {}, this.links.toJSON());
                payload.generator = $.extend(true, {}, this.generator.toJSON());
                payload.paging = $.extend(true, {}, this.paging.toJSON());
                payload.entry = [$.extend(true, {}, this.entry.toJSON())];

                payload.entry[0].links = $.extend(true, {}, this.entry.links.toJSON());
                if (options.withoutId) {
                    delete payload.entry[0].links.alternate;
                }
                payload.entry[0].acl = $.extend(true, {}, this.entry.acl.toJSON());
                payload.entry[0].content = $.extend(true, {}, this.entry.content.toJSON());
                payload.entry[0].fields = $.extend(true, {}, this.entry.fields.toJSON());

                //cleanup
                delete payload.id;
                return payload;
            },
            /*
             * Given a simple object, filter it such that the only remaining keys are those that could be saved to splunkd.
             * This is accomplished by introspecting the `entry.fields` associated model that is populated by
             * the parent model's REST endpoint.
             *
             * This method does not have side effects on the model itself.
             */
            filterInputToSaveableFields: function(obj) {
                var fieldSchemaModel = this.entry.fields,
                    nonWildcardFields = (fieldSchemaModel.get('optional') || []).concat(fieldSchemaModel.get('required') || []),
                    wildcardFields = fieldSchemaModel.get('wildcard') || [],
                    filteredObject = _(obj).pick(nonWildcardFields);

                _(wildcardFields).each(function(wildcardPattern) {
                    // The wildcards are strings from the REST API, so use a try-catch in case they are not
                    // valid javascript regex syntax.
                    try {
                        _.extend(filteredObject, generalUtil.filterObjectByRegexes(obj, wildcardPattern));
                    }
                    catch(e) {
                        console.warn('Exception thrown trying to evaluate wildcard: ' + wildcardPattern);
                        console.warn(e);
                    }
                });
                return filteredObject;
            }
        },
        {
            Links: BaseModel,
            Generator: BaseModel,
            Paging: BaseModel,
            Entry: BaseModel.extend(
                {
                    initialize: function() {
                        BaseModel.prototype.initialize.apply(this, arguments);
                    }
                },
                {
                    Links: BaseModel,
                    ACL: ACLReadOnlyModel,
                    Content: BaseModel,
                    Fields: BaseModel
                }
            )
        });

        return Model;
    }
);

define(
    'models/services/AppLocal',[
        'models/SplunkDBase'
    ],
    function(SplunkDBaseModel) {
        return SplunkDBaseModel.extend({
            url: "apps/local",
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
            },
            appAllowsDisable: function() {
                return this.entry.links.get("disable") ? true : false;
            },
            getSplunkAppsId: function() {
                var details = this.entry.content.get('details');
                if (details) {
                    var idRe = /\/apps\/id\/(.*)/g;
                    var res = idRe.exec(details);
                    if (res.length === 2) {
                        return res[1];
                    }
                }
            }
        });
    }
);
define(
    'models/StaticIdSplunkDBase',[
        'underscore',
        'models/SplunkDBase'
    ],
    function(_, BaseModel){
        var Model = BaseModel.extend(
            {
                initialize: function() {
                    BaseModel.prototype.initialize.apply(this, arguments);
                },
                defaults: function() {
                    // do a dynamic lookup of the current constructor so that this method is inheritance-friendly
                    var RootClass = this.constructor,
                        id = RootClass.id,
                        extendedDefaults = {},
                        defaults;
                    
                    if (!id) {
                        throw new Error('You must set a class level id for this model.');
                    }
                    
                    if (_.isFunction(BaseModel.prototype.defaults)){
                        defaults = BaseModel.prototype.defaults.apply(this, arguments);
                    } else {
                        defaults = BaseModel.prototype.defaults || {};
                    }
                    
                    extendedDefaults = _.extend({}, defaults);
                    extendedDefaults[this.idAttribute] = id;
                    return extendedDefaults;
                },
                clear: function(options) {
                    options = options || {};
                    var RootClass = this.constructor;
                    BaseModel.prototype.clear.call(this, options);

                    //always enforce that the id is set
                    if (!options.setDefaults) {
                        this.set(this.idAttribute, RootClass.id);
                    }
                    
                    return this;
                }
            },
            {
                id: ""
            }
        );
        
        return Model;
    }
);

define(
'models/services/server/ServerInfo',[
    'underscore',
    'models/StaticIdSplunkDBase',
    'splunk.util'
],
function(
    _,
    SplunkDBaseModel,
    splunk_util
) {
    return SplunkDBaseModel.extend({
        urlRoot: 'server/info',
        initialize: function() {
            SplunkDBaseModel.prototype.initialize.apply(this, arguments);
        },
        productDef: {
            cloud: {
                name: _('Splunk Cloud').t(),
                logo: '&#xF002;'
            },
            enterprise: {
                name: _('Splunk Enterprise').t(),
                logo: '&#xF001;'
            },
            hunk: {
                name: _('Hunk').t(),
                logo: '&#xF000;'
            },
            lite: {
                name: _('Splunk Light').t(),
                logo: '&#xF003;'
            },
            lite_free: {
                name: _('Splunk Light Free').t(),
                logo: '&#xF003;'
            },
            splunk: {
                name: _('Splunk').t(),
                logo: '&#xF001;'
            }
        },
        _getProductDef: function(key){
            var productDef = this.productDef[this.getBranding()];
            return productDef ? productDef[key] : '';
        },

        getAttr: function(attr){
            return this.entry.content.get(attr);
        },
        getBranding: function() {
            return (this.isLite() || !this.isCloud()) ? this.getProductType() : (this.getInstanceType() || 'splunk');
        },
        getProductName: function(){
            return this._getProductDef('name');
        },
        getProductLogo: function(){
            return this._getProductDef('logo');
        },
        getProductType: function(){
            return this.getAttr('product_type');
        },
        getInstanceType: function(){
            return this.getAttr('instance_type');
        },

        isProductType: function(productName){
            return this.getProductType() === productName;
        },
        isInstanceType: function(instance){
            return this.getInstanceType() === instance;
        },
        isCloud: function() {
            return this.isInstanceType('cloud');
        },
        isEnterprise: function() {
            return this.isProductType('enterprise');
        },
        isEnterpriseCloud: function() {
            return this.isEnterprise() && this.isCloud();
        },
        isHunk: function() {
            return this.isProductType('hunk');
        },
        isLite: function() {
            return this.isLiteFree() || this.isLitePaid();
        },
        isLiteCloud: function(){
            return this.isLite() && this.isCloud();
        },
        isLiteFree: function() {
            return this.isProductType('lite_free');
        },
        isLitePaid: function() {
            return this.isProductType('lite');
        },

        isTrial: function(){
            return splunk_util.normalizeBoolean(this.getAttr('isTrial'));
        },
        isCloudTrial: function() {
            // TODO: Remove 'cloudtrial' condition once Rainmakr removes all instances of it.
            return this.isInstanceType('cloudtrial') || (this.isCloud() && this.isTrial());
        },
        isFreeLicense: function() {
            return splunk_util.normalizeBoolean(this.getAttr('isFree'));
        },

        getAddOns: function() {
            return this.getAttr('addOns');
        },
        getBuild: function() {
            return this.getAttr('build');
        },
        getLicenseGroup: function() {
            return this.getAttr('activeLicenseGroup');
        },
        getOsName: function() {
            return this.getAttr('os_name');
        },
        getServerName: function() {
            return this.getAttr('serverName');
        },
        getVersion: function() {
            return this.getAttr('version');
        },

        hasAttr: function(attr){
            return this.entry.content.has(attr);
        },
        hasAddOn: function(addOn) {
            var addOns = this.getAddOns();
            if (!addOns) {
                return false;
            }
            return addOns.hasOwnProperty(addOn);
        },
        hasHadoopAddon: function() {
            return this.hasAddOn('hadoop');
        },
        hasEnterpriseLicense: function() {
            return this.getLicenseGroup() == 'Enterprise';
        },
        hasLiteLicense: function() {
            return this.getLicenseGroup() == 'Lite';
        },

        isLicenseStatePreviouslyKeyed: function() {
            return this.getAttr('licenseState') === 'PREVIOUS_KEYED_LICENSE';
        },
        isLicenseStateExpired: function() {
            return this.getAttr('licenseState') === 'EXPIRED';
        }
    },
    {
        id: 'server-info'
    });
});

define('util/xml',['jquery', 'underscore', 'util/console'], function($, _, console) {

    var tmpDoc = _.once(function(){
        return $.parseXML('<tmp/>');
    });

    /**
     * Parse the given XML string
     * @param {String} str - the XMl string to parse 
     * @returns {jQuery} the jQuery-wrapped XML document
     */
    function parse(str) {
        return $($.parseXML(str));
    }
    
    /**
     * Create a new XML node
     * @param str {string} the XML source
     * @returns {*} the jQuery wrapped XML node
     */
    function $node(str) {
        var document = $.parseXML(str);
        return $(document.childNodes[0]);
    }

    /**
     * Create a new, empty XML node with the given tag name  
     * @param name the tag name
     * @returns {*} the jQuery wrapped XML node
     */
    function $tag(name) {
        return $node('<' + name + '/>');
    }

    /**
     * Create a new XML text node
     * @param txt {String} the text content
     * @returns {*} the XML text node
     */
    function text(txt) {
        return tmpDoc().createTextNode(txt);
    }
    
    /**
     * Clone the given XML node
     * @param node the node the clone
     * @returns the cloned node
     */
    function clone(node) {
        return $node(serialize(node));
    }

    /**
     * Create a new CDATA section from the given text
     * @param str the text
     * @returns {CDATASection} the resulting XML CDATA node
     */
    function cdata(str) {
        return tmpDoc().createCDATASection(str);
    }

    /**
     * Replaces CDATA nodes with regular text nodes in the given XML fragment
     * @param node - the node to process recursively 
     * @param deep - whether to replace cdata in nested nodes 
     */
    function replaceCdataNodes(node, deep) {
        if (node) {
            node = _unwrap(node);
            var CDATA = node.CDATA_SECTION_NODE; 
            for (var i=node.childNodes.length - 1; i >= 0; i--) {
                var child = node.childNodes[i];
                if (child.nodeType === CDATA) {
                    var txt = text(child.nodeValue);
                    node.insertBefore(txt, child);
                    node.removeChild(child);
                } else if (deep && child.nodeType === node.ELEMENT_NODE || child.nodeType === node.DOCUMENT_NODE) {
                    replaceCdataNodes(child, deep);
                }
            } 
        }
    }
    
    /**
     * Remove all empty text nodes from the given XML document or node and trim all leading and trailing whitespace
     * for all other text nodes
     * @param n the XML document or node
     * @param exceptions on object for nodes to exclude from whitespace cleanup (keys correspond to node names, values
     * should be truthy)
     */
    function stripEmptyTextNodes(n, exceptions) {
        //IE <9 does not have TEXT_NODE
        var TEXT_NODE = n.TEXT_NODE || 3,
            i, child, childNodes = n.childNodes;
        for (i = childNodes.length - 1; i >= 0; i--) {
            child = childNodes[i];
            if (child !== undefined) {
                if (child.nodeType === TEXT_NODE) {
                    if (/^\s*$/.test(child.nodeValue)) {
                        n.removeChild(child);
                    } else {
                        child.nodeValue = $.trim(child.nodeValue);
                    }
                }
            }
        }
        childNodes = n.childNodes;
        if (childNodes.length === 0) {
            n.appendChild(text(''));
        } else {
            for (i = childNodes.length - 1; i >= 0; i--) {
                child = childNodes[i];
                if (child.nodeType === n.ELEMENT_NODE || child.nodeType === n.DOCUMENT_NODE) {
                    if (exceptions == null || !exceptions[child.nodeName]) {
                        stripEmptyTextNodes(child, exceptions);
                    }
                }
            }
        }
    }

    var INDENT = '  ';

    function indentTxt(level) {
        var txt = ['\n'], x = level;
        while (x--) {
            txt.push(INDENT);
        }
        return txt.join('');
    }

    function indent(n, level) {
        //IE <9 does not have TEXT_NODE
        var TEXT_NODE = n.TEXT_NODE || 3;

        for (var i = 0; i <= n.childNodes.length; i++) {
            var child1 = n.childNodes[i - 1], child2 = n.childNodes[i];
            if (child2 && child2.nodeType !== TEXT_NODE && ((!child1) || child1.nodeType !== TEXT_NODE)) {
                n.insertBefore(text(indentTxt(level)), child2);
            }
            if (i === n.childNodes.length && child1 && child1.nodeType !== TEXT_NODE) {
                n.appendChild(text(indentTxt(level - 1)));
            }
        }
        _.chain(n.childNodes).filter(function(c) {
            return c.nodeType === n.ELEMENT_NODE;
        }).each(function(c) {
                indent(c, level + 1);
            });
    }

    /**
     * Format the given jQuery-XML document by stripping out empty text nodes and indenting XML elements
     * @param $xml the jQuery-wrapped XML document
     * @param noStrip an array of node names to exclude from whitespace cleanup
     * @returns the formatted XML document
     */
    function formatXMLDocument($xml, noStrip) {
        if (!isDocument($xml)) {
            console.warn('Called formatXMLDocument with an argument which is not a XML document');
            return formatXML($xml);
        }
        stripEmptyTextNodes($xml[0], _.object(noStrip, noStrip));
        indent($xml[0].childNodes[0], 1);
        return $xml;
    }
    
    function formatXML($xml, noStrip) {
        stripEmptyTextNodes(_unwrap($xml), _.object(noStrip, noStrip));
        indent(_unwrap(isDocument($xml) ? root($xml) : $xml), 1);
        return $xml;
    }
    
    function formatDashboardXML($xml) {
        return formatXML($xml, ['html', 'delimiter']);
    }

    function isDocument(node) {
        var n = _unwrap(node);
        return n && n.nodeType === n.DOCUMENT_NODE;
    }
    
    function _unwrap(node) {
        return node instanceof $ ? node[0] : node;
    }
    
    /**
     * Serialize the given XML document to string
     * @param xml either a plain XML document or an jQuery-wrapped XML document
     * @returns {string} the formatted XML
     */
    function serialize(xml) {
        xml = _unwrap(xml);
        return Object.prototype.hasOwnProperty.call(xml, 'xml') ? xml.xml : new XMLSerializer().serializeToString(xml);
    }

    function serializeDashboardXML(xml, indent) {
        if (indent) {
            xml = formatDashboardXML(xml);
        }
        return serialize(xml);
    }
    
    /**
     * Utility method to inject a node into a container by inserting it before or after particular child elements of a
     * container. If none of the child elements can be found then a fallback can be used to either append or prepend the
     * element or to execute a function to run arbitrary alternative injection.
     *
     * @param options {object} - {
     *      node {Element}: the node to inject
     *      container {Element}: the container where the node is to be injected into
     *      where {String}: "after" or "before" - where, relative to the selectors should the node be injected
     *      selectors {Array}: child selectors of elements where node is to be injected before or after. The first match will
     *                 be used.
     *      fallback {String|Function}:
     * }
     * @returns {boolean} true if the node has been injected, false if not
     */
    function inject(options) {
        var node = options.node;
        var where = options.where;
        var container = options.container;
        var selectors = options.selectors || [];
        var fallback = options.fallback;
        var $container = $(container);
        for (var i = 0; i < selectors.length; i++) {
            var selector = selectors[i];
            var target = $container.children(selector);
            if (target.length) {
                target[where](node);
                return true;
            }
        }
        if (_.isString(fallback)) {
            $container[fallback](node);
            return true;
        } else if (_.isFunction(fallback)) {
            fallback($container, node);
            return true;
        }
        return false;
    }

    /**
     * Replace a child element matched by a selector within a container with a new node. If the no child element
     * matches the selector, then the new node is appended to the container.
     *
     * @param options {object} - {
     *      node {Element|Array|String} the node(s) to insert into the container
     *      container {element}: the container
     *      selector {String}: the child selector to use to match the elements to replace
     * }
     */
    function replaceOrAppend(options) {
        replaceOrInject(options.node, options.selector, options.container, 'append');
    }

    /**
     * Replace a child element matched by a selector within a container with a new node. If the no child element
     * matches the selector, then the new node is prepended to the container.
     *
     * @param options {object} - {
     *      node {Element|Array|String} the node(s) to insert into the container
     *      container {element}: the container
     *      selector {String}: the child selector to use to match the elements to replace
     * }
     */
    function replaceOrPrepend(options) {
        replaceOrInject(options.node, options.selector, options.container, 'prepend');
    }

    function replaceOrInject(node, selector, container, fallback) {
        var $container = $(container);
        var existing = $container.children(selector);
        if (existing.length) {
            $(_.rest(existing)).remove();
            $(existing.first()).replaceWith(node);
        } else {
            $container[fallback](node);
        }
    }

    /**
     * Get the root node of the given XML document
     * @param doc the xml document
     * @returns {*} the jQuery wrapped root node
     */
    function root(doc) {
        return $((doc instanceof $ ? doc : $(doc))[0].childNodes[0]);
    }

    /**
     * Move all children from the source node to the destination node
     * @param src {*} the source node
     * @param dst {*} the destination node
     * @returns {*} the updated destination node
     */
    function moveChildren(src, dst) {
        src = $(src)[0];
        dst = $(dst)[0];
        while (src.firstChild) {
            dst.appendChild(src.firstChild);
        }
        return $(dst);
    }
    
    return {
        parse: parse,
        $node: $node,
        $tag: $tag,
        text: text,
        cdata: cdata,
        replaceCdataNodes: replaceCdataNodes,
        stripEmptyTextNodes: stripEmptyTextNodes,
        formatXMLDocument: formatXMLDocument,
        formatXML: formatXML,
        serialize: serialize,
        formatDashboardXML: formatDashboardXML,
        serializeDashboardXML: serializeDashboardXML,
        clone: clone,
        inject: inject,
        replaceOrAppend: replaceOrAppend,
        replaceOrPrepend: replaceOrPrepend,
        root: root,
        moveChildren: moveChildren
    };
});
define(
    'models/services/data/ui/Nav',[
        'jquery',
        'models/StaticIdSplunkDBase',
        'util/xml'
    ],
    function($, SplunkDBaseModel, XML) {
        return SplunkDBaseModel.extend({
            url: 'data/ui/nav',
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
            },
            getColor: function() {
                var $xml,
                    color,
                    eaiData = this.entry.content.get('eai:data');
                if (!eaiData) {
                    return "";
                }
                try {
                    $xml = XML.parse(eaiData);
                } catch(e) {
                    return "";
                }
                color = $xml.find('nav').attr('color');
                if (color && color.charAt(0) != '#') {
                    color = '#' + color;
                }
                return color;
            }
        },
        {
            id: 'data/ui/nav'
        });
    }
);

define(
    'models/services/data/UserPref',[
        'models/StaticIdSplunkDBase'
    ],
    function(SplunkDBaseModel) {
        return SplunkDBaseModel.extend({
            url: 'data/user-prefs',
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
            }
        },
        {
            id: 'data/user-prefs/general'
        });
    }
);
define('models/services/authentication/User',[
    'underscore',
    'models/SplunkDBase'
],
function(_, SplunkDBaseModel) {
    return SplunkDBaseModel.extend({
        FREE_PAYLOAD: {
            "links": {
                "create": "/services/authentication/users/_new"
            },
            "generator": {},
            "entry": [
                {
                    "name": "admin",
                    "links": {
                        "alternate": "/services/authentication/users/admin",
                        "list": "/services/authentication/users/admin",
                        "edit": "/services/authentication/users/admin"
                    },
                    "author": "system",
                    "acl": {
                        "app": "",
                        "can_list": true,
                        "can_write": true,
                        "modifiable": false,
                        "owner": "system",
                        "perms": {
                            "read": [
                                "*"
                            ],
                            "write": [
                                "*"
                            ]
                        },
                        "removable": false,
                        "sharing": "system"
                    },
                    "fields": {
                        "required": [],
                        "optional": [
                            "defaultApp",
                            "email",
                            "password",
                            "realname",
                            "restart_background_jobs",
                            "roles",
                            "tz"
                        ],
                        "wildcard": []
                    },
                    "content": {
                        "isFree": true,
                        "capabilities": [],
                        "defaultApp": "launcher",
                        "defaultAppIsUserOverride": false,
                        "defaultAppSourceRole": "system",
                        "eai:acl": null,
                        "email": "changeme@example.com",
                        "password": "********",
                        "realname": "Administrator",
                        "restart_background_jobs": true,
                        "roles": [
                            "admin"
                        ],
                        "type": "Splunk",
                        "tz": ""
                    }
                }
            ],
            "paging": {
                "total": 1,
                "perPage": 30,
                "offset": 0
            },
            "messages": []
        },
        url: "authentication/users",
        urlRoot: "authentication/users",/* for some unknown reason, base model checks for urlRoot existance... which chokes manager pages fetching User Model */
        initialize: function() {
            SplunkDBaseModel.prototype.initialize.apply(this, arguments);
        },
        sync: function(method, model, options) {
            // without this option the UI appends a suffix to array field names, i.e. 'roles' becomes 'roles[]'
            // which is not liked by the users endpoint
            options = options || {};
            if (method === 'update' || method === 'patch' || method === 'create') {
                options.traditional = true;
            }
            return SplunkDBaseModel.prototype.sync.call(this, method, model, options);
        },
        getCapabilities: function() {
            return this.entry.content.get('capabilities') || [];
        },
        hasCapability: function(capability) {
            if (this.isFree()) {
                return true;
            }
            return this.isNew() || (_.indexOf(this.getCapabilities(), capability) !== -1);
        },
        getRoles: function() {
            return this.entry.content.get('roles') || [];
        },
        hasRole: function(role) {
            if (this.isFree()) {
                return true;
            }
            return this.isNew() || (_.indexOf(this.getRoles(), role) !== -1);
        },
        isAdmin: function() {
            return this.hasRole('admin');
        },
        isCloudAdmin: function() {
            return this.hasRole('sc_admin') && this.serverInfo.isCloud();
        },
        canViewACL: function() {
            if (this.isFree()) {
                return false;
            }
            return true;
        },
        //the ability to run searches.
        canSearch: function() {
            return this.hasCapability("search");
        },
        //the ability to run real-time searches.
        canRTSearch: function() {
            return this.hasCapability("rtsearch");
        },
        canScheduleRTSearch: function() {
            return this.hasCapability("schedule_rtsearch");
        },
        //the ability to schedule saved searches, create and update alerts, review triggered alert information, and turn on report acceleration for searches.
        canScheduleSearch: function() {
            if (this.isFree()) {
                return false;
            }
            return this.hasCapability("schedule_search");
        },
        //the ability to add new or edit existing inputs
        canEditMonitor: function() {
            return this.hasCapability("edit_monitor");
        },
        canManageRemoteApps: function() {
            return this.hasCapability("rest_apps_management");
        },
        canAccelerateDataModel: function() {
            if (this.isFree()) {
                return false;
            }
            return this.hasCapability("accelerate_datamodel");
        },
        //the ability to accelerate searches.
        canAccelerateReport: function() {
            if (this.isFree()) {
                return false;
            }
            return this.hasCapability("accelerate_search") && this.hasCapability("schedule_search");
        },
        canEmbed: function () {
            if (this.isFree()) {
                return false;
            }
            return this.hasCapability("embed_report");
        },
        canEditViewHtml: function () {
            return this.hasCapability("edit_view_html");
        },
        canPatternDetect: function() {
            return this.hasCapability("pattern_detect");
        },
        canEditUsers: function() {
            return this.hasCapability('edit_user');
        },
        canEditServer: function() {
            return this.hasCapability('edit_server');
        },
        canRestart: function() {
            return this.hasCapability('restart_splunkd');
        },
        canEditReceiving: function() {
            return this.hasCapability('edit_splunktcp');
        },
        isFree: function() {
            return (this.entry.content.get("isFree") === true);
        }
    });
});

define(
    'models/shared/User',[
        'underscore',
        'models/services/authentication/User',
        'models/services/server/ServerInfo'
    ],
    function(_, UserModel, ServerInfoModel) {
        return UserModel.extend({
            initialize: function(attributes, options) {
                UserModel.prototype.initialize.apply(this, arguments);
                options || (options={});
                var serverInfoModel = options.serverInfoModel;
                if (!options.serverInfoModel || !(serverInfoModel instanceof ServerInfoModel)) {
                    throw 'The following constructor arguments are required ({}, {serverInfoModel: <models/services/server/ServerInfo>}).';
                }
                this.associated.serverInfo = serverInfoModel;
                this.serverInfo = serverInfoModel;
            },
            canAddData: function() {
                // SystemMenu uses this.canEditMonitor to decide whether to show this link
                // Hunk uses Explore Data, not Add Data
                return this.canEditMonitor() && !(this.serverInfo.isHunk());
            },
            canExploreData: function() {
                return !this.isFree() && (this.serverInfo.hasHadoopAddon() && !this.serverInfo.isCloud()); // Hunk uses Explore Data, not Add Data
            },
            canUseApps: function() {
                if (this.serverInfo.isLite()) {
                    return false;
                }
                return true;
            },
            supportsOutputGroups: function() {
                if (this.serverInfo.isLite()) {
                    return false;
                }
                return true;
            },
            canDeleteSourcetypes: function() {
                if (this.serverInfo.isCloud() && !this.serverInfo.isLite()) {
                    return false;
                }
                return true;
            },
            canUseAlerts: function() {
                return !(this.serverInfo.isLiteFree() || this.serverInfo.isFreeLicense());
            },
            canPivot: function() {
                if (this.serverInfo.isLite()) {
                    return false;
                }
                return true;
            },
            canSchedulePDF: function() {
                return (!this.serverInfo.isLiteFree() && this.canScheduleSearch());
            },
            canUseSidenav: function() {
                if (this.serverInfo.isLite()) {
                    return true;
                }
                return false;
            },
            canManageLicenses: function() {
                if (this.hasCapability('license_edit') && this.hasCapability('license_tab')) {
                    return true;
                }
                return false;
            },
            canViewLicense: function() {
                if (this.hasCapability('license_edit') && this.hasCapability('license_tab') || (this.serverInfo.isLiteCloud() && this.isCloudAdmin())) {
                    return true;
                }
                return false;
            }
        });
    }
);
define(
    'util/router_utils',[
        'jquery',
        'underscore',
        'backbone',
        'splunk.util',
        'helpers/user_agent'
    ],
    function($, _, Backbone, splunkutil, userAgent) {
        var exports = {},
            routeStripper = /^[#\/]|\s+$/g,
            // create an in-memory dictionary to store URL history when the URL itself would be too long
            inMemoryHistory = {};

        // visible for testing only
        exports.AGENT_HAS_URL_LIMIT = userAgent.hasUrlLimit();
        exports.URL_MAX_LENGTH = userAgent.getUrlLimit();

        var fragmentIsLegal = function(fragment) {
            if(!exports.AGENT_HAS_URL_LIMIT) {
                return true;
            }
            var loc = window.location,
                urlMinusFragment = loc.href.split('#')[0];

            return (urlMinusFragment.length + fragment.length) < exports.URL_MAX_LENGTH;
        };

        var historyIdCounter = 0;
        var nextHistoryId = function() {
            return '_suid_' + (++historyIdCounter);
        };

        var historyIdRegex = /^#?_suid_\d+$/;
        var fragmentIsHistoryId = function(fragment) {
            return historyIdRegex.test(fragment);
        };

        var storeFullFragment = function(fragment) {
            var historyId = nextHistoryId();
            inMemoryHistory[historyId] = fragment;
            return historyId;
        };

        //Introduced in 0.9.9, see https://github.com/documentcloud/backbone/issues/2440
        Backbone.history.getFragment = function(fragment, forcePushState) {
            var trailingSlash = /\/$/;
            if (fragment == null) {
                if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                    fragment = this.location.pathname;
                    var search = window.location.search;
                    if (search) {
                        fragment += search;
                    }
                    var root = this.root.replace(trailingSlash, '');
                    if (!fragment.indexOf(root)) {
                        fragment = fragment.substr(root.length);
                    }
                } else {
                    fragment = this.getHash();
                }
            }
            if(fragmentIsHistoryId(fragment)) {
                fragment = inMemoryHistory[fragment] || '';
            }
            return exports.strip_route(fragment);
        };

        //Introduced in 1.1.0, Backbone is stripping query string and hash before comparing the new route to the old one,
        //meaning that changes to those data structures are ignored
        Backbone.history.navigate = function(fragment, options) {
          var History = Backbone.History;
          // start Backbone code...
          /*jsl:ignore*/
          if (!History.started) return false;
          if (!options || options === true) options = {trigger: !!options};

          var url = this.root + (fragment = this.getFragment(fragment || ''));

          // Here is where we patched...
          // - fragment = fragment.replace(pathStripper, '');

          if (this.fragment === fragment) return;
          this.fragment = fragment;

          // Don't include a trailing slash on the root.
          if (fragment === '' && url !== '/') url = url.slice(0, -1);

          // If pushState is available, we use it to set the fragment as a real URL.
          if (this._hasPushState) {
            this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

          // If hash changes haven't been explicitly disabled, update the hash
          // fragment to store history.
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
              // Opening and closing the iframe tricks IE7 and earlier to push a
              // history entry on hash-tag change.  When replace is true, we don't
              // want this.
              if(!options.replace) this.iframe.document.open().close();
              this._updateHash(this.iframe.location, fragment, options.replace);
            }

          // If you've told us that you explicitly don't want fallback hashchange-
          // based history, then `navigate` becomes a page refresh.
          } else {
            return this.location.assign(url);
          }
          if (options.trigger) return this.loadUrl(fragment);
          /*jsl:end*/
        };

        Backbone.history._updateHash = _(Backbone.history._updateHash).wrap(function(originalFn, location, fragment, replace) {
            if(!fragmentIsLegal(fragment)) {
                fragment = storeFullFragment(fragment);
                if(replace) {
                    // if doing replace state operation, we can safely remove the old entry in the inMemoryHistory
                    var currentHash = this.getHash();
                    delete inMemoryHistory[currentHash];
                }
            }
            originalFn.call(Backbone.history, location, fragment, replace);
        });

        exports.strip_route = function(route) {
            return route.replace(routeStripper, '');
        };

        // the options.forceNoPushState argument is FOR TESTING ONLY
        // in production, start_backbone_history should always be called with no arguments
        exports.start_backbone_history = function(options) {
            var hasPushstate = "pushState" in window.history;
            //Due to the URL length constraint, forcing IE to use fragment identifier for the history management
            if ((options && options.forceNoPushState) || !hasPushstate || userAgent.isIE()) {
                $(document).ready(function() {
                    var hash = Backbone.history.getHash(),
                        hashPath = '',
                        query = '',
                        adjustedHash = '';

                    if (hash) {
                        var splitHash = hash.split('?');
                        hashPath = splitHash[0] || "";
                        query = splitHash[1] || '';
                    } else {
                        query = window.location.search.split('?')[1] || '';
                    }

                    if (hashPath && !fragmentIsHistoryId(hashPath)) {
                        adjustedHash = hashPath;
                    } else {
                        adjustedHash = exports.strip_route(window.location.pathname);
                    }
                    if (query) {
                        adjustedHash += ("?" + query);
                    }

                    if(!fragmentIsLegal(adjustedHash)) {
                        adjustedHash = storeFullFragment(adjustedHash);
                    }

                    window.location.replace(window.location.href.split('#')[0] + '#' + adjustedHash);
                    
                    //SPL-96431
                    //when ignoreFragment is true, the fragment part of the URL will be ignored for routing. Note: the fragment will not be removed from the URL.
                    if(options && options.ignoreFragment) {
                        //when hashChange is false, it will prevent hasChange event from triggering and hence this event will be ignored while dispatching the route.
                        Backbone.history.start({ hashChange:false });
                    } else {
                        Backbone.history.start();
                    }

                });
            } else {
                Backbone.history.start({pushState: true});
            }
        };
        return exports;
    }
);

define(
    'models/shared/ClassicURL',[
        'jquery',
        'underscore',
        'splunk.util',
        'backbone',
        'models/Base',
        'util/router_utils',
        'util/console'
    ],
    function($, _, util, Backbone, BaseModel, routerUtils, console) {

        var ClassicURLModel = BaseModel.extend({
            initialize: function() {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            isNew: function() {
                return false;  
            },
            sync: function(method, model, options) {
                var resp,
                    state,
                    dfd = $.Deferred();
                options = options || {};

                var silentClear = options.silentClear;
                var replaceState = options.replaceState;

                delete options.silentClear;
                delete options.replaceState;

                if (silentClear) {
                    model.clear({silent: true});
                }

                if (method === 'read') {
                    resp = model.currentQueryString();
                } else if (method === 'update') {
                    state = model.encode(options);
                    if (replaceState) {
                        model.replaceState(state, options);
                    } else {
                        model.pushState(state, options);
                    }
                    resp = this.currentQueryString();
                } else if (method === 'delete') {
                    this.pushState('', options);
                    resp = this.currentQueryString();
                } else {
                    throw new Error('invalid method: ' + method);
                }

                model.trigger('request', model, dfd, options);
                options.success(resp);
                return dfd.resolve().promise();
            },
            parse: function(response) {
                var urlQueryParameters = this.decode(response);

                /*
                 * Insert undefined values for each old attribute that
                 * is not specified in the new query parameters.
                 *
                 * That way, attributes missing from the new URL will
                 * be blanked out appropriately.
                 */
                var newAttributesWithBlanks = _.clone(this.attributes);
                _.each(newAttributesWithBlanks, function(value, key) {
                    newAttributesWithBlanks[key] = undefined;
                });
                _.extend(newAttributesWithBlanks, urlQueryParameters);

                return newAttributesWithBlanks;
            },
            /**
             * Convert the model to a query string
             * @param  {Object} options
             *         * preserveEmptyStrings: if a string is empty, still encode it in
             *         the query string. Defaults to true.
             *
             * @return {String} The model encoded as a query string.
             */
            encode: function(options) {
                var queryArray = [], encodedKey;
                _.each(this.toJSON(), function(value, key) {
                    if (_.isUndefined(value)) {
                        return;
                    }

                    if (value === "" && options && options.preserveEmptyStrings === false) {
                        return;
                    }

                    encodedKey = encodeURIComponent(key);
                    if (_.isObject(value)) {
                        console.error('Non-primitive values are not allowed in the query string: ', value);
                        throw new Error('Non-primitive values are not allowed in the query string');
                    } else {
                        queryArray.push(encodedKey + '=' + encodeURIComponent(value));
                    }
                });
                return queryArray.join('&');
            },
            decode: function(queryString) {
                return util.queryStringToProp(queryString);
            },
            currentQueryString: function() {
                var fragment;
                if (Backbone.history._hasPushState) {
                    return window.location.href.split('?')[1] || '';//not safe to read directly
                }
                fragment = Backbone.history.getFragment(window.location.href.split('#')[1] || '');//not safe to read directly
                return fragment.split('?')[1] || '';
            },
            pushState: function(data, options) {
                if (data) {
                    data = '?' + data;
                }
                Backbone.history.navigate(this.root() + data, $.extend(true, {}, options, {replace: false}));
            },
            replaceState: function(data, options) {
                if (data) {
                    data = '?' + data;
                }
                Backbone.history.navigate(this.root() + data, $.extend(true, {}, options, {replace: true}));
            },
            root: function() {
                return Backbone.history._hasPushState ? window.location.pathname :
                    '#' + routerUtils.strip_route(window.location.pathname);
            }
        });

        return ClassicURLModel;
    }
);

define('util/htmlcleaner',['underscore', 'jquery'], function (_, $) {

    var HTML_COMMENTS_PATTERN = /<!--.+?-->/gmi;
    var BAD_NODE_SELECTOR = 'script,link,meta,head,*[type="text/javascript"]';
    //var ALLOWED_URLS = /^(?:\/[^\/]|https?:|#)/g;
    var BAD_URL_SCHEMES = /^(?:javascript|jscript|livescript|vbscript|data|about|mocha):/i;
    var EVENT_HANDLER_ATTRIBUTE_PREFIX = "on";
    var CSS_NODE_SELECTOR = 'style';
    var CSS_EXPRESSION_PATTERN = /(^|[\s\W])expression(\s*\()/gmi;
    var CSS_EXPRESSION_REPLACE = '$1no-xpr$2';
    var URL_ATTRIBUTES = {
        link: ['href'],
        applet: ['code', 'object'],
        iframe: ['src'],
        img: ['src'],
        embed: ['src'],
        layer: ['src'],
        a: ['href']
    };

    function removeBadNodes($root) {
        if($root.is(BAD_NODE_SELECTOR)) {
            return $([]);
        }
        $root.find(BAD_NODE_SELECTOR).remove();
        return $root;
    }

    function cleanupUrl(url) {
        return decodeURIComponent(_.unescape($.trim(url || ''))).replace(/\s/gmi, '');
    }

    function isBadUrl(url) {
        return BAD_URL_SCHEMES.test(cleanupUrl(url));
    }

    function cleanAttributes($root) {
        _($root).each(function (node) {
            var $node = $(node),
                nodeName = (node.tagName||'').toLowerCase(),
                attrs = node.attributes,
                badNodes= [];
            _.each(attrs, function (attr) {
                if (attr) {
                    var attrName = attr.name.toLowerCase();
                    if (attrName.indexOf(EVENT_HANDLER_ATTRIBUTE_PREFIX) === 0) {
                        badNodes.push(attr.name);
                    } else {
                        var urlAttrs = URL_ATTRIBUTES[nodeName];
                        if (urlAttrs && _(urlAttrs).contains(attrName)) {
                            if (isBadUrl(attr.value)) {
                                $node.attr(attr.name, '#');
                            }
                        }
                    }
                }
            });

            // removal of nodes needs to happen after the node check occurs
            _.each(badNodes, function (attr) {
                $node.removeAttr(attr);
            });

            _($node.children()).chain().map($).each(cleanAttributes);
        });
    }

    function stripComments(txt) {
        return txt.replace(HTML_COMMENTS_PATTERN, '');
    }

    function cleanStylesheets($root) {
        _($('<div />').append($root).find(CSS_NODE_SELECTOR)).each(cleanStylesheet);
    }
    
    function cleanStylesheet(styleNode) {
        var $style = $(styleNode);
        var cssText = $style.html();
        var newText = cleanCssText(cssText);
        if (cssText != newText) {
            $style.text(newText);
        }
    }

    function cleanCssText(cssText) {
        CSS_EXPRESSION_PATTERN.lastIndex = 0;
        return cssText.replace(CSS_EXPRESSION_PATTERN, CSS_EXPRESSION_REPLACE);
    }

    function cleanHtml(htmlText) {
        // debugger
        var $html = $(stripComments(htmlText));
        $html = removeBadNodes($html);
        cleanAttributes($html);
        cleanStylesheets($html);
        return $('<div />').append($html).html();
    }

    return {
        clean: cleanHtml,
        _stripComments: stripComments,
        _isBadUrl: isBadUrl,
        _cleanAttributes: cleanAttributes,
        _removeScripts: removeBadNodes,
        _cleanStylesheets: cleanStylesheets,
        _cleanCssText: cleanCssText
    };

});
define(
'models/services/data/ui/Tour',[
    'underscore',
    'models/SplunkDBase',
    'splunk.util',
    'util/splunkd_utils',
    'util/htmlcleaner'
],
function(
    _,
    SplunkDBase,
    splunk_util,
    splunkd_utils,
    HtmlCleaner
) {
    var Tour = SplunkDBase.extend({
        url: 'data/ui/ui-tour',

        bootstrap: function(tourDeferred, app, owner, tourName) {
            var tourUrl = splunkd_utils.fullpath(
                    this.url + "/" + encodeURIComponent(tourName),
                    {
                        app: app,
                        owner: owner
                    }
                 ),
                 proxyTourModel = new Tour();

            proxyTourModel.fetch({
                url: tourUrl,
                success: function(model, response) {
                     if ((owner || '').toLowerCase() !== proxyTourModel.entry.acl.get('owner')) {
                         this.fetch({
                             success: function(model, response) {
                                var data = $.extend(true, {name: tourName}, proxyTourModel.entry.content.toJSON());
                                this.entry.content.set(data);
                                this.entry.set('name', tourName);
                                this.entry.content.set('name', tourName);
                                tourDeferred.resolve();
                             }.bind(this),
                             error: function(model, response) {
                                 tourDeferred.resolve();
                             }.bind(this)
                         });
                     } else {
                         this.setFromSplunkD(proxyTourModel.toSplunkD());
                         tourDeferred.resolve();
                     }
                 }.bind(this),
                 error: function(model, response) {
                     this.fetch({
                         success: function(model, response) {
                             this.entry.content.set({
                                 name: tourName
                             });
                             tourDeferred.resolve();
                         }.bind(this),
                         error: function(model, response) {
                             tourDeferred.resolve();
                         }.bind(this)
                     });
                 }.bind(this)
            });
        },

        getName: function() {
            return this.entry.get("name");
        },

        getLabel: function() {
            return this.entry.content.get('label') || '';
        },

        getTourType: function() {
            return this.entry.content.get('type') || '';
        },

        firstTimeCheck: function() {
            return this.entry.content.has('firstTimeCheck');
        },

        viewed: function() {
            return splunk_util.normalizeBoolean(this.entry.content.get('viewed'));
        },

        isDisabled: function() {
            return splunk_util.normalizeBoolean(this.entry.content.get('disabled'));
        },

        useTour: function() {
            return this.entry.content.get('useTour');
        },

        getInfo: function() {
            return this.entry.content.get('info') || '';
        },

        getUri: function(includeTourName) {
            var link = undefined;
            if (this.entry.content.has("uri")) {
                link = this.entry.content.get("uri");

                if (includeTourName) {
                    var name = this.getName();
                    if (name) {
                        //check to see if link already has query args
                        if (link.indexOf("?") == -1) {
                            link = link + "?tour=" + name;
                        } else {
                            link = link + "&tour=" + name;
                        }
                    }   
                }
            }    
            return link;
        },

        getLink: function(linkName) {
            var linkedModel = this.getLinkedModel(linkName);
            if (linkedModel) {
                return linkedModel.getUri(true);
            }
            return undefined;
        },

        getNextLink: function() {
            return this.getLink("next");
        },

        getPreviousLink: function() {
            return this.getLink("previous");
        },

        getExitLink: function() {
            return this.entry.content.get('exitLink') || '/';
        },

        endTour: function() {
            this.trigger("endTour");
        },

        // Image Tour
        isImgTour: function() {
            return splunk_util.normalizeBoolean(this.getTourType() == 'image');
        },

        getImageContext: function() {
            return this.entry.content.get('context');
        },

        getImgPath: function() {
            return this.entry.content.get('imgPath');
        },

        getImages: function() {
            var images = [],
                imageTotal = this.getImageTotal();

            for (var i = 1; i < imageTotal + 1; i++) {
                var image = this.getImageName(i);
                images.push(image);
            }

            return images;
        },

        getImageCaptions: function() {
            var captions = [],
                imageTotal = this.getImageTotal();

            for (var i = 1; i < imageTotal + 1; i++) {
                var imageCaption = (this.getImageCaption(i)) ? HtmlCleaner.clean('<span>' + this.getImageCaption(i) + '</span>') : ' ';
                captions.push(imageCaption);
            }

            return captions;
        },

        getImageTotal: function() {
            var maxImgs = 30,
                curImg = 0;

            for (var i = 1; i < maxImgs; i++) {
                var hasImg = this.entry.content.has('imageName' + i);
                if (hasImg) {
                    curImg++;
                } else {
                    break;
                }
            }

            return curImg;
        },

        getImageName: function(imgNum) {
            return this.entry.content.get('imageName' + imgNum);
        },

        getImageCaption: function(imgNum) {
            var caption = this.entry.content.get('imageCaption' + imgNum);
            return (caption) ? _(caption).t() : '';
        },

        getImageOrder: function(imgNum) {
            return this.entry.content.get('imageOrder' + imgNum);
        },

        getImageData: function(imgNum) {
            return this.entry.content.get('imageData' + imgNum);
        },

        // Interactive Tour
        isInteractive: function() {
            return splunk_util.normalizeBoolean(this.getTourType() == 'interactive');
        },

        getNextTour: function() {
            return this.entry.content.get('nextTour');
        },

        getTourPage: function() {
            return this.entry.content.get('tourPage') || '';
        },

        getTourURLData: function() {
            return this.entry.content.get('urlData');
        },

        getIntroText: function() {
            var introText = (this.entry.content.get('intro')) ? HtmlCleaner.clean('<span>' + _(this.entry.content.get('intro')).t() + '</span>') : '';
            return introText;
        },

        getNumSteps: function() {
            var maxSteps = 50,
                curStep = 0;

            for (var i = 1; i < maxSteps; i++) {
                var hasStep = this.entry.content.has('stepText' + i);
                if (hasStep) {
                    curStep++;
                } else {
                    break;
                }
            }

            return curStep;
        },

        getSteps: function() {
            var steps = [],
                numSteps = this.getNumSteps();

            if (numSteps > 0) {
                for (var i = 1; i < numSteps + 1; i++) {
                    if (this.entry.content.has('stepText' + i)) {
                        var stepText = HtmlCleaner.clean('<span>' + _(this.entry.content.get('stepText' + i)).t() + '</span>'),
                            stepEl = this.entry.content.get('stepElement' + i) || null,
                            stepPos = this.entry.content.get('stepPosition' + i) || '',
                            stepCallbackEvent = this.entry.content.get('stepClickEvent' + i) || null,
                            stepCallbackEventEl = this.entry.content.get('stepClickElement' + i) || null,
                            stepCallback = {};

                        if (stepCallbackEvent || stepCallbackEventEl) {
                            stepCallback = {
                                eventEl: stepCallbackEventEl,
                                eventType: stepCallbackEvent
                            };
                        }

                        steps.push({element: stepEl, intro: stepText, position: stepPos, callback: stepCallback});
                    } else {
                        break;
                    }
                }
            }

            return steps;
        }
    });
    return Tour;
});

/**
 * A reusable model encapsulating the fetch data for EAI endpoints.
 *
 * Adds special handling of the "sortKey" and "sortDirection" attributes, which are mapped to the keys that
 * the EAI-like endpoints expect, and the "filter" attribute, which is mapped from a dictionary of string pairs
 * to a filter search string.
 */

define('models/shared/fetchdata/EAIFetchData',[
            'underscore',
            'models/Base'
        ], 
        function(
            _,
            Base
        ) {

    return Base.extend({

        defaults: {
            filter: {}
        },

        toJSON: function(options) {
            var json = Base.prototype.toJSON.apply(this, arguments);

            if(json.sortKey) {
                json.sort_key = json.sortKey;
                json.sort_dir = json.sortDirection;
            }
            delete json.sortKey;
            delete json.sortDirection;

            if(_(json.filter).size() > 0) {
                var search = [];
                _(json.filter).each(function(match, key) {
                    search.push(key + '=*' + match + '*');
                });
                json.search = search.join(' ');
            }
            delete json.filter;

            return json;
        }

    });

});
/**
 * A base collection with some generic useful methods/behaviors
 *
 * TODO: lots of repeated code here and in the base model for broadcasting errors, safe fetch, and the fetch data model
 *       consider one or more mixins
 *
 * TODO: potential memory leaks when binding to events on the fetchData model, do we need a hook for disposing of collections?
 */

define(
    'collections/Base',[
        'jquery',
        'underscore',
        'backbone',
        'mixins/modelcollection',
        'models/Base',
        'splunk.util',
        'util/splunkd_utils'
    ],
    function($, _, Backbone, modelcollectionMixin, Base, splunkUtils, splunkDUtils) {
        var BaseCollection = Backbone.Collection.extend({
            initialize: function(models, options) {
                Backbone.Collection.prototype.initialize.apply(this, arguments);

                this.fetchData = (options && options.fetchData) ? options.fetchData : new Base();
                this.fetchData.on('change', _.debounce(function() { this.safeFetch(); }, 0), this);
                this.associated = this.associated || {};
                this.on('sync', this._onsync, this);
                this.on('error', this._onerror, this);
                this.on('reset', this.previousModelsOff, this);
            },
            fetch: function(options) {
                // merge the contents of the fetchData model into options.data
                var mergedOptions = $.extend(true, {}, {data: this.fetchData.toJSON()}, options);
                this.fetchXhr = Backbone.Collection.prototype.fetch.call(this, mergedOptions);
                // on successful fetch, handle any calls to safeFetch that came in while we were in-flight
                var that = this;
                this.fetchXhr.done(function() {
                    if(that.touched) {
                        that.safeFetch.apply(that, that.touched);
                    }
                });
                return this.fetchXhr;
            },
            _onerror: function(collection, response, options) {
                var messages = splunkDUtils.xhrErrorResponseParser(response, this.id);
                this.trigger('serverValidated', false, this, messages);
            },
            _onsync: function(collection, response, options) {
                var messages  = this.parseSplunkDMessages(response),
                    hasErrors = _(messages).any(function(message) {
                        return (message.type === splunkDUtils.ERROR || message.type === splunkDUtils.FATAL);
                    });
                this.trigger('serverValidated', !hasErrors, this, messages);
            },
            parseSplunkDMessages: function(response) {
                if(!response) {
                    return [];
                }
                return splunkDUtils.parseMessagesObject(response.messages);
            },
            deepOff: function() {
                modelcollectionMixin.deepOff.apply(this, arguments);
                this.each(function(model) {
                    if (_.isFunction(model.deepOff)) {
                        model.deepOff();
                    }
                });
            },
            associatedOff: function(events, callback, context) {
                _(this.associated).each(function(associated) {
                    associated.off(events, callback, context);
                    if(_.isFunction(associated.associatedOff)) {
                        associated.associatedOff(events, callback, context);
                    }
                }, this);
                
                this.each(function(model) {
                    if(_.isFunction(model.associatedOff)) {
                        model.associatedOff(events, callback, context);
                    }
                });
                // fetchData is not part of the associated container, but should still be unbound
                this.fetchData.off(events, callback, context);
            },
            previousModelsOff: function(models, options) {
                _(options.previousModels).each(function(model) {
                    if (_.isFunction(model.deepOff)) {
                        model.deepOff();
                    }
                });
            },
            reverse: function(options) {
                options || (options = {});
                var reversedModels = [].concat(this.models).reverse();
                if (options.mutate===false) {
                    return reversedModels;
                }
                this.reset(reversedModels, options);
            },
            isValid: function(options) {
                return this.all(function(model) { return model.isValid(options); });
            },
            // Backbone's collection clone makes a shallow copy (the models are shared references)
            // this version will clone each model and put the clones in the new collection
            deepClone: function() {
                return new this.constructor(this.invoke('clone'));
            },
            clearErrors: function() {
                this.trigger('serverValidated', true, this, []);
            }
        });
        _.extend(BaseCollection.prototype, modelcollectionMixin);
        
        return BaseCollection;
    }
);

define(
    'collections/SplunkDsBase',[
        'jquery',
        'underscore',
        'backbone',
        'models/SplunkDBase',
        'models/shared/fetchdata/EAIFetchData',
        'collections/Base',
        'util/splunkd_utils'
    ],
    function(
        $,
        _,
        Backbone,
        SplunkDBaseModel,
        EAIFetchData,
        Base,
        splunkDUtils
    )
    {
        return Base.extend({
            model: SplunkDBaseModel,
            initialize: function(models, options) {
                options = options || {};
                options.fetchData = options.fetchData || new EAIFetchData();
                Base.prototype.initialize.call(this, models, options);
                this.initializeAssociated();
            },
            initializeAssociated: function() {
                this.links = this.links || new SplunkDBaseModel();
                this.paging = this.paging || new SplunkDBaseModel();
            },
            fetch: function(options) {
                return Base.prototype.fetch.call(this, $.extend(true, {}, { reset: true }, options));
            },
            sync: function(method, collection, options) {
                options = options || {};
                var bbXHR, url,
                    defaults = {data: {output_mode: 'json'}, traditional: true};

                switch (method) {
                    case 'read':
                        if((window.$C['SPLUNKD_FREE_LICENSE'] || options.isFreeLicense) && collection.FREE_PAYLOAD) {
                            if(options.success) {
                                options.success(collection, collection.FREE_PAYLOAD, options);
                            }
                            var dfd = $.Deferred();
                            return dfd.resolve.apply(dfd, [collection, collection.FREE_PAYLOAD, options]);
                        }
                        url = _.isFunction(collection.url) ? collection.url() : collection.url;
                        var appOwner = {};
                        if(options.data){
                            appOwner = $.extend(appOwner, { //JQuery purges undefined
                                app: options.data.app || undefined,
                                owner: options.data.owner || undefined,
                                sharing: options.data.sharing || undefined
                            });
                        }
                        defaults.url = splunkDUtils.fullpath(url, appOwner);
                        $.extend(true, defaults, options);

                        delete defaults.data.app;
                        delete defaults.data.owner;
                        delete defaults.data.sharing;

                        return Backbone.sync.call(this, "read", collection, defaults);
                    default:
                        throw new Error('invalid method: ' + method);
                }
            },
            parse: function(response){
                // Make sure to initialize the associated (if they already exist this call will do nothing).
                // There are cases where parse can be called before initialize.
                this.initializeAssociated();
                this.links.set(response.links);
                delete response.links;
                if (response.paging) {
                    this.paging.set(response.paging);
                    // TODO: clean up after the paging gets added, and update any consumers of this information
                    // delete response.paging;
                }

                var results = response.entry,
                    header = $.extend(true, {}, response);
                delete header.entry;

                return _.map(results, function(result) {
                    var container = $.extend(true, {}, header);
                    container.entry = [$.extend(true, {}, result)];
                    return container;
                });
            },
            setFromSplunkD: function(payload, options){
                // have to use parse=true or the reset won't work correctly
                this.reset(payload, $.extend({parse: true}, options));
            },
            findByEntryName: function(name) {
                return this.find(function(model) {
                    return model.entry.get('name') === name;
                });
            }
        }, {
            // When fetching with user equal to wildcard adding this string to the search param will 
            // limit results to items shared with or created by the owner.
            availableWithUserWildCardSearchString: function(owner) {
                return '((eai:acl.sharing="user" AND eai:acl.owner="' + owner + '") OR (eai:acl.sharing!="user"))';
            }
        });
    }
);

define(
    'collections/services/data/ui/Tours',[
        'underscore',
        'models/services/data/ui/Tour', 
        'collections/SplunkDsBase'
    ],
    function(_, Model, CollectionBase) {
        return CollectionBase.extend({
            url: 'data/ui/ui-tour',
            model: Model,
        
            getTourModel: function(tourName) {
                if (this.length == 0 || this.models.length == 0) {
                    return undefined;
                }

                var model = this.find(function(modelCandidate) {
                        return (modelCandidate.getName() === tourName);
                    }),
                    useTour = (model && model.useTour()) ? model.useTour() : false;

                // check for linked tour
                if (useTour) {
                    // preventing an infinite loop of linking tours
                    if (useTour !== tourName && useTour !== this.previousTour) {
                        this.previousTour = tourName;
                        return this.getTourModel(useTour);
                    }
                }

                return model;
            },

            checkTours: function(serverInfo) {
                if (serverInfo) {
                    var productType = serverInfo.getProductType(),
                        instanceType = serverInfo.getInstanceType(),
                        isLite = serverInfo.isLite(),
                        tourIdentifier = productType + ((instanceType) ? ':' + instanceType : ''),
                        searchTour = this.getTourModel('search-tour:' + tourIdentifier),
                        adddataTour = this.getTourModel('adddata-tour:' + tourIdentifier),
                        dashboardsTour = this.getTourModel('dashboards-tour:' + tourIdentifier),
                        liteTour = this.getTourModel('light-product-tour');

                    if (searchTour || adddataTour || dashboardsTour) {
                        return true;
                    }

                    if (isLite && liteTour) {
                        return true;
                    }

                    return false;
                }

                return false;
            }
        });
    }
);

define(
    'collections/services/AppLocals',[
        "jquery",
        "underscore",
        "backbone",
        "models/services/AppLocal",
        "collections/SplunkDsBase",
        'util/general_utils'
    ],
    function($, _, Backbone, AppModel, SplunkDsBaseCollection, general_utils) {
        return SplunkDsBaseCollection.extend({
            model: AppModel,
            url: "apps/local",
            initialize: function() {
                SplunkDsBaseCollection.prototype.initialize.apply(this, arguments);
            },
            /* sort the apps collection based on user preference (appOrderString).
            any app not declared in the indexDictionary, is sorted alphabetically */
            sortWithString: function(appOrderString){
                //FOR SAFETY cast to string
                appOrderString = typeof appOrderString === 'string' ? appOrderString : '';
                var indexDictionary = {};
                var appOrderArray = appOrderString.split(',');
                if(_.isArray(appOrderArray) && appOrderArray.length > 0){
                    for(var i=0, len=appOrderArray.length; i<len; i++){
                        indexDictionary[appOrderArray[i]] = i;
                    }
                }

                this.comparator = function(appA, appB){
                    var nameA = appA.entry.get('name'),
                        nameB = appB.entry.get('name'),
                        labelA = appA.entry.content.get('label'),
                        labelB = appB.entry.content.get('label'),
                        positionA = indexDictionary[nameA],
                        positionB = indexDictionary[nameB],
                        isNumberA = _.isNumber(positionA),
                        isNumberB = _.isNumber(positionB);
                    if(isNumberA && isNumberB){
                        return positionA < positionB ? -1 : 1;
                    }
                    if(!isNumberA && !isNumberB){
                        return general_utils.compareWithDirection(labelA, labelB, true);
                    }
                    if(isNumberA && !isNumberB){
                        return -1;
                    }
                    if(!isNumberA && isNumberB){
                        return 1;
                    }
                };
                this.sort();
            },

            listWithoutInternals: function() {
                var internalApps = ['splunk_datapreview','splunk_management_console','learned','introspection_generator_addon','framework'];
                return this.filter(function(model) {
                    var appName = model.entry.get('name');
                    return (internalApps.indexOf(appName) === -1);
                });
            }
        });
    }
);
define(
    'models/services/data/ui/Manager',[
        'models/SplunkDBase'
    ],
    function(SplunkDBaseModel) {
        return SplunkDBaseModel.extend({
            url: "data/ui/manager",
            urlRoot: "data/ui/manager",
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
            }
        });
    }
);
define(
    'collections/services/data/ui/Managers',[
        'jquery',
        'backbone',
        "models/services/data/ui/Manager",
        "collections/SplunkDsBase",
        'util/splunkd_utils'
    ],
    function($, Backbone, ManagerModel, SplunkDsBaseCollection, splunkdUtils) {
        return SplunkDsBaseCollection.extend({
            url: "data/ui/manager",
            model: ManagerModel,
            initialize: function() {
                SplunkDsBaseCollection.prototype.initialize.apply(this, arguments);
            },
            canShowMore: function() {
                return this.links.get('_show') ? true : false;
            },
            showMore: function() {
                var model = new ManagerModel({
                    id: 'data/ui/manager/_show'
                });

                // Use Backbone.sync() directly instead of Model.save() to
                // avoid argument whitelist wonkiness -- GET on
                // /data/ui/manager/_show isn't allowed, and even if it were,
                // it wouldn't produce meaningful optional/required args.

                var bbXHR, deferredResponse = $.Deferred(),
                    defaults = {
                        trigger: true,
                        processData: true,
                        url: splunkdUtils.fullpath(model.id, {}),
                        type: 'POST',
                        data: {
                            output_mode: 'json'
                        }
                    };

                var callback_collection = this;

                bbXHR = Backbone.sync.call(this, "update", model, defaults);
                bbXHR.done(function() {
                    callback_collection.links.unset('_show');
                    callback_collection.fetch({
                        data: {
                            app: '-',
                            owner: '-',
                            count: 0,
                            digest: 1
                        },
                        success: function() {
                            deferredResponse.resolve.apply(deferredResponse, arguments);
                        }
                    });
                });
                bbXHR.fail(function() {
                    deferredResponse.reject.apply(deferredResponse, arguments);
                });

                return deferredResponse.promise();
            }
        });
    }
);

/**
 * Mixin to add logging to a Backbone View
 *
 * This mixin will add logging statements to each DOM event handler in the view's "events" hash,
 * but only if logging is enabled and the log level is DEBUG.
 *
 * In the case where logging should not be added this code is designed to do as little work as possible.  Attaching
 * logging should not cause any changes in behavior.
 *
 * Usage:
 *
 *   var MyView = Backbone.View.extend({
 *       // view code here
 *   });
 *   _.extend(MyView.prototype, viewloggingmixin);
 */

define('mixins/viewlogging',[
            'underscore',
            'backbone',
            'splunk.logger',
            'splunk.util'
        ],
        function(
            _,
            Backbone,
            SplunkLogger,
            splunkUtils
        ) {

    var logMode = splunkUtils.getConfigValue("JS_LOGGER_MODE", "None"),
        logLevel = splunkUtils.getConfigValue("JS_LOGGER_LEVEL", "INFO"),
        shouldAttachLogging = (logMode !== 'None' && logLevel === 'DEBUG'),
        // don't attach loggers to events that will be very chatty
        domEventBlacklist = ['mousemove', 'scroll'],
        logger = null;

    return ({

        // an override of delegateEvents, which will wrap each event handler in a new function that will log
        // a useful message and then invoke the original handler
        delegateEvents: function(events) {
            // if logging should not be attached, this should be an effective no-op
            if(!shouldAttachLogging) {
                return Backbone.View.prototype.delegateEvents.call(this, events);
            }
            events = events || _.result(this, 'events');
            // if there are no events declared, again fall through to the Backbone implementation
            if(!events) {
                return Backbone.View.prototype.delegateEvents.call(this, events);
            }
            var wrappedEvents = {};
            // loop over each eventName-handler pair, making sure to normalize the fact that the handler could be a
            // function or the string name of an instance member, replace the handler with a wrapper function
            // and call the Backbone implementation with the wrapped version of the handlers
            _(events).each(function(handler, eventName) {
                var normalizedHandler = _.isFunction(handler) ? handler : this[handler];
                if(_.isFunction(normalizedHandler) && _(domEventBlacklist).indexOf(eventName) === -1) {
                    var viewId = this.moduleId + '/' + this.cid;
                    wrappedEvents[eventName] = function() {
                        if(!logger) {
                            logger = SplunkLogger.getLogger('viewlogging.js');
                        }
                        logger.debug('view ' + viewId + ' is handling event ' + eventName.replace(/\s+/g, ' '));
                        // "this" here will be the context that Backbone uses to invoke the handler
                        normalizedHandler.apply(this, arguments);
                    };
                }
                // in the case where normalizedHandler is for some reason not a function, it is not safe to create the
                // wrapper, but make sure to be non-destructive
                else {
                    wrappedEvents[eventName] = handler;
                }
            }, this);
            return Backbone.View.prototype.delegateEvents.call(this, wrappedEvents);
        }

    });

});
define('global/GlobalReflowQueue',['require','exports','module','underscore'],function(require, exports, module){
	var _  = require('underscore'),
		viewsToReflow = [],
		viewAddInterval,
		tickInterval = 50;


	var GlobalReflowQueue = {
		add: function(view) {
			viewsToReflow.push(view);
			//If there is at least one view to reflow, set an interval and validate the views
			//We set an interval in case a view is added while we are validating our existing views
			//This view will need to be processed after we have validated the current views to be reflowed.
			if (viewsToReflow.length === 1) {
				viewAddInterval = window.setInterval(GlobalReflowQueue.validateViews, tickInterval);	
			}
		},

		validateViews: function (){
			var internalViewsToReflow = _.sortBy(viewsToReflow, function(view) {
				return view.getReflowDepth();
			});
			for (var i = 0; i < internalViewsToReflow.length; i++) {
				internalViewsToReflow[i].validateReflow();
			}
			//If we have no more views to reflow, then clear the interval - we don't need to call the function again
			if (viewsToReflow.length === 0) {
				clearInterval(viewAddInterval);
			}
		},
		remove: function(view) {
			var indexToRemove = viewsToReflow.indexOf(view);
			if (indexToRemove > -1) {
				viewsToReflow.splice(indexToRemove, 1);
			}
			//If we have removed all of the views that we need to reflow, we don't need to validate views again.
			if (viewsToReflow.length === 0) {
				clearInterval(viewAddInterval);
			}
		},


		//For testing, not exposed in real API.
		getTickInterval: function() {
			return tickInterval;
		},

		clear: function() {
			viewsToReflow = [];
		}
	};
	return GlobalReflowQueue;
});
define('views/Base',[
    'jquery',
    'backbone',
    'underscore',
    'mixins/viewlogging',
    'util/console',
    'global/GlobalReflowQueue'
],
function(
    $,
    Backbone,
    _,
    viewloggingmixin,
    console,
    GlobalReflowQueue
){
    var BaseView = Backbone.View.extend({
        awake: true,
        touch: false,
        active: false,
        isReflowValid: true,

        /**
         * A collection of Backbone.View utilities and conventions to assist with template compilation and cacheing, noop nested views and
         * className naming conventions. The general rule of thumb is to not override native Backbone.View methods but to complement the core
         * API with simple and useful patterns.
         *
         * @param {Object} options {
         *      @param {String} moduleId (Optional) An id (commonly the requirejs module.id) that is formatted and appended as a className to
         *                                          the root view el. Added as an instance member if passed in via the constructor.
         *
         *      @param {String} template (Optional) An _.template that is passed through the compileTemplate method. Added as an instance member
         *                                          if passed including an additional compiledTemplate instance member (see compileTemplate for
         *                                          specification).
         *  }
         */
        constructor: function(options) {
            this.options = options || {};
            this.children = {};
            
            if (this.options.moduleId) {
                this.moduleId = this.options.moduleId;
            }
            if (this.options.template) {
                this.template = this.options.template;
            }
            if (this.template) {
                this.compiledTemplate = this.compileTemplate(this.template);
            }
            Backbone.View.apply(this, arguments);
        },
        initialize: function() {
            var render = this.render;
            this.render = _.bind(function() {
                var start = (new Date()).getTime(), 
                    end;
                if (this.awake) {
                    render.apply(this);
                } else {
                    this.touch = true;
                }
                end = (new Date()).getTime();
                if(this.options.instrument !== false) {
                    this.$el.attr('data-render-time', (end - start)/1000);
                }
                return this;
            }, this);
           
            this.$el.attr('data-cid', this.cid);
            if (this.moduleId) {
                var className = this.cssNamespace();
                if (!this.options.dontAddModuleIdAsClass) {
                    this.$el.addClass(className);
                }
                this.$el.attr('data-view', this.moduleId);
            }
        },
        
        /**
         * Calls the method named by methodName on each child of the view.
         * Any extra arguments passed to invoke will be forwarded on to the method invocation.
         */
        invokeOnChildren: function(method) {
            if (!_.isString(method)) {
                throw new Error('Your method must be a string');
            }
            var argsForMethod = Array.prototype.slice.call(arguments, 1);
            
            _.each(this.children, function(child) {
                if (_.isArray(child)) {
                    _.each(child, function(view) {
                        if (_.isFunction(view[method])) {
                            view[method].apply(view, argsForMethod);
                        }
                    });
                } else {
                    if (_.isFunction(child[method])) {
                        child[method].apply(child, argsForMethod);
                    }
                }
            });
        },
        
        /**
         * Iterates over this children of this view, yielding each in turn to an iterator function.
         * The iterator is bound to the context object, if one is passed.
         * Each invocation of iterator is called with one argument: (child).
         */
        eachChild: function(iterator, context) {            
            if (!_.isFunction(iterator)) {
                throw new Error('Your iterator must be a function');
            }
            
            _.each(this.children, function(child){
                if (_.isArray(child)) {
                    _.each(child, function(view){
                        iterator.call(context, view);
                    });
                } else {
                    iterator.call(context, child);
                }
            });
        },
        
        /**
         * Replaces render noop proxy to original render routine. Additionally traverses
         * a special children attribute that consists of an object collection of views and
         * calls wake if that method exists.
         * 
         * @param {Object} options {
         *      @param {Boolean} syncRender (Optional) Call the standard (sync) render method over async (debouncedRender) variant.
         * }
         */
        wake: function(options) {
            options || (options = {});
            this.awake = true;
            if (this.touch) {
                this.touch = false;
                if (options.syncRender) {
                    this.render();
                } else {
                    this.debouncedRender();
                }
            }
            this.invokeOnChildren('wake', options);
            return this;
        },
        /**
         * Stops any subsequent calls to render and proxies them to a noop routine. Additionally traverses
         * a special children attribute that consists of an object collection of views and calls sleep if
         * that method exists.
         */
        sleep: function() {
            this.awake = false;
            this.invokeOnChildren('sleep');
            return this;
        },

        /**
         * Postpone the execution of render until after the input has stopped arriving.
         * Useful for assigning to model/collection change event listeners that should
         * only happen after the input has stopped arriving.
         */
        debouncedRender: function() {
            if (!this._debouncedRender) {
                this._debouncedRender = _.debounce(this.render, 0);
            }
            this._debouncedRender.apply(this, arguments);
        },
        /**
         * Compiles and memoizes an _.template string into a function that can be evaulated
         * for rendering.
         *
         * @param {String} templateStr An _.template string for compilation into a function.
         * @type {Function}
         * @return A function that can be evaluated for rendering, pass in a data object that
         * that has properties corresponding to the template's free variables.
         */
        compileTemplate: _.memoize(function(templateStr) {
            return _.template(templateStr);
        }),
        /**
         * Tailored for the requirejs module.id format converting into a safe and legal css 
         * class attribute. For example the following module id '/views/shared/SkidRow' 
         * would be converted to 'views-shared-skdrow'.
         */
        cssNamespace: function() {
            return (this.moduleId || '').toLowerCase().replace(/\//g, '-').replace(/\_/g, '').replace(/^views-/, '').replace(/-master$/, '');
        },
        /**
         * Generates a unique namespace that can be humanly cross-referenced to the view. 
         */
        uniqueNS: function() {
            return (this.moduleId || 'unidentified').toLowerCase().replace(/\//g, '-') + '-' + this.cid;
        },
        
        /**
         * Subscribe listeners.
         * implement as necessary
         */
        startListening: function() {
        },

        stopListening: function() {
            if(arguments.length === 0) {
                this.modelsOff(this.model);
                this.collectionsOff(this.collection);
            }
            Backbone.View.prototype.stopListening.apply(this, arguments);
        },
        
        remove: function() {
            this.removeChildren();
            if (this._isAddedToDocument) {
                this.onRemovedFromDocument();
                this._isAddedToDocument = false;
            }
            this.stopListening();
            this.$el.remove();
            GlobalReflowQueue.remove(this);
            return this;
        },
        
        debouncedRemove: function(options) {
            options || (options = {});
            var defaults = {
                detach: false
            };
            _.defaults(options, defaults);
            if (options.detach) {
                this.$el.detach();
            }
            if (!this._debouncedRemove) {
                this._debouncedRemove = _.debounce(this.remove, 0);
            }
            this._debouncedRemove.apply(this, arguments);
            return this;
        },
        
        removeChildren: function() {
            this.invokeOnChildren('remove');
        },
        
        ensureDeactivated: function(options) {
            if (this.active) {
                this.deactivate(options);
            }
        },
        
        activate: function(options) {
            options || (options = {});
            // the options for startListening and trigger are always shallow
            var clonedOptions = _.extend({startListening: true, trigger: true}, options);
            delete options.startListening;
            delete options.trigger;
            if (!this.active && clonedOptions.startListening) {
                this.startListening();
            }
            if (this.active) {
                console.debug("Calling activate again on view:" + this.moduleId, this.cid);
            } else {
                this.active = true;
                if (clonedOptions.trigger) {
                    this.trigger("activated");
                }                
            }
            //children get activated after the parent
            if (options.deep) {
                this.invokeOnChildren('activate', options);
            }
            return this;
        },
        
        deactivate: function(options) {
            options || (options = {});
            // the options for stopListening and trigger are always shallow
            var clonedOptions = _.extend({stopListening: true, trigger: true}, options);
            delete options.stopListening;
            delete options.trigger;
            //children get deactivated before the parent
            if (options.deep) {                
                this.invokeOnChildren('deactivate', options);
            }
            if (this.active && clonedOptions.stopListening) {
                this.stopListening();
            }
            if (!this.active) {
                console.debug("Calling deactivate again on view:" + this.moduleId, this.cid);
            } else {
                this.active = false;
                if (clonedOptions.trigger) {
                    this.trigger("deactivated");
                }                
            }
            return this;
        },
        
        /**
         *  Helper function for deepDestroy, recursively calls off() on its model(s)
         */
        modelsOff: function (model) {
            if (model instanceof Backbone.Model) {
                _.isFunction(model.associatedOff) && model.associatedOff(null, null, this);
                model.off(null, null, this);
            } else if (_.isArray(model) || $.isPlainObject(model)) { // SPL-90156
                _(model).each(function(mod) {
                    this.modelsOff(mod);
                }, this);
            } else if (model instanceof Backbone.Collection) { // TODO: revisit this logic after Dash release
                console.warn("Warning: trying to call modelsOff() on a Backbone.Collection object, please move it to this.collection instead.");
                this.collectionsOff(model);
            } else if (model != null) {
                console.warn('Warning: trying to call modelsOff() on non-Backbone.Model object! Maybe move it to this.options?');
            }
            return this;
        },
        /**
         *  Helper function for deepDestroy, recursively calls off() on its collections(s)
         */
         collectionsOff: function(collection) {
            if (collection instanceof Backbone.Collection) {
                collection.off(null, null, this);
            } else if (_.isArray(collection) || $.isPlainObject(collection)) {
                _(collection).each(function(coll) {
                    this.collectionsOff(coll);
                }, this);
            } else if (collection instanceof Backbone.Model) { // TODO: revisit this logic after Dash release
                console.warn("Warning: trying to call collectionsOff() on a Backbone.Model object, pleaes move it to this.model instead.");
                this.modelsOff(collection);
            } else if (collection != null) {
                console.warn('Warning: trying to call collectionsOff() on non-Backbone.Collection object! Maybe move it to this.options?');
            }
            return this;
        },

        /**
         * Helper function for removing the view from the DOM while a render occurs. If you call this on subviews in
         * a render function, jQuery will remove all of the subview's event listeners
         */
        detach: function() {
            if (this._isAddedToDocument) {
                this.onRemovedFromDocument();
                this._isAddedToDocument = false;
            }
            this.$el.detach();
        },

        // add instance methods for all commonly used jQuery attachment methods
        //replaceContentsOf is the analog of $.html($container)
        replaceContentsOf: function($container) {
            if(_.isString($container)) {
                throw new Error('replaceContentsOf does not support selectors or HTML strings');
            }
            
            // ensure the given $container parameter is a jQuery object
            $container = $($container);
            $container.empty();
            return this.attachToDocument($container, 'appendTo'); 
        },
        appendTo: function($container) { return this.attachToDocument($container, 'appendTo'); },
        prependTo: function($container) { return this.attachToDocument($container, 'prependTo'); },
        replaceAll: function($container) { return this.attachToDocument($container, 'replaceAll'); },
        insertAfter: function($container) { return this.attachToDocument($container, 'insertAfter'); },
        insertBefore: function($container) { return this.attachToDocument($container, 'insertBefore'); },

        /**
         * Attach the view to the given DOM element using the given method.
         * If afterward the view is attached to the document element, the onAddedToDocument method will be called.
         * If the view was already attached to the document element, and the given DOM element is different than
         * the view's current parent element, the onRemovedFromDocument method will be called first.
         *
         * Not meant to be called directly, only as a helper for the more specific attachment methods above.
         *
         * @param $container (DOM element or jQuery object)
         * @param attachmentMethod (a valid jQuery DOM attachment method name)
         */
        attachToDocument: function($container, attachmentMethod) {
            if(_.isString($container)) {
                throw new Error(attachmentMethod + ' does not support selectors or HTML strings');
            }

            // ensure the given $container parameter is a jQuery object
            $container = $($container);
            
            // if no container, abort
            if ($container.length === 0) {
                return this;
            }

            // get the raw DOM container
            var container = $container[0];

            // call onRemovedFromDocument if needed
            var oldParent = this.el.parentNode;
            if (oldParent && (oldParent !== container)) {
                if (this._isAddedToDocument) {
                    this.onRemovedFromDocument();
                    this._isAddedToDocument = false;
                }
            }

            // do the attachment
            this.$el[attachmentMethod]($container);

            // call onAddedToDocument if needed
            if (oldParent !== container) {
                if ($.contains(document.documentElement, this.el)) {
                    this._isAddedToDocument = true;
                    this.onAddedToDocument();
                }
            }

            return this;
        },

        /**
         * Called when this view is added to the document. Recursively calls
         * onAddedToDocument on all child views. Override this method with custom code
         * that should be run when this view is added to the document. Make sure to call
         * the base implementation when overriding.
         * 
         * This method is automatically called and should not be called directly.
         */
        onAddedToDocument: function() {
            this.invalidateReflow();
            this.eachChild(function(child) {
                if (_.isFunction(child.onAddedToDocument) && this.isAncestorOf(child) && !child._isAddedToDocument) {
                    child._isAddedToDocument = true;
                    child.onAddedToDocument();
                }
            }, this);
        },

        /**
         * Called when this view is removed from the document. Recursively calls
         * onRemovedFromDocument on all child views. Override this method with custom
         * code that should be run when this view is removed from the document. Make
         * sure to call the base implementation when overriding.
         * 
         * This method is automatically called and should not be called directly.
         */
        onRemovedFromDocument: function() {
            this.isReflowValid = true;
            GlobalReflowQueue.remove(this);
            this.eachChild(function(child) {
                if (_.isFunction(child.onRemovedFromDocument) && this.isAncestorOf(child) && child._isAddedToDocument) {
                    child.onRemovedFromDocument();
                    child._isAddedToDocument = false;
                }
            }, this);
        },

        /**
         * Returns a boolean indicating whether the view is currently attached to the document element
         */
        isAddedToDocument: function() {
            return this._isAddedToDocument;
        },

        /**
         * Returns true if this view is an ancestor of the given view; false otherwise;
         * 
         * @param {Backbone.View} descendant A Backbone.View instance to test against.
         */
        isAncestorOf: function(descendant) {
            return descendant.el ? $.contains(this.el, descendant.el) : false;
        },

        /**
         * Returns true if this view is a descendant of the given view; false otherwise;
         * 
         * @param {Backbone.View} ancestor A Backbone.View instance to test against.
         */
        isDescendantOf: function(ancestor) {
            return ancestor.el ? $.contains(ancestor.el, this.el) : false;
        },

        /**
         * Instruct the view to re-flow itself in its current container.
         *
         * Override this method to do any work that is required when the view needs to adjust to its container size.
         */
        reflow: function() {
        },

        /**
         * Helper function that returns the paths of ancestor Backbone views. The algorithm
         * traverses the DOM up the parent chain and the data-view attribute of each DOM element
         * with a data-view attribute. The data-view attribute is added to the DOM tree root of
         * each views/Base.
         *
         * The array is sorted starting with the top-most DOM element's data-view string
         *
         * This function will only return the full ancestor list once it has been added to a DOM
         *
         * @param depth {Number} specifies the maximum number of ancestors to return
         * @return {Array}
         */
        getAncestors: function(depth) {
            var results = [];
            var parent = this.$el;

            while (true) {
                parent = parent.parent();

                if (parent.length > 0) {
                    var dataView = parent.attr("data-view");
                    if (!_(dataView).isUndefined() && !_(dataView).isEmpty())
                        results.unshift(dataView);
                } else {
                    break;
                }

                if (!_(depth).isUndefined() && depth == results.length)
                    break;
            }

            return results;
        },

        invalidateReflow: function() {
            if (this.isReflowValid) {
                this.isReflowValid = false;
                GlobalReflowQueue.add(this);
            }
        },

        validateReflow: function(force) {
            if (!this.isReflowValid || force) {
                this.reflow();
                this.isReflowValid = true;
                GlobalReflowQueue.remove(this);
            }
            this.invokeOnChildren('validateReflow');
        },

        getReflowDepth: function() {
            var depth = 0;
            for (var parentNode = this.el.parentNode; parentNode; parentNode = parentNode.parentNode) {
                depth++;
            }
            return depth;
        }
    });

    _.extend(BaseView.prototype, viewloggingmixin);

    return BaseView;

});

/**
 *   views/shared/delegates/Base
 *
 *   Desc:
 *     This a base class for other delegates.

 *   @param {Object} (Optional) options An optional object literal having one settings.
 *
 *    Usage:
 *       var p = new DelegateBase({el: {el}})
 *
 *    Options:
 *        el (required): The event delegate
 */


define('views/shared/delegates/Base',[ 'views/Base' ],function(BaseView){
    return BaseView.extend({
        
        initialize: function() {
            //no-op
        },

        wake: function() {
            //no-op
        },

        sleep: function() {
            //no-op
        },
        
        /**
         * Due to the nature of delegates acting as decorators (delegates do not own
         * their root el), we need to override on base class methods that operate on 
         * DOM elements that the view owns.
         */
        remove: function() {
            this.stopListening();
            return this;
        },

        detach: function() {
            throw new Error('detach is not supported by delegates.');
        },
        
        appendTo: function() {
            throw new Error('jQuery-like attachment methods are not supported by delegates.');
        },

        prependTo: function() {
            throw new Error('jQuery-like attachment methods are not supported by delegates.');
        },

        replaceAll: function() {
            throw new Error('jQuery-like attachment methods are not supported by delegates.');
        },

        insertBefore: function() {
            throw new Error('jQuery-like attachment methods are not supported by delegates.');
        },

        insertAfter: function() {
            throw new Error('jQuery-like attachment methods are not supported by delegates.');
        }

    });
});

define(
    'util/string_utils',[],
    function() {

        var strEndsWith = function(str, suffix) {
            if (!str || !suffix) {
                return false;
            }
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        };

        var strStartsWith = function(str, prefix) {
            if (!str || !prefix) {
                return false;
            }
            return str.indexOf(prefix) === 0;
        };

        /**
        * Changes the first letter of first word in a string to upper-case.
        * All other letters remain unchanged. 
        *
        * @param str {String} - string to capitalize.
        * @returns {String} - Returns a string with the first letter of first word upper-case. 
        */
        var capitalize = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        /**
         * Truncates and adds ellipsis in the interior of a string if
         * the string is longer than the desired length.
         * 
         * @param str {String} - The string to have inner ellipsis added to it.
         * @param maxLength {Number} - Maximum length of the string.
         * @param leadingLength {Number} - Desired length ahead of the ellipsis.
         * @param trailingLength {Number} - Desired length following the ellipsis.
         * @returns {String} - 
         */
         var maybeAddEllipsis = function(str, maxLength, leadingLength, trailingLength) {
                var label = str;
                if(label.length > maxLength) {
                    label = label.substring(0, leadingLength) +
                            '...' +
                            label.substring(label.length - trailingLength);
                }
                return label;
         };

        /**
         * Takes a regex and a text string, returns an array of arrays, containing all matches corresponding to groups within the regex
         *
         * @param text - string to match against
         * @param regExp - takes the form /(foo)...(bar)/g
         * Note that the global field "g" is required or else the function will go into an infinite loop
         */
        var getRegexMatches = function(regExp, text) {
            var matches = [];
            var match = regExp.exec(text);
            while (match != null) {
                matches.push(match);
                match = regExp.exec(text);
            }
            return matches;
        };

        var stripSearchFromSearchQuery = function(search) {
            if (search && search.indexOf('search') === 0) {
                return search.slice(6).trim();
            }
            return search;
        };


        return {
            strEndsWith: strEndsWith,
            strStartsWith: strStartsWith,
            capitalize: capitalize,
            maybeAddEllipsis: maybeAddEllipsis,
            getRegexMatches: getRegexMatches,
            stripSearchFromSearchQuery: stripSearchFromSearchQuery
        };
    }
);

define('util/keyboard',['jquery', 'underscore'], function($, _) {
    var keyboard = {};

    keyboard.KEYS = {
        ENTER: 13,
        UP_ARROW: 38,
        DOWN_ARROW: 40,
        LEFT_ARROW: 37,
        RIGHT_ARROW: 39,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        SPACE_BAR: 32,
        TAB: 9,
        ESCAPE: 27
    };

    /**
     * A helper method that will enforce circular tabbing inside the given container (i.e. tabbing from the last element
     * will wrap around to the first element and reverse tabbing from the first element will wrap around to the last).
     *
     * Will only set focus on the next element if the event's target is inside the container, and if it does, will
     * prevent the default action of the event.
     *
     * @param $container (jQuery object) the container that should enforce the circular tabbing
     * @param event (DOM event object) the keydown event that initiated the tabbing action
     * @returns (jQuery object) the element that was focused, or null if no element was focused
     */
    keyboard.handleCircularTabbing = function($container, event, includeContainer) {
        var tabbableSelectors = 'a[href]:not(.synthetic-select):not(.disabled), area[href], input:not([disabled]),' +
                                'select:not([disabled]), textarea:not([disabled]),' +
                                        'button:not([disabled]), iframe, object, embed, *[tabindex],' +
                                '*[contenteditable]',
            tabbableElements = $();


        // Support an array of containers instead of just one
        if (_.isArray($container)) {
            var containers = $container;
            _.each(containers, function($el) {
                tabbableElements = tabbableElements.add($el.find(tabbableSelectors));
            });
        } else {
            tabbableElements = $container.find(tabbableSelectors);
        }

        if (includeContainer) {
            tabbableElements = tabbableElements.add($container);
        }

        tabbableElements = _.chain(tabbableElements).uniq()
            .filter(function(el) {
                var $el = $(el);
                return $el.is(':visible') && $el.css('visibility') !== 'hidden';
            })
            .value();

        var firstElement = tabbableElements[0],
            lastElement = tabbableElements[tabbableElements.length - 1];

        if(_.contains(tabbableElements, event.target)) {
            event.preventDefault();
            if(event.target === lastElement && !event.shiftKey) {
                return $(firstElement).focus();
            }
            if(event.target === firstElement && event.shiftKey) {
                return $(lastElement).focus();
            }
            if(event.shiftKey) {
                return $(tabbableElements[_.indexOf(tabbableElements, event.target) - 1]).focus();
            }
            return $(tabbableElements[_.indexOf(tabbableElements, event.target) + 1]).focus();
        }
        return null;
    };

    return keyboard;
});
/**
 *   views/shared/delegates/Popdown
 *
 *   Desc:
 *     This class applies popdown menus and dialogs.

 *   @param {Object} (Optional) options An optional object literal having one settings.
 *
 *    Usage:
 *       var p = new Popdown({options})
 *
 *    Options:
 *        el (required): The dialog.
 *        arrow: jQuery selector or object for arrow that points up. Defaults to ".arrow".
 *        mode: menu (default) or dialog. Change to dialog to prevent clicks inside the dialog from closing the popdown.
 *        show: true or false (default). Open the menu on initialization.
 *        adjustPosition: true (default) or false. Adjust position will  keep the dialog within the screen margin.
 *        minMargin: Integer. The number of pixels between the edge of the screen and the dialog. Defaults to 20.
 *        ignoreClasses: [] array of HTML classes to ignore clicks inside of so that the popdown does not close
 *        ignoreToggleMouseDown: true or false (default). Ignore mousedown events on the toggle or toggle's children. 
 *                              If ignoreToggleMouseDown is enabled, the PopTart will take no action when
 *                              clicking on the PopTart's toggle activator element. This allows the creator of the 
 *                              PopTart to fully manage closing the opened PopTart.
 *        ignoreEscape: true or false (default). Ignore escape keypress within the popdown.
 *
 *    Methods:
 *        show: show the dialog (directly calling show should be avoided and should not be necessary).
 *        hide: hide the dialog.
 *        scrollToVisible: scrolls the page if necessary to show the entire dialog.
 */


define('views/shared/delegates/PopdownDialog',[
    'jquery',
    'underscore',
    'views/shared/delegates/Base',
    'util/string_utils',
    'util/keyboard'
],function(
    $,
    _,
    DelegateBase,
    string_utils,
    keyboard
){
    return DelegateBase.extend({
        initialize: function() {
            var defaults = {
                arrow: ".arrow",
                mode: "dialog",  // "menu" or "dialog"
                adjustPosition: true,
                minMargin: 20,
                allowPopUp: true,
                direction:'auto',
                zIndex:'auto',
                scrollContainer: window,
                ignoreClasses: [],
                ignoreEscape: false
            };

            _.defaults(this.options, defaults);
            this.isShown = false;
            
            this.addEventHandlers = _.bind(this.addEventHandlers, this);
            this.dialogClick = _.bind(this.dialogClick, this);
            this.keepInBoundsDebounced =  _.debounce(this.keepInBounds, 100);

            // if this.$el doesn't already have an id, create a unique one (to be used in show())
            if (!this.$el.attr('id')) {
                this.$el.attr('id', 'dialog-' + this.cid);
            }
            
            if (this.options.show) {
                this.show(this.options.show);
            }
        },
        events: {
            'click': 'dialogClick',
            'keydown': function(e) {
                if (e.which === keyboard.KEYS.TAB) {
                    keyboard.handleCircularTabbing(this.$el, e);
                }
            },
            'keydown .close': function(e) {
                if (e.which === keyboard.KEYS.ENTER) {
                    //Prevent click event for anchor tags
                    e.preventDefault();
                    this.hide(e);
                }
            }
        },
        arrow: function() {
            return this.$el.find(this.options.arrow).first();
        },
        scrollContainer: function() {
            if (!this.$scrollContainer) {
                this.$scrollContainer = $(this.options.scrollContainer);
            }
            return this.$scrollContainer;
        },
        toggle: function($pointTo) {
            this.trigger('toggle', $pointTo);
            
            if (this.isShown) {
                this.hide();
            } else {
                this.show($pointTo);
            }
            
            this.trigger('toggled', $pointTo);

            return true;
        },
        show: function($pointTo, $toggle) {
            $toggle = $toggle || $pointTo;
            this.trigger('show', $pointTo);

            this.$pointTo = $pointTo;
            
            if (!this.isShown) {
                _.defer(this.addEventHandlers, $toggle);
            }
            if (this.options.zIndex != 'auto') {
                this.$el.css('zIndex', this.options.zIndex);
            }

            this.options.adjustPosition && $pointTo && this.adjustPosition($pointTo);
            this.isShown = true;
            this.$el.addClass('open').show();
            // add a data attribute to map the toggle to the open dialog, this is for automated testing
            $pointTo.attr('data-dialog-id', this.$el.attr('id'));

            this.trigger('shown', $pointTo);
        },
        hide: function(e) {
            if (!this.isShown) {
                return false;
            }

            this.trigger('hide');

            this.removeEventHandlers();
            this.isShown = false;
            this.$el.removeClass('open').hide();

            this.trigger('hidden', e);
        },
        addEventHandlers: function($toggle) {
            $('html').on('mousedown.popdown.' + this.cid, function(e) {
                this.bodyMouseDown(e, $toggle);
            }.bind(this));
            $(window).on('keydown.' + this.cid, function(e) {
                this.windowKeydown(e, $toggle);
            }.bind(this));
            
            
            if (this.options.scrollContainer !== window) {
                this.scrollPosition = {top: this.scrollContainer().scrollTop(), left: this.scrollContainer().scrollLeft()};
                this.scrollContainer().on('scroll.' + this.cid, function(e) {
                    if (this.$pointTo) {
                        this.adjustPosition(this.$pointTo);
                    } else {
                        this.containerScroll(e);
                    }
                }.bind(this));
            }
            
            return this;
        },
        removeEventHandlers: function() {
            $('html').off('.' + this.cid);
            $(window).off('.' + this.cid);
            
            if (this.options.scrollContainer !== window) {
                this.scrollContainer().off('.' + this.cid);
            }
            
            return this;
        },
        deactivate: function() {
            this.hide();
            return DelegateBase.prototype.deactivate.apply(this, arguments);
        },
        stopListening: function() {
            this.removeEventHandlers();
            return DelegateBase.prototype.stopListening.apply(this, arguments);
        },
        measure: function($el, offsets) {
            var measures = {};
            
            measures.width = $el.outerWidth();
            measures.halfWidth = measures.width / 2;
            measures.height = $el.outerHeight();
            measures.halfHeight = measures.height /2;
            if (offsets !== false) {
                measures.offset = $el.offset();
                measures.position = $el.position();
                measures.center = {
                    left: measures.offset.left + measures.halfWidth,
                    top: measures.offset.top + measures.halfHeight
                };
            }
            return measures;
        },
        adjustPosition: function($pointTo) {
            var dir = this.options.direction;
            this['adjustPosition' + string_utils.capitalize(dir)]($pointTo);
        },
        adjustPositionAuto: function($pointTo) {
            this.$el.css({top: -9999, left: -9999, bottom: 'auto'});
            this.$el.show();
        
            var m = {}, //measurements
                shift = {left: 0, top:0}; //necessary corrections to fit in view
            var positionFromTop = true;
            
            m.toggle = this.measure($pointTo);
            m.dialog = this.measure(this.$el);
            m.arrow = this.measure(this.arrow(), false);
            m.window = this.measure($(window), false);
            m.window.top =  $(window).scrollTop();
            m.window.bottom = m.window.height + $(window).scrollTop();
            
            // Compensate for different offset parents.
            m.dialogParent = {offset: this.$el.offsetParent().offset()};
            m.toggle.relativeOffset = {
                                left: m.toggle.offset.left - m.dialogParent.offset.left + m.toggle.halfWidth,
                                top: Math.floor(m.toggle.offset.top - m.dialogParent.offset.top)
                            };

            //Determine if the default centering need to be shifted left or right
            if (m.toggle.center.left < m.dialog.halfWidth + this.options.minMargin) { //Needs to be pushed right
                shift.left = (m.dialog.halfWidth - m.toggle.center.left) + this.options.minMargin;
            } else if (m.toggle.center.left + m.dialog.halfWidth + this.options.minMargin  > m.window.width) { //Needs to be pushed left
                shift.left = m.window.width - (m.toggle.center.left + m.dialog.halfWidth + this.options.minMargin);
            }
            shift.left=Math.round(shift.left);
            
            // Determine if there is enough room to pop down
            var popDownDialogBottom =  m.toggle.offset.top + m.toggle.height + m.dialog.height + this.options.minMargin;
            var popUpDialogTop =  m.toggle.offset.top - m.dialog.height -  this.options.minMargin;
            if (popDownDialogBottom > m.window.bottom && this.options.allowPopUp && popUpDialogTop > m.window.top ) {
                //Pop upward
                shift.top=-m.dialog.height - m.arrow.halfWidth;
                shift.bottom= m.toggle.height + m.arrow.halfWidth;
                this.$el.addClass('up');
                
                //If this hasn't been attached the body or some other element, set positionFromTop to false. It will be positioned from the bottom.
                //It's better to position from the bottom so dialogs that change height, like the timerangepicker, are correctly positioned.
                positionFromTop = this.options.attachDialogTo || this.$el.parent()[0] == $('body')[0] || this.$el.parent()[0] == $('.modal:visible')[0];
            } else {
                //Pop downward
                shift.top= m.toggle.height;
                this.$el.removeClass('up');
                if (popDownDialogBottom > m.window.bottom) {
                    //Scroll
                    this.scrollContainer().scrollTop(this.scrollContainer().scrollTop() + popDownDialogBottom - m.window.bottom);
                    
                    //reset the relative offsets
                    m.toggle.offset = $pointTo.offset();
                    m.toggle.relativeOffset.top = m.toggle.offset.top - m.dialogParent.offset.top;
                }
            }
            
            //Reset the position and center within the viewable area
            this.position = {
                 top:  positionFromTop ? shift.top + m.toggle.relativeOffset.top : 'auto',
                 left: m.toggle.relativeOffset.left,
                 marginLeft: - m.dialog.halfWidth + shift.left,
                 bottom: positionFromTop ? 'auto' : shift.bottom 
                };
            
            this.$el.css(this.position);
            this.arrow().css('marginLeft', 0 - m.arrow.halfWidth - shift.left);

            //Fix left corner rounding if necessary
            if (m.dialog.halfWidth - m.arrow.halfWidth - shift.left < 8) { //Falling off the left
                this.$el.css('borderTopLeftRadius', Math.max(m.dialog.halfWidth - m.arrow.halfWidth - shift.left, 0));
            } else { //Needs to be pushed left
                this.$el.css('borderTopLeftRadius', '');
            }

        },
        adjustPositionRight: function($pointTo) {
            this.$el.addClass('right');
            this.$el.css({top: -9999, left: -9999});
            this.$el.show();
        
            var m = {}, //measurements
                shift = {left: 0, top:0}, //necessary corrections
                calculateTop = function() {
                    return Math.round(shift.top) + m.toggle.relativeOffset.top - m.dialog.halfHeight + m.toggle.halfHeight;
                }.bind(this); 
            
            m.toggle = this.measure($pointTo);
            m.dialog = this.measure(this.$el);
            m.arrow = this.measure(this.arrow(), false);
            m.window = this.measure($(window), false);
            m.window.top =  $(window).scrollTop();
            m.window.bottom = m.window.height + $(window).scrollTop();
            m.arrow.minMargin = 10;
            m.arrow.maxShift = m.dialog.halfHeight - m.arrow.halfHeight - m.arrow.minMargin;
            
            // Compensate for different offset parents.
            m.dialogParent = {offset: this.$el.offsetParent().offset()};
            m.toggle.relativeOffset = {
                                left: m.toggle.offset.left - m.dialogParent.offset.left + m.toggle.width,
                                top: Math.floor(m.toggle.offset.top - m.dialogParent.offset.top)
                            };

            //Determine if the default centering need to be shifted up or down
            if (m.toggle.center.top - m.window.top < m.dialog.halfHeight + this.options.minMargin) { //Needs to be down
                shift.top = (m.dialog.halfHeight - (m.toggle.center.top - m.window.top)) + this.options.minMargin;
            } else if (m.toggle.center.top + m.dialog.halfHeight+ this.options.minMargin  > m.window.bottom ) { //Needs to be pushed up
                shift.top = m.window.bottom - (m.toggle.center.top + m.dialog.halfHeight + this.options.minMargin);
            }
            
            //Make sure it's not partially hidden over the top of page
            if (calculateTop() < this.options.minMargin) {
                shift.top = shift.top + (this.options.minMargin - calculateTop());
            }
            
            //Determine if there is sufficient room to include the point
            if (shift.top > m.arrow.maxShift) { //Needs to be down
                shift.top -= shift.top - m.arrow.maxShift;
            } else if (-shift.top > m.arrow.maxShift) { //Needs to be pushed up
                shift.top -= shift.top+m.arrow.maxShift;
            }
            
            //Reset the position and center within the viewable area
            this.position = {
                 top: calculateTop(),
                 left: m.toggle.relativeOffset.left, marginLeft: m.arrow.halfWidth
                };
                
            
            this.$el.css(this.position);
            this.arrow().css('marginTop', 0 - m.arrow.halfHeight - shift.top);

        },
        containerScroll: function(e)  {
            var newScrollTop = this.scrollContainer().scrollTop(),
                newScrollLeft = this.scrollContainer().scrollLeft();
                
            this.position.top = this.position.top + (this.scrollPosition.top - newScrollTop);
            this.position.left = this.position.left + (this.scrollPosition.left  - newScrollLeft);
            this.$el.css(this.position);
                            
            this.scrollPosition = {top: newScrollTop, left: newScrollLeft};
            this.keepInBoundsDebounced();
        },
        keepInBounds: function(e)  {
            // if it is no longer pointing at something shown in the view container, close;
            var containerTop = this.scrollContainer().offset().top,
                containerBottom  = containerTop + this.scrollContainer().outerHeight(),
                elEdge = this.$el.hasClass('up') ? this.$el.offset().top + this.$el.outerHeight() : this.$el.offset().top; // use the bottom edge when popping upward
                
            if (elEdge < containerTop || elEdge > containerBottom) {
                this.hide();
            }
            
        },
        bodyMouseDown: function(e, $toggle) {
            var $target = $(e.target);
            
            // If the menu is already closed, don't do anything.
            if (!this.isShown) {
                return;
            }

            // Ignore clicks on the toggle or toggle's children.
            if (this.options.ignoreToggleMouseDown && $toggle && (($target[0] === $toggle[0]) || $toggle.has($target).length)) {
                return;
            }

            // Ignore clicks inside of the dialog
            if ($.contains(this.$el[0], e.target) || e.target === this.$el[0]) {
                return;
            }
            
            //Ignore clicks on elements with classes specified in this.options.ignoreClasses
            for(var i = 0; i < this.options.ignoreClasses.length; i++){
                if ($target.closest("." + this.options.ignoreClasses[i]).length) {
                    return;
                }
            }

            this.hide(e);
        },
        dialogClick: function(e) {
            if (this.options.mode != "dialog") {
                var $target = $(e.target);
                //Ignore clicks on elements with classes specified in this.options.ignoreClasses
                for(var i = 0; i < this.options.ignoreClasses.length; i++){
                    if ($target.closest("." + this.options.ignoreClasses[i]).length) {
                        return;
                    }
                }
                this.hide(e);
            }
        },
        windowKeydown: function(e, $toggle) {
            var escapeKeyCode = 27,
                enterKeyCode = 13;
            
            if (!this.options.ignoreEscape && e.keyCode == escapeKeyCode)  {
                this.hide();
                return true;
            }
            
            if (e.keyCode == enterKeyCode)  {
                this.bodyMouseDown(e, $toggle);
            }
            
            return true;
        },
        pointTo: function($pointTo) {
            if (!this.isShown) {
                this.show($pointTo);
            } else {
                this.adjustPosition($pointTo);
            }
        }
    });
});

/**
 *   views/shared/delegates/Popdown
 *
 *   Desc:
 *     This class applies popdown menus and dialogs.

 *   @param {Object} (Optional) options An optional object literal having one settings.
 *
 *    Usage:
 *       var p = new Popdown({options})
 *
 *    Options:
 *        el (required): The dialog and toggle container. Recommend that this is the offset container for the dialog.
 *        toggle: jQuery selector for the toggles defaults to "> .popdown-toggle, > dropdown-toggle".
 *        dialog: jQuery selector or object for the dialog defaults to "> .popdown-dialog,  > dropdown-menu".
 *        arrow: jQuery selector or object for arrow that points up. Defaults to ".arrow".
 *        mode: menu (default) or dialog. Change to dialog to prevent clicks inside the dialog from closing the popdown.
 *        show: true or false (default). Open the menu on initialization.
 *        adjustPosition: true (default) or false. Adjust position will  keep the dialog within the screen margin.
 *        minMargin: Integer. The number of pixels between the edge of the screen and the dialog. Defaults to 20.
 *        attachDialogTo: jQuery selector or object to attach the dialog element to, usually 'body'
 *                          this can be useful to avoid hidden overflow issues, but should be used with care since any
 *                          scoped CSS selectors or event delegate listeners will no longer work *
 *        ignoreClasses: [] array of HTML classes to ignore clicks inside of so that the popdown does not close
 *        ignoreEscape: true or false (default). Ignore escape keypress within the popdown.
 *
 *    Methods:
 *        show: show the dialog (directly calling show should be avoided and should not be necessary).
 *        hide: hide the dialog.
 *        scrollToVisible: scrolls the page if necessary to show the entire dialog.
 */


define('views/shared/delegates/Popdown',[
    'jquery',
    'underscore',
    'views/shared/delegates/Base',
    'views/shared/delegates/PopdownDialog'
],function(
    $,
    _,
    DelegateBase,
    PopdownDialog
){
    return DelegateBase.extend({
        initialize: function() {
            var defaults = {
                toggle: "> .popdown-toggle, > .dropdown-toggle",
                dialog: "> .popdown-dialog, > .dropdown-menu",
                arrow: ".arrow",
                mode: "menu",  // "menu" or "dialog"
                adjustPosition: true,
                minMargin: 20,
                attachDialogTo: false,
                allowPopUp: true,
                scrollContainer: window,
                ignoreClasses: [],
                ignoreEscape: false
            };

            _.defaults(this.options, defaults);

            this.children = {};
            this.events = {};
            this.events["mousedown " + this.options.toggle] = "toggle";
            this.events["keydown " + this.options.toggle] = "keydownToggle";
            this.events["click " + this.options.toggle] = "clickToggle";
            this.delegateEvents(this.events);
            this.$activeToggle = this.$(this.options.toggle).first();

            if (this.options.show) {
                this.show();
            }
        },
        startListening: function(options) {
            if (this.children.delegate) {
                this.listenTo(this.children.delegate, 'toggle', this.hearToggle);
                this.listenTo(this.children.delegate, 'toggled', this.hearToggled);
                this.listenTo(this.children.delegate, 'show', this.hearShow);
                this.listenTo(this.children.delegate, 'shown', this.hearShown);
                this.listenTo(this.children.delegate, 'hide', this.hearHide);
                this.listenTo(this.children.delegate, 'hidden', this.hearHidden);
            }
        },
        delegate: function() {
            if (!this.children.delegate) {
                var options = $.extend(true, {}, this.options);
                options.el = (options.dialog instanceof $) ? options.dialog[0] : this.$(options.dialog)[0];
                
                if (_.isString(options.scrollContainer)) {                
                    options.scrollContainer = this.$activeToggle.closest(options.scrollContainer);
                }
                               
                this.children.delegate = new PopdownDialog(options);

                this.startListening();

                if (options.attachDialogTo) {
                    $(options.attachDialogTo).append(this.children.delegate.el);
                }
            }
            return this.children.delegate;
        },
        toggle: function(e) {
            e.preventDefault();

            if ($(e.currentTarget).is('.disabled, :disabled')) return;

            this.delegate().toggle($(e.currentTarget));

            return true;
        },
        hearToggle: function($toggle) {
            this.trigger('toggle', $toggle);
        },
        hearToggled: function($toggle) {
            this.trigger('toggled', $toggle);
        },
        show: function() {
            this.delegate().show(this.$activeToggle);
        },
        hearShow: function($toggle) {
            this.trigger('show', $toggle);

            $(window).on('resize.popdown.' + this.cid, this.windowResize.bind(this));
            this.$activeToggle.removeClass('active');
            this.$activeToggle = $toggle.addClass('active');
   
        },
        hearShown: function($toggle) {
            // Need to enable focus here so the list items are tabbable (508).
            // Consumers can listen to 'shown' on the popdown to trigger a more specific focus if they need.
            this.delegate().$el.find('a:not(.disabled):first').focus();
            this.trigger('shown', $toggle);
        },
        hide: function(e) {
            if (!this.delegate().isShown) return false;

            $(window).off('.' + this.cid);

            this.$activeToggle.removeClass('active');

            if ($.contains(this.children.delegate.el, $(':focus')[0])) {
                this.$activeToggle.focus();
            }
            this.children.delegate.hide();
        },
        clickToggle: function(e) {
            e.preventDefault();
        },
        keydownToggle: function(e) {
            var enterKeyCode = 13;
            if (e.keyCode == enterKeyCode)  {
                this.toggle(e);
            }
        },
        hearHide: function($toggle) {
            $(window).off('.popdown.' + this.cid);
            this.trigger('hide', $toggle);

            this.$activeToggle.removeClass('active');
        },
        hearHidden: function($toggle) {
            this.trigger('hidden', $toggle);
        },
        stopListening: function() {
            this.children.delegate && this.children.delegate.remove();
            return DelegateBase.prototype.stopListening.apply(this, arguments);
        },
        adjustPosition: function() {
            this.delegate();
            this.children.delegate.adjustPosition(this.$activeToggle);
        },
        windowResize: function(e) {
            if (this.children.delegate && this.children.delegate.isShown) {
                this.adjustPosition(this.$activeToggle);
            }
        },
        pointTo: function($activeToggle) {
            this.$activeToggle = $activeToggle;
            this.delegate().adjustPosition(this.$activeToggle);
        },
        remove: function() {
            DelegateBase.prototype.remove.apply(this);
            this.children.delegate && this.children.delegate.remove();
            if (this.children.delegate && this.options.attachDialogTo) {
                this.children.delegate.$el.remove();
            }
            delete this.children.delegate;
            $(window).off('resize.popdown.' + this.cid);
            $(window).off('.' + this.cid);
            this.undelegateEvents();
            return this;
        }
    });
});


define('contrib/text!views/shared/splunkbar/AppMenu.html',[],function () { return '<%\n    currentAppname = currentApp ? currentApp.name : \'search\';   // TODO: search fallback is not always safe assumption\n%>\n<a href="#" class="dropdown-toggle"><%- currentApp ? _(\'App: \').t() + _(currentApp.label).t() : _(\'Apps\').t() %><b class="caret"></b></a>\n<div class="dropdown-menu dropdown-menu-selectable dropdown-menu-tall" id="global-apps-menu">\n    <div class="arrow"></div>\n    <ul class="menu-list">\n        <% _.each(apps, function(i) { %>\n        <li>\n            <a href="<%- i.href %>">\n                <% if (currentApp && i.name === currentApp.name) { %> <i class="icon-check"></i><% } %>\n                <% if (i.icon) { %> <img data-icosrc="<%-i.icon%>" alt="menu icon" class="menu-icon" style="display:none;"><% } %>\n                <span class="menu-label"><%- _(i.label).t() %></span>\n            </a>\n        </li>\n        <% }); %>\n    </ul>\n    <ul>\n        <li><a href="<%- make_url(\'manager\', currentAppname, \'apps\',\'local\') %>"><%- _("Manage Apps").t() %></a></li>\n        <% if(canManageRemoteApps){ %>\n        <li id="findMoreAppsNav"><a href="<%= appsRemote_url %>" ><%- _("Find More Apps").t() %></a></li>\n        <%} %>\n    </ul>\n</div>\n';});

define(
    'uri/route',['jquery', 'underscore', 'splunk.util', 'util/splunkd_utils', 'splunk.config', 'util/console'],
    function($, _, splunkutil, splunkdUtils, splunkConfig, console)
{
    var exports = {};
    exports.encodeRoot = function(path, locale) {
        if (splunkConfig.INDEPENDENT_MODE) {
            console.warn('route: Trying to generate URL in independent mode when URL structure is unknown');
        }

        var parts = _.map((path || '').split('/'), function(part) {
            return encodeURIComponent(part);
        });
        path = parts.join('/');
        path = path ? '/' + path : path;
        return path + '/' + encodeURIComponent(locale);
    };
    exports.alertActionIconFile = function(root, locale, appName, options) {
        options = options || {};
        if (options.file) {
            if (appName === 'system') {
                return exports.img(root, locale, undefined, options.file);
            }
            return exports.appStaticFile(root, locale, appName, options.file);
        } else {
            return exports.img(root, locale, undefined, 'mod_alert_icon_default.png');
        }
    };
    exports.appStaticFile = function(root, locale, appName, file) {
        return exports.encodeRoot(root, locale) + '/static/app/' + encodeURIComponent(appName) + '/' + file;
    };
    exports.staticFile = function(root, locale, version, file) {
        return exports.encodeRoot(root,  locale)  + '/static/' + encodeURIComponent(version) + '/' + encodeURIComponent(file);
    };
    exports.img = function(root, locale, version, file) {
        var url = exports.encodeRoot(root,  locale)  + '/static/';
        if (!_.isUndefined(version) && !_.isNull(version)) {
            url += encodeURIComponent(version) + '/';
        }
        url += 'img/' + encodeURIComponent(file);
        return url;
    };
    exports.page = function(root, locale, app, page, options) {
        if(typeof page === 'undefined'){
            page = '';
        }
        var url = exports.encodeRoot(root, locale) + '/app/' + encodeURIComponent(app);
            if (_.isArray(page)) {
            _.each(page, function(dir) {
                url += '/' + encodeURIComponent(dir);
            });
        } else {
            url += '/' + encodeURIComponent(page);
        }
        if (options) {
            if (options.data) {
                url = url + '?' + splunkutil.propToQueryString(options.data);
            }
            if (options.absolute) {
                url = window.location.protocol + "//" + window.location.host + url;
            }
        }
        return url;
    };
    exports.appIcon = function(root, locale, owner, app, options){
        options = options || {}; 
        var size = '';
        if((window && window.devicePixelRatio > 1) || options.hiRes) {
            size = '_2x';
        }
        return exports.splunkdNS(root, locale, owner, app, 'static/appIcon'+size+'.png', options);
    };
    exports.appIconAlt = function(root, locale, owner, app, options){
        var size = '';
        if(window && window.devicePixelRatio > 1){
            size = '_2x';
        }
        return exports.splunkdNS(root, locale, owner, app, 'static/appIconAlt'+size+'.png', options);
    };
    exports.appLogo = function(root, locale, owner, app, options){
        var size = '';
        if(window && window.devicePixelRatio > 1){
            size = '_2x';
        }
        return exports.splunkdNS(root, locale, owner, app, 'static/appLogo'+size+'.png', options);
    };
    exports.fileExplorer = function(root, locale, owner, app, options){
        return exports.splunkdNS(root, locale, owner, app, 'admin/file-explorer', options);
    };
    exports.regExplorer = function(root, locale, owner, app, options){
        return exports.splunkdNS(root, locale, owner, app, 'admin/win-reg-explorer', options);
    };
    exports.adExplorer = function(root, locale, owner, app, options){
        return exports.splunkdNS(root, locale, owner, app, 'admin/win-ad-explorer', options);
    };
    exports.gettingStartedPlaceholderContent = function(root, locale, owner, app, options){
        return exports.splunkdNS(root, locale, owner, app, 'static/gettingStartedPlaceholder.png', options);
    };
    exports.chooseDashboardIcon = function(root, locale, owner, app, options){
        return exports.splunkdNS(root, locale, owner, app, 'static/chooseDashboardIcon.png', options);
    };
    exports.moreAppsIcon = function(root, locale, owner, app, options){
        return exports.splunkdNS(root, locale, owner, app, 'static/moreAppsIcon.png', options);
    };
    exports.splunkd = function(root, locale){
        return exports.encodeRoot(root, locale) + '/splunkd';
    };
    exports.splunkdRaw = function(root, locale){
        return exports.splunkd(root, locale) + '/__raw';
    };
    exports.splunkdNS = function(root, locale, owner, app, path){
        return exports.splunkdRaw(root, locale) + '/servicesNS/' + encodeURIComponent(owner) + '/' + encodeURIComponent(app) + '/' + path;
    };
    exports.indexingPreviewUpload = function(root, locale){
        return exports.splunkd(root, locale) + '/__upload/indexing/preview';
    };
    exports.receiversStream = function(root, locale){
        return exports.splunkd(root, locale) + '/__upload/receivers/stream';
    };
    exports.identicons = function(root, locale, value){
        return exports.encodeRoot(root, locale) + '/static/app/search/identicons/' + encodeURIComponent(value) + '.png';
    };
    exports.pivot = function(root, locale, app, options) {
        return exports.page(root, locale, app, 'pivot', options);
    };
    exports.data_model_manager = function(root, locale, app, options) {
        return exports.page(root, locale, app, 'data_model_manager', options);
    };
    exports.data_model_editor = function(root, locale, app, options) {
        return exports.page(root, locale, app, 'data_model_editor', options);
    };
    exports.field_extractor = function(root, locale, app, options) {
        return exports.page(root, locale, app, 'field_extractor', options);
    };
    exports.search = function(root, locale, app, options) {
        if (app === splunkdUtils.SYSTEM) {
            app = 'search';
        }
        return exports.page(root, locale, app, 'search', options);
    };
    exports.report = function(root, locale, app, options) {
        return exports.page(root, locale, app, 'report', options);
    };
    exports.reports = function(root, locale, app, options) {
        return exports.page(root, locale, app, 'reports', options);
    };
    exports.alert = function(root, locale, app, options) {
        return exports.page(root, locale, app, 'alert', options);
    };
    exports.alerts = function(root, locale, app, options) {
        return exports.page(root, locale, app, 'alerts', options);
    };
    exports.managementConsole = function(root, locale, options) {
        return exports.page(root, locale, 'splunk_management_console', 'managementconsole_overview', options);
    };
    exports.addData = function(root, locale, app, step, options) {
        // if app is not provided, default to search
        var page = step ? ["adddata", step] : 'adddata';
        return exports.manager(root, locale, app || "search", page, options);
    };
    exports.editDashboard = function(root, locale, app, name, options) {
        return exports.page(root, locale, app, [name, 'edit'], options);
    };
    exports.dashboardFromID = function(root, locale, id, options) {
        options = options || {};
        //owner[1]/app[0]/data[2]/ui[3]/views[4]/name[5]
        var parts = id.split('/').slice(-6);
        return this.page(root, locale, parts[1], parts[5], options);
    };
    exports.logout = function(root, locale) {
        return exports.encodeRoot(root, locale) + '/account/logout';
    };
    exports.proxyLogin = function(root, locale) {
        return exports.encodeRoot(root, locale) + '/account/login';
    };
    exports.returnTo = function(root, locale, url) {
        if (url.indexOf('/')===0) {
            return url.replace(/^(\/)+(\s)*(\/)/, '/');
        }
        return exports.encodeRoot(root, locale);
    };
    exports.embed = function(root, locale, embedToken, savedSearchId) {
        var url,
        data = {
            s: savedSearchId,
            oid: embedToken
        };
        if (splunkConfig.EMBED_URI) {
            url = splunkConfig.EMBED_URI + '/';
        } else {
            url = window.location.protocol + "//" + window.location.host + '/';
            if (root) {
                url += root + '/';
            }
        }
        return url + locale + '/embed?' + splunkutil.propToQueryString(data);
    };
    exports.jobInspector = function(root, locale, app, sid) {
        var data = {
            sid: sid,
            namespace: app
        };
        return exports.encodeRoot(root, locale) + '/search/inspector' + '?' + splunkutil.propToQueryString(data);
    };
    exports.manager = function(root, locale, app, page, options) {
        var url =  exports.encodeRoot(root, locale) + '/manager/' + encodeURIComponent(app);
        if (_.isArray(page)) {
            _.each(page, function(dir) {
                url += '/' + encodeURIComponent(dir);
            });
        } else {
            url += '/' + encodeURIComponent(page);
        }
        if (options) {
            if (options.data) {
                url = url + '?' + splunkutil.propToQueryString(options.data);
            }
        }
        return url;
    };
    exports.appSetupLink = function(root, locale, app, options) {
        options || (options = {});
        options.data = _.extend({ action: 'edit' }, options.data);
        var page = ['apps', 'local', app, 'setup'];
        return exports.manager(root, locale, app, page, options);
    };
    // HUNK routes
    exports.providers = function(root, locale, app, options) {
        options = options || {};
        _(options).defaults({data:{t:"providers"}});
        return exports.manager(root, locale, "system", "virtual_indexes", options);
    };
    exports.virtualIndexes = function(root, locale, app, options) {
        options = options || {};
        _(options).defaults({data:{t:"indexes"}});
        return exports.manager(root, locale, "system", "virtual_indexes", options);
    };
    exports.exploreData = function(root, locale, app, options) {
        options = options || {};
        return exports.manager(root, locale, "system", "explore_data", options);
    };
    exports.managerEdit = function(root, locale, app, page, id, options) {
        options = options || {};
        options = $.extend(true, {data: {action: 'edit', uri: id}}, options);
        return exports.manager(root, locale, app, page, options);
    };
    exports.managerPermissions = function(root, locale, app, page, id, options) {
        options || (options = {});
        var url =  exports.encodeRoot(root, locale) + '/manager/permissions/' + encodeURIComponent(app);
        url += '/' + _.chain([page]).flatten().map(encodeURIComponent).value().join('/');
        url += '/' + encodeURIComponent(id);
        if (options.data) {
            url = url + '?' + splunkutil.propToQueryString(options.data);
        }
        return url;
    };
    exports.triggeredAlerts = function(root, locale, app, options) {
        var url = exports.encodeRoot(root, locale) + '/alerts/' + encodeURIComponent(app);
        if (options) {
            if (options.data) {
                url = url + '?' + splunkutil.propToQueryString(options.data);
            }
        }
        return url;
    };
    exports.docSearch = function(locale, version, isFree, isTrial, search) {
        var base = 'http://docs.splunk.com/Special:SplunkSearch/docs',
            params = {
                locale: locale,
                versionNumber: version,
                license: isFree ? 'free' : 'pro',
                installType: isTrial ? 'trial' : 'prod',
                q: search
            };
        return base + '?' + splunkutil.propToQueryString(params);
    };
    exports.docHelp = function(root, locale, location) {
        locale = locale || splunkdUtils.DEFAULT_LOCALE;
        var url =  exports.encodeRoot(root, locale) + '/help',
            params = {
                location: location
            };
        return url + '?' + splunkutil.propToQueryString(params);
    };
    exports.docHelpInAppContext = function(root, locale, location, appName, appVersion, appAllowsDisable, appDocSectionOverride) {
        var url = exports.encodeRoot(root, locale) + '/help',
            params = {
                location: location
            };
            if (appAllowsDisable) {
                if (appDocSectionOverride) {
                    params.location = '[' + appDocSectionOverride + ']' + params.location;
                } else {
                    params.location = '[' + appName + ':' + appVersion + ']' + params.location;
                }
            }
        return url + '?' + splunkutil.propToQueryString(params);
    };
    exports.exportUrl = function(root, locale, sid, filename, format, limit, maxResults, count, isReport, options) {
        options = options || {};
        var resultType = isReport ? 'results' : 'event';
        var url = exports.encodeRoot(root, locale) + '/api/search/jobs/' + encodeURIComponent(sid) + '/' + resultType;
        var params = {
            isDownload: true,
            timeFormat: options.timeFormat || '%FT%T.%Q%:z',
            maxLines: 0,
            count: count,
            filename: filename || '',
            outputMode: format,
            'spl_ctrl-limit': limit,
            'spl_ctrl-count': maxResults
        };
        url += '?' + splunkutil.propToQueryString(params);
        return url;
    };
    exports.updateChecker = function(baseURL, isFree, versionNumber, checkerLocation, isTrial, guid, masterGuid) {
        var url,
            installType = (isTrial) ? 'trial' : 'prod',
            licenseType = (isFree) ? 'free' : 'pro';
        if (guid!==masterGuid) {
            installType += '_slave';
        }
        url = baseURL + licenseType + '/' +  encodeURIComponent(versionNumber) + '/' +  encodeURIComponent(checkerLocation) + '/' +  encodeURIComponent(installType) + '/basic';
        return url;
    };
    exports.answers = function() {
        return 'http://answers.splunk.com';
    };
    exports.getContextualPageRouter = function(applicationModel) {
        var root = applicationModel.get('root'),
            locale = applicationModel.get('locale'),
            app = applicationModel.get('app'),
            nonPageMethods = ['page', 'docSearch', 'docHelp', 'docHelpInAppContext', 'exportUrl', 'exportUrl', 'getContextualPageRouter', 'pageStart', 'encodeRoot', 'redirectTo'],
            routeNames = _(exports).chain().functions().difference(nonPageMethods),
            router = {};

        _(routeNames).each(function(route) {
            var routeFn = exports[route];
            router[route] = function() {
                var fullArgs = [root, locale, app].concat(_(arguments).toArray());
                return routeFn.apply(null, fullArgs);
            };
        });
        return router;
    };
    exports.appNavUrl = function(root, locale, app){
        return exports.encodeRoot(root,  locale)  + '/appnav/' + encodeURIComponent((app || ''));
    };
    exports.appsRemote = function(root, locale, app){
       return  exports.manager(root, locale, app, 'appsremote');
    };
    exports.splunkbaseApp = function(app) {
        return 'https://apps.splunk.com/app/' + encodeURIComponent(app); 
    };
    exports.appInstallRestart = function(root, locale, app){
        return exports.manager(root, locale, 'system', 'control') + '?return_to=' + encodeURIComponent('/en-US/app/' + app) + '&auto_restart=1';
    };
    exports.appSetup = function(root, locale, setuplink){
        return exports.encodeRoot(root,  locale)  + setuplink;
    };
    exports.viewStrings = function(root, locale, app, view){
        return exports.page(root, locale, app, view) + "/strings";
    };
    exports.prebuiltAppLink = function(root, locale, app, link) {
        /* properly sets up a URL for an /app/<app> link
         *  returns root/locale/app/link
         *  since link may contain a query string, it is not encoded
         *  example:
         *     root = /gadzooks, locale = en-US, app = search, link = search?tour=test
         *     return /gadzooks/en-US/search/search?tour=test
         */
        return exports.encodeRoot(root, locale) + '/app/' + encodeURIComponent(app) + '/' + link;
    };
    exports.home = function(root, locale) {
        /* our routing system routes /root/locale to the user's default app/default page
         * as we ship, this is launcher/home, but the user can override this
         * root and locale are accessible from application model
         */
        return exports.encodeRoot(root, locale);
    };
    /**
     * Redirects to a new url, optionally in a new tab.
     *
     * Intentionally forked from the redirect_to function in util.js, instead providing a redirect method
     * that is intended to consume a fully-formed URL like the ones generated by the other methods in this file.
     *
     * Correctly handles the case where we have an asynchronously generated URL that needs to open in a new tab.
     * The new tab is created synchronously (to avoid pop-up blockers) and given its location when the promise resolves.
     *
     * @param url {String or a promise resolving with a string} the URL to navigate to
     * @param useNewTab {Boolean}
     *
     */
    exports.redirectTo = function(url, useNewTab) {
        var target = useNewTab ? window.open() : window;
        target.focus();
        $.when(url)
            .done(function(newLocation) {
                target.location = newLocation;
            })
            .fail(function() {
                console.error('failed to open new URL: ' + url);
                console.error.apply(console, arguments);
                if(useNewTab) {
                    target.close();
                }
            });
    };
    exports.sourcetypeList = function(root, locale, app, options) {
        // if app is not provided, default to search
        return exports.manager(root, locale, app, 'sourcetypes', options);
    };
    exports.sourcetypeEdit = function(root, locale, app, id, options) {
        // if app is not provided, default to search
        return exports.sourcetypeList(root, locale, app, options) + '/'+id;
    };
    return exports;
});

define(
    'views/shared/splunkbar/AppMenu',[
        'jquery',
        'module',
        'views/Base',
        'views/shared/delegates/Popdown',
        'splunk.util',
        'contrib/text!views/shared/splunkbar/AppMenu.html',
        'uri/route'
    ],
    function(
        $,
        module,
        BaseView,
        Popdown,
        splunk_util,
        appsTemplate,
        route
    ){
        return BaseView.extend({
            moduleId: module.id,
            template: appsTemplate,
            tagName: 'li',
            className: 'dropdown menu-apps',
            initialize: function() {
                this.haveIcons = false;
                BaseView.prototype.initialize.apply(this, arguments);

                if(this.options.activeMenu && this.options.activeMenu.name === 'app'){
                    this.currentApp = this.model.application.get('app');
                }
                this.collection.apps.on('ready change reset', this.debouncedRender, this);
                this.model.user.on('ready change', this.debouncedRender, this);
                // handle the case when collection.apps is already set
                if (this.collection.apps.length > 0) {
                    this.debouncedRender();
                }
            },
            render: function() {
                this.haveIcons = false;
                var that = this,
                    app,
                    curApp = null,
                    apps = this.collection.apps.filter(function(app) {
                        return app.entry.content.get('show_in_nav');
                    }).map(function(model, key, list) {
                        var appIcon = route.appIconAlt(
                            that.model.application.get('root'),
                            that.model.application.get('locale'),
                            that.model.application.get('owner'),
                            model.entry.get('name')
                        );

                        app = {
                            href: splunk_util.make_url('/app/'+ model.entry.get('name')),
                            label: model.entry.content.get('label'),
                            name: model.entry.get('name'),
                            icon: appIcon
                        };
                        if(model.entry.get('name') === that.currentApp) {
                            curApp = app;
                        }
                        return app;
                    }),

                    html = this.compiledTemplate({
                        apps: apps,
                        currentApp: curApp,
                        make_url: splunk_util.make_url,
                        appsRemote_url: route.appsRemote(
                                this.model.application.get('root'),
                                this.model.application.get('locale'),
                                this.model.application.get('app')),
                        canManageRemoteApps: that.model.user.canManageRemoteApps()
                    });

                this.$el.html(html);
                this.popdown = new Popdown({el:this.$('#global-apps-menu').parent(), mode: 'dialog'});
                this.popdown.on('show', this.setIcons, this);
                return this;
            },
            setIcons: function() {
                if(this.haveIcons){
                    return;
                }
                this.haveIcons = true;
                var icons = this.$el.find('.menu-icon');
                icons.each(function(index, ico){
                    ico = $(ico);
                    ico.attr('src', ico.attr('data-icosrc')).show();
                });
            }
        });
    });


define('contrib/text!views/shared/splunkbar/SystemMenuSection.html',[],function () { return '<i class="icon icon-<%-this.model.get(\'icon\')%>"></i>\n<h5><%=this.model.get(\'label\')%></h5>\n<ul class="menu">\n    <% var addedItems = []; %>\n    <%_.each(this.model.get(\'items\'), function(item, i){ %>\n        <% if(_.indexOf(addedItems, item.entry.content.get(\'menu.label\')) === -1) {%>    \n            <li><a href="<%-item.get(\'url\')%>"><%-_(item.entry.content.get(\'menu.label\')).t() || _(item.entry.get(\'name\')).t() || \'\'%></a></li>\n            <% addedItems.push(item.entry.content.get(\'menu.label\')); %>\n        <%}%>\n    <%});%>\n</ul>\n';});

define('views/shared/splunkbar/SystemMenuSection',[
    'jquery',
    'underscore',
    'module',
    'views/Base',
    'contrib/text!views/shared/splunkbar/SystemMenuSection.html'
],
function(
    $,
    _,
    module,
    BaseView,
    systemMenuSectionTemplate
){
    return BaseView.extend({
        moduleId: module.id,
        template: systemMenuSectionTemplate,
        className: 'menu-section',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            var itemsArray = this.model.get('items');
            itemsArray.sort(function(a,b){
                return parseInt(a.get('order'), 10) - parseInt(b.get('order'), 10);
            });
        },
        render: function() {
            var html = this.compiledTemplate(this.model);
            this.$el.html(html);
            return this;
        }
    });
});
/**
 *   views/shared/delegates/StopScrollPropagation
 *
 *   Desc:
 *     This class prevents the user from scrolling the page when scrolling a div.

 *   @param {Object} (Optional) options An optional object literal having one settings.
 *
 *    Usage:
 *       var p = new StopScrollPropagation({options})
 *
 *    Options:
 *        el (required): The event delegate.
 *        selector: jQuery selector for the scrolling elements. If not provided, all mousewheel events in the el will not propagate.
 *
 */


define('views/shared/delegates/StopScrollPropagation',['jquery', 'underscore', 'views/shared/delegates/Base'], function($, _, DelegateBase) {
    return DelegateBase.extend({
        initialize: function(){
            var defaults = {
                selector: ""
            };
            _.defaults(this.options, defaults);

            this.events = {};
            this.events["mousewheel " + this.options.selector] = "mousewheel";
            this.events["DOMMouseScroll " + this.options.selector] = "mousewheel";
            this.delegateEvents(this.events);
        },
        mousewheel: function (e) {
            var delta = -e.originalEvent.wheelDelta || e.originalEvent.detail* 20;
            e.currentTarget.scrollTop += delta;
            e.stopPropagation();
            e.preventDefault();
        }

    });
});
/* ===================================================
 * bootstrap-transition.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#transitions
 * ===================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


  /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
   * ======================================================= */

  $(function () {

    $.support.transition = (function () {

      var transitionEnd = (function () {

        var el = document.createElement('bootstrap')
          , transEndEventNames = {
               'WebkitTransition' : 'webkitTransitionEnd'
            ,  'MozTransition'    : 'transitionend'
            ,  'OTransition'      : 'oTransitionEnd otransitionend'
            ,  'transition'       : 'transitionend'
            }
          , name

        for (name in transEndEventNames){
          if (el.style[name] !== undefined) {
            return transEndEventNames[name]
          }
        }

      }())

      return transitionEnd && {
        end: transitionEnd
      }

    })()

  })

}(window.jQuery);
define("bootstrap.transition", ["jquery"], function(){});

/* =========================================================
 * bootstrap-modal.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#modals
 * =========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */


!function ($) {

  "use strict"; // jshint ;_;


 /* MODAL CLASS DEFINITION
  * ====================== */

  var Modal = function (element, options) {
    this.options = options
    this.$element = $(element)
      .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)
  }

  Modal.prototype = {

      constructor: Modal

    , toggle: function () {
        return this[!this.isShown ? 'show' : 'hide']()
      }

    , show: function () {
        var that = this
          , e = $.Event('show')

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        this.isShown = true

        this.escape()

        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade')

          if (!that.$element.parent().length) {
            that.$element.appendTo(document.body) //don't move modals dom position
          }

          that.$element.show()

          if (transition) {
            that.$element[0].offsetWidth // force reflow
          }

          that.$element
            .addClass('in')
            .attr('aria-hidden', false)

          that.enforceFocus()

          transition ?
            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :
            that.$element.focus().trigger('shown')

        })
      }

    , hide: function (e) {
        e && e.preventDefault()

        var that = this

        e = $.Event('hide')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        this.escape()

        $(document).off('focusin.modal')

        this.$element
          .removeClass('in')
          .attr('aria-hidden', true)

        $.support.transition && this.$element.hasClass('fade') ?
          this.hideWithTransition() :
          this.hideModal()
      }

    , enforceFocus: function () {
        var that = this
        $(document).on('focusin.modal', function (e) {
          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
            that.$element.focus()
          }
        })
      }

    , escape: function () {
        var that = this
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keyup.dismiss.modal', function ( e ) {
            e.which == 27 && that.hide()
          })
        } else if (!this.isShown) {
          this.$element.off('keyup.dismiss.modal')
        }
      }

    , hideWithTransition: function () {
        var that = this
          , timeout = setTimeout(function () {
              that.$element.off($.support.transition.end)
              that.hideModal()
            }, 500)

        this.$element.one($.support.transition.end, function () {
          clearTimeout(timeout)
          that.hideModal()
        })
      }

    , hideModal: function () {
        var that = this
        this.$element.hide()
        this.backdrop(function () {
          that.removeBackdrop()
          that.$element.trigger('hidden')
        })
      }

    , removeBackdrop: function () {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
      }

    , backdrop: function (callback) {
        var that = this
          , animate = this.$element.hasClass('fade') ? 'fade' : ''

        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate

          this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
            .appendTo(document.body)

          this.$backdrop.click(
            this.options.backdrop == 'static' ?
              $.proxy(this.$element[0].focus, this.$element[0])
            : $.proxy(this.hide, this)
          )

          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

          this.$backdrop.addClass('in')

          if (!callback) return

          doAnimate ?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in')

          $.support.transition && this.$element.hasClass('fade')?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (callback) {
          callback()
        }
      }
  }


 /* MODAL PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.modal

  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('modal')
        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option]()
      else if (options.show) data.show()
    })
  }

  $.fn.modal.defaults = {
      backdrop: true
    , keyboard: true
    , show: true
  }

  $.fn.modal.Constructor = Modal


 /* MODAL NO CONFLICT
  * ================= */

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


 /* MODAL DATA-API
  * ============== */

  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this)
      , href = $this.attr('href')
      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())

    e.preventDefault()

    $target
      .modal(option)
      .one('hide', function () {
        $this.focus()
      })
  })

}(window.jQuery);

define("bootstrap.modal", ["jquery"], function(){});

define(
    'views/shared/Modal',[
        'jquery',
        'underscore',
        'views/Base',
        'views/shared/delegates/StopScrollPropagation',
        'util/keyboard',
        'bootstrap.transition',
        'bootstrap.modal'
    ],
    function($,
            _,
            Base,
            StopScrollPropagation,
            keyboard
            //bootstrap.transition
            //bootstrap.modal
            ) {
        var CLASS_NAME = 'modal fade',
            CLASS_MODAL_WIDE = 'modal-wide',
            HEADER_CLASS = 'modal-header',
            NON_SCROLLING_BODY_CLASS = 'modal-body',
            BODY_SCROLLING_CLASS = 'modal-body-scrolling',
            BODY_SCROLLING_SELECTOR = '.' + BODY_SCROLLING_CLASS,
            BODY_CLASS = 'modal-body ' + BODY_SCROLLING_CLASS,
            FOOTER_CLASS = 'modal-footer',
            HEADER_SELECTOR = "." + HEADER_CLASS,
            HEADER_TITLE_SELECTOR = HEADER_SELECTOR + " > h3",
            BUTTON_CLOSE_CLASS = 'close',
            BUTTON_CLOSE_SELECTOR = '.' + BUTTON_CLOSE_CLASS,
            LOADING_CLASS = "modal-loading",
            LOADING_SELECTOR = "." + LOADING_CLASS,
            LOADING_HORIZONTAL = '<div class="'+ LOADING_CLASS + '"></div>',
            BODY_SELECTOR = ".modal-body",
            BODY_FORM_SELECTOR = BODY_SELECTOR + " > div.form",
            FORM_HORIZONTAL = '<div class="form form-horizontal"></div>',
            FORM_HORIZONTAL_COMPLEX = '<div class="form form-horizontal form-complex"></div>',
            FORM_HORIZONTAL_JUSTIFIED = '<div class="form form-horizontal form-justified"></div>',
            FOOTER_SELECTOR = "." + FOOTER_CLASS,
            BUTTON_CANCEL = '<a href="#" class="btn cancel modal-btn-cancel pull-left" data-dismiss="modal">' + _('Cancel').t() + '</a>',
            BUTTON_CANCEL_PRIMARY = '<a href="#" class="btn btn-primary cancel modal-btn-primary modal-btn-cancel pull-left" data-dismiss="modal">' + _('Cancel').t() + '</a>',
            BUTTON_CLOSE = '<button type="button" class="' + BUTTON_CLOSE_CLASS + '" data-dismiss="modal" aria-hidden="true">&times;</button>',
            BUTTON_BACK = '<a href="#" class="btn back modal-btn-back">' + _('Back').t() + '</a>',
            BUTTON_SAVE = '<a href="#" class="btn btn-primary modal-btn-primary pull-right">' + _('Save').t() + '</a>',
            BUTTON_DONE = '<a href="#" class="btn btn-primary modal-btn-primary pull-right" data-dismiss="modal">' + _('Done').t() + '</a>',
            BUTTON_DELETE = '<a href="#" class="btn btn-primary modal-btn-delete modal-btn-primary">' + _('Delete').t() + '</a>',
            BUTTON_DELETE_SECONDARY = '<a href="#" class="btn modal-btn-delete pull-right">' + _('Delete').t() + '</a>',
            BUTTON_NEXT = '<a href="#" class="btn btn-primary modal-btn-primary">' + _('Next').t() + '</a>',
            BUTTON_CONTINUE = '<a href="#" class="btn modal-btn-continue pull-left" data-dismiss="modal">' + _('Continue Editing').t() + '</a>',
            TEMPLATE = '\
                <div class="' + HEADER_CLASS + '">\
                   ' + BUTTON_CLOSE + '\
                    <h3 class="modal-title">&nbsp;</h3>\
                </div>\
                <div class="' +  BODY_CLASS + '">\
                </div>\
                <div class="' + FOOTER_CLASS + '">\
                </div>\
            ';

        // non-exported constants
        var INPUT_SELECTOR = '.btn, input[type="text"], input[type="password"], textarea';

        return Base.extend({
                className: CLASS_NAME,
                attributes: {
                    style: 'display:none',
                    tabindex: -1
                },
                initialize: function() {
                    Base.prototype.initialize.apply(this, arguments);

                    var defaults = {
                        show: false,
                        keyboard: true,
                        backdrop: true
                    };
                    this.keydownEventCode = null;
                    this.keydownEventTarget = null;
                    this.$el.modal(_.extend({}, defaults, _.pick(this.options, ['backdrop', 'keyboard', 'show', 'remote'])));
                    this.shown = false;

                    //when the hidden event is triggered the modal destroys itself
                    if (this.options.onHiddenRemove) {
                        this.on('hidden', this.remove, this);
                    }
                },
                //if you extend this class and need your own events object then you need to declare it like:
                // $.extend({}, Modal.prototype.events, {
                events: {
                    'show': function(e) {
                        if (e.target !== e.currentTarget) return;
                        this.trigger("show");
                    },
                    'shown': function(e) {
                        if (e.target !== e.currentTarget) return;
                        this.shown = true;
                        // check for any text inputs inside the dialog, focus the first visible one
                        var $textInputs = this.$(INPUT_SELECTOR),
                            textInputsLength = $textInputs.length;
                        if(textInputsLength > 0) {
                            for(var i = 0; i < textInputsLength; i++) {
                                var $textInput = $($textInputs[i]);
                                if ($textInput.is(':visible') && $textInput.css('visibility') !== 'hidden') {
                                    $textInput.focus();
                                    break;
                                }
                            }
                        }
                        this.children.stopScrollPropagation = new StopScrollPropagation({el: this.el, selector: BODY_SCROLLING_SELECTOR});
                        this.trigger("shown");
                    },
                    'hide': function(e) {
                        if (e.target !== e.currentTarget) return;
                        this.trigger("hide");
                    },
                    'hidden': function(e) {
                        if (e.target !== e.currentTarget) return;
                        this.shown = false;
                        this.trigger("hidden");
                    },
                    'keydown': function(e) {
                        var keyCode = e.which;
                        this.keydownEventCode = e.which;
                        this.keydownEventTarget = e.target;

                        if (keyCode === keyboard.KEYS.TAB) {
                            keyboard.handleCircularTabbing(this.$el, e);
                        }
                    },
                    'keyup': function(e) {
                        var keyCode = e.which;
                        if (keyCode === keyboard.KEYS.ENTER && this.keydownEventCode === keyboard.KEYS.ENTER) {
                            var $target = $(e.target);

                            if(e.target !== this.keydownEventTarget && $(this.keydownEventTarget).is('input')  && $(this.keydownEventTarget).attr('type') === 'text')
                                $target = $(this.keydownEventTarget);

                            if ($target.is('input') && $target.attr('type') === 'text' && this.$el.find('.btn-primary:visible').length === 1) {
                                // if the currently focused element is any kind of text input,
                                // make sure to blur it so that any change listeners are notified
                                if ($target.is(INPUT_SELECTOR)) {
                                    $target.blur();
                                }
                                e.preventDefault();
                                this.keydownEventCode = null;
                                this.keydownEventTarget = null;
                                this.$el.find('.btn-primary:visible').click();
                            }
                        }
                    }
                },
                hide: function() {
                    this.$el.modal('hide');
                },
                show: function() {
                    this.$el.modal('show');
                },
                toggle: function() {
                    this.$el.modal('toggle');
                },
                remove: function() {
                    if (this.shown){
                        this.hide();
                    }
                    Base.prototype.remove.apply(this, arguments);
                }
            },
            {
                CLASS_NAME: CLASS_NAME,
                CLASS_MODAL_WIDE: CLASS_MODAL_WIDE,
                HEADER_CLASS: HEADER_CLASS,
                BODY_SCROLLING_CLASS: BODY_SCROLLING_CLASS,
                BODY_SCROLLING_SELECTOR: BODY_SCROLLING_SELECTOR,
                BODY_CLASS: BODY_CLASS,
                FOOTER_CLASS: FOOTER_CLASS,
                HEADER_SELECTOR: HEADER_SELECTOR,
                HEADER_TITLE_SELECTOR: HEADER_TITLE_SELECTOR,
                BUTTON_CLOSE_CLASS: BUTTON_CLOSE_CLASS,
                BUTTON_CLOSE_SELECTOR: BUTTON_CLOSE_SELECTOR,
                BODY_SELECTOR: BODY_SELECTOR,
                BODY_FORM_SELECTOR: BODY_FORM_SELECTOR,
                LOADING_CLASS: LOADING_CLASS,
                LOADING_SELECTOR: LOADING_SELECTOR,
                LOADING_HORIZONTAL: LOADING_HORIZONTAL,
                FOOTER_SELECTOR: FOOTER_SELECTOR,
                TEMPLATE: TEMPLATE,
                FORM_HORIZONTAL: FORM_HORIZONTAL,
                FORM_HORIZONTAL_COMPLEX: FORM_HORIZONTAL_COMPLEX,
                FORM_HORIZONTAL_JUSTIFIED: FORM_HORIZONTAL_JUSTIFIED,
                BUTTON_CANCEL: BUTTON_CANCEL,
                BUTTON_CANCEL_PRIMARY: BUTTON_CANCEL_PRIMARY,
                BUTTON_CLOSE: BUTTON_CLOSE,
                BUTTON_BACK: BUTTON_BACK,
                BUTTON_SAVE: BUTTON_SAVE,
                BUTTON_CONTINUE: BUTTON_CONTINUE,
                BUTTON_DELETE: BUTTON_DELETE,
                BUTTON_DELETE_SECONDARY: BUTTON_DELETE_SECONDARY,
                BUTTON_DONE: BUTTON_DONE,
                BUTTON_NEXT: BUTTON_NEXT
            }
        );
    }
);

define(
    'views/shared/splunkbar/SystemMenuModal',[
         'jquery',
         'underscore',
         'module',
         'views/Base',
         'views/shared/Modal',
         'uri/route'
     ],
     function($, _, module, Base, Modal, route) {
        return Modal.extend({
            moduleId: module.id,
            initialize: function() {
                Base.prototype.initialize.apply(this, arguments);
            },
            events: $.extend({}, Modal.prototype.events, {
                "click .modal-btn-primary": function(e) {
                    e.preventDefault();
                    this.submit();
                }
            }),
            render: function() {
                this.$el.html(Modal.TEMPLATE);
                this.$(Modal.HEADER_TITLE_SELECTOR).html(_("Show All Settings").t());
                this.$(Modal.BODY_SELECTOR).append(Modal.FORM_HORIZONTAL);

                this.$(Modal.BODY_SELECTOR).append(_('Because search head clustering is enabled, some sections of the settings menu are hidden. Do you wish to re-enable the full settings menu?').t());
                this.$(Modal.BODY_SELECTOR).append(_('<br><br>').t());
                this.$(Modal.BODY_SELECTOR).append(_('Note that system settings modified via re-enabled menus will not be replicated across your search head cluster.').t());
                this.$(Modal.BODY_SELECTOR).append(_('<br><br>').t());

                var docLink = route.docHelp(this.model.application.get("root"), this.model.application.get("locale"), 'manager.shclustering.settings.menu');
                this.$(Modal.BODY_SELECTOR).append('<a href="' + docLink + '" class="external" target="_blank">' + _('Learn more about configuration changes under search head clustering').t() + '</a>');

                this.$(Modal.FOOTER_SELECTOR).append(Modal.BUTTON_CANCEL);
                this.$(Modal.FOOTER_SELECTOR).append('<a href="#" class="btn btn-primary modal-btn-primary pull-right" data-dismiss="modal">' + _('Show').t() + '</a>');
                return this;
            },
            submit: function() {
                $.when(this.collection.managers.showMore()).then(function() {
                    this.collection.sections.reset();
                }.bind(this));
            }
        });
    }
);


define('contrib/text!views/shared/splunkbar/SystemMenu.html',[],function () { return '<a href="#" class="dropdown-toggle"><%- _("Settings").t() %><b class="caret"></b></a>\n<div class="popdown-dialog mega-menu" id="global-system-menu">\n    <div class="arrow"></div>\n    \n    <% if(userCanAddData || userCanExploreData || managementConsoleAvailable) { %>\n    <div class="mega-menu-sidebar">\n\t\t<% if(userCanAddData) { %>\n\t    \t<a href="<%= addDataURL %>" class="mega-menu-sidebar-bar-link">\n\t            <svg width="52px" height="52px" viewBox="0 0 52 52" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n\t                <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n\t                    <g id="AddData" sketch:type="MSLayerGroup" transform="translate(1.000000, 1.000000)">\n\t                        <path d="M50,25 C50,38.808 38.807,50 25,50 C11.193,50 0,38.808 0,25 C0,11.193 11.193,0 25,0 C38.807,0 50,11.193 50,25 L50,25 Z" id="Stroke-2" stroke="#65A637" stroke-width="2" sketch:type="MSShapeGroup"></path>\n\t                        <path d="M28.714,25.72 C28.908,25.914 28.908,26.233 28.714,26.427 L24.473,30.668 C24.278,30.863 23.96,30.863 23.766,30.668 L19.524,26.42 C19.329,26.225 19.33,25.907 19.525,25.714 L19.831,25.41 C20.027,25.216 20.346,25.217 20.54,25.411 L23.052,27.923 C23.246,28.117 23.405,28.051 23.406,27.776 L23.413,17.866 C23.413,17.591 23.638,17.366 23.913,17.366 L24.34,17.366 C24.615,17.366 24.84,17.591 24.84,17.866 L24.833,27.776 C24.833,28.051 24.992,28.117 25.186,27.923 L27.698,25.411 C27.892,25.217 28.21,25.217 28.405,25.411 L28.714,25.72" id="Fill-4" fill="#65A637" sketch:type="MSShapeGroup"></path>\n\t                        <path d="M24,11 C17.3722529,11 12,12.5669725 12,14.5 C12,16.4330275 17.3722529,18 24,18 C30.6277471,18 36,16.4330275 36,14.5 C36,12.5669725 30.6277471,11 24,11 Z M35,14.4994903 C35,15.8807339 30.0760127,17 24.0005046,17 C17.9249966,17 13,15.8807339 13,14.4994903 C13,13.1192661 17.9249966,12 24.0005046,12 C30.0760127,12 35,13.1192661 35,14.4994903 Z" id="Path" fill="#65A637" sketch:type="MSShapeGroup"></path>\n\t                        <path d="M13.0000071,34.0049738 C13.0000024,34.0038246 13,34.0026752 13,34.0015257 C13.0257725,33.9752197 35,34.0015257 35,34.0015257 C35,34.0033372 34.9999941,34.0051484 34.9999824,34.0069591 C35.6381395,34.0050728 36.0014311,34.0027682 36,34 C36,36.210102 30.6277471,38 24,38 C17.3722529,38 12,36.210102 12,34 C12.0013058,34.0017685 12.3642568,34.0034414 13.0000071,34.0049738 Z M13.0000071,34.0049738 C13.0068329,35.6606217 17.9292108,37.002 24.0005046,37.002 C30.0693715,37.002 34.9892338,35.6616939 34.9999824,34.0069591 C31.09585,34.0184994 16.9041198,34.0143844 13.0000071,34.0049738 Z" id="Fill-7" fill="#65A637" sketch:type="MSShapeGroup"></path>\n\t                        <rect id="Rectangle-1" fill="#65A637" sketch:type="MSShapeGroup" x="12" y="14.5" width="1" height="19.5"></rect>\n\t                        <rect id="Rectangle-2" fill="#65A637" sketch:type="MSShapeGroup" x="35" y="14.5" width="1" height="19.5"></rect>\n\t                    </g>\n\t                </g>\n\t            </svg>\n\t            <%- _("Add Data").t() %>\n\t        </a>\n\t\t<% } %>\n\n        <% if(userCanExploreData) { %>\n        <a href="<%= exploreDataURL %>" class="mega-menu-sidebar-bar-link">\n            <svg width="52px" height="52px" viewBox="0 0 52 52" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n                <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n                    <g id="AddData" sketch:type="MSLayerGroup" transform="translate(1.000000, 1.000000)">\n                        <path d="M50,25 C50,38.808 38.807,50 25,50 C11.193,50 0,38.808 0,25 C0,11.193 11.193,0 25,0 C38.807,0 50,11.193 50,25 L50,25 Z" id="Stroke-2" stroke="#65A637" stroke-width="2" sketch:type="MSShapeGroup"></path>\n                        <path transform="translate(13.00000, 17.500000)"  d="M8.77311574,5.419 C7.96336667,5.3545 7.15461852,5.263 6.34937361,5.1435 L6.34937361,6.583 C7.15461852,6.702 7.96336667,6.794 8.77311574,6.8585 L8.77311574,5.419 L8.77311574,5.419 Z M1.56644907,7.696 C1.04146343,7.543 0.518980093,7.3775 0,7.2 L0,8.64 C0.518980093,8.818 1.04146343,8.983 1.56644907,9.136 L1.56644907,7.696 L1.56644907,7.696 Z M6.34937361,8.743 C5.5441287,8.6235 4.74188657,8.4765 3.94414861,8.3025 L3.94414861,9.7425 C4.74188657,9.917 5.5441287,10.064 6.34937361,10.1835 L6.34937361,8.743 L6.34937361,8.743 Z M18.4825977,8.4675 C15.2801352,9.092 12.0136134,9.276 8.77311574,9.0185 L8.77311574,10.459 C12.0136134,10.716 15.2801352,10.5325 18.4825977,9.908 L18.4825977,8.4675 L18.4825977,8.4675 Z M23.2259856,7.2 C22.4472653,7.4665 21.6615384,7.705 20.8703065,7.9165 L20.8703065,9.3565 C21.6615384,9.1455 22.4472653,8.9065 23.2259856,8.64 L23.2259856,7.2 L23.2259856,7.2 Z M23.2259856,3.6005 C21.9282852,4.044 20.6110667,4.4115 19.2813366,4.7025 L19.2813366,6.142 C20.6110667,5.851 21.9282852,5.4835 23.2259856,5.04 L23.2259856,3.6005 L23.2259856,3.6005 Z M16.8761116,5.1435 C14.9973736,5.422 13.1016199,5.5505 11.2068671,5.529 L11.2068671,6.9685 C13.1016199,6.99 14.9973736,6.8615 16.8761116,6.583 L16.8761116,5.1435 L16.8761116,5.1435 Z M23.2259856,14.401 C21.4088046,15.0225 19.5545894,15.494 17.6803556,15.8155 L17.6803556,17.2555 C19.5545894,16.934 21.4088046,16.4625 23.2259856,15.841 L23.2259856,14.401 L23.2259856,14.401 Z M15.2621185,16.146 C10.1398801,16.6695 4.9320625,16.088 0,14.401 L0,15.841 C4.9320625,17.528 10.1398801,18.11 15.2621185,17.5865 L15.2621185,16.146 L15.2621185,16.146 Z M23.2259856,0 C21.4088046,0.6215 19.5545894,1.093 17.6803556,1.4145 L17.6803556,2.8545 C19.5545894,2.533 21.4088046,2.0615 23.2259856,1.44 L23.2259856,0 L23.2259856,0 Z M15.2621185,1.745 C13.9138713,1.8825 12.560119,1.944 11.2068671,1.9285 L11.2068671,3.369 C12.560119,3.384 13.9138713,3.323 15.2621185,3.185 L15.2621185,1.745 L15.2621185,1.745 Z M8.77311574,1.8185 C5.80286806,1.5825 2.8551412,0.9765 0,0 L0,1.44 C2.8551412,2.4165 5.80286806,3.023 8.77311574,3.2585 L8.77311574,1.8185 L8.77311574,1.8185 Z M3.94414861,4.7025 C2.61491898,4.4115 1.29770046,4.044 0,3.6005 L0,5.04 C1.29770046,5.484 2.61491898,5.851 3.94414861,6.142 L3.94414861,4.7025 L3.94414861,4.7025 Z M5.54512963,12.215 C3.6713963,11.8935 1.81718102,11.422 0,10.8005 L0,12.241 C1.81718102,12.862 3.6713963,13.334 5.54512963,13.655 L5.54512963,12.215 L5.54512963,12.215 Z M12.0191185,12.7295 C10.6658667,12.7445 9.31161389,12.6835 7.96386713,12.5455 L7.96386713,13.986 C9.31161389,14.1235 10.6658667,14.185 12.0191185,14.1695 L12.0191185,12.7295 L12.0191185,12.7295 Z M14.4523694,14.0595 L14.4523694,12.619 C17.4226171,12.3835 20.370344,11.777 23.2259856,10.8005 L23.2259856,12.241 C20.370344,13.2175 17.4226171,13.8235 14.4523694,14.0595 Z" id="Imported-Layers" fill="#65A637" sketch:type="MSShapeGroup"></path>\n                        <path d="M24,11 C17.3722529,11 12,12.5669725 12,14.5 C12,16.4330275 17.3722529,18 24,18 C30.6277471,18 36,16.4330275 36,14.5 C36,12.5669725 30.6277471,11 24,11 Z M35,14.4994903 C35,15.8807339 30.0760127,17 24.0005046,17 C17.9249966,17 13,15.8807339 13,14.4994903 C13,13.1192661 17.9249966,12 24.0005046,12 C30.0760127,12 35,13.1192661 35,14.4994903 Z" id="Path" fill="#65A637" sketch:type="MSShapeGroup"></path>\n                        <path d="M13.0000071,34.0049738 C13.0000024,34.0038246 13,34.0026752 13,34.0015257 C13.0257725,33.9752197 35,34.0015257 35,34.0015257 C35,34.0033372 34.9999941,34.0051484 34.9999824,34.0069591 C35.6381395,34.0050728 36.0014311,34.0027682 36,34 C36,36.210102 30.6277471,38 24,38 C17.3722529,38 12,36.210102 12,34 C12.0013058,34.0017685 12.3642568,34.0034414 13.0000071,34.0049738 Z M13.0000071,34.0049738 C13.0068329,35.6606217 17.9292108,37.002 24.0005046,37.002 C30.0693715,37.002 34.9892338,35.6616939 34.9999824,34.0069591 C31.09585,34.0184994 16.9041198,34.0143844 13.0000071,34.0049738 Z" id="Fill-7" fill="#65A637" sketch:type="MSShapeGroup"></path>\n                        <rect id="Rectangle-1" fill="#65A637" sketch:type="MSShapeGroup" x="12" y="14.5" width="1" height="19.5"></rect>\n                        <rect id="Rectangle-2" fill="#65A637" sketch:type="MSShapeGroup" x="35" y="14.5" width="1" height="19.5"></rect>\n                    </g>\n                </g>\n            </svg>\n            <%- _("Explore Data").t() %>\n        </a>\n        <% } %>\n\t\t\n\t\t<% if(managementConsoleAvailable) { %>\n\t    \t<a href="<%= managementConsoleURL %>" class="mega-menu-sidebar-bar-link">\n\t            <svg width="52px" height="52px" viewBox="0 0 52 52" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n\t                <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n\t                    <path d="M51,26 C51,39.808 39.807,51 26,51 C12.193,51 1,39.808 1,26 C1,12.193 12.193,1 26,1 C39.807,1 51,12.193 51,26 L51,26 Z" id="Stroke-2" stroke="#65A637" stroke-width="2" sketch:type="MSShapeGroup"></path>\n\t                    <path d="M22.841066,29.158934 C23.7354338,30.0523306 24.7832326,30.5 26,30.5 C28.4199396,30.5 30.5,28.4189685 30.5,26 C30.5,23.5800604 28.4199396,21.5 26,21.5 C23.5810315,21.5 21.5,23.5800604 21.5,26 C21.5,27.2167674 21.9476694,28.2645662 22.841066,29.158934 L22.841066,29.158934 Z M34.6807156,28.1586387 C34.5705253,28.1586387 34.3809185,28.3313695 34.3809185,28.4574431 L33.6721265,30.1907074 C33.5937028,30.3326643 33.5937028,30.4746213 33.6721265,30.6155855 L34.97952,32.9474513 C35.0579438,33.1211748 35.0430532,33.2472485 34.9169796,33.3097889 L33.3097889,34.9169796 C33.2472485,35.0430532 33.1201821,35.0589365 32.9474513,34.97952 L30.6155855,33.6721265 C30.4736286,33.5937028 30.3316716,33.5937028 30.1907074,33.6721265 L28.3949027,34.3809185 C28.1894126,34.4911088 28.0951055,34.5864086 28.0951055,34.6807156 L27.4339635,37.2488454 C27.4339635,37.3739264 27.26024,37.5 27.1341663,37.5 L24.8658337,37.5 C24.7238767,37.5 24.6295697,37.4215762 24.5660365,37.2488454 L23.9048945,34.6807156 C23.9048945,34.5864086 23.8105874,34.4911088 23.6050973,34.3809185 L21.7467521,33.6095861 C21.6047952,33.5301696 21.4628383,33.5301696 21.3208814,33.6095861 L19.0525487,34.97952 C18.8788252,35.0589365 18.7537442,35.0430532 18.6902111,34.9169796 L17.0830204,33.3097889 C16.9569468,33.2472485 16.9420562,33.1211748 17.02048,32.9474513 L18.3914066,30.6791186 C18.4698304,30.5371617 18.4698304,30.3952048 18.3914066,30.2532479 L17.6190815,28.3949027 C17.5088912,28.1904053 17.4145841,28.0951055 17.3192844,28.0951055 L14.7521473,27.4339635 C14.5784238,27.3704303 14.5,27.2761233 14.5,27.1341663 L14.5,24.8658337 C14.5,24.7238767 14.5784238,24.6295697 14.7521473,24.5670292 L17.3192844,23.9048945 C17.4145841,23.9048945 17.5088912,23.8105874 17.6190815,23.60609 L18.3914066,21.7467521 C18.4698304,21.6047952 18.4698304,21.4628383 18.3914066,21.3208814 L17.02048,19.0525487 C16.9420562,18.8798179 16.9569468,18.7537442 17.0830204,18.6902111 L18.6902111,17.0840131 C18.7537442,16.9579395 18.8788252,16.9420562 19.0525487,17.02048 L21.3208814,18.3914066 C21.4628383,18.4698304 21.6047952,18.4698304 21.7467521,18.3914066 L23.5425569,17.6190815 C23.6686305,17.6190815 23.8413613,17.4304674 23.8413613,17.3202771 L24.5660365,14.7521473 C24.5660365,14.6260736 24.73976,14.5 24.8658337,14.5 L27.1341663,14.5 C27.26024,14.5 27.4339635,14.6260736 27.4339635,14.7521473 L28.1586387,17.3202771 C28.1586387,17.4304674 28.3313695,17.6190815 28.4574431,17.6190815 L30.1907074,18.3278735 C30.3316716,18.4072899 30.4736286,18.4072899 30.6155855,18.3278735 L32.9474513,17.02048 C33.1201821,16.9420562 33.2472485,16.9579395 33.3097889,17.0840131 L34.9169796,18.6902111 C35.0430532,18.7537442 35.0579438,18.8798179 34.97952,19.0525487 L33.6721265,21.3844145 C33.5937028,21.5263714 33.5937028,21.6683284 33.6721265,21.8092926 L34.3809185,23.5425569 C34.3809185,23.6686305 34.5705253,23.842354 34.6807156,23.842354 L37.2478527,24.5670292 C37.3739264,24.5670292 37.5,24.73976 37.5,24.8658337 L37.5,27.1341663 C37.5,27.26024 37.3739264,27.4339635 37.2478527,27.4339635 L34.6807156,28.1586387 Z" id="Stroke-4" stroke="#65A637" sketch:type="MSShapeGroup"></path>\n\t                    <path d="M40.091,35.629 C40.552,35.913 40.782,36.197 40.782,36.496 L40.782,37.617 L29.576,37.617 L29.576,36.496 C29.576,36.366 29.645,36.235 29.783,36.12 C29.913,36.005 30.121,35.875 30.389,35.714 C30.95,35.391 31.61,35.092 32.377,34.816 C33.114,34.562 33.467,34.401 33.736,34.148 C34.005,33.895 34.058,33.634 34.058,33.15 C33.145,32.329 32.377,30.901 32.377,29.773 C32.377,27.585 33.452,26.411 35.179,26.411 C36.906,26.411 37.98,27.585 37.98,29.773 C37.98,30.901 37.213,32.329 36.3,33.15 C36.3,34.048 36.561,34.271 37.98,34.816 C38.134,34.869 38.886,35.13 39.162,35.23 C39.439,35.33 39.884,35.506 40.091,35.629" id="Fill-5" fill="#65A637" sketch:type="MSShapeGroup"></path>\n\t                </g>\n\t            </svg>\n\t            <%- _("Distributed Management Console").t() %>\n\t        </a>\n\t\t<% } %>\n    </div>\n    <% } %>\n    \n    <div class="popdown-dialog-body">\n    </div><!-- /.popdown-dialog-body -->\n    <div class="popdown-dialog-footer" style="display: none;">\n        <a href="#" class="show-all-sections btn pull-right"><%- _("Show All Settings").t() %></a>\n    </div>\n</div><!-- /.podown -->\n';});

define('views/shared/splunkbar/SystemMenu',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'splunk.util',
    'util/string_utils',
    'views/Base',
    'views/shared/delegates/Popdown',
    'views/shared/splunkbar/SystemMenuSection',
    'views/shared/splunkbar/SystemMenuModal',
    'uri/route',
    'contrib/text!views/shared/splunkbar/SystemMenu.html'
],
function(
    $,
    _,
    Backbone,
    module,
    splunk_util,
    string_utils,
    BaseView,
    Popdown,
    SystemMenuSection,
    SystemMenuModal,
    route,
    systemMenuTemplate
){
    return BaseView.extend({
        moduleId: module.id,
        template: systemMenuTemplate,
        tagName: 'li',
        className: 'dropdown menu-system',
        initialize: function() {
            var self = this;
            BaseView.prototype.initialize.apply(this, arguments);
            self.debouncedRender();
            this.collection.sections.on('ready', function(){
                self.debouncedRender();
            }, this);
        },
        events: {
            'click .show-all-sections': 'showAllSections'
        },
        render: function() {
            var root = this.model.application.get('root'),
                locale = this.model.application.get('locale'),
                app = this.model.application.get('app'),
                managementConsoleApp = this.collection.apps.findByEntryName('splunk_management_console'),
                managementConsoleAvailable = (managementConsoleApp && !managementConsoleApp.entry.content.get("disabled")),
                html = this.compiledTemplate({
                userCanAddData:
                    this.model.user.canAddData() &&
                    this.collection.managers.findByEntryName('adddata'),
                addDataURL: route.addData(root, locale, (app === 'launcher' ? undefined : app)),
                userCanExploreData:
                    this.model.user.canExploreData() &&
                    this.collection.managers.findByEntryName('explore_data'),
                exploreDataURL: route.exploreData(root, locale, app),
                managementConsoleAvailable: managementConsoleAvailable,
                managementConsoleURL: route.managementConsole(root, locale)
            });
            var $html = $(html);
            var $menu = $html.find('.popdown-dialog-body');

            this.addSections($menu);
            if(this.sectionCount < 2) {
                $menu.parent().addClass('mega-menu-narrow');
            }

            var $footer = $html.find('.popdown-dialog-footer');
            if (this.collection.managers.canShowMore()) {
                $footer.show();
            } else {
                $footer.hide();
            }

            this.$el.html($html);

            var popup = this.$el.find('#global-system-menu');
            this.children.popdown = new Popdown({el:popup.parent(), mode: 'dialog'});

            return this;
        },
        addSections: function($menu){
            var self = this;
            this.sectionCount = 0;
            this.collection.sections.each(function(section){
                if (section.get('items') && section.get('items').length === 0) {
                    return;
                }
                var sectionView = self.children[section.get('id')] = new SystemMenuSection({
                    model: section
                });

                self.sectionCount++;
                $menu.append(sectionView.render().el);
            });
        },
        showAllSections: function(evt) {
            this.children.dialog = new SystemMenuModal({
                collection: {
                    managers: this.collection.managers,
                    sections: this.collection.sections
                },
                model: {
                    application: this.model.application
                },
                onHiddenRemove: true
            });
            this.children.popdown.hide();
            this.modalWrapper = $('<div class="splunk-components"></div>').appendTo($("body"));
            this.modalWrapper.append(this.children.dialog.render().el);
            this.children.dialog.show();
        }
    });
});


define('contrib/text!views/shared/splunkbar/UserMenu.html',[],function () { return '<a href="#" class="dropdown-toggle"><% if (isCloud || isLite) { %><i class="icon icon-user"></i><% } %><span class="realname"><%-realName%></span><b class="caret"></b></a>\n<div class="dropdown-menu dropdown-menu-narrow global-user-menu">\n    <div class="arrow"></div>\n    <ul>\n        <li><a href="<%-accountLink%>" class="edit">\n            <% if (isCloud) { %>\n                <%- _("User Settings").t() %>\n            <% } else { %>\n                <%- _("Edit Account").t() %>\n            <% } %>\n        </a></li>\n        <% if (logoutLink) { %>\n            <li><a href="<%-logoutLink%>" class="logout"><%- _("Logout").t() %></a></li>\n        <% } %>\n        <% if (showUserMenuProfile) { %>\n            <li><a href="<%=productMenuUriPrefix%>apex/CP_ProfilePage" class="profile external" target="productlink"><%- _("Profile").t() %></a></li>\n        <% } %>\n    </ul>\n</div>\n';});

define('views/shared/splunkbar/UserMenu',[
    'underscore',
    'module',
    'views/Base',
    'views/shared/delegates/Popdown',
    'contrib/text!views/shared/splunkbar/UserMenu.html',
    'uri/route',
    'splunk.util'
],
function(
    _,
    module,
    BaseView,
    Popdown,
    userMenuTemplate,
    route,
    splunk_util
){
    return BaseView.extend({
        moduleId: module.id,
        template: userMenuTemplate,
        tagName: 'li',
        className: 'dropdown user',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            this.model.user.on('change', this.render, this);
            this.model.webConf.on('change reset', this.render, this);
            if (this.model.user.entry.get('name')) {
                this.render();
            }
        },
        render: function() {

            var realName = this.model.user.entry.content.get('realname'),
                userName = this.model.user.entry.get('name');

            if (!realName || !realName.length) {
                realName = userName;
            }

            var rootUrl = this.model.application.get('root'),
                locale = this.model.application.get('locale'),
                isLite = this.model.serverInfo.isLite(),
                accountLink = route.manager(
                    rootUrl,
                    locale,
                    this.model.application.get('app'),
                    [
                        'authentication',
                        'changepassword',
                        userName
                    ],
                    {
                        data: { action: 'edit' }
                    }
                ),
                accountLinkLite = route.manager(
                    rootUrl,
                    locale,
                    this.model.application.get('app'),
                    [
                        'authentication',
                        'users'
                    ]
                ),
                logoutLink = this.model.config.get('SSO_CREATED_SESSION') ? null : route.logout(rootUrl, locale),
                showUserMenuProfile = this.model.serverInfo.isCloud() &&
                    splunk_util.normalizeBoolean(this.model.webConf.entry.content.get('showUserMenuProfile')),
                html = this.compiledTemplate({
                    userName: userName,
                    realName: realName,
                    accountLink: (isLite) ? accountLinkLite : accountLink,
                    logoutLink: logoutLink,
                    showUserMenuProfile: showUserMenuProfile,
                    productMenuUriPrefix: this.model.webConf.entry.content.get('productMenuUriPrefix') || '',
                    isCloud: this.model.serverInfo.isCloud(),
                    isLite: isLite
                });

            this.$el.html(html);

            var popup = this.$el.find('.global-user-menu');
            this.popdown = new Popdown({el:popup.parent(), mode: 'dialog'});
            return this;
        }
    });
});

define(
    'models/services/Message',[
        'models/SplunkDBase'
    ],
    function(SplunkDBaseModel) {
        return SplunkDBaseModel.extend({
            url: 'messages',
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
            }
        });
    }
);

define(
    'collections/services/Messages',[
        "jquery",
        "models/services/Message",
        "collections/SplunkDsBase"
    ],
    function($, MessageModel, SplunkDsBaseCollection) {
        return SplunkDsBaseCollection.extend({
            model: MessageModel,
            url: 'messages',
            initialize: function() {
                SplunkDsBaseCollection.prototype.initialize.apply(this, arguments);
            },
            destroyAll: function() {
                if (this.destroying === true) {
                    return this.destroyDFD;
                }
                this.destroying = true;
                var that = this;
                this.destroyDFD = new $.Deferred(function(dfd){
                    function destroyNext() {
                        var dummyDefered = new $.Deferred();
                        if (that.length > 0) {
                            var model = that.pop();
                            var destroyPromise = model.destroy() || dummyDefered.resolve().promise();
                            destroyPromise.always( destroyNext);
                            return destroyPromise;
                        }
                        else {
                            dfd.resolve();
                        }
                    }
                    destroyNext();
                });
                this.destroyDFD.then(function() {
                    that.destroying = false;
                });
                return this.destroyDFD.promise();
            }
        });
    }
);

define('views/shared/controls/Control',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/Base'
],
function(
    $,
    _,
    Backbone,
    module,
    Base
){

    /**
     * The base Control class for all controls.
     *
     * When the value has changed (either through a change to the model, calling setValue or a user action), the control
     * dispatches a "change" event with the arguments (newValue, oldValue).
     */
    return Base.extend({
        moduleId: module.id,
        className: 'control',
        initialize: function(){
            Base.prototype.initialize.apply(this, arguments);
            
            var defaults = {
                    defaultValue: '',
                    enabled: true,
                    validate: false,
                    forceUpdate: false,
                    updateModel: true
            };
            _.defaults(this.options, defaults);

            this._setValue(this.options.defaultValue, false);
            if (this.options.modelAttribute) {
                this.$el.attr('data-name', this.options.modelAttribute);
            }

            if (this.model) {
                this.activate({skipSetValueRender: true});
            }
            return this;
        },
        startListening: function() {
            if (this.model) {
                this.listenTo(this.model, 'change:'+this.options.modelAttribute, this.setValueFromModel);
            }
        },
        activate: function(options) {
            options = options || {};
            if (this.active) {
                return Base.prototype.activate.apply(this, arguments);
            }
            if (this.model) {
                this.setValueFromModel(options.skipSetValueRender ? false : true);
            }
            return Base.prototype.activate.apply(this, arguments);
        },
        /**
         * Public value accessor
         */
        getValue: function(){
            return this._value;
        },
        getModelAttribute: function() {
            return this.options.modelAttribute;
        },
        /**
         * Set Value and Update Model,
         * @param value {*} - the new value to assign to the control. If the updateModel flag was set to true in the constructor,
         * then this will also update the model's value
         * @param render {Boolean} - if true, then render the control to display the updated value
         * @param options {Object} - additional options to control behavior
         *      {
         *          silent {Boolean} - if true, then don't trigger a change event from the model or control. Default is false
         *      }
         */
        setValue: function(value, render, options){
            options = options || {};
            var returnValue = this._setValue(value, render, options.silent);
            if (this.options.updateModel) {
                this.updateModel(options);
            }
            return returnValue;
        },
        /**
         * Set Value. Does not update model.
         */
        _setValue: function(value, render, suppressEvent){
            value = this.normalizeValue(value);
            if (this._value !== value) {
                var oldValue = this._value;

                this._value = value;

                (render === false) || this.render(); // if render is undefined, render anyway.

                if (!suppressEvent) {
                    this.trigger('change', value, oldValue, this);
                }
            } else {
                if (render) {
                    this.render();
                }
            }
            return this;
        },
        /**
         * Override this method if the value needs to be normalized before being used.
         */
        normalizeValue: function(value) {
            return value;
        },
        /**
         * Unsets value from the model
         */
        unsetValue: function() {
            this.model.unset(this.getModelAttribute());
        },
        /**
         * Gets the value to use in the control from the model. The default behavior is to return the value
         * of the modelAttribute. Render is called except on initialize.
         */
        setValueFromModel: function(render) {
            this._setValue(this.model.get(this.options.modelAttribute), render);
            return this;
        },
        /**
         * Applies the value from the control to the model. Subclasses should call this in response to user
         * interaction
         */
        updateModel: function(options) {
            options = options || {};
            var updateOptions = {
                validate: this.options.validate,
                forceUpdate: this.options.forceUpdate
            };
            $.extend(true, updateOptions, options);

            if (this.model) {
                return (this.model[this.options.save ? 'save' : 'set']
                    (this.getUpdatedModelAttributes(), updateOptions));
            }
            return true;
        },
        /**
         * Returns a dictionary of attribute key-value pairs to apply when updating the model.
         * Can be overridden by subclasses as needed.
         */
        getUpdatedModelAttributes: function() {
            var updatedAttrs = {};
            updatedAttrs[this.options.modelAttribute] = this._value;
            return updatedAttrs;
        },
        enable: function() {
            this.$el.removeClass('disabled');
        },
        disable: function() {
            this.$el.addClass('disabled');
        }
    });

});

define(
    'views/shared/tablecaption/Input',[
        'module',
        'underscore',
        'views/Base',
        'util/splunkd_utils',
        'util/keyboard'
    ],
    function(
        module,
        _,
        BaseView,
        splunkdUtils,
        keyboardUtil
    )
    {
        return BaseView.extend({
            moduleId: module.id,
            tagName: 'form',
            className: 'search-query-control',
            /**
             * @param {Object} options {
             *     model: {
             *          state: <models.State>,
             *          rawSearch: <models.Base> (Optional)
             *     }
             *     findBar: <boolean> true if this view is for the findBar
             * }
             */
            initialize: function(options) {
                BaseView.prototype.initialize.apply(this, arguments);
                this.key = this.options.key || "name";
                this.fetchDataFilter = this.options.fetchDataFilter || false;

                this.nativePlaceholder = this.supportsNativePlaceholder();
            },
            events: {
                'keyup input': function(e) {
                    e.preventDefault();
                    if (e.which === keyboardUtil.KEYS["ESCAPE"]) {
                        this.clear();
                    } else {
                        this.set(this.$input.val());
                    }
                    this.updateClear();
                    this.updatePlaceholder();
                },
                'click .placeholder': function(e) {
                    this.$input.focus();
                },
                'mouseup input': function(e) { //could result in pasted text
                    this.updatePlaceholder();
                },
                'submit': function(e) {
                    return false;
                },
                'click a.search-query-clear': function(e) {
                    e.preventDefault();
                    this.clear();
                    this.updateClear();
                    this.updatePlaceholder();
                }
            },
            clear: function(){
                this.$input.val('');
                this.set('');
            },
            updateClear: function(){
                this.$clear[this.$input.val() ? 'show' : 'hide']();
            },
            set: function(value) {
                if (!this._set) {
                    var oldVal, newVal;
                    this._set = _.debounce(function(value) {
                        if(this.fetchDataFilter && !value && this.model.state.get('filter')) {
                            this.model.state.unset('filter');
                        } else {
                            var keys = _.isArray(this.key) ? this.key : this.key.split(' ');
                            if(this.fetchDataFilter) {
                                newVal = splunkdUtils.createSearchFilterObj(value, keys);
                                oldVal = this.model.state.get('filter');
                                if (this.hasNotChanged(newVal, oldVal)) {
                                    return;
                                }
                                this.model.state.set('filter', newVal);
                            } else {
                                //in the future, consumers of the shared input should refactor away
                                //from passing fetch data as the state model
                                newVal = splunkdUtils.createSearchFilterString(value, keys);
                                oldVal = this.model.state.get('search');
                                if (this.hasNotChanged(newVal, oldVal)) {
                                    return;
                                }
                                this.model.state.set('search', newVal);
                                if (this.model.rawSearch ){
                                    this.model.rawSearch.set('rawSearch', value);
                                }
                            }
                            this.model.state.set({
                                'offset': '0'
                            });
                        }
                    }, 250);
                }
                this._set.apply(this, arguments);
            },
            updatePlaceholder: function() {
                if (!this.nativePlaceholder) {
                    this.$placeholder[this.$input.val() === '' ? 'show' : 'hide']();
                }
            },
            supportsNativePlaceholder: function() {
                var test = document.createElement('input');
                return ('placeholder' in test);
            },
            isEmpty: function() {
                return this.$input.val() === '';
            },
            /**
             * This will normalize the search before comparing the two
             * search="*" is the same as an empty string due to "*" being a wildcard in search
             * @param newVal
             * @param oldVal
             * @returns {boolean}
             */
            hasNotChanged: function(newVal, oldVal) {
                oldVal = oldVal || (!_.isObject(oldVal) && "search=*");
                newVal = newVal || (!_.isObject(newVal) && "search=*");
                return _.isEqual(newVal, oldVal);
            },
            render: function() {
                var placeholder = _("filter").t();
                if (this.options.findBar) {
                    placeholder = _("Find").t();
                }
                this.$el.html(this.compiledTemplate({
                    _: _,
                    nativePlaceholder: this.nativePlaceholder,
                    placeholder: placeholder
                }));
                if (!this.nativePlaceholder) {
                    this.$placeholder = this.$('.placeholder');
                }
                this.$clear = this.$('.search-query-clear');
                this.$input = this.$('input');
                if (this.model.rawSearch && this.model.rawSearch.get('rawSearch')) {
                    this.$input.val(this.model.rawSearch.get('rawSearch'));
                }
                this.updateClear();
                return this;
            },
            template: '<input type="text" class="input-medium search-query" <% if(nativePlaceholder){ %>placeholder="<%- placeholder %>"<%}%> >\
                <a href="#" class="search-query-clear" style="display:none"><i class="icon-x-circle"></i></a>\
                <% if(!nativePlaceholder){ %> <span class="placeholder"><%= placeholder %></span><% } %>'
        });
    }
);

/* ===========================================================
 * bootstrap-tooltip.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init('tooltip', element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut
        , triggers
        , trigger
        , i

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      triggers = this.options.trigger.split(' ')

      for (i = triggers.length; i--;) {
        trigger = triggers[i]
        if (trigger == 'click') {
          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
        } else if (trigger != 'manual') {
          eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
          eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
          this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var defaults = $.fn[this.type].defaults
        , options = {}
        , self

      this._options && $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      }, this)

      self = $(e.currentTarget)[this.type](options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = 'in'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = 'out'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp
        , e = $.Event('show')

      if (this.hasContent() && this.enabled) {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass('fade')
        }

        placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        $tip
          .detach()
          .css({ top: 0, left: 0, display: 'block' })

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

        pos = this.getPosition()

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (placement) {
          case 'bottom':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'top':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'left':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case 'right':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break
        }

        this.applyPlacement(tp, placement)
        this.$element.trigger('shown')
      }
    }

  , applyPlacement: function(offset, placement){
      var $tip = this.tip()
        , width = $tip[0].offsetWidth
        , height = $tip[0].offsetHeight
        , actualWidth
        , actualHeight
        , delta
        , replace

      $tip
        .offset(offset)
        .addClass(placement)
        .addClass('in')

      actualWidth = $tip[0].offsetWidth
      actualHeight = $tip[0].offsetHeight

      if (placement == 'top' && actualHeight != height) {
        offset.top = offset.top + height - actualHeight
        replace = true
      }

      if (placement == 'bottom' || placement == 'top') {
        delta = 0

        if (offset.left < 0){
          delta = offset.left * -2
          offset.left = 0
          $tip.offset(offset)
          actualWidth = $tip[0].offsetWidth
          actualHeight = $tip[0].offsetHeight
        }

        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
      } else {
        this.replaceArrow(actualHeight - height, actualHeight, 'top')
      }

      if (replace) $tip.offset(offset)
    }

  , replaceArrow: function(delta, dimension, position){
      this
        .arrow()
        .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()
        , e = $.Event('hide')

      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return

      $tip.removeClass('in')

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).detach()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.detach()
        })
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        removeWithAnimation() :
        $tip.detach()

      this.$element.trigger('hidden')

      return this
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function () {
      var el = this.$element[0]
      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
        width: el.offsetWidth
      , height: el.offsetHeight
      }, this.$element.offset())
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , arrow: function(){
      return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function (e) {
      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
      self.tip().hasClass('in') ? self.hide() : self.show()
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  var old = $.fn.tooltip

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tooltip')
        , options = typeof option == 'object' && option
      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }


 /* TOOLTIP NO CONFLICT
  * =================== */

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(window.jQuery);

define("bootstrap.tooltip", ["jquery"], function(){});

define('views/shared/controls/SyntheticSelectControl',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/shared/controls/Control',
    'views/shared/delegates/Popdown',
    'views/shared/tablecaption/Input',
    'util/math_utils',
    'util/string_utils',
    'util/keyboard',
    'bootstrap.tooltip'
],
function(
    $,
    _,
    Backbone,
    module,
    Control,
    Popdown,
    InputView,
    math_utils,
    string_utils,
    keyboard_utils,
    tooltip
){
    /**
     * Synthetic Select dropdown a-la Bootstrap
     *
     * @param {Object} options
     *     {Object} model The model to operate on
     *     {String} modelAttribute The attribute on the model to observe and update on selection
     *     {Object} items An array of elements and/or subarrays, where:
     *                    - An element is an object with keys described below (e.g. value & label)
     *                       ~ An element typically represent a menu item
     *                       ~ An element can be just a menu header, commonly used with menu item groupings (see below)
     *                       ~ An element can represent a submenu if it contains `children` array of elements (nested format)
     *                    - A subarray is a group of elements
     *                       ~ A subarray represents a grouping of menu items with an divider and an optional menu header
     *                    
     *                    label (textual display - if none specified, will default to value),
     *                    value (value to store in model - if none specified, element is considered a menu header instead of menu item)
     *                    icon (icon name to show in menu and button label)
     *                    iconURL (URL of icon to show in menu and button label)
     *                    enabled (optional boolean, defaults to true, whether to enable the selection)
     *                    description (additional text)
     *                    children (array of elements - use for submenus)
     *                    (ie, {label: 'Foo Bar', value: 'foo', icon: 'bar'}).
     *     {String} prompt (Optional) String to display if the value is undefined. If prompt is undefined,
     *                                then the control will just display the first item. Default value
     *                                is undefined
     *     {String} help (Optional) Html to display in the bottom help section
     *     {String} label (Optional) Html to display as the button label
     *     {String} toggleClassName (Optional) Class attribute to add to the parent element
     *     {String} menuClassName (Optional) Class attribute to add to the dialog element
     *     {String} menuWidth (Optional) narrow, normal, or wide
     *     {String} additionalClassNames (Optional) Class attribute(s) to add to control
     *     {String} iconClassName (Optional) Class attribute(s) to add to icon
     *     {String} iconURLClassName (Optional) Class attribute(s) to add to iconURL
     *     {Boolean} nearestValue (Optional) if true: try to select the nearest value from items for the value of the modelAttribute 
     *     {String} descriptionPosition (Optional) [top|right|bottom] Default value is "right". Position of the element's description text
     *     relative to the item's label
     *     {Number} maxLabelLength (Optional) maximum label length 
     *     {Object} stateModel (Optional) state for tablecaption/input, if this exists show input-container element
     *     {Object} rawSearch (Optional) rawSearch for tablecaption/input, must be present if stateModel is present
     *
     *
     *   Advanced example of items array with nesting & grouping of elements:
     *   var items = [
     *       [
     *           {value: "item1", label: "Menu item with desc", description: "Click here!"},
     *           {value: "item2", label: "Menu item"},
     *           {label: "Sub menu", children: [
     *               {value: "item3", label: "Action one"},
     *               {value: "item4", label: "Action two"}
     *           ]},
     *       ],
     *       [
     *           {label: "Menu group header"},
     *           {value: "item5", label: "Another menu item"},
     *           {value: "item6"}
     *       ],
     *       [
     *           {label: "Submenu in a group", children: [
     *               {label: "Cool submenu header"},
     *               {value: "item7", label: "More action", description: "foo"},
     *               {value: "item8", label: "Yet another action", description: "bar"},
     *           ]}
     *       ]
     *   ];
     */

    return Control.extend({
        moduleId: module.id,
        className: 'control btn-group',
        items: undefined,
        selectedItem: undefined,
        renderList: true,
        initialize: function() {
            var defaults = {
                toggleClassName: '' ,
                menuClassName: '',
                iconClassName: 'icon-large',
                iconURLClassName: 'icon-large',
                descriptionPosition: 'right',
                label: '',
                popdownOptions: {el: this.el},
                html: '',
                nearestValue: false,
                prompt: undefined,
                // optional method to customize item label formatting
                formatLabel : function(item) {
                    // By default label displayed is item.label.
                    // If none specified this defaults to item.value. 
                    return item.label || item.value;
                }
            };

            _.defaults(this.options, defaults);
            _.defaults(this.options.popdownOptions, defaults.popdownOptions);
            // our own expando property
            this.options.expando = 'ssc-' + this.cid;
            // store structure in this.items
            this.setItems(this.options.items, {skipRender: true});

            this.children.inputView = new InputView({
                model: {
                    state: this.options.stateModel,
                    rawSearch: this.options.rawSearch
                },
                findBar: false
            });
            this.inputViewRendered = false;

            // compile sub template (main template already compiled in constructor)
            this.compiledSubTemplate = this.compileTemplate(this.subTemplate);

            Control.prototype.initialize.apply(this, arguments);
        },
        
        activate: function(options) {
            options = options || {};
            if (this.active) {
                return Control.prototype.activate.apply(this, arguments);
            }
            this.renderList = true;
            Control.prototype.activate.apply(this, arguments);
        },

        // override setValue to keep _value and selectedItem in sync by definition
        _setValue: function(value, render, suppressEvent) {
            var oldValue = this._value;
            value = this.normalizeValue(value);
            this._value = value;

            if (_.isUndefined(this._value) || !this.items || !this.items.length) {
                this.selectedItem = undefined;
            } else if (this.options.nearestValue) {
                var nearestObject = math_utils.nearestMatchAndIndexInArray(this._value, this.valuesAsInts);
                if (!_.isUndefined(nearestObject.index)) {
                    var nearestItem = this.itemsMap[nearestObject.index];
                    this.selectedItem = this.findItem(nearestItem.value);
                }
            } else {
                this.selectedItem = this.findItem(this._value);
            }

            // trigger change event
            if (!suppressEvent) {
                this.trigger('change', value, oldValue, this);
            }

            // if render requested or undefined, render anyway.
            if (render !== false) {
                this.render();
            }

            return this;
        },

        /**
         * This is a parametrized recursive algorithm to traverse
         * @items hierarchy and execute a base function @baseFn at
         * each leaf item. If baseFn returns a truthy value, this
         * signals that the required leaf operation is complete, and
         * traversal is terminated.
         */
        _recursiveTreeTraversal: function(items, baseFn) {
            var item, args, found, i, len;
            for (i = 0, len = items.length; i < len; i++) {
                item = items[i];
                // recursive case 1: array (i.e. grouped items)
                if (_.isArray(item)) {
                    // recursive call using current arguments with items=item
                    args = Array.prototype.slice.call(arguments, 1);
                    args.unshift(item);
                    found = this._recursiveTreeTraversal.apply(this, args);
                }
                // recursive case 2: children array (i.e. nested sub menu)
                else if (item.children) {
                    // recursive call using current arguments with items=item.children
                    args = Array.prototype.slice.call(arguments, 1);
                    args.unshift(item.children);
                    found = this._recursiveTreeTraversal.apply(this, args);
                }
                // base case for leaf items
                else if (_(item).has('value')) {
                    // call baseFn using current arguments without items or baseFn
                    args = Array.prototype.slice.call(arguments, 2);
                    args.unshift(item);
                    found = baseFn.apply(this, args);
                }
                if (found) { return found; }
            }
            return false;
        },

        getFirstItem: function() {
            return this._recursiveTreeTraversal(this.items, function(item){
                return item;
            });
        },

        // keeping this for backward compatibility but this is a not a proper naming
        // and not required, since item is now part of the view state.
        findItem: function(value) {
            // if no value set, default to selected item
            if (_.isUndefined(value)) {
                return this.selectedItem;
            }
            return this._recursiveTreeTraversal(this.items, function(item, value) {
                if (_.isEqual(item.value, value)) {
                    return item;
                }
            }, value);
        },

        _mapItemsToIndices: function() {
            // internal map of item index to item object
            this.itemsMap = [];
            this._recursiveTreeTraversal(this.items, function(item, memo) {
                // each item gets a unique index
                // note that expando is a random key to avoid collisions
                item[this.options.expando] = memo.length;
                memo.push(item);
            }.bind(this), this.itemsMap);
        },

        _mapItemsToValues: function() {
            this.valuesAsInts = [];
            this._recursiveTreeTraversal(this.items, function(item, memo) {
                var convertedToInt = parseInt(item.value, 10);
                if (_.isNaN(convertedToInt)) {
                    throw new Error('You cannot use the nearestValue option with a SyntheticSelect control that has values other than ints!');
                }
                memo.push(convertedToInt);
            }, this.valuesAsInts);
        },

        setItems: function(items, options) {
            this.items = items;
            // flag to re-render popdown
            this.renderList = true;
            // build local map
            if (this.items && this.items.length) {
                this._mapItemsToIndices();
                if (this.options.nearestValue) {
                    this._mapItemsToValues();
                }
            }
            // In case the items change affects the currently selected item, re-run the _setValue routine
            // but don't cause a render or a change event.
            this._setValue(this._value, false, true);
            if (options && options.skipRender) { return; }
            this.debouncedRender();
        },

        stopListening: function() {
            if (arguments.length === 0) {
                $(window).off('.' + this.cid);
                this.$menu && this.$menu.off('.' + this.cid);                
            }
            Control.prototype.stopListening.apply(this, arguments);
        },
        show: function(){
            this.$menu.find(".icon-check:visible").closest('a').focus();
            this.$menu.on('click.' + this.cid, 'a', this.click.bind(this));
            $(window).on('keydown.' + this.cid, this.keydown.bind(this));
            this.trigger('popdownShown');
            if (this.options.stateModel) {
                this.$menu.find('.input-container .search-query').focus();
            }
        },
        hide: function(){
            $(window).off('.' + this.cid);
            this.$menu.off('.' + this.cid);
            this.trigger('popdownHidden');
        },
        disable: function(){
            this.options.enabled = false;
            this.$('a.dropdown-toggle').addClass('disabled');
        },
        enable: function(){
            this.options.enabled = true;
            this.$('a.dropdown-toggle').removeClass('disabled');
        },
        tooltip: function(options){
            this.$('a.dropdown-toggle').tooltip(options);
        },
        click: function(e) {
            var $currentTarget = $(e.currentTarget);
            if (!$currentTarget.hasClass('disabled') &&
                !$currentTarget.is('.submenu-label') &&
                !$currentTarget.is('.search-query-clear')) {
                var itemIdx = $currentTarget.data('item-idx'),
                    item = this.itemsMap[itemIdx];
                this.setValue(item.value, true);
                this.$(".dropdown-toggle").focus();
            }
            e.preventDefault();
        },
        keydown: function (e) {
            if ((e.shiftKey && e.which !== keyboard_utils.KEYS['TAB']) || e.ctrlKey || e.metaKey || e.altKey) {
                return true;
            }

            if (!this.options.stateModel && e.keyCode === keyboard_utils.KEYS['ESC']) {
                this.$('.dropdown-toggle').focus();
                e.preventDefault();
                e.stopPropagation();
                return;
            }

            var $focused = $(':focus');
            // if dropdown toggle in focus, only handle DOWN key - leave rest for lovely Popdown
            if ($focused.is('.dropdown-toggle')) {
                if (e.keyCode === keyboard_utils.KEYS['DOWN_ARROW']) {
                    this.$menu.find('a:eq(0)').focus();
                }
                e.preventDefault();
                e.stopPropagation();
                return;
            }

            // if dropdown menu item in focus, respond to UP/DOWN/<letter/digit> keys 
            // TODO: support all dropdown-menu (i.e. submenu with LEFT/RIGHT keys)
            var $menu = $focused.closest('ul.dropdown-menu-main'),
                $items = $menu.find('> li a:visible'),
                index = -1, handled = false;

            if (!$items.length) return true;

            index = $items.index($focused);
            if (e.keyCode === keyboard_utils.KEYS['DOWN_ARROW']) {
                if (index < $items.length - 1) {
                    index++;
                    $items.eq(index).focus();
                } else {
                    $items.eq(0).focus();
                }
                handled = true;
            } else if (e.keyCode === keyboard_utils.KEYS['UP_ARROW']) {
                if (index === 0) {
                    this.$(".dropdown-toggle").focus();
                } else {
                    index--;
                    $items.eq(index).focus();
                }
                handled = true;
            } else if (e.keyCode === keyboard_utils.KEYS['TAB']) {
                if (e.shiftKey) {
                    if (index > 0) {
                        return true;
                    }
                    $items.eq($items.length - 1).focus();
                    handled = true;
                } else {
                    if (index < $items.length - 1) {
                        return true;
                    }
                    $items.eq(0).focus();
                    handled = true;
                }
            } else if (!this.options.stateModel &&
                (((e.keyCode >= 48) && (e.keyCode <= 57))  || //number
                ((e.keyCode >= 65) && (e.keyCode <= 90))  || //uppercase letter
                ((e.keyCode >= 97) && (e.keyCode <= 122)) || //lowercase letter
                ((e.keyCode >= 128) && (e.keyCode <= 165)))   //extended letter
            ) {
                var keyChar = String.fromCharCode(e.keyCode).toLowerCase();
                $items.each(function() {
                    var $option = $(this),
                        firstChar = $option.text().replace(/^\s\s*/, '').substring(0, 1).toLowerCase();

                    if (keyChar == firstChar) {
                        $option.focus();
                        handled = true;
                        return false; // break out of each() loops
                    }
                });
            }

            if (handled) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }

            return true;
        },
        render: function() {
            var selectedItem = this.selectedItem;

            if (!this.items || !this.items.length) {
                return this;
            }

            // if no item selected
            if (!selectedItem) {
                // if we have a prompt then display prompt as label
                if (!_(this.options.prompt).isUndefined()) {
                    selectedItem = {
                        label: this.options.prompt,
                        value: undefined
                    };
                // otherwise default to first item of list
                } else {
                    selectedItem = this.getFirstItem();
                }
            }

            if (this.renderList) {
                if (this.children.inputView) {
                    this.children.inputView.detach();
                }
                
                var template = this.compiledTemplate({
                    items: this.items,
                    selectedItem: selectedItem,
                    options: this.options,
                    menuWidthClass: (this.options.menuWidth && this.options.menuWidth != "normal" ? "dropdown-menu-" + this.options.menuWidth : ''),
                    subTemplate: this.compiledSubTemplate,
                    hasInput: this.options.stateModel
                });
                this.$el.html(template);
                
                if (!this.inputViewRendered) {
                    this.children.inputView.render();
                    this.inputViewRendered = true;
                }
                
                this.children.inputView.appendTo(this.$('.input-container'));

                this.$menu =  this.$('> .dropdown-menu');
                
                // menu has submenus if any of its items has children
                var hasSubMenus = !!(_.find(_.flatten(this.items, true), function(item) {
                    return _.has(item, 'children');
                }));
                if (hasSubMenus) {
                    // ensure sub menu flyouts are not hidden
                    this.$menu.find('> ul').css({
                        'overflow': 'visible',
                        'max-height': 'none'
                    });
                }

                if (this.children.popdown) {
                    this.children.popdown.remove();
                    this.stopListening(this.children.popdown);
                    delete this.children.popdown;
                }

                this.children.popdown = new Popdown($.extend(true, {}, this.options.popdownOptions));
                this.listenTo(this.children.popdown, "shown", this.show);
                this.listenTo(this.children.popdown, "hidden", this.hide);

                this.renderList = false;
            }

            var additionalClassNames = this.options.additionalClassNames;
            if(additionalClassNames) {
                this.$el.addClass(additionalClassNames); 
            }

            // TODO: this is not required if Popdown view supports successive rendering as it should
            // Hide or show the checkmarks
            this.$menu.find('a.synthetic-select').each(function(i, el) {
                // using attr() instead of data() since latter attempts to deduce the type
                // and automatically convert value from string to a JavaScript type value
                var $el = $(el),
                    itemIdx = $el.data('item-idx'),
                    item = this.itemsMap[itemIdx];
                $el.find('.icon-check')[(selectedItem && _.isEqual(item.value, selectedItem.value)) ? 'show' : 'hide']();
            }.bind(this));
                                    
            // TODO: this is not required if Popdown view supports successive rendering as it should
            //Update the toggle label
            if (selectedItem) {
                if (selectedItem.label || selectedItem.value) {
                    var formattedLabel = _(this.options.label).t() + " " +
                        _(selectedItem.label || selectedItem.value).t();
                    if (this.options.maxLabelLength && this.options.maxLabelLength > 3) {
                        formattedLabel = string_utils.maybeAddEllipsis(
                            formattedLabel, this.options.maxLabelLength, this.options.maxLabelLength - 3, 0);
                    }
                    this.$(".dropdown-toggle > .link-label").text(formattedLabel);
                }
                if (selectedItem.icon) {
                    this.$(".dropdown-toggle > i").attr('class',  "icon-" + selectedItem.icon);
                }
            }

            return this;
        },
        // NOTE: the "data-item-value" attribute of each list item is exposed for testing only
        subTemplate: '\
            <% if (_.isArray(item)) { %>\
                <% if (index > 0) { %> <li role="presentation" class="divider"></li> <% } %>\
                <% _.each(item, function(subItem, subIndex, list) { %>\
                    <%= subTemplate({item: subItem, index: subIndex, options: options, subTemplate: subTemplate}) %>\
                <% }); %>\
            <% } else if (item.children) { %>\
                <li class="dropdown-submenu">\
                    <a href="#" class="submenu-label"><%- options.formatLabel(item) %></a>\
                    <ul class="dropdown-menu">\
                        <% _.each(item.children, function(subItem, subIndex, list) { %>\
                            <%= subTemplate({item: subItem, index: subIndex, options: options, subTemplate: subTemplate}) %>\
                        <% }); %>\
                    </ul>\
                </li>\
            <% } else if (!_.has(item, "value")) { %>\
                <li role="presentation" class="dropdown-header"><%- options.formatLabel(item) %></li>\
            <% } else { %>\
                <li><a class="synthetic-select <%- item.enabled === false ? \"disabled\" : \"\"%>" href="#" data-item-idx="<%- item[options.expando] %>" data-item-value="<%- item.value %>">\
                    <i class="icon-check"></i>\
                    <% if (item.icon) { %> <i class="icon-<%-item.icon%> <%-options.iconClassName %>"></i><% } %>\
                    <% if (item.iconURL) { %> <img class="<%-options.iconURLClassName %>" src="<%-item.iconURL%>" alt="icon"><% } %>\
                    <% if (item.description && (options.descriptionPosition == "top")) { %> <span class="link-description"><%- item.description %></span><% } %>\
                    <span class="link-label"><%- options.formatLabel(item) %></span>\
                    <% if (item.description && (options.descriptionPosition == "right")) { %> <span class="link-description"><%- item.description %></span><% } %>\
                    <% if (item.description && (options.descriptionPosition == "bottom")) { %> <span class="link-description-below"><%- item.description %></span><% } %>\
                </a></li>\
            <% } %>\
        ',
        template: '\
            <a class="dropdown-toggle <%- options.toggleClassName %>" href="#">\
                <i class="<%- (selectedItem && selectedItem.icon) ? "icon-" + selectedItem.icon : ""%> icon-large"></i>\
                <span class="link-label"><%- options.label %> <%- selectedItem && options.formatLabel(selectedItem) %></span><span class="caret"></span>\
            </a>\
            <div class="dropdown-menu dropdown-menu-selectable <%- options.menuClassName %> <%- menuWidthClass %> ">\
                <div class="arrow"></div>\
                <ul class="dropdown-menu-main">\
                <% if (hasInput) { %>\
                    <li class="input-container"></li>\
                    <li role="presentation" class="divider"></li>\
                <% } %>\
                <% _.each(items, function(item, index, list) { %>\
                <%= subTemplate({item: item, index: index, options: options, subTemplate: subTemplate}) %>\
                <% }); %>\
                </ul>\
            </div>\
        '
    });
});

define(
        'views/shared/controls/SyntheticRadioControl',[
            'jquery',
            'underscore',
            'module',
            'views/shared/controls/Control',
            'util/general_utils',
            'bootstrap.tooltip'
        ],
        function(
            $,
            _,
            module,
            Control,
            util
            // bootstrap tooltip
            ) {
    /**
     * Synthetic Radio Button Bar a-la iPhone
     *
     * @param {Object} options
     *                        {Object} model The model to operate on
     *                        {String} modelAttribute The attribute on the model to observe and update on selection
     *                        {Object} items An array of one-level deep data structures:
     *                                      label (textual display),
     *                                      value (value to store in model)
     *                                      icon (icon name to show in menu and button label)
     *                                      className (class attribute to be applied),
     *                                      tooltip  (Text to display in the tooltip)
     *                                 (ie, {label: 'Foo Bar', value: 'foo', icon: 'bar', className: 'foo'}).
     *                        {String} buttonClassName (Optional) Class attribute to each button element. Default is btn.
     *                        {Boolean} elastic Automatically assigns percentage width to children to completely fill the parent. Defaults to false.
     *                        {String} additionalClassNames (Optional) Class attribute(s) to add to control
     */

    return Control.extend({
        className: 'control btn-group',
        moduleId: module.id,
        initialize: function(){
            var defaults = {
                buttonClassName: 'btn',
                elastic: false
            };

            _.defaults(this.options, defaults);


            // dunno if this should be the default but it was hard coded before so defaulting for legacy
            var itemDefaults = {iconSize: 'icon-large'};
            // attempt to default iconSize for each item
            _.each(this.options.items, function(el, i, list){
                _.defaults(el, itemDefaults);
            });
            this.$el.addClass('btn-group-radio');
            Control.prototype.initialize.call(this, this.options);
            
        },
        events: {
            'click button': function(e) {
                if (this.options.enabled)
                    this.setValue( $(e.currentTarget).data('value'), true);
                e.preventDefault();
            }

        },
        disable: function(){
            this.options.enabled = false;
            this.$('button').addClass('disabled');
        },
        enable: function(){
            this.options.enabled = true;
            this.$('button').removeClass('disabled');
        },
        render: function(){
            if (!this.el.innerHTML) {
                var template = _.template(this.template, {
                                items: this.options.items,
                                buttonClassName: this.options.buttonClassName,
                                help: this.options.help,
                                elastic: this.options.elastic,
                                enabled: this.options.enabled,
                                modelAttribute: this.options.modelAttribute
                        });
                this.$el.html(template);
                this.$('[rel="tooltip"]').tooltip({animation:false, container: 'body', trigger: 'hover'});

                //bind that values to the items
                var items = this.options.items;
                this.$el.find('button').each(function(i, el) {
                    $(el).attr('data-value', items[i].value).data('value', items[i].value);
                });
            }

            var value = this._value;

            this.$el.find('button').each(function(i, el) {
                var $el = $(el);
                $el[util.checkEquality($el.data('value'), value) ? 'addClass' : 'removeClass']('active');
            });

            var additionalClassNames = this.options.additionalClassNames;
            if(additionalClassNames) {
                this.$el.addClass(additionalClassNames);
            }

            return this;
        },
        remove: function(){
            this.$('[rel="tooltip"]').tooltip('destroy');
            Control.prototype.remove.call(this);
        },
        template: '\
            <% _.each(items, function(item, index){ %>\
                <button name="<%- modelAttribute || "" %>" \
                        <% if (elastic) { %> style="width:<%- Math.round(100*(1/items.length)) %>%" <% } %> \
                        <% if (item.tooltip) { %> rel="tooltip" title="<%=item.tooltip%>" <% } %>\
                        class="<%=buttonClassName%> <%- item.className || "" %> <%- enabled ? "" : "disabled" %>">\
                    <% if (item.icon) { %> <i class="icon-<%-item.icon%> <%-item.iconSize%>"></i><% } %>\
                    <% if(item.label){ %> <%= item.label%> <%}%>\
                </button>\
            <% }) %>\
        '
    });
});

define( 'views/shared/controls/SyntheticCheckboxControl',[
    'underscore',
    'module',
    'views/shared/controls/Control',
    'splunk.util'
], function(
    _,
    module,
    Control,
    splunk_util
    )
{
    /**
     * Synthetic Checkbox
     *
     * @param {Object} options
     *                        {Object} model The model to operate on
     *                        {String} modelAttribute The attribute on the model to observe and update on selection
     *                        {Object} items An array of one-level deep data structures:
     *                                 label (textual display),
     *                                      value (value to store in model)
     *                                      icon (icon name to show in menu and button label)
     *                                 (ie, {label: 'Foo Bar', value: 'foo', icon: 'bar'}).
     *                        {Boolean} invertValue (Optional) If true, then a checked checkBox has a value of false and
     *                                  an unchecked has a value of true. This is useful for model attributes that denote a negative
     *                                  (ex. disabled). Defaults to false.
     *                        {String} checkboxClassName (Optional) Class attribute to the button element. Default is btn.
     *                        {String} additionalClassNames (Optional) Class attribute(s) to add to control
     */
    var SyntheticCheckboxControl = Control.extend({
        className: 'control',
        moduleId: module.id,
        initialize: function(){
            var defaults = {
                checkboxClassName: 'btn',
                defaultValue: false,
                label: ''
            };

            _.defaults(this.options, defaults);
            
            Control.prototype.initialize.apply(this, arguments);
        },
        events: {
            'click label': function(e) {
                !this.options.enabled || this.setValue(!this._value);
                e.preventDefault();
            },
            'click .btn': function(e) {
                e.preventDefault();
            }

        },
        disable: function(){
            this.options.enabled = false;
            this.$('label').addClass('disabled');
            this.$('.btn').addClass('disabled');
        },
        enable: function(){
            this.options.enabled = true;
            this.$('label').removeClass('disabled');
            this.$('.btn').removeClass('disabled');
        },
        normalizeValue: function(value) {
            return splunk_util.normalizeBoolean(value) ? 1 : 0;
        },
        render: function(){
            var checked = this.options.invertValue ? !this.getValue() : this.getValue();

            if (!this.el.innerHTML) {
                var template = _.template(this.template, {
                                options: this.options,
                                checked: checked
                        });
                this.$el.html(template);
                
                if (!this.options.enabled) {
                    this.disable();
                }
            } else {
                this.$('.icon-check')[checked ? 'show' : 'hide']();
            }

            var additionalClassNames = this.options.additionalClassNames;
            if(additionalClassNames) {
                this.$el.addClass(additionalClassNames); 
            }

            return this;
        },
        template: '\
            <label class="checkbox">\
                  <a href="#" data-name="<%- options.modelAttribute || "" %>" class="<%- options.checkboxClassName %>"><i class="icon-check" <% if (!checked) {%>style="display:none"<% } %>></i></a>\
                  <%- options.label%>\
            </label>\
        '
    });
    
    return SyntheticCheckboxControl;
});

define(
    'views/shared/controls/SyntheticSliderControl',[
        'jquery',
        'underscore',
        'module',
        'views/shared/controls/Control',
        'util/general_utils',
        'util/keyboard'
    ],
    function($, _, module, Control, util, keyboard) {
        /**
         * Synthetic Slider Control
         *
         * @param   {Object} options
         *            |
         *            |--> {Object} model               [Required] The model to operate on
         *            |--> {String} modelAttribute      [Required] The attribute on the model to observe and update on selection
         *            |
         *            |--> {Number} min                 [Optional: Defaults to 1] The minimum value selectable on the slider
         *            |--> {Number} max                 [Optional: Defaults to 5] The maximum value selectable on the slider
         *            |--> {Number} step                [Optional: Defaults to 1] The step interval amount between selectable values on the slider
         *            |
         *            |--> {Array} steps                [Optional: Default is unused] Allows every step of the slider to be explicitly defined. If
         *            |                                 this option is defined, it will override any previously defined min, max, and step settings.
         *            |
         *            |                                     Each array element should be one of the following:
         *            |
         *            |                                         (a) {String/Number} If the element is a string or number, the element will be used
         *            |                                         as both he slider step's label and value.
         *            |
         *            |                                             - OR -
         *            |
         *            |                                         (b) {Object: of format { label: String, value: String/Number } } If the element is
         *            |                                         of the above object format, the element's label property will be used
         *            |                                         as the slider step's label and the element's value property will be used as the
         *            |                                         slider's value.
         *            |                             
         *            |                                 Example: ['Low', 'Medium', { label: 'High', value: 10000 }]
         *            |--> {Boolean} enableStepLabels   [Optional: Defaults to true] If a steps array (as defined above) is provided, this
         *            |                                 determines whether or not to display step labels in the UI as the slider is moved.
         *            |
         *            |--> {Number} value               [Optional: Defaults to min] The default value selected on the slider
         *            |--> {Number} width               [Optional: Defaults to 256] The width of the slider bar in pixels
         *            |--> {Number} minLabel            [Optional] The text label displayed next to the minimum slider end
         *            |--> {Number} maxLabel            [Optional] The text label displayed next to the maximum slider end
         */
        return Control.extend({
            className: 'control slider-control',
            moduleId: module.id,
            initialize: function() {
                var defaults = {
                    min: 1,
                    max: 5,
                    step: 1,
                    steps: [],
                    enableStepLabels: true,
                    width: 256
                };
                _.defaults(this.options, defaults);
                this.setSyntheticSteps();
                this.syncFromModel();
                this.setStyles();
                Control.prototype.initialize.call(this, this.options);
            },
            syntheticStepsMode: false,
            value: 0,
            selected: false,
            notches: 0,
            styles: {
                slider: {
                    height: 0
                },
                sliderBar: {
                    width: 0,
                    height: 0,
                    top: 0,
                    borderRadius: 0
                },
                sliderHandle: {
                    width: 0,
                    height: 0,
                    top: 0,
                    left: 0,
                    borderRadius: 0
                },
                sliderNotch: {
                    height: 0,
                    marginLeftRight: 0
                }
            },
            setSyntheticSteps: function() {
                if (this.options.steps.length) {
                    this.syntheticStepsMode = true;
                    this.options.min = 0;
                    this.options.max = this.options.steps.length - 1;
                    this.options.step = 1;
                    if (this.options.value !== undefined) {
                        this.options.value = this.syntheticToInternalValue(this.options.value);
                    }
                }
            },
            syntheticValueAt: function(index) {
                var syntheticStep = this.options.steps[index];
                return syntheticStep.value || syntheticStep;
            },
            syntheticLabelAt: function(index) {
                var syntheticStep = this.options.steps[index];
                return syntheticStep.label || syntheticStep;
            },
            syntheticToInternalValue: function(syntheticValue) {
                var numSteps = this.options.steps.length;
                for (var i = 0; i < numSteps; i++) {
                    if (this.syntheticValueAt(i) == syntheticValue) {
                        return i;
                    }
                }
                return 0;
            },
            setStyles: function() {
                this.styles.slider.height = this.options.width / 5;        
                // Set bar styles
                this.styles.sliderBar.width = this.options.width;
                this.styles.sliderBar.height = this.styles.sliderBar.width / 50;
                this.styles.sliderBar.top = (this.styles.slider.height - this.styles.sliderBar.height) / 2;
                this.styles.sliderBar.borderRadius = this.styles.sliderBar.height / 2;
                // Set handle styles
                this.styles.sliderHandle.width = this.styles.sliderBar.width / 20;
                this.styles.sliderHandle.height = this.styles.sliderHandle.width;
                this.styles.sliderHandle.top = (this.styles.slider.height - this.styles.sliderHandle.height) / 2 - 1;
                this.styles.sliderHandle.borderRadius = this.styles.sliderHandle.width / 2 + 1;
                // Set notch styles
                this.notches = Math.round((this.options.max - this.options.min) / this.options.step) + 1;
                this.styles.sliderNotch.height = this.styles.sliderBar.height * 1.5;
                this.styles.sliderNotch.marginLeftRight = (this.styles.sliderBar.width - 2 * this.styles.sliderHandle.width) / (this.notches - 1);
            },
            activate: function() {
                Control.prototype.activate.apply(this, arguments);
                if (this.options.modelAttribute) {
                    this.syncFromModel();
                }
            },
            startListening: function() {
                Control.prototype.startListening.apply(this, arguments);
                if (this.options.modelAttribute) {
                    this.listenTo(this.options.model, 'change:' + this.options.modelAttribute, this.syncFromModel);
                }
            },
            events: {
                'mousedown .slider': function(e) {
                    this.select();
                    this.update(e);
                    $('body').addClass('text-highlight-disabled');

                    $(window).on('mousemove.slider', function(e) {
                        this.update(e);
                    }.bind(this));

                    $(window).on('mouseup.slider', function() {
                        this.deselect();
                        $('body').removeClass('text-highlight-disabled');
                        $(window).off('.slider');
                    }.bind(this));
                },
                'mousemove .slider': function(e) {
                    this.update(e);
                },
                'keydown .slider-handle': function(e) {
                    if (e.which == keyboard.KEYS.LEFT_ARROW || e.which == keyboard.KEYS.RIGHT_ARROW) {
                        e.preventDefault();
                        this.select();
                        var delta = e.which == keyboard.KEYS.LEFT_ARROW ? -this.options.step : this.options.step;
                        this.value = this.snapToValue(this.value + delta);
                        this.delayedDeselect();
                        this.render();
                        this.$el.find('.slider-handle').focus();
                    }
                }
            },
            delayedDeselect: function() {
                if (!this._delayedDeselect) {
                    this._delayedDeselect = _.debounce(function() {
                        this.deselect();
                    }, 750);
                }
                this._delayedDeselect.apply(this, arguments);
            },
            syncFromModel: function() {
                var modelValue = this.options.model.get(this.options.modelAttribute);
                if (modelValue !== undefined) {
                    var oldValue = this.value;
                    this.value = this.syntheticStepsMode ? this.syntheticToInternalValue(modelValue) : this.snapToValue(parseFloat(modelValue));
                    if (oldValue != this.value) {
                        this.syncToModel();
                    }
                    this.render();
                } else {
                    this.value = this.options.value !== undefined ? this.snapToValue(this.options.value) : this.options.min;
                }
            },
            syncToModel: function() {
                var modelValue = this.options.model.get(this.options.modelAttribute),
                    newModelValue;
                if (this.syntheticStepsMode) {
                    newModelValue = this.syntheticValueAt(this.value);
                    if (modelValue === undefined || modelValue != newModelValue) {
                        this.setValue(newModelValue);
                    }
                } else {
                    newModelValue = this.value.toFixed(3);
                    if (modelValue === undefined || this.snapToValue(parseFloat(modelValue)).toFixed(3) != newModelValue) {
                        this.setValue(newModelValue);
                    }
                }
            },
            select: function() {
                this.selected = true;
                this.render();
            },
            deselect: function() {
                this.selected = false;
                this.syncToModel();
                this.render();
            },
            snapToValue: function(value) {
                var exactValue = Math.min(Math.max(value, this.options.min), this.options.max);
                return Math.round(exactValue / this.options.step) * this.options.step;
            },
            offsetToValue: function(offset) {
                var padding = this.styles.sliderHandle.width / 2;
                var range = this.styles.sliderBar.width - 4 * padding;
                var offsetInRange = offset - padding;
                var valueInRange = offsetInRange / range;
                var trueRange = this.options.max - this.options.min;
                var desiredValue = this.options.min + valueInRange * trueRange;
                return this.snapToValue(desiredValue);
            },
            valueToOffset: function(value) {
                var padding = this.styles.sliderHandle.width / 2;
                var range = this.styles.sliderBar.width - 4 * padding;
                var trueRange = this.options.max - this.options.min;
                var valueInRange = (value - this.options.min) / trueRange;
                return padding + valueInRange * range - 1;
            },
            update: function(e) {
                if (this.selected) {
                    var padding = this.styles.sliderHandle.width / 2;
                    var offset = e.clientX - this.$el.find('.slider-bar').offset().left - padding;
                    this.value = this.offsetToValue(offset);
                    this.render();
                }
            },
            render: function() {
                var currentLabel = this.syntheticStepsMode && this.options.enableStepLabels ? this.syntheticLabelAt(this.value) : undefined;
                this.styles.sliderHandle.left = this.valueToOffset(this.value);
                this.$el.html(_.template(this.template, {
                    currentLabel: currentLabel,
                    width: this.options.width,
                    notches: this.notches,
                    styles: this.styles,
                    sliderHandleClass: this.selected ? 'slider-handle-moving' : '',
                    sliderHandleTooltipClass: this.selected && currentLabel ? 'slider-handle-tooltip' : '',
                    minLabel: this.options.minLabel,
                    maxLabel: this.options.maxLabel
                }));
                return this;
            },
            template: '\
                <div class="slider-container">\
                    <% if (minLabel) { %>\
                        <div class="slider-min-label"><%= minLabel %></div>\
                    <% } %>\
                    <div class="slider" style="width:<%= styles.sliderBar.width %>px;height:<%= styles.slider.height %>px;">\
                        <div class="slider-bar" style="width:<%= styles.sliderBar.width %>px;height:<%= styles.sliderBar.height %>px;top:<%= styles.sliderBar.top %>px;border-radius:<%= styles.sliderBar.borderRadius %>px;">\
                            <% for (var i = 0; i < notches; i++) { %>\
                                <div class="slider-notch" style="height:<%= styles.sliderNotch.height %>px;left:<%= styles.sliderHandle.width + i * styles.sliderNotch.marginLeftRight %>px;"></div>\
                            <% } %>\
                        </div>\
                        <div class="slider-handle <%= sliderHandleTooltipClass %> <%= sliderHandleClass %>" tabindex="0" style="width:<%= styles.sliderHandle.width %>px;height:<%= styles.sliderHandle.height %>px;top:<%= styles.sliderHandle.top %>px;left:<%= styles.sliderHandle.left %>px;border-radius:<%= styles.sliderHandle.borderRadius %>px" data-label="<%- currentLabel %>"></div>\
                    </div>\
                    <% if (maxLabel) { %>\
                        <div class="slider-max-label"><%= maxLabel %></div>\
                    <% } %>\
                </div>\
            '
        });
    }
);

define('views/shared/controls/CheckboxGroup',[
            'jquery',
            'underscore',
            'module',
            'backbone',
            'views/shared/controls/Control',
            'views/shared/controls/SyntheticCheckboxControl',
            'util/general_utils'
        ],
        function(
            $,
            _,
            module,
            Backbone,
            Control,
            SyntheticCheckboxControl,
            util
        ) {
        /**
         * Synthetic Checkbox Group Control 
         *
         * @param {Object} options
         *                        {Object} model The model to operate on
         *                        {String} modelAttribute The attribute on the model to observe and update on selection
         *                        {Object} items An array of one-level deep data structures:
         *                                      label (textual display),
         *                                      value (value to store in model)
         *                                 (ie, {label: 'Foo Bar', value: 'foo', icon: 'bar', className: 'foo'}).
         *                        {String} additionalClassNames (Optional) Class attribute(s) to add to control
         */

        return Control.extend({
            className: 'control checkbox-group',
            moduleId: module.id,
            initialize: function(options) {
                this._checkboxes = [];
                this._selections = new Backbone.Model();
                _.each(options.items, function(value){
                    var syntheticCheckboxControl = new SyntheticCheckboxControl({
                        model: this._selections,
                        modelAttribute: value.value,
                        label: _($.trim(value.label) || value.value || '').t()
                    });
                    this._checkboxes.push(syntheticCheckboxControl);
                }, this );
                this.listenTo(this._selections, "change", this._updateValue);
                this.listenTo(this.model, 'change:' + options.modelAttribute, this.updateDomVal);
                this.updateDomVal();
                Control.prototype.initialize.apply(this, arguments);
            },
            _updateValue: function(model, change, options) {
                // Must copy array so we always get a change event
                var val = util.asArray(this.model.get(this.options.modelAttribute)).slice(0);
                _(model.changed).each(function(v, k) {
                   if (!v) {
                       val = _(val).without(k);
                   } else if (val.indexOf(k) < 0) {
                       val.push(k);
                   }
                });
                this.model.set(this.options.modelAttribute, val);
            },
            enable: function(){
                this._enabled = true;
                _.each(this._checkboxes, function(checkbox) {
                    checkbox.enable();
                }, this);
            },
            disable: function(){
                this._enabled = false;
                _.each(this._checkboxes, function(checkbox) {
                    checkbox.disable();
                }, this);
            },
            render: function(){
                _.each(this._checkboxes, function(checkbox) {
                    checkbox.render().appendTo(this.$el);
                }, this);
                return this;
            },
            updateDomVal: function() {
                var oldSelections = this._selections.toJSON();
                var newSelections = {};
                _(oldSelections).each(function(value, key) {
                    newSelections[key] = 0;
                });
                _.each(util.asArray(this.model.get(this.options.modelAttribute)), function(val) {
                    newSelections[val] = 1;
                },this);
                this._selections.set(newSelections);
            },
            remove: function(){
                _.each(this._checkboxes, function(checkbox) {
                    checkbox.remove();
                });
                this._checkboxes = [];
                Control.prototype.remove.call(this);
            }
        });
});

define('views/shared/controls/TextControl',[
            'underscore',
            'module',
            'views/shared/controls/Control',
            'util/keyboard',
            'helpers/user_agent'
        ],
        function(
            _,
            module,
            Control,
            keyboardUtil,
            userAgent
        ) {
    /**
     * Text Input with Bootstrap markup
     *
     * @param {Object} options
     *                        {String} modelAttribute The attribute on the model to observe and update on selection
     *                        {Object} model The model to operate on
     *                        {String} inputClassName (Optional) Class attribute for the input
     *                        {String} placeholder (Optional) Placeholder text to display in the input if browser supports
     *                        {String} useSyntheticPlaceholder (Optional) If true, use the placeholder value
     *                        {Object} defaultValue (Optional) If the modelAttribute in the model is undefined, then
     *                                 use this value to populate the text input
     *                        {String} additionalClassNames (Optional) Class attribute(s) to add to control
     *                        {Boolean} updateOnKeyUp (Optional) Update the model with the value on any key-up event
     *                        {Boolean} canClear (Optional) show a clear button
     *                        {Boolean} autocomplete (Optional) the input allows native autocomplete,
     *                        {Boolean} updateOnAutofill (Optional) Should the input update the model in response to browser autofill events,
     *                                  used for username/password inputs, default is false
     *                        {String} elementId (Optional) Element id attribute(s) to add to control input
     *
     * TODO [JCS] Do we use prepend and append?
     */

    return Control.extend({
        moduleId: module.id,
        initialize: function() {
            var defaults = {
                inputClassName: '',
                placeholder: '',
                prepend: false,
                append: false,
                useSyntheticPlaceholder: false,
                trimLeadingSpace: true,
                trimTrailingSpace: true,
                password: false,
                updateOnKeyUp: false,
                canClear: false,
                autocomplete: false,
                elementId: ''
            };
            _.defaults(this.options, defaults);

            
            if (this.options.placeholder && !this.supportsNativePlaceholder()) {
                this.options.useSyntheticPlaceholder = true;
            }


            Control.prototype.initialize.apply(this, arguments);
        },
        events: {
            'change input[type=password], input[type=text]': function(e) {
                this.updateClear();
                this.onInputChange();
            },
            'click .placeholder': function(e) {
                this.$input.focus();
            },
            'keyup input[type=password], input[type=text]': function(e) {
                this.updateClear();
                this.updatePlaceholder();
                this.trigger("keyup", e, this.$input.val());
                if (this.options.updateOnKeyUp || e.keyCode === keyboardUtil.KEYS['ENTER']) {
                    this.onInputChange();
                }
            },

            'mouseup input[type=password], input[type=text]': function(e) { //could result in pasted text
                this.updateClear();
                this.updatePlaceholder();
            },
            'click a.control-clear': function(e) {
                e.preventDefault();
                this.clear();
                this.updateClear();
                this.updatePlaceholder();
            },
            // The input event is fired by Firefox when auto-filling a text box.
            'input input': function() {
                if (this.options.updateOnAutofill) {
                    this.updateClear();
                    this.onInputChange();
                }
            }
        },
        focus: function() {
            this.$("input").focus();
        },
        onInputChange: function() {
            var inputValue = this.$input.val();
            if(this.options.trimLeadingSpace) {
                inputValue = inputValue.replace(/^\s+/g, '');
            }
            if(this.options.trimTrailingSpace) {
                inputValue = inputValue.replace(/\s+$/g, '');
            }
            this.setValue(inputValue, false);
            this.updatePlaceholder();
        },

        updatePlaceholder: function() {
           if (this.options.useSyntheticPlaceholder)
               this.$placeholder[this.$input.val() === '' ? 'show' : 'hide']();
        },
        supportsNativePlaceholder: function() {
            return ('placeholder' in document.createElement('input'));
        },
        disable: function(){
            if (this.$input) {
                this.$input.hide();
            }
            if (this.$disabledInput) {
                this.$disabledInput.css('display', 'inline-block');
            }
        },
        enable: function(){
            if (this.$input) {
                this.$input.show();
            }
            if (this.$disabledInput) {
                this.$disabledInput.hide();
            }
        },
        updateClear: function(){
            this.$clear[this.$input.val() ? 'show' : 'hide']();
        },
        clear: function(){
            this.$input.val('');
            this.setValue('');
        },
        render: function() {
            if (!this.el.innerHTML) {
                var template = _.template(this.template, {
                        options: this.options,
                        value: (_.isUndefined(this._value) || _.isNull(this._value)) ? '' : this._value
                    });

                this.$el.html(template);
                this.$input = this.$('input');
                this.$disabledInput = this.$('.uneditable-input');
                if (this.options.useSyntheticPlaceholder)
                    this.$placeholder = this.$('.placeholder');
                if (this.options.prepend)
                    this.$el.addClass('input-prepend').prepend(this.options.prepend);
                if (this.options.append)
                    this.$el.addClass('input-append').append(this.options.append);

                // Black magic to listen for changes due to auto-filling of the text input by the browser.
                // In IE, the "change" and "input" events are not fired in this case.
                if (this.options.updateOnAutofill && userAgent.isIE()) {
                    this.$input[0].onpropertychange = _.debounce(function() {
                        if (this.$clear) {
                            this.updateClear();
                        }
                        this.onInputChange();
                    }.bind(this), 50);
                }
            } else {
                this.$input.val(this._value);
                this.$disabledInput.text(this._value);
            }
            this.updatePlaceholder();

            var additionalClassNames = this.options.additionalClassNames;
            if(additionalClassNames) {
                this.$el.addClass(additionalClassNames);
            }

            this.$clear = this.$('.control-clear');
            this.updateClear();

            return this;
        },
        remove: function() {
            if (this.$input && this.$input.length > 0) {
                this.$input[0].onpropertychange = null;
            }
            return Control.prototype.remove.apply(this, arguments);
        },
        // TODO: the `for` control-controlCid needs to be hooked up to the input with same `id`
        template: '\
        <span class="uneditable-input <%= options.inputClassName %>" \
            <% if(options.enabled){ %>style="display:none"<%}%>><%- value %></span>\
        <input type="<% if (options.password){%>password<%}else{%>text<%}%>" \
               name="<%- options.modelAttribute || "" %>" \
               class="<%- options.canClear ? "text-clear " : "" %><%- options.inputClassName%>"\
               value="<%- value %>" \
               autocomplete="<% if (options.autocomplete){ %>on<% } else { %>off<% } %>" \
               <% if(options.elementId){ %>id="<%- options.elementId %>"<%}%> \
               <% if(options.placeholder && !options.useSyntheticPlaceholder){ %>placeholder="<%- options.placeholder %>"<%}%> \
               <% if(!options.enabled){ %>style="display:none"<%}%>>\
            <% if (options.useSyntheticPlaceholder) { %> <span class="placeholder"><%- options.placeholder %></span><% } %>\
            <% if (options.canClear) { %><a href="#" class="control-clear" style="display:none"><i class="icon-x-circle"></i></a><% } %>\
        '
    });
});

define(
    'util/dom_utils',[],
    function() {
        
        //see: http://stackoverflow.com/questions/512528/set-cursor-position-in-html-textbox
        //submission by mcpDESIGNS
        var setCaretPosition = function(el, caretPos) {
            if (el) {
                el.value = el.value;
                // ^ this is used to not only get "focus", but
                // to make sure we don't have it everything -selected-
                // (it causes an issue in chrome, and having it doesn't hurt any other browser)

                if (el.createTextRange) {
                    var range = el.createTextRange();
                    range.move('character', caretPos);
                    range.select();
                    return true;
                } else {
                    // (el.selectionStart === 0 added for Firefox bug)
                    if (el.setSelectionRange && (el.selectionStart || el.selectionStart === 0)) {
                        el.focus();
                        el.setSelectionRange(caretPos, caretPos);
                        return true;
                    } else { // fail city, fortunately this never happens (as far as I've tested) :)
                        el.focus();
                        return false;
                    }
                }
            }
            
            return false;
        };
        
        //see: http://stackoverflow.com/questions/2897155/get-cursor-position-within-an-text-input-field
        //sbumission by Max
        var getCaretPosition = function(el) {
            var caretPos, selection;
            
            if (el) {
                if (el.selectionStart || el.selectionStart === 0) {
                    caretPos = el.selectionStart;
                } else if (document.selection) {
                    // IE Support
                    el.focus();
                    selection = document.selection.createRange();
                    selection.moveStart('character', -el.value.length);
                    caretPos = selection.text.length;
                }
            }
            
            return caretPos;
        };
        
        var supportsNativePlaceholder = function() {
            return ('placeholder' in document.createElement('input'));
        };
        
        return {
            setCaretPosition: setCaretPosition,
            getCaretPosition: getCaretPosition,
            supportsNativePlaceholder: supportsNativePlaceholder
        };        
    }
);
define('views/shared/controls/TextareaControl',['underscore', 'module', 'views/shared/controls/Control', 'util/dom_utils'], function(_, module, Control, dom_utils) {
    /**
     * Textarea with Bootstrap markup
     *
     * @param {Object} options
     *                        {String} modelAttribute The attribute on the model to observe and update on selection
     *                        {Object} model The model to operate on
     *                        {String} textareaClassName (Optional) Class attribute for the textarea
     *                        {String} additionalClassNames (Optional) Class attribute(s) to add to control
     */
    var ENTER_KEY = 13;

    return Control.extend({
        moduleId: module.id,
        initialize: function() {
            var defaults = {
                    textareaClassName: '',
                    placeholder: '',
                    useSyntheticPlaceholder: false,
                    trimLeadingSpace: true,
                    trimTrailingSpace: true,
                    spellcheck: true
            };
            _.defaults(this.options, defaults);
           
            if (this.options.placeholder && !dom_utils.supportsNativePlaceholder()) {
                this.options.useSyntheticPlaceholder = true;
            }
            
            Control.prototype.initialize.apply(this, arguments);
        },
        events: {
            'change textarea': function(e) {
                if (this.options.enabled) {
                    var textareaValue = this.$('textarea').val();
                    if(this.options.trimLeadingSpace) {
                        textareaValue = textareaValue.replace(/^\s+/g, '');
                    }
                    if(this.options.trimTrailingSpace) {
                        textareaValue = textareaValue.replace(/\s+$/g, '');
                    }
                    this.setValue(textareaValue, false);
                    this.updatePlaceholder();
                }
            },
            'click .placeholder': function(e) {
                if (this.options.enabled)
                    this.$textarea.focus();
            },
            'keyup textarea': function(e) {
                this.updatePlaceholder();
            },
            'mouseup textarea': function(e) { //could result in pasted text
                this.updatePlaceholder();
            },
            'keypress textarea': function(e) {
                // Eat the Enter event since the textarea input handles this event. Ideally we'd call preventDefault
                // and listen for defaultPrevented, but this isn't
                if (e.which == ENTER_KEY) {
                    e.stopPropagation();
                }
            }
        },
        updatePlaceholder: function() {
           if (this.options.useSyntheticPlaceholder) {
                this.$placeholder[this.$textarea.val() === '' ? 'show' : 'hide']();
           }
        },
        disable: function(){
            this.options.enabled = false;
            this.$textarea.hide();
            this.$disabledTextarea.show();
        },
        enable: function(){
            this.options.enabled = true;
            this.$textarea.show();
            this.$disabledTextarea.hide();
        },
        render: function() {
            if (!this.el.innerHTML) {
                var template = _.template(this.template, {
                        options: this.options,
                        value: (_.isUndefined(this._value) || _.isNull(this._value)) ? '' : this._value
                    });
                this.$el.html(template);
                this.$textarea = this.$('textarea');
                this.$disabledTextarea = this.$('.uneditable-input');
                if (this.options.useSyntheticPlaceholder) {
                    this.$placeholder = this.$('.placeholder');
                }
            } else {
                this.$textarea.val(this._value);
                this.$disabledTextarea.text(this._value);
            }
            this.updatePlaceholder();
            
            var additionalClassNames = this.options.additionalClassNames;
            if(additionalClassNames) {
                this.$el.addClass(additionalClassNames);
            }

            return this;
        },
        template: '\
            <span class="uneditable-input uneditable-input-multiline \
                        <%= options.textareaClassName %>" \
                    <% if(options.enabled){ %>\
                        style="display:none"\
                    <%}%>><%- value %></span>\
            <textarea type="text" \
                        name="<%- options.modelAttribute || "" %>" \
                        class="<%= options.textareaClassName %>" \
                        <% if(options.placeholder && !options.useSyntheticPlaceholder){ %>\
                           placeholder="<%- options.placeholder %>"\
                        <%}%> \
                        <% if(!options.enabled){ %>\
                            style="display:none"\
                        <%}%>\
                        <% if(!options.spellcheck){ %>\
                            spellcheck="false"\
                        <%}%>\
            ><%- value %></textarea>\
            <% if (options.useSyntheticPlaceholder) { %> \
                <span class="placeholder"><%- options.placeholder %></span>\
            <% } %>\
        '
    });
});

// Generated by CoffeeScript 1.6.3
/*
Copyright 2013 Marco Braak

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


(function() {
  var $, BorderDropHint, DragAndDropHandler, DragElement, FolderElement, GhostDropHint, HitAreasGenerator, JqTreeWidget, KeyHandler, MouseWidget, Node, NodeElement, Position, SaveStateHandler, ScrollHandler, SelectNodeHandler, SimpleWidget, VisibleNodeIterator, html_escape, indexOf, json_escapable, json_meta, json_quote, json_str, _indexOf, _ref, _ref1, _ref2,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  $ = this.jQuery;

  SimpleWidget = (function() {
    SimpleWidget.prototype.defaults = {};

    function SimpleWidget(el, options) {
      this.$el = $(el);
      this.options = $.extend({}, this.defaults, options);
    }

    SimpleWidget.prototype.destroy = function() {
      return this._deinit();
    };

    SimpleWidget.prototype._init = function() {
      return null;
    };

    SimpleWidget.prototype._deinit = function() {
      return null;
    };

    SimpleWidget.register = function(widget_class, widget_name) {
      var callFunction, createWidget, destroyWidget, getDataKey;
      getDataKey = function() {
        return "simple_widget_" + widget_name;
      };
      createWidget = function($el, options) {
        var data_key, el, widget, _i, _len;
        data_key = getDataKey();
        for (_i = 0, _len = $el.length; _i < _len; _i++) {
          el = $el[_i];
          widget = new widget_class(el, options);
          if (!$.data(el, data_key)) {
            $.data(el, data_key, widget);
          }
          widget._init();
        }
        return $el;
      };
      destroyWidget = function($el) {
        var data_key, el, widget, _i, _len, _results;
        data_key = getDataKey();
        _results = [];
        for (_i = 0, _len = $el.length; _i < _len; _i++) {
          el = $el[_i];
          widget = $.data(el, data_key);
          if (widget && (widget instanceof SimpleWidget)) {
            widget.destroy();
          }
          _results.push($.removeData(el, data_key));
        }
        return _results;
      };
      callFunction = function($el, function_name, args) {
        var el, result, widget, widget_function, _i, _len;
        result = null;
        for (_i = 0, _len = $el.length; _i < _len; _i++) {
          el = $el[_i];
          widget = $.data(el, getDataKey());
          if (widget && (widget instanceof SimpleWidget)) {
            widget_function = widget[function_name];
            if (widget_function && (typeof widget_function === 'function')) {
              result = widget_function.apply(widget, args);
            }
          }
        }
        return result;
      };
      return $.fn[widget_name] = function() {
        var $el, args, argument1, function_name, options;
        argument1 = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        $el = this;
        if (argument1 === void 0 || typeof argument1 === 'object') {
          options = argument1;
          return createWidget($el, options);
        } else if (typeof argument1 === 'string' && argument1[0] !== '_') {
          function_name = argument1;
          if (function_name === 'destroy') {
            return destroyWidget($el);
          } else {
            return callFunction($el, function_name, args);
          }
        }
      };
    };

    return SimpleWidget;

  })();

  this.SimpleWidget = SimpleWidget;

  /*
  This widget does the same a the mouse widget in jqueryui.
  */


  MouseWidget = (function(_super) {
    __extends(MouseWidget, _super);

    function MouseWidget() {
      _ref = MouseWidget.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    MouseWidget.is_mouse_handled = false;

    MouseWidget.prototype._init = function() {
      this.$el.bind('mousedown.mousewidget', $.proxy(this._mouseDown, this));
      this.$el.bind('touchstart.mousewidget', $.proxy(this._touchStart, this));
      this.is_mouse_started = false;
      this.mouse_delay = 0;
      this._mouse_delay_timer = null;
      this._is_mouse_delay_met = true;
      return this.mouse_down_info = null;
    };

    MouseWidget.prototype._deinit = function() {
      var $document;
      this.$el.unbind('mousedown.mousewidget');
      this.$el.unbind('touchstart.mousewidget');
      $document = $(document);
      $document.unbind('mousemove.mousewidget');
      return $document.unbind('mouseup.mousewidget');
    };

    MouseWidget.prototype._mouseDown = function(e) {
      var result;
      if (e.which !== 1) {
        return;
      }
      result = this._handleMouseDown(e, this._getPositionInfo(e));
      if (result) {
        e.preventDefault();
      }
      return result;
    };

    MouseWidget.prototype._handleMouseDown = function(e, position_info) {
      if (MouseWidget.is_mouse_handled) {
        return;
      }
      if (this.is_mouse_started) {
        this._handleMouseUp(position_info);
      }
      this.mouse_down_info = position_info;
      if (!this._mouseCapture(position_info)) {
        return;
      }
      this._handleStartMouse();
      this.is_mouse_handled = true;
      return true;
    };

    MouseWidget.prototype._handleStartMouse = function() {
      var $document;
      $document = $(document);
      $document.bind('mousemove.mousewidget', $.proxy(this._mouseMove, this));
      $document.bind('touchmove.mousewidget', $.proxy(this._touchMove, this));
      $document.bind('mouseup.mousewidget', $.proxy(this._mouseUp, this));
      $document.bind('touchend.mousewidget', $.proxy(this._touchEnd, this));
      if (this.mouse_delay) {
        return this._startMouseDelayTimer();
      }
    };

    MouseWidget.prototype._startMouseDelayTimer = function() {
      var _this = this;
      if (this._mouse_delay_timer) {
        clearTimeout(this._mouse_delay_timer);
      }
      this._mouse_delay_timer = setTimeout(function() {
        return _this._is_mouse_delay_met = true;
      }, this.mouse_delay);
      return this._is_mouse_delay_met = false;
    };

    MouseWidget.prototype._mouseMove = function(e) {
      return this._handleMouseMove(e, this._getPositionInfo(e));
    };

    MouseWidget.prototype._handleMouseMove = function(e, position_info) {
      if (this.is_mouse_started) {
        this._mouseDrag(position_info);
        return e.preventDefault();
      }
      if (this.mouse_delay && !this._is_mouse_delay_met) {
        return true;
      }
      this.is_mouse_started = this._mouseStart(this.mouse_down_info) !== false;
      if (this.is_mouse_started) {
        this._mouseDrag(position_info);
      } else {
        this._handleMouseUp(position_info);
      }
      return !this.is_mouse_started;
    };

    MouseWidget.prototype._getPositionInfo = function(e) {
      return {
        page_x: e.pageX,
        page_y: e.pageY,
        target: e.target,
        original_event: e
      };
    };

    MouseWidget.prototype._mouseUp = function(e) {
      return this._handleMouseUp(this._getPositionInfo(e));
    };

    MouseWidget.prototype._handleMouseUp = function(position_info) {
      var $document;
      $document = $(document);
      $document.unbind('mousemove.mousewidget');
      $document.unbind('touchmove.mousewidget');
      $document.unbind('mouseup.mousewidget');
      $document.unbind('touchend.mousewidget');
      if (this.is_mouse_started) {
        this.is_mouse_started = false;
        this._mouseStop(position_info);
      }
    };

    MouseWidget.prototype._mouseCapture = function(position_info) {
      return true;
    };

    MouseWidget.prototype._mouseStart = function(position_info) {
      return null;
    };

    MouseWidget.prototype._mouseDrag = function(position_info) {
      return null;
    };

    MouseWidget.prototype._mouseStop = function(position_info) {
      return null;
    };

    MouseWidget.prototype.setMouseDelay = function(mouse_delay) {
      return this.mouse_delay = mouse_delay;
    };

    MouseWidget.prototype._touchStart = function(e) {
      var touch;
      if (e.originalEvent.touches.length > 1) {
        return;
      }
      touch = e.originalEvent.changedTouches[0];
      return this._handleMouseDown(e, this._getPositionInfo(touch));
    };

    MouseWidget.prototype._touchMove = function(e) {
      var touch;
      if (e.originalEvent.touches.length > 1) {
        return;
      }
      touch = e.originalEvent.changedTouches[0];
      return this._handleMouseMove(e, this._getPositionInfo(touch));
    };

    MouseWidget.prototype._touchEnd = function(e) {
      var touch;
      if (e.originalEvent.touches.length > 1) {
        return;
      }
      touch = e.originalEvent.changedTouches[0];
      return this._handleMouseUp(this._getPositionInfo(touch));
    };

    return MouseWidget;

  })(SimpleWidget);

  this.Tree = {};

  $ = this.jQuery;

  Position = {
    getName: function(position) {
      return Position.strings[position - 1];
    },
    nameToIndex: function(name) {
      var i, _i, _ref1;
      for (i = _i = 1, _ref1 = Position.strings.length; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
        if (Position.strings[i - 1] === name) {
          return i;
        }
      }
      return 0;
    }
  };

  Position.BEFORE = 1;

  Position.AFTER = 2;

  Position.INSIDE = 3;

  Position.NONE = 4;

  Position.strings = ['before', 'after', 'inside', 'none'];

  this.Tree.Position = Position;

  Node = (function() {
    function Node(o, is_root, node_class) {
      if (is_root == null) {
        is_root = false;
      }
      if (node_class == null) {
        node_class = Node;
      }
      this.setData(o);
      this.children = [];
      this.parent = null;
      if (is_root) {
        this.id_mapping = {};
        this.tree = this;
        this.node_class = node_class;
      }
    }

    Node.prototype.setData = function(o) {
      var key, value, _results;
      if (typeof o !== 'object') {
        return this.name = o;
      } else {
        _results = [];
        for (key in o) {
          value = o[key];
          if (key === 'label') {
            _results.push(this.name = value);
          } else {
            _results.push(this[key] = value);
          }
        }
        return _results;
      }
    };

    Node.prototype.initFromData = function(data) {
      var addChildren, addNode,
        _this = this;
      addNode = function(node_data) {
        _this.setData(node_data);
        if (node_data.children) {
          return addChildren(node_data.children);
        }
      };
      addChildren = function(children_data) {
        var child, node, _i, _len;
        for (_i = 0, _len = children_data.length; _i < _len; _i++) {
          child = children_data[_i];
          node = new _this.tree.node_class('');
          node.initFromData(child);
          _this.addChild(node);
        }
        return null;
      };
      addNode(data);
      return null;
    };

    /*
    Create tree from data.

    Structure of data is:
    [
        {
            label: 'node1',
            children: [
                { label: 'child1' },
                { label: 'child2' }
            ]
        },
        {
            label: 'node2'
        }
    ]
    */


    Node.prototype.loadFromData = function(data) {
      var node, o, _i, _len;
      this.removeChildren();
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        o = data[_i];
        node = new this.tree.node_class(o);
        this.addChild(node);
        if (typeof o === 'object' && o.children) {
          node.loadFromData(o.children);
        }
      }
      return null;
    };

    /*
    Add child.

    tree.addChild(
        new Node('child1')
    );
    */


    Node.prototype.addChild = function(node) {
      this.children.push(node);
      return node._setParent(this);
    };

    /*
    Add child at position. Index starts at 0.

    tree.addChildAtPosition(
        new Node('abc'),
        1
    );
    */


    Node.prototype.addChildAtPosition = function(node, index) {
      this.children.splice(index, 0, node);
      return node._setParent(this);
    };

    Node.prototype._setParent = function(parent) {
      this.parent = parent;
      this.tree = parent.tree;
      return this.tree.addNodeToIndex(this);
    };

    /*
    Remove child. This also removes the children of the node.

    tree.removeChild(tree.children[0]);
    */


    Node.prototype.removeChild = function(node) {
      node.removeChildren();
      return this._removeChild(node);
    };

    Node.prototype._removeChild = function(node) {
      this.children.splice(this.getChildIndex(node), 1);
      return this.tree.removeNodeFromIndex(node);
    };

    /*
    Get child index.

    var index = getChildIndex(node);
    */


    Node.prototype.getChildIndex = function(node) {
      return $.inArray(node, this.children);
    };

    /*
    Does the tree have children?

    if (tree.hasChildren()) {
        //
    }
    */


    Node.prototype.hasChildren = function() {
      return this.children.length !== 0;
    };

    Node.prototype.isFolder = function() {
      return this.hasChildren() || this.load_on_demand;
    };

    /*
    Iterate over all the nodes in the tree.

    Calls callback with (node, level).

    The callback must return true to continue the iteration on current node.

    tree.iterate(
        function(node, level) {
           console.log(node.name);

           // stop iteration after level 2
           return (level <= 2);
        }
    );
    */


    Node.prototype.iterate = function(callback) {
      var _iterate,
        _this = this;
      _iterate = function(node, level) {
        var child, result, _i, _len, _ref1;
        if (node.children) {
          _ref1 = node.children;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            child = _ref1[_i];
            result = callback(child, level);
            if (_this.hasChildren() && result) {
              _iterate(child, level + 1);
            }
          }
          return null;
        }
      };
      _iterate(this, 0);
      return null;
    };

    /*
    Move node relative to another node.

    Argument position: Position.BEFORE, Position.AFTER or Position.Inside

    // move node1 after node2
    tree.moveNode(node1, node2, Position.AFTER);
    */


    Node.prototype.moveNode = function(moved_node, target_node, position) {
      if (moved_node.isParentOf(target_node)) {
        return;
      }
      moved_node.parent._removeChild(moved_node);
      if (position === Position.AFTER) {
        return target_node.parent.addChildAtPosition(moved_node, target_node.parent.getChildIndex(target_node) + 1);
      } else if (position === Position.BEFORE) {
        return target_node.parent.addChildAtPosition(moved_node, target_node.parent.getChildIndex(target_node));
      } else if (position === Position.INSIDE) {
        return target_node.addChildAtPosition(moved_node, 0);
      }
    };

    /*
    Get the tree as data.
    */


    Node.prototype.getData = function() {
      var getDataFromNodes,
        _this = this;
      getDataFromNodes = function(nodes) {
        var data, k, node, tmp_node, v, _i, _len;
        data = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          tmp_node = {};
          for (k in node) {
            v = node[k];
            if ((k !== 'parent' && k !== 'children' && k !== 'element' && k !== 'tree') && Object.prototype.hasOwnProperty.call(node, k)) {
              tmp_node[k] = v;
            }
          }
          if (node.hasChildren()) {
            tmp_node.children = getDataFromNodes(node.children);
          }
          data.push(tmp_node);
        }
        return data;
      };
      return getDataFromNodes(this.children);
    };

    Node.prototype.getNodeByName = function(name) {
      var result;
      result = null;
      this.iterate(function(node) {
        if (node.name === name) {
          result = node;
          return false;
        } else {
          return true;
        }
      });
      return result;
    };

    Node.prototype.addAfter = function(node_info) {
      var child_index, node;
      if (!this.parent) {
        return null;
      } else {
        node = new this.tree.node_class(node_info);
        child_index = this.parent.getChildIndex(this);
        this.parent.addChildAtPosition(node, child_index + 1);
        return node;
      }
    };

    Node.prototype.addBefore = function(node_info) {
      var child_index, node;
      if (!this.parent) {
        return null;
      } else {
        node = new this.tree.node_class(node_info);
        child_index = this.parent.getChildIndex(this);
        this.parent.addChildAtPosition(node, child_index);
        return node;
      }
    };

    Node.prototype.addParent = function(node_info) {
      var child, new_parent, original_parent, _i, _len, _ref1;
      if (!this.parent) {
        return null;
      } else {
        new_parent = new this.tree.node_class(node_info);
        new_parent._setParent(this.tree);
        original_parent = this.parent;
        _ref1 = original_parent.children;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          child = _ref1[_i];
          new_parent.addChild(child);
        }
        original_parent.children = [];
        original_parent.addChild(new_parent);
        return new_parent;
      }
    };

    Node.prototype.remove = function() {
      if (this.parent) {
        this.parent.removeChild(this);
        return this.parent = null;
      }
    };

    Node.prototype.append = function(node_info) {
      var node;
      node = new this.tree.node_class(node_info);
      this.addChild(node);
      return node;
    };

    Node.prototype.prepend = function(node_info) {
      var node;
      node = new this.tree.node_class(node_info);
      this.addChildAtPosition(node, 0);
      return node;
    };

    Node.prototype.isParentOf = function(node) {
      var parent;
      parent = node.parent;
      while (parent) {
        if (parent === this) {
          return true;
        }
        parent = parent.parent;
      }
      return false;
    };

    Node.prototype.getLevel = function() {
      var level, node;
      level = 0;
      node = this;
      while (node.parent) {
        level += 1;
        node = node.parent;
      }
      return level;
    };

    Node.prototype.getNodeById = function(node_id) {
      return this.id_mapping[node_id];
    };

    Node.prototype.addNodeToIndex = function(node) {
      if (node.id != null) {
        return this.id_mapping[node.id] = node;
      }
    };

    Node.prototype.removeNodeFromIndex = function(node) {
      if (node.id != null) {
        return delete this.id_mapping[node.id];
      }
    };

    Node.prototype.removeChildren = function() {
      var _this = this;
      this.iterate(function(child) {
        _this.tree.removeNodeFromIndex(child);
        return true;
      });
      return this.children = [];
    };

    Node.prototype.getPreviousSibling = function() {
      var previous_index;
      if (!this.parent) {
        return null;
      } else {
        previous_index = this.parent.getChildIndex(this) - 1;
        if (previous_index >= 0) {
          return this.parent.children[previous_index];
        } else {
          return null;
        }
      }
    };

    Node.prototype.getNextSibling = function() {
      var next_index;
      if (!this.parent) {
        return null;
      } else {
        next_index = this.parent.getChildIndex(this) + 1;
        if (next_index < this.parent.children.length) {
          return this.parent.children[next_index];
        } else {
          return null;
        }
      }
    };

    return Node;

  })();

  this.Tree.Node = Node;

  /*
  Copyright 2013 Marco Braak

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  */


  JqTreeWidget = (function(_super) {
    __extends(JqTreeWidget, _super);

    function JqTreeWidget() {
      _ref1 = JqTreeWidget.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    JqTreeWidget.prototype.defaults = {
      autoOpen: false,
      saveState: false,
      dragAndDrop: false,
      selectable: true,
      useContextMenu: true,
      onCanSelectNode: null,
      onSetStateFromStorage: null,
      onGetStateFromStorage: null,
      onCreateLi: null,
      onIsMoveHandle: null,
      onCanMove: null,
      onCanMoveTo: null,
      onLoadFailed: null,
      autoEscape: true,
      dataUrl: null,
      closedIcon: '&#x25ba;',
      openedIcon: '&#x25bc;',
      slide: true,
      nodeClass: Node,
      dataFilter: null,
      keyboardSupport: true,
      openFolderDelay: 500
    };

    JqTreeWidget.prototype.toggle = function(node, slide) {
      if (slide == null) {
        slide = true;
      }
      if (node.is_open) {
        return this.closeNode(node, slide);
      } else {
        return this.openNode(node, slide);
      }
    };

    JqTreeWidget.prototype.getTree = function() {
      return this.tree;
    };

    JqTreeWidget.prototype.selectNode = function(node) {
      return this._selectNode(node, false);
    };

    JqTreeWidget.prototype._selectNode = function(node, must_toggle) {
      var canSelect, deselected_node, openParents, saveState,
        _this = this;
      if (must_toggle == null) {
        must_toggle = false;
      }
      if (!this.select_node_handler) {
        return;
      }
      canSelect = function() {
        if (_this.options.onCanSelectNode) {
          return _this.options.selectable && _this.options.onCanSelectNode(node);
        } else {
          return _this.options.selectable;
        }
      };
      openParents = function() {
        var parent;
        parent = node.parent;
        if (parent && parent.parent && !parent.is_open) {
          return _this.openNode(parent, false);
        }
      };
      saveState = function() {
        if (_this.options.saveState) {
          return _this.save_state_handler.saveState();
        }
      };
      if (!node) {
        this._deselectCurrentNode();
        saveState();
        return;
      }
      if (!canSelect()) {
        return;
      }
      if (this.select_node_handler.isNodeSelected(node)) {
        if (must_toggle) {
          this._deselectCurrentNode();
          this._triggerEvent('tree.select', {
            node: null,
            previous_node: node
          });
        }
      } else {
        deselected_node = this.getSelectedNode();
        this._deselectCurrentNode();
        this.addToSelection(node);
        this._triggerEvent('tree.select', {
          node: node,
          deselected_node: deselected_node
        });
        openParents();
      }
      return saveState();
    };

    JqTreeWidget.prototype.getSelectedNode = function() {
      return this.select_node_handler.getSelectedNode();
    };

    JqTreeWidget.prototype.toJson = function() {
      return JSON.stringify(this.tree.getData());
    };

    JqTreeWidget.prototype.loadData = function(data, parent_node) {
      return this._loadData(data, parent_node);
    };

    JqTreeWidget.prototype.loadDataFromUrl = function(url, parent_node, on_finished) {
      if ($.type(url) !== 'string') {
        on_finished = parent_node;
        parent_node = url;
        url = null;
      }
      return this._loadDataFromUrl(url, parent_node, on_finished);
    };

    JqTreeWidget.prototype._loadDataFromUrl = function(url_info, parent_node, on_finished) {
      var $el, addLoadingClass, parseUrlInfo, removeLoadingClass,
        _this = this;
      $el = null;
      addLoadingClass = function() {
        var folder_element;
        if (!parent_node) {
          $el = _this.element;
        } else {
          folder_element = new FolderElement(parent_node, _this);
          $el = folder_element.getLi();
        }
        return $el.addClass('jqtree-loading');
      };
      removeLoadingClass = function() {
        if ($el) {
          return $el.removeClass('jqtree-loading');
        }
      };
      parseUrlInfo = function() {
        if ($.type(url_info) === 'string') {
          url_info = {
            url: url_info
          };
        }
        if (!url_info.method) {
          return url_info.method = 'get';
        }
      };
      addLoadingClass();
      if (!url_info) {
        url_info = this._getDataUrlInfo(parent_node);
      }
      parseUrlInfo();
      return $.ajax({
        url: url_info.url,
        data: url_info.data,
        type: url_info.method.toUpperCase(),
        cache: false,
        dataType: 'json',
        success: function(response) {
          var data;
          if ($.isArray(response) || typeof response === 'object') {
            data = response;
          } else {
            data = $.parseJSON(response);
          }
          if (_this.options.dataFilter) {
            data = _this.options.dataFilter(data);
          }
          removeLoadingClass();
          _this._loadData(data, parent_node);
          if (on_finished && $.isFunction(on_finished)) {
            return on_finished();
          }
        },
        error: function(response) {
          removeLoadingClass();
          if (_this.options.onLoadFailed) {
            return _this.options.onLoadFailed(response);
          }
        }
      });
    };

    JqTreeWidget.prototype._loadData = function(data, parent_node) {
      var n, selected_nodes_under_parent, _i, _len;
      if (!data) {
        return;
      }
      this._triggerEvent('tree.load_data', {
        tree_data: data
      });
      if (!parent_node) {
        this._initTree(data);
      } else {
        selected_nodes_under_parent = this.select_node_handler.getSelectedNodes(parent_node);
        for (_i = 0, _len = selected_nodes_under_parent.length; _i < _len; _i++) {
          n = selected_nodes_under_parent[_i];
          this.select_node_handler.removeFromSelection(n);
        }
        parent_node.loadFromData(data);
        parent_node.load_on_demand = false;
        this._refreshElements(parent_node.parent);
      }
      if (this.is_dragging) {
        return this.dnd_handler.refreshHitAreas();
      }
    };

    JqTreeWidget.prototype.getNodeById = function(node_id) {
      return this.tree.getNodeById(node_id);
    };

    JqTreeWidget.prototype.getNodeByName = function(name) {
      return this.tree.getNodeByName(name);
    };

    JqTreeWidget.prototype.openNode = function(node, slide) {
      if (slide == null) {
        slide = true;
      }
      return this._openNode(node, slide);
    };

    JqTreeWidget.prototype._openNode = function(node, slide, on_finished) {
      var doOpenNode, parent,
        _this = this;
      if (slide == null) {
        slide = true;
      }
      doOpenNode = function(_node, _slide, _on_finished) {
        var folder_element;
        folder_element = new FolderElement(_node, _this);
        return folder_element.open(_on_finished, _slide);
      };
      if (node.isFolder()) {
        if (node.load_on_demand) {
          return this._loadFolderOnDemand(node, slide, on_finished);
        } else {
          parent = node.parent;
          while (parent && !parent.is_open) {
            if (parent.parent) {
              doOpenNode(parent, false, null);
            }
            parent = parent.parent;
          }
          doOpenNode(node, slide, on_finished);
          return this._saveState();
        }
      }
    };

    JqTreeWidget.prototype._loadFolderOnDemand = function(node, slide, on_finished) {
      var _this = this;
      if (slide == null) {
        slide = true;
      }
      return this._loadDataFromUrl(null, node, function() {
        return _this._openNode(node, slide, on_finished);
      });
    };

    JqTreeWidget.prototype.closeNode = function(node, slide) {
      if (slide == null) {
        slide = true;
      }
      if (node.isFolder()) {
        new FolderElement(node, this).close(slide);
        return this._saveState();
      }
    };

    JqTreeWidget.prototype.isDragging = function() {
      return this.is_dragging;
    };

    JqTreeWidget.prototype.refreshHitAreas = function() {
      return this.dnd_handler.refreshHitAreas();
    };

    JqTreeWidget.prototype.addNodeAfter = function(new_node_info, existing_node) {
      var new_node;
      new_node = existing_node.addAfter(new_node_info);
      this._refreshElements(existing_node.parent);
      return new_node;
    };

    JqTreeWidget.prototype.addNodeBefore = function(new_node_info, existing_node) {
      var new_node;
      new_node = existing_node.addBefore(new_node_info);
      this._refreshElements(existing_node.parent);
      return new_node;
    };

    JqTreeWidget.prototype.addParentNode = function(new_node_info, existing_node) {
      var new_node;
      new_node = existing_node.addParent(new_node_info);
      this._refreshElements(new_node.parent);
      return new_node;
    };

    JqTreeWidget.prototype.removeNode = function(node) {
      var parent;
      parent = node.parent;
      if (parent) {
        this.select_node_handler.removeFromSelection(node, true);
        node.remove();
        return this._refreshElements(parent.parent);
      }
    };

    JqTreeWidget.prototype.appendNode = function(new_node_info, parent_node) {
      var is_already_folder_node, node;
      if (!parent_node) {
        parent_node = this.tree;
      }
      is_already_folder_node = parent_node.isFolder();
      node = parent_node.append(new_node_info);
      if (is_already_folder_node) {
        this._refreshElements(parent_node);
      } else {
        this._refreshElements(parent_node.parent);
      }
      return node;
    };

    JqTreeWidget.prototype.prependNode = function(new_node_info, parent_node) {
      var node;
      if (!parent_node) {
        parent_node = this.tree;
      }
      node = parent_node.prepend(new_node_info);
      this._refreshElements(parent_node);
      return node;
    };

    JqTreeWidget.prototype.updateNode = function(node, data) {
      var id_is_changed;
      id_is_changed = data.id && data.id !== node.id;
      if (id_is_changed) {
        this.tree.removeNodeFromIndex(node);
      }
      node.setData(data);
      if (id_is_changed) {
        this.tree.addNodeToIndex(node);
      }
      this._refreshElements(node.parent);
      return this._selectCurrentNode();
    };

    JqTreeWidget.prototype.moveNode = function(node, target_node, position) {
      var position_index;
      position_index = Position.nameToIndex(position);
      this.tree.moveNode(node, target_node, position_index);
      return this._refreshElements();
    };

    JqTreeWidget.prototype.getStateFromStorage = function() {
      return this.save_state_handler.getStateFromStorage();
    };

    JqTreeWidget.prototype.addToSelection = function(node) {
      this.select_node_handler.addToSelection(node);
      return this._getNodeElementForNode(node).select();
    };

    JqTreeWidget.prototype.getSelectedNodes = function() {
      return this.select_node_handler.getSelectedNodes();
    };

    JqTreeWidget.prototype.isNodeSelected = function(node) {
      return this.select_node_handler.isNodeSelected(node);
    };

    JqTreeWidget.prototype.removeFromSelection = function(node) {
      this.select_node_handler.removeFromSelection(node);
      return this._getNodeElementForNode(node).deselect();
    };

    JqTreeWidget.prototype.scrollToNode = function(node) {
      var $element, top;
      $element = $(node.element);
      top = $element.offset().top - this.$el.offset().top;
      return this.scroll_handler.scrollTo(top);
    };

    JqTreeWidget.prototype.getState = function() {
      return this.save_state_handler.getState();
    };

    JqTreeWidget.prototype.setState = function(state) {
      this.save_state_handler.setState(state);
      return this._refreshElements();
    };

    JqTreeWidget.prototype._init = function() {
      JqTreeWidget.__super__._init.call(this);
      this.element = this.$el;
      this.mouse_delay = 300;
      this.is_initialized = false;
      if (typeof SaveStateHandler !== "undefined" && SaveStateHandler !== null) {
        this.save_state_handler = new SaveStateHandler(this);
      } else {
        this.options.saveState = false;
      }
      if (typeof SelectNodeHandler !== "undefined" && SelectNodeHandler !== null) {
        this.select_node_handler = new SelectNodeHandler(this);
      }
      if (typeof DragAndDropHandler !== "undefined" && DragAndDropHandler !== null) {
        this.dnd_handler = new DragAndDropHandler(this);
      } else {
        this.options.dragAndDrop = false;
      }
      if (typeof ScrollHandler !== "undefined" && ScrollHandler !== null) {
        this.scroll_handler = new ScrollHandler(this);
      }
      if ((typeof KeyHandler !== "undefined" && KeyHandler !== null) && (typeof SelectNodeHandler !== "undefined" && SelectNodeHandler !== null)) {
        this.key_handler = new KeyHandler(this);
      }
      this._initData();
      this.element.click($.proxy(this._click, this));
      this.element.dblclick($.proxy(this._dblclick, this));
      if (this.options.useContextMenu) {
        return this.element.bind('contextmenu', $.proxy(this._contextmenu, this));
      }
    };

    JqTreeWidget.prototype._deinit = function() {
      this.element.empty();
      this.element.unbind();
      this.key_handler.deinit();
      this.tree = null;
      return JqTreeWidget.__super__._deinit.call(this);
    };

    JqTreeWidget.prototype._initData = function() {
      if (this.options.data) {
        return this._loadData(this.options.data);
      } else {
        return this._loadDataFromUrl(this._getDataUrlInfo());
      }
    };

    JqTreeWidget.prototype._getDataUrlInfo = function(node) {
      var data_url, getUrlFromString,
        _this = this;
      data_url = this.options.dataUrl || this.element.data('url');
      getUrlFromString = function() {
        var data, selected_node_id, url_info;
        url_info = {
          url: data_url
        };
        if (node && node.id) {
          data = {
            node: node.id
          };
          url_info['data'] = data;
        } else {
          selected_node_id = _this._getNodeIdToBeSelected();
          if (selected_node_id) {
            data = {
              selected_node: selected_node_id
            };
            url_info['data'] = data;
          }
        }
        return url_info;
      };
      if ($.isFunction(data_url)) {
        return data_url(node);
      } else if ($.type(data_url) === 'string') {
        return getUrlFromString();
      } else {
        return data_url;
      }
    };

    JqTreeWidget.prototype._getNodeIdToBeSelected = function() {
      if (this.options.saveState) {
        return this.save_state_handler.getNodeIdToBeSelected();
      } else {
        return null;
      }
    };

    JqTreeWidget.prototype._initTree = function(data) {
      this.tree = new this.options.nodeClass(null, true, this.options.nodeClass);
      if (this.select_node_handler) {
        this.select_node_handler.clear();
      }
      this.tree.loadFromData(data);
      this._openNodes();
      this._refreshElements();
      if (!this.is_initialized) {
        this.is_initialized = true;
        return this._triggerEvent('tree.init');
      }
    };

    JqTreeWidget.prototype._openNodes = function() {
      var max_level;
      if (this.options.saveState) {
        if (this.save_state_handler.restoreState()) {
          return;
        }
      }
      if (this.options.autoOpen === false) {
        return;
      } else if (this.options.autoOpen === true) {
        max_level = -1;
      } else {
        max_level = parseInt(this.options.autoOpen);
      }
      return this.tree.iterate(function(node, level) {
        if (node.hasChildren()) {
          node.is_open = true;
        }
        return level !== max_level;
      });
    };

    JqTreeWidget.prototype._refreshElements = function(from_node) {
      var $element, createFolderLi, createLi, createNodeLi, createUl, doCreateDomElements, escapeIfNecessary, is_root_node, node_element,
        _this = this;
      if (from_node == null) {
        from_node = null;
      }
      escapeIfNecessary = function(value) {
        if (_this.options.autoEscape) {
          return html_escape(value);
        } else {
          return value;
        }
      };
      createUl = function(is_root_node) {
        var class_string;
        if (is_root_node) {
          class_string = 'jqtree-tree';
        } else {
          class_string = '';
        }
        return $("<ul class=\"jqtree_common " + class_string + "\"></ul>");
      };
      createLi = function(node) {
        var $li;
        if (node.isFolder()) {
          $li = createFolderLi(node);
        } else {
          $li = createNodeLi(node);
        }
        if (_this.options.onCreateLi) {
          _this.options.onCreateLi(node, $li);
        }
        return $li;
      };
      createNodeLi = function(node) {
        var class_string, escaped_name, li_classes;
        li_classes = ['jqtree_common'];
        if (_this.select_node_handler && _this.select_node_handler.isNodeSelected(node)) {
          li_classes.push('jqtree-selected');
        }
        class_string = li_classes.join(' ');
        escaped_name = escapeIfNecessary(node.name);
        return $("<li class=\"" + class_string + "\"><div class=\"jqtree-element jqtree_common\"><span class=\"jqtree-title jqtree_common\">" + escaped_name + "</span></div></li>");
      };
      createFolderLi = function(node) {
        var button_char, button_classes, escaped_name, folder_classes, getButtonClasses, getFolderClasses;
        getButtonClasses = function() {
          var classes;
          classes = ['jqtree-toggler'];
          if (!node.is_open) {
            classes.push('jqtree-closed');
          }
          return classes.join(' ');
        };
        getFolderClasses = function() {
          var classes;
          classes = ['jqtree-folder'];
          if (!node.is_open) {
            classes.push('jqtree-closed');
          }
          if (_this.select_node_handler && _this.select_node_handler.isNodeSelected(node)) {
            classes.push('jqtree-selected');
          }
          return classes.join(' ');
        };
        button_classes = getButtonClasses();
        folder_classes = getFolderClasses();
        escaped_name = escapeIfNecessary(node.name);
        if (node.is_open) {
          button_char = _this.options.openedIcon;
        } else {
          button_char = _this.options.closedIcon;
        }
        return $("<li class=\"jqtree_common " + folder_classes + "\"><div class=\"jqtree-element jqtree_common\"><a class=\"jqtree_common " + button_classes + "\">" + button_char + "</a><span class=\"jqtree_common jqtree-title\">" + escaped_name + "</span></div></li>");
      };
      doCreateDomElements = function($element, children, is_root_node, is_open) {
        var $li, $ul, child, _i, _len;
        $ul = createUl(is_root_node);
        $element.append($ul);
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          $li = createLi(child);
          $ul.append($li);
          child.element = $li[0];
          $li.data('node', child);
          if (child.hasChildren()) {
            doCreateDomElements($li, child.children, false, child.is_open);
          }
        }
        return null;
      };
      if (from_node && from_node.parent) {
        is_root_node = false;
        node_element = this._getNodeElementForNode(from_node);
        node_element.getUl().remove();
        $element = node_element.$element;
      } else {
        from_node = this.tree;
        $element = this.element;
        $element.empty();
        is_root_node = true;
      }
      doCreateDomElements($element, from_node.children, is_root_node, is_root_node);
      return this._triggerEvent('tree.refresh');
    };

    JqTreeWidget.prototype._click = function(e) {
      var click_target, event, node;
      click_target = this._getClickTarget(e.target);
      if (click_target) {
        if (click_target.type === 'button') {
          this.toggle(click_target.node, this.options.slide);
          e.preventDefault();
          return e.stopPropagation();
        } else if (click_target.type === 'label') {
          node = click_target.node;
          event = this._triggerEvent('tree.click', {
            node: node,
            click_event: e
          });
          if (!event.isDefaultPrevented()) {
            return this._selectNode(node, true);
          }
        }
      }
    };

    JqTreeWidget.prototype._dblclick = function(e) {
      var click_target;
      click_target = this._getClickTarget(e.target);
      if (click_target && click_target.type === 'label') {
        return this._triggerEvent('tree.dblclick', {
          node: click_target.node,
          click_event: e
        });
      }
    };

    JqTreeWidget.prototype._getClickTarget = function(element) {
      var $button, $el, $target, node;
      $target = $(element);
      $button = $target.closest('.jqtree-toggler');
      if ($button.length) {
        node = this._getNode($button);
        if (node) {
          return {
            type: 'button',
            node: node
          };
        }
      } else {
        $el = $target.closest('.jqtree-element');
        if ($el.length) {
          node = this._getNode($el);
          if (node) {
            return {
              type: 'label',
              node: node
            };
          }
        }
      }
      return null;
    };

    JqTreeWidget.prototype._getNode = function($element) {
      var $li;
      $li = $element.closest('li');
      if ($li.length === 0) {
        return null;
      } else {
        return $li.data('node');
      }
    };

    JqTreeWidget.prototype._getNodeElementForNode = function(node) {
      if (node.isFolder()) {
        return new FolderElement(node, this);
      } else {
        return new NodeElement(node, this);
      }
    };

    JqTreeWidget.prototype._getNodeElement = function($element) {
      var node;
      node = this._getNode($element);
      if (node) {
        return this._getNodeElementForNode(node);
      } else {
        return null;
      }
    };

    JqTreeWidget.prototype._contextmenu = function(e) {
      var $div, node;
      $div = $(e.target).closest('ul.jqtree-tree .jqtree-element');
      if ($div.length) {
        node = this._getNode($div);
        if (node) {
          e.preventDefault();
          e.stopPropagation();
          this._triggerEvent('tree.contextmenu', {
            node: node,
            click_event: e
          });
          return false;
        }
      }
    };

    JqTreeWidget.prototype._saveState = function() {
      if (this.options.saveState) {
        return this.save_state_handler.saveState();
      }
    };

    JqTreeWidget.prototype._mouseCapture = function(position_info) {
      if (this.options.dragAndDrop) {
        return this.dnd_handler.mouseCapture(position_info);
      } else {
        return false;
      }
    };

    JqTreeWidget.prototype._mouseStart = function(position_info) {
      if (this.options.dragAndDrop) {
        return this.dnd_handler.mouseStart(position_info);
      } else {
        return false;
      }
    };

    JqTreeWidget.prototype._mouseDrag = function(position_info) {
      var result;
      if (this.options.dragAndDrop) {
        result = this.dnd_handler.mouseDrag(position_info);
        if (this.scroll_handler) {
          this.scroll_handler.checkScrolling();
        }
        return result;
      } else {
        return false;
      }
    };

    JqTreeWidget.prototype._mouseStop = function(position_info) {
      if (this.options.dragAndDrop) {
        return this.dnd_handler.mouseStop(position_info);
      } else {
        return false;
      }
    };

    JqTreeWidget.prototype._triggerEvent = function(event_name, values) {
      var event;
      event = $.Event(event_name);
      $.extend(event, values);
      this.element.trigger(event);
      return event;
    };

    JqTreeWidget.prototype.testGenerateHitAreas = function(moving_node) {
      this.dnd_handler.current_item = this._getNodeElementForNode(moving_node);
      this.dnd_handler.generateHitAreas();
      return this.dnd_handler.hit_areas;
    };

    JqTreeWidget.prototype._selectCurrentNode = function() {
      var node, node_element;
      node = this.getSelectedNode();
      if (node) {
        node_element = this._getNodeElementForNode(node);
        if (node_element) {
          return node_element.select();
        }
      }
    };

    JqTreeWidget.prototype._deselectCurrentNode = function() {
      var node;
      node = this.getSelectedNode();
      if (node) {
        return this.removeFromSelection(node);
      }
    };

    return JqTreeWidget;

  })(MouseWidget);

  SimpleWidget.register(JqTreeWidget, 'tree');

  NodeElement = (function() {
    function NodeElement(node, tree_widget) {
      this.init(node, tree_widget);
    }

    NodeElement.prototype.init = function(node, tree_widget) {
      this.node = node;
      this.tree_widget = tree_widget;
      return this.$element = $(node.element);
    };

    NodeElement.prototype.getUl = function() {
      return this.$element.children('ul:first');
    };

    NodeElement.prototype.getSpan = function() {
      return this.$element.children('.jqtree-element').find('span.jqtree-title');
    };

    NodeElement.prototype.getLi = function() {
      return this.$element;
    };

    NodeElement.prototype.addDropHint = function(position) {
      if (position === Position.INSIDE) {
        return new BorderDropHint(this.$element);
      } else {
        return new GhostDropHint(this.node, this.$element, position);
      }
    };

    NodeElement.prototype.select = function() {
      return this.getLi().addClass('jqtree-selected');
    };

    NodeElement.prototype.deselect = function() {
      return this.getLi().removeClass('jqtree-selected');
    };

    return NodeElement;

  })();

  FolderElement = (function(_super) {
    __extends(FolderElement, _super);

    function FolderElement() {
      _ref2 = FolderElement.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    FolderElement.prototype.open = function(on_finished, slide) {
      var $button, doOpen,
        _this = this;
      if (slide == null) {
        slide = true;
      }
      if (!this.node.is_open) {
        this.node.is_open = true;
        $button = this.getButton();
        $button.removeClass('jqtree-closed');
        $button.html(this.tree_widget.options.openedIcon);
        doOpen = function() {
          _this.getLi().removeClass('jqtree-closed');
          if (on_finished) {
            on_finished();
          }
          return _this.tree_widget._triggerEvent('tree.open', {
            node: _this.node
          });
        };
        if (slide) {
          return this.getUl().slideDown('fast', doOpen);
        } else {
          this.getUl().show();
          return doOpen();
        }
      }
    };

    FolderElement.prototype.close = function(slide) {
      var $button, doClose,
        _this = this;
      if (slide == null) {
        slide = true;
      }
      if (this.node.is_open) {
        this.node.is_open = false;
        $button = this.getButton();
        $button.addClass('jqtree-closed');
        $button.html(this.tree_widget.options.closedIcon);
        doClose = function() {
          _this.getLi().addClass('jqtree-closed');
          return _this.tree_widget._triggerEvent('tree.close', {
            node: _this.node
          });
        };
        if (slide) {
          return this.getUl().slideUp('fast', doClose);
        } else {
          this.getUl().hide();
          return doClose();
        }
      }
    };

    FolderElement.prototype.getButton = function() {
      return this.$element.children('.jqtree-element').find('a.jqtree-toggler');
    };

    FolderElement.prototype.addDropHint = function(position) {
      if (!this.node.is_open && position === Position.INSIDE) {
        return new BorderDropHint(this.$element);
      } else {
        return new GhostDropHint(this.node, this.$element, position);
      }
    };

    return FolderElement;

  })(NodeElement);

  html_escape = function(string) {
    return ('' + string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
  };

  _indexOf = function(array, item) {
    var i, value, _i, _len;
    for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
      value = array[i];
      if (value === item) {
        return i;
      }
    }
    return -1;
  };

  indexOf = function(array, item) {
    if (array.indexOf) {
      return array.indexOf(item);
    } else {
      return _indexOf(array, item);
    }
  };

  this.Tree.indexOf = indexOf;

  this.Tree._indexOf = _indexOf;

  if (!((this.JSON != null) && (this.JSON.stringify != null) && typeof this.JSON.stringify === 'function')) {
    json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    json_meta = {
      '\b': '\\b',
      '\t': '\\t',
      '\n': '\\n',
      '\f': '\\f',
      '\r': '\\r',
      '"': '\\"',
      '\\': '\\\\'
    };
    json_quote = function(string) {
      json_escapable.lastIndex = 0;
      if (json_escapable.test(string)) {
        return '"' + string.replace(json_escapable, function(a) {
          var c;
          c = json_meta[a];
          return (typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4));
        }) + '"';
      } else {
        return '"' + string + '"';
      }
    };
    json_str = function(key, holder) {
      var i, k, partial, v, value, _i, _len;
      value = holder[key];
      switch (typeof value) {
        case 'string':
          return json_quote(value);
        case 'number':
          if (isFinite(value)) {
            return String(value);
          } else {
            return 'null';
          }
        case 'boolean':
        case 'null':
          return String(value);
        case 'object':
          if (!value) {
            return 'null';
          }
          partial = [];
          if (Object.prototype.toString.apply(value) === '[object Array]') {
            for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
              v = value[i];
              partial[i] = json_str(i, value) || 'null';
            }
            return (partial.length === 0 ? '[]' : '[' + partial.join(',') + ']');
          }
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v = json_str(k, value);
              if (v) {
                partial.push(json_quote(k) + ':' + v);
              }
            }
          }
          return (partial.length === 0 ? '{}' : '{' + partial.join(',') + '}');
      }
    };
    if (this.JSON == null) {
      this.JSON = {};
    }
    this.JSON.stringify = function(value) {
      return json_str('', {
        '': value
      });
    };
  }

  SaveStateHandler = (function() {
    function SaveStateHandler(tree_widget) {
      this.tree_widget = tree_widget;
    }

    SaveStateHandler.prototype.saveState = function() {
      var state;
      state = JSON.stringify(this.getState());
      if (this.tree_widget.options.onSetStateFromStorage) {
        return this.tree_widget.options.onSetStateFromStorage(state);
      } else if (this.supportsLocalStorage()) {
        return localStorage.setItem(this.getCookieName(), state);
      } else if ($.cookie) {
        $.cookie.raw = true;
        return $.cookie(this.getCookieName(), state, {
          path: '/'
        });
      }
    };

    SaveStateHandler.prototype.restoreState = function() {
      var state;
      state = this.getStateFromStorage();
      if (state) {
        this.setState($.parseJSON(state));
        return true;
      } else {
        return false;
      }
    };

    SaveStateHandler.prototype.getStateFromStorage = function() {
      if (this.tree_widget.options.onGetStateFromStorage) {
        return this.tree_widget.options.onGetStateFromStorage();
      } else if (this.supportsLocalStorage()) {
        return localStorage.getItem(this.getCookieName());
      } else if ($.cookie) {
        $.cookie.raw = true;
        return $.cookie(this.getCookieName());
      } else {
        return null;
      }
    };

    SaveStateHandler.prototype.getState = function() {
      var open_nodes, selected_node, selected_node_id,
        _this = this;
      open_nodes = [];
      this.tree_widget.tree.iterate(function(node) {
        if (node.is_open && node.id && node.hasChildren()) {
          open_nodes.push(node.id);
        }
        return true;
      });
      selected_node = this.tree_widget.getSelectedNode();
      if (selected_node) {
        selected_node_id = selected_node.id;
      } else {
        selected_node_id = '';
      }
      return {
        open_nodes: open_nodes,
        selected_node: selected_node_id
      };
    };

    SaveStateHandler.prototype.setState = function(state) {
      var open_nodes, selected_node, selected_node_id,
        _this = this;
      if (state) {
        open_nodes = state.open_nodes;
        selected_node_id = state.selected_node;
        this.tree_widget.tree.iterate(function(node) {
          node.is_open = node.id && node.hasChildren() && (indexOf(open_nodes, node.id) >= 0);
          return true;
        });
        if (selected_node_id && this.tree_widget.select_node_handler) {
          this.tree_widget.select_node_handler.clear();
          selected_node = this.tree_widget.getNodeById(selected_node_id);
          if (selected_node) {
            return this.tree_widget.select_node_handler.addToSelection(selected_node);
          }
        }
      }
    };

    SaveStateHandler.prototype.getCookieName = function() {
      if (typeof this.tree_widget.options.saveState === 'string') {
        return this.tree_widget.options.saveState;
      } else {
        return 'tree';
      }
    };

    SaveStateHandler.prototype.supportsLocalStorage = function() {
      var testSupport;
      testSupport = function() {
        var error, key;
        if (typeof localStorage === "undefined" || localStorage === null) {
          return false;
        } else {
          try {
            key = '_storage_test';
            sessionStorage.setItem(key, true);
            sessionStorage.removeItem(key);
          } catch (_error) {
            error = _error;
            return false;
          }
          return true;
        }
      };
      if (this._supportsLocalStorage == null) {
        this._supportsLocalStorage = testSupport();
      }
      return this._supportsLocalStorage;
    };

    SaveStateHandler.prototype.getNodeIdToBeSelected = function() {
      var state, state_json;
      state_json = this.getStateFromStorage();
      if (state_json) {
        state = $.parseJSON(state_json);
        return state.selected_node;
      } else {
        return null;
      }
    };

    return SaveStateHandler;

  })();

  SelectNodeHandler = (function() {
    function SelectNodeHandler(tree_widget) {
      this.tree_widget = tree_widget;
      this.clear();
    }

    SelectNodeHandler.prototype.getSelectedNode = function() {
      var selected_nodes;
      selected_nodes = this.getSelectedNodes();
      if (selected_nodes.length) {
        return selected_nodes[0];
      } else {
        return false;
      }
    };

    SelectNodeHandler.prototype.getSelectedNodes = function() {
      var id, node, selected_nodes;
      if (this.selected_single_node) {
        return [this.selected_single_node];
      } else {
        selected_nodes = [];
        for (id in this.selected_nodes) {
          node = this.tree_widget.getNodeById(id);
          if (node) {
            selected_nodes.push(node);
          }
        }
        return selected_nodes;
      }
    };

    SelectNodeHandler.prototype.isNodeSelected = function(node) {
      if (node.id) {
        return this.selected_nodes[node.id];
      } else if (this.selected_single_node) {
        return this.selected_single_node.element === node.element;
      } else {
        return false;
      }
    };

    SelectNodeHandler.prototype.clear = function() {
      this.selected_nodes = {};
      return this.selected_single_node = null;
    };

    SelectNodeHandler.prototype.removeFromSelection = function(node, include_children) {
      var _this = this;
      if (include_children == null) {
        include_children = false;
      }
      if (!node.id) {
        if (this.selected_single_node && node.element === this.selected_single_node.element) {
          return this.selected_single_node = null;
        }
      } else {
        delete this.selected_nodes[node.id];
        if (include_children) {
          return node.iterate(function(n) {
            delete _this.selected_nodes[node.id];
            return true;
          });
        }
      }
    };

    SelectNodeHandler.prototype.addToSelection = function(node) {
      if (node.id) {
        return this.selected_nodes[node.id] = true;
      } else {
        return this.selected_single_node = node;
      }
    };

    return SelectNodeHandler;

  })();

  DragAndDropHandler = (function() {
    function DragAndDropHandler(tree_widget) {
      this.tree_widget = tree_widget;
      this.hovered_area = null;
      this.$ghost = null;
      this.hit_areas = [];
      this.is_dragging = false;
    }

    DragAndDropHandler.prototype.mouseCapture = function(position_info) {
      var $element, node_element;
      $element = $(position_info.target);
      if (this.tree_widget.options.onIsMoveHandle && !this.tree_widget.options.onIsMoveHandle($element)) {
        return null;
      }
      node_element = this.tree_widget._getNodeElement($element);
      if (node_element && this.tree_widget.options.onCanMove) {
        if (!this.tree_widget.options.onCanMove(node_element.node)) {
          node_element = null;
        }
      }
      this.current_item = node_element;
      return this.current_item !== null;
    };

    DragAndDropHandler.prototype.mouseStart = function(position_info) {
      var offset;
      this.refreshHitAreas();
      offset = $(position_info.target).offset();
      this.drag_element = new DragElement(this.current_item.node, position_info.page_x - offset.left, position_info.page_y - offset.top, this.tree_widget.element);
      this.is_dragging = true;
      this.current_item.$element.addClass('jqtree-moving');
      return true;
    };

    DragAndDropHandler.prototype.mouseDrag = function(position_info) {
      var area, can_move_to;
      this.drag_element.move(position_info.page_x, position_info.page_y);
      area = this.findHoveredArea(position_info.page_x, position_info.page_y);
      can_move_to = this.canMoveToArea(area);
      if (area) {
        if (this.hovered_area !== area) {
          this.hovered_area = area;
          if (this.mustOpenFolderTimer(area)) {
            this.startOpenFolderTimer(area.node);
          }
          if (can_move_to) {
            this.updateDropHint();
          }
        }
      } else {
        this.removeHover();
        this.removeDropHint();
        this.stopOpenFolderTimer();
      }
      return true;
    };

    DragAndDropHandler.prototype.canMoveToArea = function(area) {
      var position_name;
      if (!area) {
        return false;
      } else if (this.tree_widget.options.onCanMoveTo) {
        position_name = Position.getName(area.position);
        return this.tree_widget.options.onCanMoveTo(this.current_item.node, area.node, position_name);
      } else {
        return true;
      }
    };

    DragAndDropHandler.prototype.mouseStop = function(position_info) {
      this.moveItem(position_info);
      this.clear();
      this.removeHover();
      this.removeDropHint();
      this.removeHitAreas();
      if (this.current_item) {
        this.current_item.$element.removeClass('jqtree-moving');
      }
      this.is_dragging = false;
      return false;
    };

    DragAndDropHandler.prototype.refreshHitAreas = function() {
      this.removeHitAreas();
      return this.generateHitAreas();
    };

    DragAndDropHandler.prototype.removeHitAreas = function() {
      return this.hit_areas = [];
    };

    DragAndDropHandler.prototype.clear = function() {
      this.drag_element.remove();
      return this.drag_element = null;
    };

    DragAndDropHandler.prototype.removeDropHint = function() {
      if (this.previous_ghost) {
        return this.previous_ghost.remove();
      }
    };

    DragAndDropHandler.prototype.removeHover = function() {
      return this.hovered_area = null;
    };

    DragAndDropHandler.prototype.generateHitAreas = function() {
      var hit_areas_generator;
      hit_areas_generator = new HitAreasGenerator(this.tree_widget.tree, this.current_item.node, this.getTreeDimensions().bottom);
      return this.hit_areas = hit_areas_generator.generate();
    };

    DragAndDropHandler.prototype.findHoveredArea = function(x, y) {
      var area, dimensions, high, low, mid;
      dimensions = this.getTreeDimensions();
      if (x < dimensions.left || y < dimensions.top || x > dimensions.right || y > dimensions.bottom) {
        return null;
      }
      low = 0;
      high = this.hit_areas.length;
      while (low < high) {
        mid = (low + high) >> 1;
        area = this.hit_areas[mid];
        if (y < area.top) {
          high = mid;
        } else if (y > area.bottom) {
          low = mid + 1;
        } else {
          return area;
        }
      }
      return null;
    };

    DragAndDropHandler.prototype.mustOpenFolderTimer = function(area) {
      var node;
      node = area.node;
      return node.isFolder() && !node.is_open && area.position === Position.INSIDE;
    };

    DragAndDropHandler.prototype.updateDropHint = function() {
      var node_element;
      if (!this.hovered_area) {
        return;
      }
      this.removeDropHint();
      node_element = this.tree_widget._getNodeElementForNode(this.hovered_area.node);
      return this.previous_ghost = node_element.addDropHint(this.hovered_area.position);
    };

    DragAndDropHandler.prototype.startOpenFolderTimer = function(folder) {
      var openFolder,
        _this = this;
      openFolder = function() {
        return _this.tree_widget._openNode(folder, _this.tree_widget.options.slide, function() {
          _this.refreshHitAreas();
          return _this.updateDropHint();
        });
      };
      this.stopOpenFolderTimer();
      return this.open_folder_timer = setTimeout(openFolder, this.tree_widget.options.openFolderDelay);
    };

    DragAndDropHandler.prototype.stopOpenFolderTimer = function() {
      if (this.open_folder_timer) {
        clearTimeout(this.open_folder_timer);
        return this.open_folder_timer = null;
      }
    };

    DragAndDropHandler.prototype.moveItem = function(position_info) {
      var doMove, event, moved_node, position, previous_parent, target_node,
        _this = this;
      if (this.hovered_area && this.hovered_area.position !== Position.NONE && this.canMoveToArea(this.hovered_area)) {
        moved_node = this.current_item.node;
        target_node = this.hovered_area.node;
        position = this.hovered_area.position;
        previous_parent = moved_node.parent;
        if (position === Position.INSIDE) {
          this.hovered_area.node.is_open = true;
        }
        doMove = function() {
          _this.tree_widget.tree.moveNode(moved_node, target_node, position);
          _this.tree_widget.element.empty();
          return _this.tree_widget._refreshElements();
        };
        event = this.tree_widget._triggerEvent('tree.move', {
          move_info: {
            moved_node: moved_node,
            target_node: target_node,
            position: Position.getName(position),
            previous_parent: previous_parent,
            do_move: doMove,
            original_event: position_info.original_event
          }
        });
        if (!event.isDefaultPrevented()) {
          return doMove();
        }
      }
    };

    DragAndDropHandler.prototype.getTreeDimensions = function() {
      var offset;
      offset = this.tree_widget.element.offset();
      return {
        left: offset.left,
        top: offset.top,
        right: offset.left + this.tree_widget.element.width(),
        bottom: offset.top + this.tree_widget.element.height() + 16
      };
    };

    return DragAndDropHandler;

  })();

  VisibleNodeIterator = (function() {
    function VisibleNodeIterator(tree) {
      this.tree = tree;
    }

    VisibleNodeIterator.prototype.iterate = function() {
      var is_first_node, _iterateNode,
        _this = this;
      is_first_node = true;
      _iterateNode = function(node, next_node) {
        var $element, child, children_length, i, must_iterate_inside, _i, _len, _ref3, _results;
        must_iterate_inside = (node.is_open || !node.element) && node.hasChildren();
        if (node.element) {
          $element = $(node.element);
          if (!$element.is(':visible')) {
            return;
          }
          if (is_first_node) {
            _this.handleFirstNode(node, $element);
            is_first_node = false;
          }
          if (!node.hasChildren()) {
            _this.handleNode(node, next_node, $element);
          } else if (node.is_open) {
            if (!_this.handleOpenFolder(node, $element)) {
              must_iterate_inside = false;
            }
          } else {
            _this.handleClosedFolder(node, next_node, $element);
          }
        }
        if (must_iterate_inside) {
          children_length = node.children.length;
          _ref3 = node.children;
          _results = [];
          for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
            child = _ref3[i];
            if (i === (children_length - 1)) {
              _results.push(_iterateNode(node.children[i], null));
            } else {
              _results.push(_iterateNode(node.children[i], node.children[i + 1]));
            }
          }
          return _results;
        }
      };
      return _iterateNode(this.tree, null);
    };

    VisibleNodeIterator.prototype.handleNode = function(node, next_node, $element) {};

    VisibleNodeIterator.prototype.handleOpenFolder = function(node, $element) {};

    VisibleNodeIterator.prototype.handleClosedFolder = function(node, next_node, $element) {};

    VisibleNodeIterator.prototype.handleFirstNode = function(node, $element) {};

    return VisibleNodeIterator;

  })();

  HitAreasGenerator = (function(_super) {
    __extends(HitAreasGenerator, _super);

    function HitAreasGenerator(tree, current_node, tree_bottom) {
      HitAreasGenerator.__super__.constructor.call(this, tree);
      this.current_node = current_node;
      this.tree_bottom = tree_bottom;
    }

    HitAreasGenerator.prototype.generate = function() {
      this.positions = [];
      this.last_top = 0;
      this.iterate();
      return this.generateHitAreas(this.positions);
    };

    HitAreasGenerator.prototype.getTop = function($element) {
      return $element.offset().top;
    };

    HitAreasGenerator.prototype.addPosition = function(node, position, top) {
      this.positions.push({
        top: top,
        node: node,
        position: position
      });
      return this.last_top = top;
    };

    HitAreasGenerator.prototype.handleNode = function(node, next_node, $element) {
      var top;
      top = this.getTop($element);
      if (node === this.current_node) {
        this.addPosition(node, Position.NONE, top);
      } else {
        this.addPosition(node, Position.INSIDE, top);
      }
      if (next_node === this.current_node || node === this.current_node) {
        return this.addPosition(node, Position.NONE, top);
      } else {
        return this.addPosition(node, Position.AFTER, top);
      }
    };

    HitAreasGenerator.prototype.handleOpenFolder = function(node, $element) {
      if (node === this.current_node) {
        return false;
      }
      if (node.children[0] !== this.current_node) {
        this.addPosition(node, Position.INSIDE, this.getTop($element));
      }
      return true;
    };

    HitAreasGenerator.prototype.handleClosedFolder = function(node, next_node, $element) {
      var top;
      top = this.getTop($element);
      if (node === this.current_node) {
        return this.addPosition(node, Position.NONE, top);
      } else {
        this.addPosition(node, Position.INSIDE, top);
        if (next_node !== this.current_node) {
          return this.addPosition(node, Position.AFTER, top);
        }
      }
    };

    HitAreasGenerator.prototype.handleFirstNode = function(node, $element) {
      if (node !== this.current_node) {
        return this.addPosition(node, Position.BEFORE, this.getTop($(node.element)));
      }
    };

    HitAreasGenerator.prototype.generateHitAreas = function(positions) {
      var group, hit_areas, position, previous_top, _i, _len;
      previous_top = -1;
      group = [];
      hit_areas = [];
      for (_i = 0, _len = positions.length; _i < _len; _i++) {
        position = positions[_i];
        if (position.top !== previous_top && group.length) {
          if (group.length) {
            this.generateHitAreasForGroup(hit_areas, group, previous_top, position.top);
          }
          previous_top = position.top;
          group = [];
        }
        group.push(position);
      }
      this.generateHitAreasForGroup(hit_areas, group, previous_top, this.tree_bottom);
      return hit_areas;
    };

    HitAreasGenerator.prototype.generateHitAreasForGroup = function(hit_areas, positions_in_group, top, bottom) {
      var area_height, area_top, position, _i, _len;
      area_height = (bottom - top) / positions_in_group.length;
      area_top = top;
      for (_i = 0, _len = positions_in_group.length; _i < _len; _i++) {
        position = positions_in_group[_i];
        hit_areas.push({
          top: area_top,
          bottom: area_top + area_height,
          node: position.node,
          position: position.position
        });
        area_top += area_height;
      }
      return null;
    };

    return HitAreasGenerator;

  })(VisibleNodeIterator);

  DragElement = (function() {
    function DragElement(node, offset_x, offset_y, $tree) {
      this.offset_x = offset_x;
      this.offset_y = offset_y;
      this.$element = $("<span class=\"jqtree-title jqtree-dragging\">" + node.name + "</span>");
      this.$element.css("position", "absolute");
      $tree.append(this.$element);
    }

    DragElement.prototype.move = function(page_x, page_y) {
      return this.$element.offset({
        left: page_x - this.offset_x,
        top: page_y - this.offset_y
      });
    };

    DragElement.prototype.remove = function() {
      return this.$element.remove();
    };

    return DragElement;

  })();

  GhostDropHint = (function() {
    function GhostDropHint(node, $element, position) {
      this.$element = $element;
      this.node = node;
      this.$ghost = $('<li class="jqtree_common jqtree-ghost"><span class="jqtree_common jqtree-circle"></span><span class="jqtree_common jqtree-line"></span></li>');
      if (position === Position.AFTER) {
        this.moveAfter();
      } else if (position === Position.BEFORE) {
        this.moveBefore();
      } else if (position === Position.INSIDE) {
        if (node.isFolder() && node.is_open) {
          this.moveInsideOpenFolder();
        } else {
          this.moveInside();
        }
      }
    }

    GhostDropHint.prototype.remove = function() {
      return this.$ghost.remove();
    };

    GhostDropHint.prototype.moveAfter = function() {
      return this.$element.after(this.$ghost);
    };

    GhostDropHint.prototype.moveBefore = function() {
      return this.$element.before(this.$ghost);
    };

    GhostDropHint.prototype.moveInsideOpenFolder = function() {
      return $(this.node.children[0].element).before(this.$ghost);
    };

    GhostDropHint.prototype.moveInside = function() {
      this.$element.after(this.$ghost);
      return this.$ghost.addClass('jqtree-inside');
    };

    return GhostDropHint;

  })();

  BorderDropHint = (function() {
    function BorderDropHint($element) {
      var $div, width;
      $div = $element.children('.jqtree-element');
      width = $element.width() - 4;
      this.$hint = $('<span class="jqtree-border"></span>');
      $div.append(this.$hint);
      this.$hint.css({
        width: width,
        height: $div.height() - 4
      });
    }

    BorderDropHint.prototype.remove = function() {
      return this.$hint.remove();
    };

    return BorderDropHint;

  })();

  ScrollHandler = (function() {
    function ScrollHandler(tree_widget) {
      this.tree_widget = tree_widget;
      this.previous_top = -1;
      this._initScrollParent();
    }

    ScrollHandler.prototype._initScrollParent = function() {
      var $scroll_parent, getParentWithOverflow, setDocumentAsScrollParent,
        _this = this;
      getParentWithOverflow = function() {
        var css_values, el, hasOverFlow, _i, _len, _ref3;
        css_values = ['overflow', 'overflow-y'];
        hasOverFlow = function(el) {
          var css_value, _i, _len, _ref3;
          for (_i = 0, _len = css_values.length; _i < _len; _i++) {
            css_value = css_values[_i];
            if ((_ref3 = $.css(el, css_value)) === 'auto' || _ref3 === 'scroll') {
              return true;
            }
          }
          return false;
        };
        if (hasOverFlow(_this.tree_widget.$el[0])) {
          return _this.tree_widget.$el;
        }
        _ref3 = _this.tree_widget.$el.parents();
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          el = _ref3[_i];
          if (hasOverFlow(el)) {
            return $(el);
          }
        }
        return null;
      };
      setDocumentAsScrollParent = function() {
        _this.scroll_parent_top = 0;
        return _this.$scroll_parent = null;
      };
      if (this.tree_widget.$el.css('position') === 'fixed') {
        setDocumentAsScrollParent();
      }
      $scroll_parent = getParentWithOverflow();
      if ($scroll_parent && $scroll_parent.length && $scroll_parent[0].tagName !== 'HTML') {
        this.$scroll_parent = $scroll_parent;
        return this.scroll_parent_top = this.$scroll_parent.offset().top;
      } else {
        return setDocumentAsScrollParent();
      }
    };

    ScrollHandler.prototype.checkScrolling = function() {
      var hovered_area;
      hovered_area = this.tree_widget.dnd_handler.hovered_area;
      if (hovered_area && hovered_area.top !== this.previous_top) {
        this.previous_top = hovered_area.top;
        if (this.$scroll_parent) {
          return this._handleScrollingWithScrollParent(hovered_area);
        } else {
          return this._handleScrollingWithDocument(hovered_area);
        }
      }
    };

    ScrollHandler.prototype._handleScrollingWithScrollParent = function(area) {
      var distance_bottom;
      distance_bottom = this.scroll_parent_top + this.$scroll_parent[0].offsetHeight - area.bottom;
      if (distance_bottom < 20) {
        this.$scroll_parent[0].scrollTop += 20;
        this.tree_widget.refreshHitAreas();
        return this.previous_top = -1;
      } else if ((area.top - this.scroll_parent_top) < 20) {
        this.$scroll_parent[0].scrollTop -= 20;
        this.tree_widget.refreshHitAreas();
        return this.previous_top = -1;
      }
    };

    ScrollHandler.prototype._handleScrollingWithDocument = function(area) {
      var distance_top;
      distance_top = area.top - $(document).scrollTop();
      if (distance_top < 20) {
        return $(document).scrollTop($(document).scrollTop() - 20);
      } else if ($(window).height() - (area.bottom - $(document).scrollTop()) < 20) {
        return $(document).scrollTop($(document).scrollTop() + 20);
      }
    };

    ScrollHandler.prototype.scrollTo = function(top) {
      var tree_top;
      if (this.$scroll_parent) {
        return this.$scroll_parent[0].scrollTop = top;
      } else {
        tree_top = this.tree_widget.$el.offset().top;
        return $(document).scrollTop(top + tree_top);
      }
    };

    ScrollHandler.prototype.isScrolledIntoView = function(element) {
      var $element, element_bottom, element_top, view_bottom, view_top;
      $element = $(element);
      if (this.$scroll_parent) {
        view_top = 0;
        view_bottom = this.$scroll_parent.height();
        element_top = $element.offset().top - this.scroll_parent_top;
        element_bottom = element_top + $element.height();
      } else {
        view_top = $(window).scrollTop();
        view_bottom = view_top + $(window).height();
        element_top = $element.offset().top;
        element_bottom = element_top + $element.height();
      }
      return (element_bottom <= view_bottom) && (element_top >= view_top);
    };

    return ScrollHandler;

  })();

  KeyHandler = (function() {
    var DOWN, LEFT, RIGHT, UP;

    LEFT = 37;

    UP = 38;

    RIGHT = 39;

    DOWN = 40;

    function KeyHandler(tree_widget) {
      this.tree_widget = tree_widget;
      if (tree_widget.options.keyboardSupport) {
        $(document).bind('keydown.jqtree', $.proxy(this.handleKeyDown, this));
      }
    }

    KeyHandler.prototype.deinit = function() {
      return $(document).unbind('keydown.jqtree');
    };

    KeyHandler.prototype.handleKeyDown = function(e) {
      var current_node, key, moveDown, moveLeft, moveRight, moveUp, selectNode,
        _this = this;
      if ($(document.activeElement).is('textarea,input')) {
        return true;
      }
      current_node = this.tree_widget.getSelectedNode();
      selectNode = function(node) {
        if (node) {
          _this.tree_widget.selectNode(node);
          if (_this.tree_widget.scroll_handler && (!_this.tree_widget.scroll_handler.isScrolledIntoView($(node.element).find('.jqtree-element')))) {
            _this.tree_widget.scrollToNode(node);
          }
          return false;
        } else {
          return true;
        }
      };
      moveDown = function() {
        return selectNode(_this.getNextNode(current_node));
      };
      moveUp = function() {
        return selectNode(_this.getPreviousNode(current_node));
      };
      moveRight = function() {
        if (current_node.hasChildren() && !current_node.is_open) {
          _this.tree_widget.openNode(current_node);
          return false;
        } else {
          return true;
        }
      };
      moveLeft = function() {
        if (current_node.hasChildren() && current_node.is_open) {
          _this.tree_widget.closeNode(current_node);
          return false;
        } else {
          return true;
        }
      };
      if (!current_node) {
        return true;
      } else {
        key = e.which;
        switch (key) {
          case DOWN:
            return moveDown();
          case UP:
            return moveUp();
          case RIGHT:
            return moveRight();
          case LEFT:
            return moveLeft();
        }
      }
    };

    KeyHandler.prototype.getNextNode = function(node, include_children) {
      var next_sibling;
      if (include_children == null) {
        include_children = true;
      }
      if (include_children && node.hasChildren() && node.is_open) {
        return node.children[0];
      } else {
        if (!node.parent) {
          return null;
        } else {
          next_sibling = node.getNextSibling();
          if (next_sibling) {
            return next_sibling;
          } else {
            return this.getNextNode(node.parent, false);
          }
        }
      }
    };

    KeyHandler.prototype.getPreviousNode = function(node) {
      var previous_sibling;
      if (!node.parent) {
        return null;
      } else {
        previous_sibling = node.getPreviousSibling();
        if (previous_sibling) {
          if (!previous_sibling.hasChildren() || !previous_sibling.is_open) {
            return previous_sibling;
          } else {
            return this.getLastChild(previous_sibling);
          }
        } else {
          if (node.parent.parent) {
            return node.parent;
          } else {
            return null;
          }
        }
      }
    };

    KeyHandler.prototype.getLastChild = function(node) {
      var last_child;
      if (!node.hasChildren()) {
        return null;
      } else {
        last_child = node.children[node.children.length - 1];
        if (!last_child.hasChildren() || !last_child.is_open) {
          return last_child;
        } else {
          return this.getLastChild(last_child);
        }
      }
    };

    return KeyHandler;

  })();

}).call(this);
define("tree.jquery", ["jquery"], function(){});

define(
    'views/shared/add_data/input_forms/sourceselector/Tree',[
        'underscore',
        'jquery',
        'module',
        'views/Base',
        'uri/route',
        'tree.jquery' //NO IMPORT
    ],
    function(
        _,
        $,
        module,
        Base,
        route
    ){
        return Base.extend({
            moduleId: module.id,
            className: 'treeview',
            initialize: function(options) {
                Base.prototype.initialize.apply(this, arguments);
                this.urlArgsOverride = this.options.urlArgsOverride || {};
            },
            events: {
                'tree.select': 'onTreeSelect'
            },
            onTreeSelect: function(event){
                if (event.node) {
                    this.trigger('select', event.node);
                }
            },
            render: function() {
                this.fileSystemUrl = this.options.explorerUrl;
                if (!this.fileSystemUrl){
                    return;
                }

                var tree = this.$el.tree({
                    dataUrl: function(node){
                        return this.treeUrl(node);
                    }.bind(this),
                    dataFilter: function(data){
                        var mapped = [];
                        _.each(data.entry, function(obj){
                            var loadOnDemand = false;
                            if (obj.content.hasSubNodes == true ||
                                !obj.content.hasOwnProperty('hasSubNodes') // some root nodes
                            ){
                                loadOnDemand = true;
                            }
                            mapped.push( {
                                id: obj.name,
                                label: obj.content.name || obj.name,
                                hasSubNodes: obj.content.hasSubNodes,
                                load_on_demand: loadOnDemand
                            });
                        });
                        return mapped;
                    },
                    onCanSelectNode: function(node) {
                        return true;
                    },
                    onLoadFailed: function(response) {
                        var msg = response.responseJSON.messages[0];
                        msg['html'] = msg['text'];
                        this.trigger('fetchError', msg);
                    }.bind(this),
                    onCreateLi: function(node, $li) {
                        if (!node.isFolder()) {
                            if (node.id === node.parent.id) {
                                // Hide the contents of an empty folder.
                                $li.hide();
                            }
                        }
                    }
                });

                tree.tree('loadDataFromUrl', this.treeUrl('/'), tree.children[0]);

                return this;
            },
            treeUrl: function(node) {
                node = node || {id:''};
                var urlArgs = {
                    	output_mode: 'json',
                    	count: 10000,
                    	sort_key: ['hasSubNodes', 'name'],
                    	sort_dir: 'desc',
                    	sort_mode: 'num'
                    },
                    nodeid = node.id;
                urlArgs = _.extend(urlArgs, this.urlArgsOverride);
                urlArgs = $.param(urlArgs).replace(/%5B%5D/g,'');
                
                // we have to work around the issue of http proxies automatically
                // unescaping %2F into /.  if we escape it manually once, THEN urlencode
                // the whole string, we can hide the / from these troublemakers.
                // REF- EAIOutputParameters.cpp
                if (nodeid) {
                    nodeid = nodeid.replace(/\//g, '%2F');
                }
                return this.fileSystemUrl + '/' + encodeURIComponent(nodeid || '') + '?' + urlArgs;
            }
        });
    }
);


define('contrib/text!views/shared/add_data/input_forms/sourceselector/SourceSelector.html',[],function () { return '<div class="filepath selected-path">\n    <%=selectedPath%>\n</div>';});

define(
    'views/shared/add_data/input_forms/sourceselector/SourceSelector',[
        'underscore',
        'jquery',
        'module',
        'views/Base',
        'views/shared/add_data/input_forms/sourceselector/Tree',
        'uri/route',
        'util/splunkd_utils',
        'util/string_utils',
        'contrib/text!views/shared/add_data/input_forms/sourceselector/SourceSelector.html'
    ],
    function(
        _, 
        $,
        module, 
        Base,
        Tree,
        route,
        splunkd_utils,
        stringUtils,
        template
    ){
        return Base.extend({
            moduleId: module.id,
            template: template,
            initialize: function(options) {
                var self = this;
                this.explorerUrl = null;
                this.prompt = '';
                this.selectedNode = null;

                if (this.options.browserType == 'files') {
                    this.explorerUrl = route.fileExplorer(
                        this.model.application.get("root"),
                        this.model.application.get("locale"),
                        this.model.application.get("owner"),
                        this.model.application.get("app")
                    );
                    this.prompt = _('File path').t();
                } else if (this.options.browserType == 'registry') {
                    this.explorerUrl = route.regExplorer(
                        this.model.application.get("root"),
                        this.model.application.get("locale"),
                        this.model.application.get("owner"),
                        this.model.application.get("app")
                    );
                    this.prompt = _('Registry hive').t();
                } else if (this.options.browserType == 'ad') {
                    this.explorerUrl = route.adExplorer(
                        this.model.application.get("root"),
                        this.model.application.get("locale"),
                        this.model.application.get("owner"),
                        this.model.application.get("app")
                    );
                    this.prompt = _('Active Directory path').t();
                }

                Base.prototype.initialize.apply(this, arguments);

                if (this.model.classicUrl) {
                    this.model.classicUrl.on('change:file', function(){
                        this.render();
                    }.bind(this));
                }


                this.children.tree = new Tree({
                    collection: this.collection,
                    model: this.model,
                    deferreds: this.options.deferreds,
                    explorerUrl: this.explorerUrl,
                    urlArgsOverride: this.options.urlArgsOverride
                });

                this.children.tree.on('select', function(node){
                    self.selectedNode = node;
                    self.$('.selected-path').text(
                        stringUtils.maybeAddEllipsis(node.id, 125, 45, 80));
                }, this);

                this.children.tree.on('fetchError', function(message){
                    this.options.flashMsgHelper.addGeneralMessage('fetch-error', message);
                }, this);


            },

            getSelectedNode: function() {
                return this.selectedNode;
            },

            render: function() {
            	this.$el.html(this.compiledTemplate({
                      selectedPath : this.model.sourceModel.get('input'),
                      prompt: this.prompt
                  }));
                          
                this.$el.prepend(this.children.tree.render().el);
                return this;
            }

        });
    }
);

define(
    'models/shared/FlashMessage',[
        'models/Base'
    ],
    function(BaseModel) {
        return BaseModel.extend({
            initialize: function() {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            idAttribute: 'key'
        });
    }
);

define(
        'collections/shared/FlashMessages',[
            'collections/Base',
            "models/shared/FlashMessage"
        ],
        function(BaseCollection, FlashMessageModel) {
            return BaseCollection.extend({
                model: FlashMessageModel,
                initialize: function() {
                    BaseCollection.prototype.initialize.apply(this, arguments);
                }
            });
        }
);

define(
    'helpers/FlashMessagesHelper',[
        'jquery',
        'underscore',
        'models/shared/FlashMessage',
        'util/splunkd_utils'
    ],
    function($, _, FlashMessageModel, splunkDUtils) {

        /**
         * @param flashMessagesCollection - the collection to use as the target for messages
         * @param options {Object} {
         *     removeDuplicates {Boolean} - (optional) whether to dedup messages with the same content, defaults to false
         *     postProcess {Function} - (optional) a function to perform cleanup of the messages before they are placed in the collection
         *         the list of FlashMessage models will be passed as the only argument (duplicates will already be removed if enabled)
         *         the return value will become the contents of the FlashMessages collection
         * }
         * @constructor
         */

        var FlashMessagesHelper = function(flashMessagesCollection, options) {
            this.options = options || {};
            this.defaults = $.extend(true, {}, this.options);

            _.defaults(this.defaults, {
                removeDuplicates: true,
                removeServerPrefix: false
            });
            
            if (_.isUndefined(flashMessagesCollection)) {
                throw "FlashMessagesHelper must be created with a valid FlashMessages collection";
            }
            this.flashMessagesCollection = flashMessagesCollection;
            // registered is a dictionary, indexed by model/collection cid
            // each entry is an object containing the model/collection itself,
            //      and (optionally) a whitelist of message types to broadcast
            this.registered = {};
            this.clientModelMessages = {};
            this.serverModelMessages = {};
            this.generalMessages = {};
        };

        FlashMessagesHelper.prototype = {
            // whitelist is optional, it should be a list of message types that should be broadcasted
            // if whitelist is omitted, all messages will be broadcasted
            register: function(obj, whitelist) {
                this.registered[obj.cid] = { instance: obj };
                if(whitelist) {
                    this.registered[obj.cid]['whitelist'] = _(whitelist).isArray() ? whitelist : [whitelist];
                }
                obj.on('serverValidated', _.debounce(this.serverValidationHandler, 0), this);
                obj.on("validated", _.debounce(this.clientValidationHandler, 0), this);
            },
            unregister: function(obj) {
                obj.off(null, null, this);
                delete this.clientModelMessages[obj.cid];
                delete this.serverModelMessages[obj.cid];
                delete this.registered[obj.cid];
            },
            destroy: function() {
                var registeredObjects = _(this.registered).pluck('instance');
                _(registeredObjects).each(function(obj) { this.unregister(obj); }, this);
            },
            clientValidationHandler: function(isValid, model, invalidAttrs) {
                this.clientModelMessages[model.cid] = invalidAttrs;
                this.updateFlashMessageCollection();
            },
            serverValidationHandler: function(isValid, model, messages) {
                this.serverModelMessages[model.cid] = messages;
                this.updateFlashMessageCollection();
            },
            /**
             * Manually add a message to the Flash Messages Collection. Use this if you want to display a message
             * that isn't associated with a model
             *
             * @param id - the caller must generate a unique ID for the message
             * @param message
             *              - type {string} The type of message (splunkDUtils.ERROR | splunkDUtils.WARNING | splunkDUtils.INFO)
             *              - html {string} The message text
             */
            addGeneralMessage: function(id, message) {
                this.generalMessages[id] = message;
                this.updateFlashMessageCollection();
            },
            /**
             * Remove a message from the Flash Messages Collection that was previously added via addMessage.
             *
             * @param id - the caller generated id used in the addMessage call
             */
            removeGeneralMessage: function(id) {
                if (_(this.generalMessages).has(id)) {
                    delete this.generalMessages[id];
                    this.updateFlashMessageCollection();
                }
            },

            /**
             * Returns the number of general messages
             *
             * @return {Number}
             */
            getGeneralMessagesSize: function() {
                return _(this.generalMessages).size();
            },

            /**
             * Returns the number of client validation messages
             *
             * @return {Number}
             */
            getClientModelMessagesSize: function() {
                return _(this.clientModelMessages).size();
            },

            /**
             * Returns the number of server messages
             *
             * @return {Number}
             */
            getServerModelMessagesSize: function() {
                return _(this.serverModelMessages).size();
            },

            /**
             *  Messages from splunkd usually begin with 'In handler ...:'. This method cuts it off
             * when option removeServerPrefix=true.
             */
            removeServerPrefix: function(msg) {
                if (msg.message) {
                    msg.message = msg.message.replace(/(^[\s]*In handler [^:]+:\s)/g, "");
                }
            },

            /**
             * Update the flash message collection when the clientMessages, serverMessages or generalMessages change
             */
            updateFlashMessageCollection: function() {
                var clientMessages = [], serverMessages = [], generalMessages = [];
                _(this.clientModelMessages).each(function(clientMsgs) {
                    _(clientMsgs).each(function(msg) {
                        clientMessages.push(new FlashMessageModel({ type: splunkDUtils.ERROR, html: msg }));
                    }, this);
                }, this);
                _(this.serverModelMessages).each(function(serverMsgs, cid) {
                    var whitelist = this.registered[cid] ? this.registered[cid].whitelist : null;
                    _(serverMsgs).each(function(msg) {
                        if(!whitelist || _(whitelist).contains(msg.type)) {
                            if (this.defaults.removeServerPrefix) {
                                this.removeServerPrefix(msg);
                            }
                            serverMessages.push(new FlashMessageModel({
                                type: splunkDUtils.normalizeType(msg.type),
                                // make sure to HTML-escape here, since these messages are coming from the server
                                html: _.escape(msg.message)
                            }));
                        }
                    }, this);
                }, this);
                _(this.generalMessages).each(function(msg) {
                    generalMessages.push(new FlashMessageModel({
                        type: splunkDUtils.normalizeType(msg.type),
                        html: msg.html
                    }));
                }, this);
                var allMessages = _.union(clientMessages, serverMessages, generalMessages);
                if (this.defaults.removeDuplicates) {
                    allMessages = _(allMessages).uniq(function(msg) { return msg.get('html'); });
                }
                if (this.defaults.postProcess) {
                    allMessages = this.defaults.postProcess(allMessages);
                }
                this.flashMessagesCollection.reset(allMessages);
            }
        };
    return FlashMessagesHelper;
});

define(
    'views/shared/FlashMessages',[
        'jquery',
        'underscore',
        'backbone',
        'views/Base', 
        'collections/shared/FlashMessages',
        'helpers/FlashMessagesHelper',
        'module'
    ], 
    function($, _, Backbone, Base, FlashMessagesCollection, FlashMessagesHelper,module) {
        return Base.extend({
            moduleId: module.id,
            className: 'alerts',
            collectionLength: 0,
           /**
            * @param {Object} options {
            *     model: {
            *         <name>: <model to be registered>
            *         ....
            *     },
            *     collection: {
            *         <name>: <collection to be registered>
            *         ....
            *     }
            * }
            */
            initialize: function(options){
                Base.prototype.initialize.call(this, options);
                this.flashMsgCollection = new FlashMessagesCollection();
                this.flashMsgHelper     = new FlashMessagesHelper(this.flashMsgCollection, this.options.helperOptions);
                
                this.activate({skipRender: true});

                // SPL-70327, put ourselves to sleep before the window unloads
                // this avoids rendering messages from the XHRs that are cancelled by the browser
                this.beforeUnloadHandler = _(function() { this.sleep(); }).bind(this);
                $(window).on('beforeunload', this.beforeUnloadHandler);
            },
            startListening: function() {
                this.listenTo(this.flashMsgCollection, 'add remove reset', this.onCollectionChange);
            },
            activate: function(options) {
                options = options || {};
                
                if (this.active) {
                    return Base.prototype.activate.apply(this, arguments);
                }
                
                if (this.model instanceof Backbone.Model){
                    this.flashMsgHelper.register(this.model, this.options.whitelist);
                    
                    //see if we already have errors in the model.error
                    if (this.model.error && this.model.error.get("messages")){
                        this.flashMsgHelper.serverValidationHandler(true, this.model, this.model.error.get("messages"));
                    }
                } else {
                    _(this.model).each(function(model, k) {
                        this.flashMsgHelper.register(model, this.options.whitelist);
                        
                        //see if we already have errors in the model.error
                        if (model.error && model.error.get("messages")){
                            this.flashMsgHelper.serverValidationHandler(true, model, model.error.get("messages"));
                        }
                    },this);
                }
                
                if (this.collection instanceof Backbone.Collection) {
                    this.flashMsgHelper.register(this.collection, this.options.whitelist);
                    this.collection.each(function(model){
                        this.flashMsgHelper.register(model, this.options.whitelist);
                    },this);
                } else {
                    _(this.collection).each(function(collection){
                        this.flashMsgHelper.register(collection, this.options.whitelist);
                        collection.each(function(model){
                            this.flashMsgHelper.register(model, this.options.whitelist);
                        },this);
                    },this);
                }
                
                if (!options.skipRender) {
                    this.render();
                }
                
                return Base.prototype.activate.apply(this, arguments);
            },
            deactivate: function(options) {
                if (!this.active) {
                    return Base.prototype.deactivate.apply(this, arguments);
                }
                this.flashMsgCollection.reset();
                Base.prototype.deactivate.apply(this, arguments);
                                
                if (this.model instanceof Backbone.Model){
                    this.flashMsgHelper.unregister(this.model);
                } else {
                    _(this.model).each(function(model, k) {
                        this.flashMsgHelper.unregister(model);
                    },this);
                }
                
                if (this.collection instanceof Backbone.Collection) {
                    this.flashMsgHelper.unregister(this.collection);
                    this.collection.each(function(model){
                        this.flashMsgHelper.unregister(model);
                    },this);
                } else {
                    _(this.collection).each(function(collection){
                        this.flashMsgHelper.unregister(collection);
                        collection.each(function(model){
                            this.flashMsgHelper.unregister(model);
                        },this);
                    },this);
                }
                return this;
            },
            /**
             * Listen to validation events from a given object
             *
             * @param obj - the object to listen on
             * @param whitelist (optional) - the array of event types to listen for. If ommitted, then we listen to all events
             */
            register: function(obj, whitelist) {
                this.flashMsgHelper.register(obj, whitelist);
            },
            /**
             * Stop listening to validation events from a given object
             *
             * @param obj - the object to stop listen to
             */
            unregister: function(obj) {
                this.flashMsgHelper.unregister(obj);
            },
            remove: function() {
                this.flashMsgHelper.destroy();
                $(window).off('beforeunload', this.beforeUnloadHandler);
                return Base.prototype.remove.apply(this, arguments);
            },
            onCollectionChange: function() {
                if (this.collectionLength != this.flashMsgCollection.length) {
                    // Trigger change if the number of messages has changed
                    this.trigger("change", this);
                    this.collectionLength = this.flashMsgCollection.length;
                }
                this.render();
            },
            render: function() {
                this.$el.empty();
                this.$el.append(this.compiledTemplate({ flashMessages: this.flashMsgCollection }));
                (!this.flashMsgCollection.length) ? this.$el.hide() : this.$el.show();
                return this;
            },
            template: '\
                <% flashMessages.each(function(flashMessage){ %> \
                    <div class="alert alert-<%- flashMessage.get("type") %>">\
                        <i class="icon-alert"></i>\
                        <%= flashMessage.get("html") %>\
                    </div>\
                <% }); %> \
            '
        });
    }
);

define('views/shared/add_data/input_forms/sourceselector/Master',[
    'underscore',
    'jquery',
    'module',
    'views/Base',
    'views/shared/add_data/input_forms/sourceselector/SourceSelector',
    'views/shared/FlashMessages'
],
function(
    _,
    $,
    module,
    Base,
    SourceSelector,
    FlashMessages
){	
    return Base.extend({
        moduleId: module.id,
        initialize: function(options) {
            Base.prototype.initialize.apply(this, arguments);

            this.children.flashMessages = new FlashMessages();

            this.children.selector = new SourceSelector({
                model: this.model,
                collection: this.collection,
                deferreds: this.options.deferreds,
                browserType: this.options.browserType,
                urlArgsOverride: this.options.urlArgsOverride,
                flashMsgHelper: this.children.flashMessages.flashMsgHelper
            });


        },
        getSelection: function(){
            return this.getSelectedNode().id;
        },
        getSelectedNode: function(){
            return this.children.selector.getSelectedNode();
        },
        render: function() {
            this.$el
                .append(this.children.selector.render().el)
                .append(this.children.flashMessages.render().el);
            
            return this;
        }
    });
});

define('views/shared/add_data/input_forms/SourceSelectorDialog',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/shared/add_data/input_forms/sourceselector/Master',
    'views/shared/Modal'
],
function(
    $,
    _,
    Backbone,
    module,
    SourceSelector,
    Modal
){
    return Modal.extend({
        moduleId: module.id,
        className: Modal.CLASS_NAME + " " + Modal.CLASS_MODAL_WIDE,
        initialize: function(options) {
            Modal.prototype.initialize.call(this, arguments);

            this.children.sourceSelector = new SourceSelector({
                model: this.model,
                collection: this.collection,
                deferreds: this.deferreds,
                browserType: this.options.browserType,
                urlArgsOverride: this.options.urlArgsOverride
            });
            
            this.$el.removeClass('fade');
        },
        events: $.extend({}, Modal.prototype.events, {
            'click .btn-primary': function(e) {
                this.hide();
                var selectedNode = this.children.sourceSelector.getSelectedNode();
                this.model.sourceModel.set({
                    input: selectedNode.id,
                    selectedNodeHasChildren: selectedNode.hasSubNodes
                });
            }
        }),
        render: function() {
            this.$el.html(Modal.TEMPLATE);
            this.$(Modal.BODY_SELECTOR).show();
            this.$(Modal.BODY_SELECTOR).removeClass('modal-body-scrolling').append(this.children.sourceSelector.render().el);
            this.$(Modal.HEADER_TITLE_SELECTOR).html(_("Select source").t());
            this.$(Modal.FOOTER_SELECTOR).append(Modal.BUTTON_CANCEL);
            this.$(Modal.FOOTER_SELECTOR).append('<a href="#" class="btn btn-primary modal-btn-primary">'+_('Select').t()+'</a>');
            return this;
        }
    });
});

/**
 * @author leo
 * @date 04/7/2014
 *
 * @description This component displays a textfield with a Browse button next to it, which brings
 * a popup with a treeview for selecting an item from some structure like filesystem.
 */

define(
    'views/shared/controls/TextBrowseControl',[
        'underscore',
        'views/shared/controls/TextControl',
        'views/shared/add_data/input_forms/SourceSelectorDialog',
        'module'
    ],
    function (
        _,
        TextControl,
        SourceSelectorDialog,
        module
        ) {

        return TextControl.extend({
            moduleId: module.id,
            className: 'control input-append',
            initialize: function () {
            
                 TextControl.prototype.initialize.apply(this, arguments);
                 
                 // showSourceSelectorDialog always sets input attribute, so need to remap to correct value;
                 this.options.model.on('change:input', function(val) {
                     this.options.model.set(this.options.modelAttribute, val.get('input') );
                 },this);
                 
            },
            events: $.extend({}, TextControl.prototype.events, {'click .btn' : 'showSourceSelectorDialog'}),
            showSourceSelectorDialog: function(){

                    if(!this.children.sourceSelectorDialog){
                        this.children.sourceSelectorDialog = new SourceSelectorDialog({
                            model: {
                                sourceModel: this.options.model,
                                application: this.options.applicationModel
                            },
                            browserType: this.options.browserType,
                            urlArgsOverride: this.options.urlArgsOverride
                        });
                        $('body').append(this.children.sourceSelectorDialog.render().el);
                    }
                    this.children.sourceSelectorDialog.show();

            },
            template: TextControl.prototype.template +
            '<button class="btn" id="browseBtn"><%= _("Browse").t() %></button>'
        });
    }
);
/*!
 * jQuery UI Core 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

define("jquery.ui.core", ["jquery"], function(){});

/*!
 * jQuery UI Widget 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

define("jquery.ui.widget", ["jquery.ui.core"], function(){});

/*!
 * jQuery UI Datepicker 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.10.4" } });

var PROP_NAME = "datepicker",
	instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17;

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					digits = new RegExp("^\\d{1," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate(selector, "mouseover", function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.10.4";

})(jQuery);

define("jquery.ui.datepicker", ["jquery","jquery.ui.widget","splunk.i18n"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (jQuery, widget, i18n) {
                var initFn = i18n.jQuery_ui_datepicker_install;
                if (typeof initFn === 'function') {
                    initFn(jQuery);
                }
                return jQuery.ui.datepicker;
            };
        ret = fn.apply(global, arguments);
        return ret || global.jquery.ui.datepicker;
    };
}(this)));

// footer nav
define('views/shared/controls/DateControl',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/shared/controls/Control',
    'jquery.ui.datepicker'
],
function(
    $,
    _,
    Backbone,
    module,
    Control,
    jqueryDatepicker
){
    /**
     * Synthetic Select drodpown a-la Bootstrap
     *
     * @param {Object} options
     *        {Object} model The DateTime model to operate on
     *        {String} inputClassName (Optional) Class attribute for the input
     *        {String} additionalClassNames (Optional) Class attribute(s) to add to control
     */

    return Control.extend({
        moduleId: module.id,
        tagName: 'span',
        className: 'pull-left',
        initialize: function() {
            var defaults = {
                    inputClassName: '',
                    help: 'MM/DD/YYYY'
            };
            _.defaults(this.options, defaults);
            Control.prototype.initialize.call(this, this.options);
        },
        startListening: function() {
            Control.prototype.startListening.apply(this, arguments);
            this.listenTo(this.model, 'change', this.render);
        },
        activate: function(options) {
            options = options || {};
            if (this.active) {
                return Control.prototype.activate.apply(this, arguments);
            }
            
            if (!options.skipSetValueRender) {
                this.render();
            }
            
            return Control.prototype.activate.apply(this, arguments);
        },
        events: {
            'change input[type=text]': function(e) {
                this.setValue(this.$('input').datepicker('getDate'), false);
            }
        },
        updateModel: function(options){
            options = options || {};
            var updateOptions = {
                validate: this.options.validate,
                forceUpdate: this.options.forceUpdate
            };

            $.extend(true, updateOptions, options);

            if (this.model) {
                return this.model.setMonDayYearFromJSDate(this._value, updateOptions);
            }
            return true;
        },

        render: function() {
            if (!this.el.innerHTML) {
                var template = _.template(this.template, {
                    options: this.options
                });

                this.$el.html(template);

                this.$('input').datepicker({
                    defaultDate: this.model.jsDate({includeTime:false})
                });

                var additionalClassNames = this.options.additionalClassNames;
                if(additionalClassNames) {
                    this.$el.addClass(additionalClassNames);
                }
            }

            // SPL-70724, in IE setting the same date will cause the date picker dialog to open again
            // so we first check if they are equal
            var inputDate = this.$('input').datepicker('getDate');
            var modelDate = this.model.jsDate({includeTime:false});

            if(!inputDate || inputDate.getTime() !== modelDate.getTime()) {
                this.$('input').datepicker('setDate',  modelDate);
            }
            this.$('input').blur();

            return this;
        },
        template: '\
            <input type="text" class="mdy-input <%= options.inputClassName %>" value=""/>\
        '
    });
});

define('views/shared/controls/LabelControl',['underscore', 'module', 'views/shared/controls/Control', 'bootstrap.tooltip'], function(_, module, Control /*tooltip*/) {
    /**
     * Text Input with Bootstrap markup
     *
     * @param {Object} options
     *                        {String} modelAttribute The attribute on the model to observe
     *                        {Object} model The model to observe
     *                        {String} inputClassName (Optional) Class attribute for the input
     *                        {Boolean} multiline (Optional) if enabled, behaves more like a textarea: scroll and pre-wrap
     *                        {Boolean} breakword (Optional) If true, words will break. Good for uris.
     *                        {Object} defaultValue (Optional) If the modelAttribute in the model is undefined, then
     *                                 use this value to populate the input
     *                        {String} additionalClassNames (Optional) Class attribute(s) to add to control
     *                        {String} tooltip (Optional) Text to display in the tooltip.
     */

    return Control.extend({
        moduleId: module.id,
        initialize: function() {
            var defaults = {
                inputClassName: 'input-label',
                defaultValue: 'label',
                iconSize: 'icon-large'
            };
         
            _.defaults(this.options, defaults);

            Control.prototype.initialize.apply(this, arguments);

        },
        render: function() {
            var value = (_.isUndefined(this._value) || _.isNull(this._value)) ? '' : this._value;
            
            if (!this.el.innerHTML) {
                var template = _.template(this.template, {
                        options: this.options,
                        value: value
                    });

                this.$el.html(template);
                this.$span = this.$('span');
            } else {
                this.$span.text(value);
            }

            var additionalClassNames = this.options.additionalClassNames;
            if(additionalClassNames) {
                this.$el.addClass(additionalClassNames); 
            }

            if (this.options.tooltip) {
                this.$('.tooltip-text').tooltip({animation:false, title: this.options.tooltip});
            }
            return this;
        },
        // Using concatenation for constructing the template so extra whitespace isn't introduced into the span.
        // This allows the use of preformatted text styling on the span.
        template: '' +
            '<span class="<%= options.inputClassName %><% if(options.tooltip) { %> tooltip-text<% } %>">' +
                '<% if (options.icon) { %> <i class="icon-<%-options.icon%> <%-options.iconSize%>"></i> <% } %>' +
                '<%- value %>' +
            '</span>'
    });
});

define('views/shared/controls/Accumulator',[
        'underscore',
        'module',
        'views/shared/controls/Control'
    ],
    function (
        _,
        module,
        Control
        ) {
        return Control.extend({
            moduleId: module.id,
            initialize: function() {
                var defaults = {
                    /*inputClassName: 'input-label',
                    defaultValue: 'label',
                    iconSize: 'icon-large'*/
                    itemName: _('item(s)').t()
                };

                _.defaults(this.options, defaults);

                Control.prototype.initialize.apply(this, arguments);
            },
            events: {
                'click a.addAllLink': function(e) {
                    this._addAll();
                    e.preventDefault();
                },
                'click a.removeAllLink': function(e) {
                    this._removeAll();
                    e.preventDefault();
                },
                'click .availableOptions li': function(e) {
                    var li = e.currentTarget;
                    this._addToSelected([li]);
                    e.preventDefault();
                },
                'click .selectedOptions li': function(e) {
                    var li = e.currentTarget;
                    this._removeFromSelected([li]);
                    e.preventDefault();
                }
            },

            render: function () {
                if (!this.el.innerHTML) {
                    this.$el.html(this.compiledTemplate({ options: this.options }));
                    this._populateAvailableOptions();
                    this._addPreSelected();
                    this.$('.availableOptionsHeader').text(_('Available ').t() + this.options.itemName);
                    this.$('.selectedOptionsHeader').text(_('Selected ').t() + this.options.itemName);
                }
                return this;
            },

            onInputChange: function() {
                // collect selected values and update the model
                var $selectedOptions = this.$('.selectedOptions li');
                var selectedValues = [];
                $.each($selectedOptions, function(ix, option) {
                    selectedValues.push($(option).data('id'));
                });
                this.setValue(selectedValues, false);

                // sort alphabetically
                $selectedOptions.sort(function(a,b){
                    var keyA = $(a).text();
                    var keyB = $(b).text();

                    if (keyA < keyB) return -1;
                    if (keyA > keyB) return 1;
                    return 0;
                });
                var selItemsUl = this.$('.selectedOptions');
                $.each($selectedOptions, function(i, li){
                    selItemsUl.append(li);
                });
            },

            _populateAvailableOptions: function(options) {
                var $availableOptions = this.$('.availableOptions');
                for (var i = 0, len = this.options.availableItems.length; i < len; i++) {
                    var item = this.options.availableItems[i],
                        iconClass = item['icon'],
                        $row = $('<div>').text(item['label']).append($('<span class="icon-class">').text(iconClass)),
                        opt = $('<li>').data({
                            id: item['value'],
                            label: item['label'],
                            'icon-class': iconClass
                        }).html($row);
                    $availableOptions.append(opt);
                }
            },

            _addToSelected: function(liArray) {
                var $selectedOptions = this.$('.selectedOptions');
                $.each(liArray, function(ix, li) {
                    if (!$(li).hasClass('selected')) {
                        var id = $(li).data('id'),
                            iconClass = $(li).data('icon-class'),
                            label = $(li).data('label'),
                            $row = $('<div>').text(label).append($('<span class="icon-class">').text(iconClass));
                        var newLi = $('<li>').data('id',id).html($row);
                        $selectedOptions.append(newLi);
                        $(li).addClass('selected');
                    } else {
                        this._removeFromSelected(liArray);
                    }
                }.bind(this));
                this.onInputChange();
            },
            _removeFromSelected: function(liArray) {
                $.each(liArray, function(ix, li) {
                    var id = $(li).data('id');
                    this.$('.availableOptions li').filter(function(ix,item) {
                        return $(item).data('id') == id;
                    }).removeClass("selected");
                    this.$('.selectedOptions li').filter(function(ix,item) {
                        return $(item).data('id') == id;
                    }).remove();
                }.bind(this));
                this.onInputChange();
            },
            _addAll: function() {
                var liArray = this.$('.availableOptions').find('li').not('.selected').get();
                this._addToSelected(liArray);
                this.onInputChange();
            },
            _removeAll: function() {
                this.$('.selectedOptions').find('li').remove();
                this.$('.availableOptions li.selected').removeClass("selected");
                this.onInputChange();
            },
            _addPreSelected: function() {
                if (this.options.selectedItems instanceof Array && this.options.selectedItems.length > 0) {
                    var liArray = this.$('.availableOptions li').filter(function(ix, item) {
                        return this.options.selectedItems.indexOf($(item).data('id')) > -1;
                    }.bind(this));
                    this._addToSelected(liArray);
                    this.onInputChange();
                }
            },
            remove: function () {
                return Control.prototype.remove.apply(this, arguments);
            },
            template: '\
                <style>\
                .accumulator {\
                    width: 700px;\
                }\
                .availableOptionsContainer, \
                .selectedOptionsContainer {\
                    float: left;\
                    width:300px;\
                    margin: 0px 20px 0px 0px;\
                }\
                .accumulator .addAllLink, \
                .accumulator .removeAllLink {\
                    float: right;\
                }\
                .accumulator .selectedOptionsContainer {\
                    margin-right:0px;\
                }\
                .accumulator h4 {\
                    font-weight:normal;\
                    font-size:12px;\
                    width:200px;\
                    margin-right:22px;\
                    padding-bottom:5px;\
                    line-height: 0px;\
                }\
                .accumulator h4.selectedOptionsHeader {\
                    width: 200px;\
                    margin-right:0px;\
                }\
                .accumulator ul.availableOptions,\
                .accumulator ul.selectedOptions {\
                    height:100px;\
                    overflow: auto;\
                    list-style: none none;\
                    margin: 0;\
                    padding:0;\
                    border: 1px solid #CCC;\
                    clear: left;\
                }\
                .accDisabled ul.availableOptions,\
                .accDisabled ul.selectedOptions {\
                    background-color: #f0f0f0;\
                }\
                .accumulator ul.availableOptions li,\
                .accumulator ul.selectedOptions li {\
                    clear:left;\
                    padding: 4px 5px;\
                    font-size:12px;\
                    cursor: pointer;\
                    line-height: 12px;\
                }\
                .accumulator ul.availableOptions li:hover,\
                .accumulator ul.selectedOptions li:hover {\
                    background-color: #e5f2f5;\
                }\
                .accumulator ul.availableOptions li span,\
                .accumulator ul.selectedOptions li span {\
                    margin:0px 8px 0 0;\
                    display: block;\
                    float: left;\
                }\
                .accumulator ul span.splIcon-arrow-e {\
                    background-color:  #73a550;\
                }\
                .accumulator ul.availableOptions li.selected,\
                .accDisabled ul li {\
                    color: #999;\
                }\
                .accumulator ul.availableOptions li.selected span.splIcon,\
                .accDisabled ul li span.splIcon {\
                    background-color:#CCC;\
                }\
                .accumulator .selected {\
                    background-color: transparent;\
                }\
                .accumulator .nofloat {\
                    clear: both;\
                }\
                .control-group.error ul {\
                    border-color: #d85d3c;\
                }\
                .accumulator .icon-class {\
                    color: #999999;\
                }\
                .accumulator div.wide {\
                    width: 340px;\
                }\
                </style>\
                \
                <div class="accumulator">\
                    <div class="availableOptionsContainer">\
                        <a class="addAllLink"><%= _("add all").t() %> &raquo;</a>\
                        <h4 class="availableOptionsHeader"></h4>\
                        <ul class="availableOptions"></ul>\
                    </div>\
                    \
                    <div class="selectedOptionsContainer">\
                        <a class="removeAllLink">&laquo; <%= _("remove all").t() %></a>\
                        <h4 class="selectedOptionsHeader"></h4>\
                        <ul class="selectedOptions"></ul> \
                    </div>\
                    <div class="nofloat"></div>\
                </div>'
        });
    });
// Control wrapper around a native input of type range
//
// NOTES:
// this has not been well tested


define('views/shared/controls/SliderControl',[
        'underscore',
        'module',
        'views/shared/controls/TextControl'
    ],
    function(
        _,
        module,
        TextControl
    ){
        return TextControl.extend({

            /**
            * @constructor
            * @param {Object} options {
            *     {String, required} modelAttribute The attribute on the model to observe and update on selection
            *     {Model, required} model The model to operate on
            *     {Number, optional} min The minimum allowed value. Default 0.
            *     {Number, optional} max The maximum allowed value. Default 100.
            *     {Number, optional} step The step to apply when buttons/arrow keys are used. Default 1.
            *     {String, optional} inputClassName A class name to apply to the input element
            * }
            */

            moduleId: module.id,
            initialize: function() {
                var defaults = {
                        min: '0',
                        max: '100',
                        step: '1',
                        inputClassName: '',
                        enabled: true
                };
                _.defaults(this.options, defaults);
                
                TextControl.prototype.initialize.apply(this, arguments);
            },
            events: _.extend({}, TextControl.prototype.events, {
                'change input[type=range]': function(e) {
                    this.setValue($(e.target).val(), false);
                }
            }),
            disable: function() {
                this.$('input').prop('disabled', true);
                TextControl.prototype.disable.call(this);
            },
            enable: function() {
                this.$('input').prop('disabled', false);
                TextControl.prototype.enable.call(this);
            },
            render: function() {
                if (!this.el.innerHTML) {
                    TextControl.prototype.render.call(this);
                    this.$el.prepend(_.template(this.sliderTemplate, {
                      options: this.options,
                      value: this._value
                    }));
                } else {
                    this.$('input').val(this._value);
                }
            },
            sliderTemplate: '\
                <input  class="slider <%= options.inputClassName %>" type="range" \
                min="<%- options.min %>" max="<%- options.max %>" \
                step="<%- options.step %>" value="<%- value %>" />\
            '
        });
    }
);
define(
    'views/shared/controls/ControlGroup',[
        'jquery',
        'underscore',
        'module',
        'backbone',
        'views/Base',
        'views/shared/controls/Control',
        'views/shared/controls/SyntheticSelectControl',
        'views/shared/controls/SyntheticRadioControl',
        'views/shared/controls/SyntheticCheckboxControl',
        'views/shared/controls/SyntheticSliderControl',
        'views/shared/controls/CheckboxGroup',
        'views/shared/controls/TextControl',
        'views/shared/controls/TextareaControl',
        'views/shared/controls/TextBrowseControl',
        'views/shared/controls/DateControl',
        'views/shared/controls/LabelControl',
        'views/shared/controls/Accumulator',
        'views/shared/controls/SliderControl',
        'bootstrap.tooltip'
    ],
    function
    (
        $,
        _,
        module,
        Backbone,
        Base,
        Control,
        SyntheticSelectControl,
        SyntheticRadioControl,
        SyntheticCheckboxControl,
        SyntheticSliderControl,
        CheckboxGroupControl,
        TextControl,
        TextareaControl,
        TextBrowseControl,
        DateControl,
        LabelControl,
        Accumulator,
        SliderControl
        //tooltip
    )
{
    /**
     * Wrapper around a Control that adds a label and an error state
     *
     * @param {Object} options
     *                        {String} controlType The attribute on the model to observe and update on selection
     *                        {Object} controlOptions dictionary passed to the control
     *                        {Array or View} controls An array of dictionaries with types and options, and/or views, or a View
     *                        {String} label (Optional) the contents of the label tag
     *                        {Boolean} error (Optional) Whether or not the control group is in an error state
     *                        {Boolean} validate (Optional) Whether controls should use validation when setting model attributes,
     *                                                          defaults to false.
     *                        {Boolean} forceUpdate (Optional) Whether controls should force updates when setting model attributes,
     *                                                          defaults to false
     *                        {Boolean} enabled (Optional) Whether the control group should appear enabled, defaults to true
     *                        {Boolean} required (Optional) Whether the control group is required and should have a red asterisk,
     *                                                          defaults to false
     *                        {String} tooltip (Optional) Text to display in the tooltip.
     */

    return Base.extend({
        className: 'control-group',
        moduleId: module.id,
        initialize: function() {
            var defaults = {
                    label: '',
                    controls:[],
                    error: false,
                    _errorMsg : "",
                    controlClass: '',
                    enabled: true,
                    required: false
            };
            _.defaults(this.options, defaults);

            if (this.options.controls.length == 0) {
                this.options.controls = [{type: this.options.controlType, options: this.options.controlOptions}];
            }

            this.controlTypes= {
                    'SyntheticSelect': SyntheticSelectControl,
                    'SyntheticRadio': SyntheticRadioControl,
                    'SyntheticCheckbox': SyntheticCheckboxControl,
                    'SyntheticSlider': SyntheticSliderControl,
                    'CheckboxGroup': CheckboxGroupControl,
                    'Text': TextControl,
                    'Textarea': TextareaControl,
                    'TextBrowse': TextBrowseControl,
                    'Date': DateControl,
                    'Label': LabelControl,
                    'Accumulator': Accumulator,
                    'Slider': SliderControl
            };

            // Allow user to pass in there own control component.
            $.extend(true, this.controlTypes, this.options.controlTypes || {});

            Base.prototype.initialize.apply(this, arguments);

            if(!this.options.enabled) {
                this.$el.addClass('disabled');
            }

            // normalize controls to an array if it's a single item
            if(!_(this.options.controls).isArray()) {
                this.options.controls = [this.options.controls];
            }

            // create a list to hold the controls (in addition to the children dictionary) so that order can be preserved
            this.childList = [];

            _.each(this.options.controls, function(control, index) {
                // if the control is already a view, just add it to the children object
                if(control instanceof Backbone.View) {
                    this.children['child' + index] = control;
                    this.childList.push(control);
                }
                // otherwise construct a new view using the "type" and "options" fields
                else {
                    // allow a control to inherit the "validate", "forceUpdate" and "enabled" properties from the group options
                    var controlOptions = $.extend(
                        true,
                        {
                            validate: !!this.options.validate,
                            forceUpdate: !!this.options.forceUpdate,
                            enabled: !!this.options.enabled
                        },
                        control.options
                    );
                    var controlView = this.children['child' + index] = new this.controlTypes[control.type](controlOptions);
                    this.childList.push(controlView);
                }
            }, this);

            this.activate();
        },
        startListening: function() {
            var perAttrValidation = {};
            if(_.isArray(this.options.controls)){
                 _.each(this.options.controls, function(control, index) {
                    if(control.options && control.options.model){
                        perAttrValidation[control.options.modelAttribute] = true;
                        this.listenTo(control.options.model, 'attributeValidated:' + control.options.modelAttribute, function(isValid, key, error){
                            perAttrValidation[key] = isValid;
                            this.error(_.any(perAttrValidation, function(value) { return !value; }));
                        });
                    }
                 },this);
            }
            
            if(this.options.controlOptions && (this.options.controlOptions.model instanceof Backbone.Model)) {
                if(!_.isArray(this.options.controlOptions)) {
                    perAttrValidation[this.options.controlOptions.modelAttribute] = true;
                    this.listenTo(this.options.controlOptions.model, 'attributeValidated:' + this.options.controlOptions.modelAttribute, function(isValid, key, error){
                        perAttrValidation[key] = isValid;
                        this.error(_.any(perAttrValidation, function(value) { return !value; }));
                    });
                }
            }
        },
        events: {
            'click a.tooltip-link': function(e) {
                e.preventDefault();
            }
        },
        render: function() {
            if(!this.el.innerHTML) {
                var template = _.template(this.template, {
                    _: _,
                    controlCid: this.children.child0.cid,
                    label: this.options.label,
                    help: this.options.help,
                    controlClass: this.options.controlClass,
                    helpClass: this.options.helpClass,
                    tooltip: this.options.tooltip,
                    required: this.options.required
                });
                this.$el.html(template);

                if (this.options.tooltip) {
                    this.$('.tooltip-link').tooltip({animation:false, title: this.options.tooltip, container: 'body'});
                }

                _.each(this.childList, function(child, i) {
                    this.$('.controls').append(child.render().$el);
                    if(!i) { 
                        child.$el.attr('id', "control-" + this.children.child0.cid);
                    }
                }, this);
                if (this.options.help) {
                    this.$('.controls').append(this.$('.help-block')); //move the help block back to the end
                }
            }

            // TODO [JCS] How come this is coming from options and not from an internal variable set in error()?
            this.error(this.options.error);

            return this;
        },
        hide: function() {
            this.$el.hide();
        },
        show: function() {
            this.$el.show();
        },
        remove: function() {
            if(this.options.tooltip) {
                this.$('.tooltip-link').tooltip('destroy');
            }
            return Base.prototype.remove.apply(this, arguments);
        },
        enable: function() {
            this.$el.removeClass('disabled');
            _(this.getAllControls()).invoke('enable');
        },
        disable: function() {
            this.$el.addClass('disabled');
            _(this.getAllControls()).invoke('disable');
        },
        getModelAttributes: function() {
            var attrs = [];
            _.each(this.childList, function(child) {
                attrs.push(child.getModelAttribute());
            }, this);
            return attrs;
        },
        error: function(state, errorMsg) {
            state ? this.$el.addClass("error") : this.$el.removeClass("error");

            // Store the error message internally. For now, we aren't displaying it.
            this._errorMsg = errorMsg;
            return this;
        },
        getAllControls: function() {
            return _(this.children).filter(function(child) { return child instanceof Control; });
        },
        // NOTE: The help text is intentionally not HTML-escaped, it is up to the caller to
        // pre-process this input as need to avoid XSS attacks.
        setHelpText: function(helpText) {
            var $helpBlock = this.$('.help-block');
            if ($helpBlock.length === 0) {
                $helpBlock = $('<span></span>').addClass('help-block').appendTo(this.$('.controls'));
            }
            $helpBlock.html(helpText);
        },
        // TODO: the `for` control-controlCid needs to be hooked up to the input with same `id`
        template: '\
                <label class="control-label" for="control-<%- controlCid %>">\
                <%- label %><% if (tooltip) { %><a href="#" class="tooltip-link"><%- _("?").t() %></a><% } %>\
                <% if (required) { %>\
                    <span class="required">*</span>\
                <% } %>\
                </label>\
                <div class="controls <%- controlClass %>">\
                <% if (help) { %> <span class="help-block <%- helpClass %>"><%= help %></span><% } %>\
                </div>\
                \
        '
    });
});

define(
    'views/shared/litebar/RestartDialog',[
        'jquery',
        'underscore',
        'backbone',
        'module',
        'splunk.util',
        'views/shared/controls/ControlGroup',
        'views/shared/Modal'
    ],
    function($, 
        _, 
        backbone, 
        module, 
        SplunkUtil,
        ControlGroup, 
        Modal
    ){
        return Modal.extend({
            moduleId: module.id,
            initialize: function() {
                Modal.prototype.initialize.apply(this, arguments);

                this._onRestartSSL = this._onRestartSSL.bind(this);

                // listen to global 'restart_ssl' event
                // try using window.$ first since event is triggered by legacy code
                (window.$ || $)(document).on('restart_ssl', this._onRestartSSL);
            },

            stopListening: function() {
                // stop listening to global 'restart_ssl' event
                // try using window.$ first since event is triggered by legacy code
                (window.$ || $)(document).off('restart_ssl', this._onRestartSSL);

                Modal.prototype.stopListening.apply(this, arguments);
            },

            render: function() {
                this.$el.html(Modal.TEMPLATE);
                this.$(Modal.HEADER_SELECTOR).html('<h3>' + _("Restart initiated.").t() + '</h3>');

                this.$(Modal.BODY_SELECTOR).append(Modal.FORM_HORIZONTAL);
                if (this._sslBase) {
                    var url = this._sslBase + SplunkUtil.make_url('/');
                    this.$(Modal.BODY_SELECTOR).append(SplunkUtil.sprintf(_('Splunk Light is restarting. Check the web_service.log file to determine when Splunk Light has restarted and then <a href="%s">click here to continue</a>.').t(), url));
                } else {
                    this.$(Modal.BODY_SELECTOR).append(_("Splunk Light is restarting. This may take a few minutes.").t());
                }
            },

            _onRestartSSL: function(e) {
                this._sslBase = e.sslBase;
                this.render();
            }

        });
    }
);

//! moment.js
//! version : 2.8.3
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {
    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = '2.8.3',
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for locale config files
        locales = {},

        // extra moment internal properties (plugins register props here)
        momentProperties = [],

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-15', '30']
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.localeData().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.localeData().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.localeData().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.localeData().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.localeData().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        deprecations = {},

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error('Implement me');
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Locale() {
    }

    // Moment prototype object
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = moment.localeData();

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment._locale[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                moment.locale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Locale
    ************************************/


    extend(Locale.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : 'h:mm A',
            L : 'MM/DD/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM D, YYYY LT'
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },

        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },

        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace('%d', number);
        },
        _ordinal : '%d',

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) {
                return parseTokenOneDigit;
            }
            /* falls through */
        case 'SS':
            if (strict) {
                return parseTokenTwoDigits;
            }
            /* falls through */
        case 'SSS':
            if (strict) {
                return parseTokenThreeDigits;
            }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return config._locale._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return parseTokenOrdinal;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || '';
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = config._locale.monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = config._locale.isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = config._locale.weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += 'Z';
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            years = round(duration.as('y')),

            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days < relativeTimeThresholds.d && ['dd', days] ||
                months === 1 && ['M'] ||
                months < relativeTimeThresholds.M && ['MM', months] ||
                years === 1 && ['y'] || ['yy', years];

        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || moment.localeData(config._l);

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i);
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            diffRes;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function (threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };

    moment.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        function (key, value) {
            return moment.locale(key, value);
        }
    );

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    moment.locale = function (key, values) {
        var data;
        if (key) {
            if (typeof(values) !== 'undefined') {
                data = moment.defineLocale(key, values);
            }
            else {
                data = moment.localeData(key);
            }

            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }

        return moment._locale._abbr;
    };

    moment.defineLocale = function (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            moment.locale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    };

    moment.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        function (key) {
            return moment.localeData(key);
        }
    );

    // returns locale data
    moment.localeData = function (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return moment._locale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function (keepLocalTime) {
            return this.zone(0, keepLocalTime);
        },

        local : function (keepLocalTime) {
            if (this._isUTC) {
                this.zone(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.add(this._dateTzOffset(), 'm');
                }
            }
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },

        add : createAdder(1, 'add'),

        subtract : createAdder(-1, 'subtract'),

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output, daysAdjust;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                daysAdjust = (this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'));
                // same as above but with zones, to negate all dst
                daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4;
                output += daysAdjust / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf : function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        },

        isAfter: function (input, units) {
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                return +this.clone().startOf(units) > +moment(input).startOf(units);
            }
        },

        isBefore: function (input, units) {
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                return +this.clone().startOf(units) < +moment(input).startOf(units);
            }
        },

        isSame: function (input, units) {
            units = normalizeUnits(units || 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
            }
        },

        min: deprecate(
                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateTzOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.subtract(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._dateTzOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? 'UTC' : '';
        },

        zoneName : function () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        week : function (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        locale : function (key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },

        lang : deprecate(
            'moment().lang() is deprecated. Use moment().localeData() instead.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        ),

        localeData : function () {
            return this._locale;
        },

        _dateTzOffset : function () {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absRound(years / 4) -
        //     absRound(years / 100) + absRound(years / 400);
        return years * 146097 / 400;
    }

    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);

            // Accurately convert days to years, assume start from year 0.
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));

            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absRound(days / 30);
            days %= 30;

            // 12 months -> 1 year
            years += absRound(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;
        },

        abs : function () {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);

            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);

            return this;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());

            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }

            return this.localeData().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            var days, months;
            units = normalizeUnits(units);

            if (units === 'month' || units === 'year') {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + yearsToDays(this._months / 12);
                switch (units) {
                    case 'week': return days / 7 + this._milliseconds / 6048e5;
                    case 'day': return days + this._milliseconds / 864e5;
                    case 'hour': return days * 24 + this._milliseconds / 36e5;
                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        },

        lang : moment.fn.lang,
        locale : moment.fn.locale,

        toIsoString : deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead ' +
            '(notice the capitals)',
            function () {
                return this.toISOString();
            }
        ),

        toISOString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        },

        localeData : function () {
            return this._locale;
        }
    });

    moment.duration.fn.toString = moment.duration.fn.toISOString;

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }

    moment.duration.fn.asMilliseconds = function () {
        return this.as('ms');
    };
    moment.duration.fn.asSeconds = function () {
        return this.as('s');
    };
    moment.duration.fn.asMinutes = function () {
        return this.as('m');
    };
    moment.duration.fn.asHours = function () {
        return this.as('h');
    };
    moment.duration.fn.asDays = function () {
        return this.as('d');
    };
    moment.duration.fn.asWeeks = function () {
        return this.as('weeks');
    };
    moment.duration.fn.asMonths = function () {
        return this.as('M');
    };
    moment.duration.fn.asYears = function () {
        return this.as('y');
    };

    /************************************
        Default Locale
    ************************************/


    // Set default locale, other locale will inherit from English.
    moment.locale('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LOCALES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    'Accessing Moment through the global scope is ' +
                    'deprecated, and will be removed in an upcoming ' +
                    'release.',
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === 'function' && define.amd) {
        define('moment', ['require','exports','module'],function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);
define('util/moment',['splunk.i18n', 'moment'],function(i18n, moment){
    var initFn = i18n.moment_install;
    if(typeof initFn === 'function') {
        initFn(moment);
    }
    return moment;
});
define(
    'util/time',[
        'underscore',
        'splunk.i18n',
        'splunk.util',
        'util/moment',
        'util/console'
    ],
    function(_, i18n, splunkUtils, moment, console) {

        var BD_TIME_REGEX_MILLIS = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d+)[+-]{1}\d{2}[:]?\d{2}$/,
            BD_TIME_REGEX_NO_MILLIS = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})[+-]{1}\d{2}[:]?\d{2}$/,
            STRIP_TIMEZONE_REGEX = /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.{0,1}(\d*))[+-]{1}\d{2}[:]?\d{2}$/,
            u = {},
            language = i18n.locale_name().substring(0, 2),
            ISO_PATTERN = '%Y-%m-%dT%H:%M:%S.%Q%:z';
        
        u.s = u.sec = u.secs = u.second = u.seconds = {abbr: "s",  singular: _("second").t(), plural: _("seconds").t()};
        u.m = u.min = u.mins = u.minute = u.minutes = {abbr: "m", singular: _("minute").t(), plural: _("minutes").t()};
        u.h = u.hr  = u.hrs  = u.hour   = u.hours   = {abbr: "h", singular: _("hour").t(), plural: _("hours").t()};
        u.d = u.day = u.days = {abbr: "d", singular: _("day").t(), plural: _("days").t()};
        u.w = u.week = u.weeks = {abbr: "w", singular: _("week").t(), plural: _("weeks").t()};
        u.mon = u.month = u.months = {abbr: "mon", singular: _("month").t(), plural: _("months").t()};
        u.q = u.qtr = u.qtrs = u.quarter = u.quarters = {abbr: "q", singular: _("quarter").t(), plural: _("quarters").t()};
        u.y = u.yr = u.yrs = u.year = u.years = {abbr: "y", singular: _("year").t(), plural: _("years").t()};
            
        var TIME_UNITS = u;
    
        var BdTime = function(isoString) {
            var bdPieces = BD_TIME_REGEX_MILLIS.exec(isoString) || BD_TIME_REGEX_NO_MILLIS.exec(isoString);
            if(!bdPieces) {
                this.isInvalid = true;
            }
            else {
                this.year   = parseInt(bdPieces[1], 10);
                this.month  = parseInt(bdPieces[2], 10);
                this.day    = parseInt(bdPieces[3], 10);
                this.hour   = parseInt(bdPieces[4], 10);
                this.minute = parseInt(bdPieces[5], 10);
                this.second = parseInt(bdPieces[6], 10);
                this.millisecond = bdPieces.length > 7 ? parseInt(bdPieces[7], 10) : 0;
            }
        };
    
        var extractBdTime = function(timeString) {
            return new BdTime(timeString);
        };
    
        var bdTimeToDateObject = function(bdTime) {
            var year     = bdTime.year,
                month    = bdTime.month - 1,
                day      = bdTime.day,
                hour     = bdTime.hour,
                minute   = bdTime.minute,
                second   = bdTime.second,
                millisecond = bdTime.millisecond;
    
            return new Date(year, month, day, hour, minute, second, millisecond);
        };

        var getTimezoneString = function(dateObj) {
            var timezoneOffset = dateObj.getTimezoneOffset(),
                absoluteValueTimezoneOffset = Math.abs(timezoneOffset),
                hours = Math.floor(absoluteValueTimezoneOffset / 60),
                minutes = absoluteValueTimezoneOffset % 60,
                formattedHours = hours < 10 ? '0' + hours : '' + hours,
                formattedMinutes = minutes < 10 ? '0' + minutes : '' + minutes,
                timezone = (timezoneOffset > 0 ? '-' : '+') + formattedHours + ':' + formattedMinutes;
            
            return timezone;
        };
    
        var isoToDateObject = function(isoString) {
            var matches = STRIP_TIMEZONE_REGEX.exec(isoString);
            if (matches) {
                var isoWithoutTimezone = matches[1],
                    isoWithSpoofedTimezone = isoWithoutTimezone + getTimezoneString(new Date()),
                    correctedIso = isoWithoutTimezone + getTimezoneString(moment(isoWithSpoofedTimezone).toDate());
                return moment(correctedIso).toDate();
            }

            return new Date(NaN);
        };
        
        var jsDateToSplunkDateTimeWithMicroseconds = function(jsDate) {
            var dateTime = new i18n.DateTime({
                date: jsDate,
                year: jsDate.getFullYear(),
                month: jsDate.getMonth() + 1,
                day: jsDate.getDate(),
                hour: jsDate.getHours(),
                minute: jsDate.getMinutes(),
                second: jsDate.getSeconds(),
                microsecond: jsDate.getMilliseconds() * 1000
            });
            dateTime.weekday = function() {
                var d = this.date.getDay() - 1;
                if (d < 0)
                    d = 6;
                return d;
            };
            return dateTime;
        };

        var _calculateTimeFormat = function(time, spanSeries) {
            var span = parseFloat(spanSeries[0]);
            if(!(time instanceof BdTime)) {
                time = extractBdTime(time);
            }
            if (!span) {
                return time.millisecond === 0 ? 'second' : 'millisecond';
            }

            if((span >= 0 && span < 1) || (time.millisecond !== 0)) {
                return 'millisecond';
            }
            if((span >= 1 && span < 60) || (time.second !== 0)) {
                return 'second';
            }
            if((span >= 60 && span < 3600) || (time.minute !== 0)) {
                return 'minute';
            }
            if ((span >= 3600 && span <= 82800) || (time.hour !== 0)) { // 23 hour (82800)
                return 'hour';
            }
            if ((span > 82800 && span <= 2419200) || (time.day !== 1)) { // 1 day to 28 days
                return 'day';
            }
            if ((span > 2419200 && span <= 31535999) || (time.month !== 1)) { // 28 days - 1 year
                return 'month';
            }
            if (span >= 31536000) { // year
                return 'year';
            }
            console.log('_span value (' + span + ') did not meet any time formatting condition');
            return 'second';
        };
    
        var determineLabelGranularity = function(times, spanSeries) {
            if(!(times[0] instanceof BdTime)) {
                times = _(times).map(extractBdTime);
            }
            times = _(times).filter(function(time) { return !time.isInvalid; });
            if(times.length === 1 && (!spanSeries || spanSeries.length === 0)) {
                return times[0].millisecond === 0 ? 'second' : 'millisecond';
            }
            if(times.length === 1 && spanSeries) {
                return _calculateTimeFormat(times[0], spanSeries);
            }
            var milliseconds = [],
                seconds = [],
                minutes = [],
                hours   = [],
                days    = [],
                months  = [],
    
                allInListMatch = function(list, matchMe) {
                    for(var i = 0; i < list.length; i++) {
                        if(list[i] !== matchMe) {
                            return false;
                        }
                    }
                    return true;
                };
    
            _(times).each(function(time) {
                milliseconds.push(time.millisecond);
                seconds.push(time.second);
                minutes.push(time.minute);
                hours.push(time.hour);
                days.push(time.day);
                months.push(time.month);
            });

            if(!allInListMatch(milliseconds, 0)) {
                return 'millisecond';
            }
            if(!allInListMatch(seconds, 0)) {
                return 'second';
            }
            if(!allInListMatch(minutes, 0)) {
                return 'minute';
            }
            if((!allInListMatch(hours, 0))) {
                return 'hour';
            }
            if(!allInListMatch(days, 1)) {
                return 'day';
            }
            if(!allInListMatch(months, 1)) {
                return 'month';
            }
            return 'year';
        };
    
        var isValidIsoTime = function(str) {
            return BD_TIME_REGEX_MILLIS.test(str) || BD_TIME_REGEX_NO_MILLIS.test(str);
        };
        
    
        /**
         * Epoch seconds to LocaleString
         * @param epochTime
         * @return {String}
         */
        var convertToLocalTime = function(epochTime) {
            if (!epochTime) {
                return null;
            }
            return new Date(epochTime*1000).toLocaleString();
        };
    
        /**
         * Converts time difference to "1 year, 6 months ago"; "20 minutes, 30 seconds ago"
         * @param endTime Unix epoch seconds
         * @param startTime [optional] Unix epoch seconds; By default - current time.
         * @param withoutSuffix [optional] true to omit the "ago" suffix
         * @return {String}
         */
        var convertToRelativeTime = function(endTime, startTime, withoutSuffix) {
            if (!endTime) {
                return null;
            }
            var endMoment = moment.unix(endTime);
            return startTime !== undefined ?
                    endMoment.from(moment.unix(startTime), withoutSuffix) :
                    endMoment.fromNow(withoutSuffix);
        };

        /**
         * Converts parsed time amount and unit to seconds. Converts 1h to 3600.
         * @param amount {Number}
         * @param unit {String} ('s', 'm', 'h', 'd')
         * @return {Number}
         */
        var convertAmountAndUnitToSeconds = function(amount, unit) {
            var seconds = amount;
            switch (unit) {
                case 'd':
                    seconds *= 24 * 60 * 60;
                    break;
                case 'h':
                    seconds *= 60 * 60;
                    break;
                case 'm':
                    seconds *= 60;
                    break;
            }
            return seconds;
        };

        var getRelativeStringFromSeconds = function(seconds, removeAgo) {
            if (_.isString(seconds)) {
                seconds = parseInt(seconds, 10);
            }
            
            var now = new Date(),
                startTime = now.getTime() / 1000,
                endTime = startTime - seconds;
            
            return convertToRelativeTime(endTime, startTime, removeAgo);
        };
        
        /*  
         * Normalize units to their shortest abbreviations.
         * Required is an optional parameter, defaults to true.
         * If required and there is no match, s is returned.
         * 
         */
        var normalizeUnit = function(abbr, required) {
            var hasUnit = TIME_UNITS.hasOwnProperty(abbr),
                defaultUnit = required === false ? '' : TIME_UNITS.s.abbr;
            return hasUnit ? TIME_UNITS[abbr].abbr : defaultUnit;
        };
        
        var parseTimeString = function(timeString){
            if (!_.isString(timeString)) {
                return false;
            }
            //This regex is not a validator of splunk time! Use the TimeParser for that!
            //-1, -1s, -1@s, -1s@s, +1, +1s, +1@s, +1s@s, s@s, rt@s, @s, rtnow, now
            var parse = timeString.match(/^\s*(rt|)([-+]?)(\d*)([a-zA-Z]*)(@?)([a-zA-Z]*)(\d*)\s*$/);
                                           //   1     2     3       4       5       6      7
            if (parse) {
                var normalizedUnit = normalizeUnit(parse[4], false),
                    hasSnap = (parse[5] !== '');
                
                return {
                    amount: (normalizedUnit ? (parseInt(parse[3], 10) || 1) : 0),
                    unit: normalizedUnit,
                    hasSnap: hasSnap,
                    snapUnit: normalizeUnit(parse[6], false),
                    snapUnitAmount: parseInt(parse[7], 10),
                    isNow: parse[4] === "now",
                    isRealTime: parse[1] === 'rt',
                    isPositive: parse[2] === "+" || true,
                    parse: parse 
                };
            }
            
            return false;
        };

        /*
         *  Takes timeStrings of the format "-7d" or "+5h"
         *  and returns a breakdown of the +/-, amount, and unit components.
         *  Also, returns false if the timeString is not of a valid
         *  Splunk relative time modifier format.
         *  Ignores 'snapTo' '@' syntax.
         */
        var parseTimeModifier = function(timeString) {
            if (!_.isString(timeString)) {
                return false;
            }
            var parse = timeString.match(/^([+-])([0-9]+)([a-zA-Z]+)@?[a-zA-Z]*$/),
                timeVariance,
                amount,
                unit;
            if (parse) {
                timeVariance = parse[1];
                amount = parse[2];
                unit = normalizeUnit(parse[3], false);
                return {
                    timeVariance: timeVariance,
                    amount: amount,
                    unit: unit
                };
            }
            return false;
        };
        
        var isRealtime = function(time) {
            return (_.isString(time) && time.indexOf("rt") === 0);
        };
        
        var stripRTSafe = function(timeString, isLatest) {
            var sign,
                parsedTimeString,
                strippedString;
            
            if (!isRealtime(timeString)) {
                return timeString;
            }
            
            parsedTimeString = parseTimeString(timeString);
            if (!parsedTimeString) {
                return timeString;
            }
            
            if (parsedTimeString.unit || parsedTimeString.isNow) {
                return parsedTimeString.parse.slice(2, parsedTimeString.parse.length).join("");
            }
            
            strippedString = parsedTimeString.parse.slice(3, parsedTimeString.parse.length).join("");
            if (strippedString) {
                sign = parsedTimeString.isPositive ? "+" : "-";
                return sign + strippedString;
            }
            
            if (isLatest) {
                return "";
            } else {
                return "0";
            }
        };

        /**
         * @param {Object} options {
         *     iso: time,
         *     unit: w|d|m|h|s|ms
         *     amount: <int> 
         *     type: plus|minus|plusminus
         * }
         */
        var rangeFromIsoAndOffset = function(iso, unit, amount, type) {
            amount = parseInt(amount, 10);
            amount = isNaN(amount) ? 1 : amount;
            type = type === undefined ? 'plusminus' : type;
            if (['plus', 'minus', 'plusminus'].indexOf(type) === -1) {
                throw new Error('Invalid type');
            }
            var origanalDate = new Date(iso),
                lowerRange = new Date(iso),
                upperRange = new Date(iso);

            switch(unit) {
                case 'w': 
                    lowerRange.setDate(lowerRange.getDate() - (7 * amount));
                    upperRange.setDate(upperRange.getDate() + (7 * amount));
                    break;
                case 'd': 
                    lowerRange.setDate(lowerRange.getDate() - amount);
                    upperRange.setDate(upperRange.getDate() + amount);
                    break;
                case 'h': 
                    lowerRange.setHours(lowerRange.getHours() - amount);
                    upperRange.setHours(upperRange.getHours() + amount);
                    break;
                case 'm': 
                    lowerRange.setMinutes(lowerRange.getMinutes() - amount);
                    upperRange.setMinutes(upperRange.getMinutes() + amount);
                    break;
                case 's': 
                    lowerRange.setSeconds(lowerRange.getSeconds() - amount);
                    upperRange.setSeconds(upperRange.getSeconds() + amount);
                    break;
                case 'ms': 
                    lowerRange.setMilliseconds(lowerRange.getMilliseconds() - amount);
                    upperRange.setMilliseconds(upperRange.getMilliseconds() + amount);
                    break;
                default:
                    throw new Error('Invalid unit');
            }
            return { 
                lowerRange: (type === 'minus' || type === 'plusminus') ? lowerRange : origanalDate,
                upperRange: (type === 'plus' || type === 'plusminus') ? upperRange : origanalDate 
            }; 
        };
        
        var isAbsolute = function(time) {
            if (time === undefined) {
                return false;
            }
            return _.isNumber(time) || !(/^(now|-|\+|@|rt).*/.test(time));
        };
        
        var isEpoch = function(time) {
            return _.isNumber(time) || (_.isString(time) && /^\d+((\.\d+)|(\d*))$/.test(time) && time !== '0');
        };
        
        var timeAndJsDateIsWholeDay = function(time, jsDate) {
            if (isAbsolute(time) && jsDate) {
                return (jsDate.getHours() == 0) && (jsDate.getMinutes() == 0) && (jsDate.getSeconds() == 0) && (jsDate.getMilliseconds() == 0);
            }
            return false;
        };
        
        var isNow = function(time) {
            if (!time) {
                return true;
            }
            return (_.isString(time) && ((time === '') || (/now/.test(time))));
        };
        
        var isEmpty = function(time) {
            if (time === '0') {
                return true;
            }
            return (!time);
        };
        
        var findPresetLabel = function(presetsCollection, earliest, latest) {
            var presetModel;
            
            if (presetsCollection.length > 0) {
                //TODO: this should probably get moved to the Times collection
                presetModel = presetsCollection.find(function(model) {
                    var timesConfEarliest = model.entry.content.get("earliest_time"),
                        timesConfLatest = model.entry.content.get("latest_time"),
                        noEarliests = (isEmpty(timesConfEarliest) && isEmpty(earliest)),
                        noLatests = (isEmpty(timesConfLatest) && isEmpty(latest)),
                        isDisabled = model.isDisabled(),
                        isSubMenu = model.isSubMenu();
                    
                    return ((!isDisabled && !isSubMenu) && (noEarliests || (timesConfEarliest == earliest)) && (noLatests || (timesConfLatest == latest)));
                });
                
                if (presetModel) {
                    return presetModel.entry.content.get("label");
                }
            }
            return false;
        };
        
        var generateRealtimeLabel = function(earliest, latest) {
            var earliestParse, latestIsNow;
            
            if (isRealtime(earliest) || isRealtime(latest)) {
                earliestParse = parseTimeString(earliest);
                latestIsNow = isNow(latest);
                
                var labelTemplates = {
                    s:_("%t second window").t(),
                    m: _("%t minute window").t(),
                    h: _("%t hour window").t(),
                    d: _("%t day window").t(),
                    w: _("%t week window").t(),
                    mon: _("%t month window").t(),
                    q: _("%t quarter window").t(),
                    y: _("%t year window").t()
                };
            
                //A windowed time with a latest time of now.
                if (earliestParse && earliestParse.amount && latestIsNow && labelTemplates.hasOwnProperty(earliestParse.unit)) {
                    return labelTemplates[earliestParse.unit].replace(/%t/, earliestParse.amount);
                } 
                
                //Other Real-Time.
                return _("Real-time").t();
            }
            return false;
        };
        
        var generateRelativeTimeLabel = function(earliest, latest) {
            var earliestParse = parseTimeString(earliest),
                latestIsNow = isNow(latest),
                latestParse = parseTimeString(latest);
            
            if (!earliestParse || earliestParse.isRealTime || latestParse.isRealTime) {
                return false;
            }
            
            if (earliestParse.amount
                    && (!earliestParse.snapUnit || earliestParse.unit === earliestParse.snapUnit)
                    && (latestParse.isNow || (latestParse.snapUnit && !latestParse.amount))
                    && (!latestParse.snapUnit || earliestParse.unit === latestParse.snapUnit)) {
                var relativeLabel = _("Last %amount %unit").t();
                relativeLabel = relativeLabel.replace(/%amount/, earliestParse.amount);
                relativeLabel = relativeLabel.replace(/%unit/, TIME_UNITS[earliestParse.unit][earliestParse.amount > 1? 'plural' : 'singular']);
                return relativeLabel;
            }
            
            return false;
        };
        
        var generateBetweenTimeLabel = function(earliest, earliestJSDate, latest, latestJSDate) {
            var earliestIsWholeDay = timeAndJsDateIsWholeDay(earliest, earliestJSDate),
                latestIsWholeDay = timeAndJsDateIsWholeDay(latest, latestJSDate);
            
            if (earliestIsWholeDay && latestIsWholeDay) {
                if (language == 'en') {
                    return i18n.format_datetime_range(null, earliestJSDate, latestJSDate, true);
                } else {
                    var dateLabel = _("%1 through %2").t();
                    var labelDate = new Date(latestJSDate.getTime());
                    labelDate.setDate(labelDate.getDate() -1);
                    return dateLabel.replace('%1', i18n.format_date(earliestJSDate, 'short')).replace('%2', i18n.format_date(labelDate, 'short'));
                }
            }
            
            return false;
        };
        
        var generateSinceDateLabel = function(earliest, earliestJSDate, latest){
            var earliestIsWholeDay = timeAndJsDateIsWholeDay(earliest, earliestJSDate),
                latestIsNow = isNow(latest);
            
            if (earliestIsWholeDay && latestIsNow) {
                var dateLabel = _("Since %1").t();
                return dateLabel.replace('%1', i18n.format_date(earliestJSDate, 'short'));
            }
            
            return false;
        };
        
        var generateBeforeDateLabel = function(earliest, latest, latestJSDate) {            
            if (isEmpty(earliest) && timeAndJsDateIsWholeDay(latest, latestJSDate)) {
                var dateLabel = _("Before %1").t();
                return dateLabel.replace('%1', i18n.format_date(latestJSDate, 'short'));
            }
            
            return false;
        };
        
        var generateDateTimeRangeLabel = function(earliest, latest) {
            if (!isEmpty(earliest) && isAbsolute(earliest) && isAbsolute(latest)) {
                return _("Date time range").t();
            }
            return false;
        };
        
        var generateSinceTimeRangeLabel = function(earliest, latest) {
            if (isAbsolute(earliest) && isNow(latest)) {
                return _("Since date time").t();
            }
            return false;
         };
         
         var generateBeforeTimeRangeLabel = function(earliest, latest) {
             if (isEmpty(earliest) && isAbsolute(latest)) {
                 return _("Before date time").t();
             }
             return false;
         };
         
         var generateAllTimeLabel = function(earliest, latest) {
             if (isEmpty(earliest) && isNow(latest)) {
                 return _("All time").t();
             }
             return false;
         };

        var makeTodayRelativeWithNoTimeZone = function(time) {
            var date = new Date(time),
                mDate = moment(date),
                iscurrentDate = (mDate).isSame(new Date(), "day");
            if(iscurrentDate)
            {
                return (mDate).fromNow();
            }

            return date.toString().slice(0,24);
        };
    
        /**
        * presets: <collections.services.data.ui.TimesV2>
        **/
        var generateLabel = function(presetsCollection, earliest, earliestJSDate, latest, latestJSDate) {
            return generateAllTimeLabel(earliest, latest) ||
                findPresetLabel(presetsCollection, earliest, latest) ||
                generateRealtimeLabel(earliest, latest) ||
                generateRelativeTimeLabel(earliest, latest) ||
                generateBetweenTimeLabel(earliest, earliestJSDate, latest, latestJSDate) ||
                generateSinceDateLabel(earliest, earliestJSDate, latest) ||
                generateBeforeDateLabel(earliest, latest, latestJSDate) ||
                generateDateTimeRangeLabel(earliest, latest) ||
                generateSinceTimeRangeLabel(earliest, latest) ||
                generateBeforeTimeRangeLabel(earliest, latest) ||
                _("Custom time").t();
        };

        var RESULTS_TIMESTAMP_FORMATS = {
            year: 'YYYY',
            month: 'YYYY-MM',
            day: 'YYYY-MM-dd',
            hour: 'YYYY-MM-dd HH:00',
            minute: 'YYYY-MM-dd HH:mm:00',
            second: 'YYYY-MM-dd HH:mm:ss',
            millisecond: 'YYYY-MM-dd HH:mm:ss.TTT'
        };
        
        return ({
            extractBdTime: extractBdTime,
            bdTimeToDateObject: bdTimeToDateObject,
            rangeFromIsoAndOffset: rangeFromIsoAndOffset,
            getTimezoneString: getTimezoneString,
            isoToDateObject: isoToDateObject,
            determineLabelGranularity: determineLabelGranularity,
            isValidIsoTime: isValidIsoTime,
            TIME_UNITS: TIME_UNITS,
            ISO_PATTERN: ISO_PATTERN,
            normalizeUnit: normalizeUnit,
            parseTimeString: parseTimeString,
            parseTimeModifier: parseTimeModifier,
            isRealtime: isRealtime,
            stripRTSafe: stripRTSafe,
            isAbsolute: isAbsolute,
            isEpoch: isEpoch,
            timeAndJsDateIsWholeDay: timeAndJsDateIsWholeDay,
            isNow: isNow,
            isEmpty: isEmpty,
            findPresetLabel: findPresetLabel,
            generateRealtimeLabel: generateRealtimeLabel,
            generateRelativeTimeLabel: generateRelativeTimeLabel,
            generateBetweenTimeLabel: generateBetweenTimeLabel,
            generateSinceDateLabel: generateSinceDateLabel,
            generateBeforeDateLabel: generateBeforeDateLabel,
            generateDateTimeRangeLabel: generateDateTimeRangeLabel,
            generateSinceTimeRangeLabel: generateSinceTimeRangeLabel,
            generateBeforeTimeRangeLabel: generateBeforeTimeRangeLabel,
            generateAllTimeLabel: generateAllTimeLabel,
            generateLabel: generateLabel,
            convertToRelativeTime: convertToRelativeTime,
            convertToLocalTime: convertToLocalTime,
            jsDateToSplunkDateTimeWithMicroseconds: jsDateToSplunkDateTimeWithMicroseconds,
            getRelativeStringFromSeconds: getRelativeStringFromSeconds,
            convertAmountAndUnitToSeconds: convertAmountAndUnitToSeconds,
            makeTodayRelativeWithNoTimeZone: makeTodayRelativeWithNoTimeZone,
            RESULTS_TIMESTAMP_FORMATS: RESULTS_TIMESTAMP_FORMATS
        });
    }
);

// splunk bar
define(
'views/shared/splunkbar/messages/Message',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/Base',
    'views/shared/litebar/RestartDialog',
    'splunk.util',
    'util/time'
],
function(
    $,
    _,
    Backbone,
    module,
    BaseView,
    RestartDialog,
    splunk_util,
    time_utils
){
    /**
     * View Hierarchy:
     *
     * Messages
     */
    return BaseView.extend({
        moduleId: module.id,

        messageMap: {
            'restart_required': _('Splunk must be restarted for changes to take effect. [[/manager/search/control|Click here to restart from the Manager]].').t()
        },

        messageMapForLite: {
            'restart_required': _('Restart for changes to take effect. [[/manager/search/control|Click here to restart]].').t(),
            'LM_LICENSE_ALERTS_STATUS': _('Daily indexing volume limit exceeded today. See [[/manager/system/licensing|License Manager]] for details.').t()
        },

        tagName: 'li',

        isLiteRestart : false,

        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);

            //listen for restart events
            $(document).on('restart_failed', function() {
                this.hideRestartModal();
            }.bind(this));

        },

        events: {
            'click .message-content a' : 'checkRestartForLite'     
        },

        checkRestartForLite: function(e) {
            if (this.isLiteRestart) {
                e.preventDefault();
                if (confirm(_("Are you sure you want to restart Splunk?").t())) {
                    this.showRestartModal();
                    splunk_util.restart_server();
                }
            }
        },

        showRestartModal: function() {
            this.children.restartDialog = new RestartDialog({backdrop: 'static'});
            // Necessary for modal to render correctly in manager.
            $("body").append('<div class="splunk-components restartModal"></div>');
            $(".restartModal").append(this.children.restartDialog.render().el);
            this.children.restartDialog.show();
        },
 
        hideRestartModal: function() {
            if (this.children.restartDialog) {
                this.children.restartDialog.hide();
            }
        },

        render: function() {
            var msgFullId = this.model.id,
                msgId = (this.model.entry.get('name')||''),
                msg,
                msgLevel = this.model.entry.content.get('severity') || 'warn',
                contactToken = '$CONTACT_SPLUNK_SALES_TEXT$',
                contactStr = '[http://www.splunk.com/r/getlicense Contact Splunk] (sales@splunk.com or +1.866.GET.SPLUNK) for details on how to renew.',
                contactStrLite = 'To manage your license or to learn how to renew your license go the licensing management page.';

            var isLite = false;
            if (this.options.serverInfo && this.options.serverInfo.isLite()) {
                isLite = true;
            }

            var messageMap = isLite ? this.messageMapForLite : this.messageMap;
            if (msgId && messageMap[msgId]) {
                msg = messageMap[msgId]; 
            } else {
                msg = this.model.entry.content.get("message") || "";
            }

            if (msg.indexOf(contactToken) != -1) {
                msg = msg.replace(contactToken, (isLite) ? contactStrLite : contactStr);
            }

            var msgTime = this.model.entry.content.get("timeCreated_iso");
            if(msgTime){
                var dateObj = time_utils.isoToDateObject(msgTime);
                msgTime = dateObj.toLocaleString();
            }

            var formattedMsg = splunk_util.getWikiTransform(msg);
            if ((msgId == 'restart_required') && isLite) {
                this.isLiteRestart = true;
            }                                                                                             

            var html = this.compiledTemplate({
                msg: formattedMsg,
                msgLevel: msgLevel,
                msgTime: msgTime || ''
            });

            this.$el.html(html);
            this.$el.addClass(msgLevel + '-message');
            this.$el.attr('data-id', msgFullId);

            return this;
        },
        template: '<i class="message-icon icon-<%- msgLevel %>"></i>\
                <span class="message-content"><%= msg %></span>\
                <span class="message-time"><%= msgTime %></span>\
                <a href="#" class="delete-message"><i class="icon-x-circle"></i></a>'
    });
});

// splunk bar
define(
    'views/shared/splunkbar/messages/LegacyMessage',[
        'jquery',
        'underscore',
        'backbone',
        'module',
        'views/Base',
        'splunk.util'
    ],
    function(
        $,
        _,
        Backbone,
        module,
        BaseView,
        splunk_util
        ){
        /**
         * View Hierarchy:
         *
         * Messages
         */
        return BaseView.extend({
            moduleId: module.id,
            className: 'view-navbar-global navbar navbar-fixed-top',
            messageMap: {
                'restart_required': _('Splunk must be restarted for changes to take effect. [[/manager/search/control|Click here to restart from the Manager]].').t()
            },
            initialize: function() {
                BaseView.prototype.initialize.apply(this, arguments);
            },
            render: function() {

                var msgId = (this.model.get('id')||'').toLowerCase(),
                    msg,
                    msgLevel = this.model.get('severity') || 'warn';
                if (msgId && this.messageMap[msgId]) {
                    msg = this.messageMap[msgId];
                } else {
                    msg = this.model.get("content") || "";
                }
                var html = this.compiledTemplate({
                    msgId: msgId,
                    msg: splunk_util.getWikiTransform(msg),
                    msgLevel: msgLevel
                });
                this.$el = $(html);
                return this;
            },
            template: '<li class="<%- msgLevel %>" data-islegacy="1" data-id="<%- msgId %>">\
                <span class="message-content"><%= msg %></span>\
                <a href="#" class="delete-message"><i class="icon-x-circle"></i></a>\
            </li>'
        });
    });


define('contrib/text!views/shared/splunkbar/messages/Master.html',[],function () { return '<a href="#" class="dropdown-toggle">\n    <span class="label label-warning" style="display: none;"><%- collection.length %></span> <%- _("Messages").t() %><b class="caret"></b>\n</a>\n<div class="dropdown-menu" id="global-messages-menu">\n\n    <div class="arrow"></div>\n    <ul class="message-list" style="display: none;">\n    </ul>\n    <div class="no-messages">\n        <%- _("You have no messages.").t() %>\n    </div>\n    <div class="popdown-dialog-footer" style="display: none;">\n        <a href="#" class="delete-all-messages btn pull-right"><%- _("Delete All").t() %></a>\n    </div>\n</div>\n';});

define(
    'views/shared/splunkbar/messages/Master',[
        'jquery',
        'underscore',
        'module',
        'views/Base',
        'views/shared/delegates/Popdown',
        'views/shared/delegates/StopScrollPropagation',
        'collections/services/Messages',
        'views/shared/splunkbar/messages/Message',
        'views/shared/splunkbar/messages/LegacyMessage',
        'contrib/text!views/shared/splunkbar/messages/Master.html',
        'util/general_utils'
    ],
    function($, _, module, BaseView, Popdown, StopScrollPropagation, MessagesCollection, MessageView, LegacyMessageView, MasterTemplate, general_utils) {
        return BaseView.extend({
            moduleId: module.id,
            template: MasterTemplate,
            tagName: 'li',
            className: 'dropdown messages',
            initialize: function() {
                BaseView.prototype.initialize.apply(this, arguments);
                this.legacyMessages = this.collection.legacyMessages || false;
                this.collection = this.collection.messages;
                this.collection.on('change reset remove', this.renderMessages, this);
                if(this.legacyMessages){
                    this.legacyMessages.on('reset remove', this.renderMessages, this);
                }
                this.isLocalMouseSelection = false;
            },
            events: {
                'click .message-list .delete-message': 'deleteMessage',
                'click .delete-all-messages': 'deleteAllMessages',
                'mouseup .message-list': function() {
                    // this is to stop message refresh only when selection is LOCAL to .message-list
                    this.isLocalMouseSelection = true;
                }
            },
            render: function() {
                //destroy already existing popdowns...
                var html = this.compiledTemplate({collection: this.collection});
                this.$el.html(html);
                this.children.popdown = new Popdown({el:this.el, mode: 'dialog'});
                this.children.stopScrollPropagation = new StopScrollPropagation({el:this.$('#global-messages-menu ul'), mode: 'dialog'});

                return this;
            },
            renderMessages: function(forceUpdate) {
                if(forceUpdate !== true &&
                    this.isLocalMouseSelection &&
                    general_utils.getMouseSelection() && general_utils.getMouseSelection().length>0) {
                    return;
                }
                this.isLocalMouseSelection = false;
                var numMessages = this.collection.length;
                if(this.legacyMessages){
                    numMessages = numMessages + this.legacyMessages.length;
                }

                this.$('.label-warning').text(numMessages);

                //remove existing message children
                _.each(this.children, function(view, key){
                    if (key.substr(0, 7) == 'message') {
                        this.children[key].remove();
                        delete this.children[key];
                    }
                }, this);

                //iterate through collection
                var messageView;

                this.collection.each(function(model, key){
                    //create view
                    var serverInfoModel = (this.model && this.model.serverInfo) ? this.model.serverInfo : {};
                    messageView = new MessageView({model: model, serverInfo: serverInfoModel});
                    this.children['message' + model.get("id")] = messageView;
                    this.$('#global-messages-menu .message-list').append(messageView.render().$el);
                    //bind destruction of model to delete view
                }, this);

                var numLegacyMessages = 0;
                if(this.legacyMessages){
                    numLegacyMessages = this.legacyMessages.length;
                    this.legacyMessages.each(function(model){
                        messageView = new LegacyMessageView({model: model});
                        this.children['messageLegacy' + model.get("id")] = messageView;
                        this.$('#global-messages-menu .message-list').append(messageView.render().$el);
                    }, this);
                }


                if (this.collection.length > 0 || numLegacyMessages > 0) {
                    this.$(".label-warning, .popdown-dialog-footer, .message-list, .message_count_wrapper").show();
                    this.$('#global-messages-menu').addClass('dropdown-menu-wide');
                    this.$(".no-messages").hide();

                    if(this.$('#global-messages-menu').is(':visible')) {
                        this.children.popdown.adjustPosition();
                    }
                } else {
                    this.$(".label-warning, .popdown-dialog-footer, .message-list, .message_count_wrapper").hide();
                    this.$('#global-messages-menu').removeClass('dropdown-menu-wide');
                    this.$(".no-messages").show();
                }

            },
            deleteMessage: function(evt) {
                evt.preventDefault();
                var $li = $(evt.currentTarget).parent();
                var id = $li.data('id');
                var isLegacy = $li.data('islegacy');

                var toRemove;
                if(this.legacyMessages && isLegacy){
                    toRemove = this.legacyMessages.get(id);
                    if(toRemove){
                        this.legacyMessages.remove( toRemove );
                    }
                }else{
                    toRemove = this.collection.get(id);
                    if(toRemove){
                        toRemove.destroy();
                    }
                }

                if (this.collection.length === 0 && (this.legacyMessages === false || this.legacyMessages.length === 0)) {
                    this.children.popdown.hide();
                }

                this.renderMessages(true);
            },
            deleteAllMessages: function(evt) {
                evt.preventDefault();
                this.collection.destroyAll();

                if(this.legacyMessages){
                    this.legacyMessages.reset();
                }
                this.children.popdown.hide();
            }
        });
    }
);


define('contrib/text!views/shared/splunkbar/ActivityMenu.html',[],function () { return '<a href="#" class="dropdown-toggle"><%- _("Activity").t() %><b class="caret"></b></a>\n<div class="dropdown-menu dropdown-menu-narrow" id="global-activity-menu">\n    <div class="arrow"></div>\n    <ul>\n        <li>\n            <a class="primary-link" href="<%= jobLink %>"><%- _("Jobs").t() %></a>\n            <a class="secondary-link" href="<%= jobLink %>" target="_blank"><i class="icon-external"></i></a>\n        </li>\n    <% if (typeof alertsLink !== "undefined" && alertsLink !== null) { %>\n        <li>\n            <a class="primary-link" href="<%= alertsLink %>"><%- _("Triggered Alerts").t() %></a>\n            <a class="secondary-link" href="<%= alertsLink %>" target="_blank"><i class="icon-external"></i></a>\n        </li>\n    <% } %>\n\t<% if (typeof statusLink !== "undefined" && statusLink !== null) { %>\n\t\t<li>\n\t\t    <a class="primary-link" href="<%= statusLink %>"><%- _("System Activity").t() %></a>\n\t\t    <a class="secondary-link" href="<%= statusLink %>" target="_blank"><i class="icon-external"></i></a>\n\t\t</li>\n\t<% } %>\n    </ul>\n</div>\n';});

define(
'views/shared/splunkbar/ActivityMenu',[
    'underscore',
    'jquery',
    'module',
    'views/Base',
    'views/shared/delegates/Popdown',
    'contrib/text!views/shared/splunkbar/ActivityMenu.html',
    'splunk.util',
    'uri/route'
],
function(
    _,
    $,
    module,
    BaseView,
    Popdown,
    activityMenuTemplate,
    splunk_util,
    route
){
    return BaseView.extend({
        moduleId: module.id,
        template: activityMenuTemplate,
        tagName: 'li',
        className: 'dropdown activity',
        initialize: function(){
            BaseView.prototype.initialize.apply(this, arguments);
            this.render();
            this.model.application.on('change', this.render);
            this.model.user.on('change', this.render);
        },
        render: function(){
            // can't render unless we have app and roles info
            if (typeof this.model.application.get('app') === "undefined" ||
                typeof this.model.user.entry.content.get('roles') === "undefined") {
                return this;
            } else {
                var app = this.model.application.get('app'),
                    isAdmin = (this.model.user.entry.content.get('roles').indexOf('admin') > -1),
                    jobLink = route.page(
                        this.model.application.get('root'),
                        this.model.application.get('locale'),
                        app,
                        'job_management'
                    ),
                    statusLink = null,
                    alertsLink = null;
                
                if (this.model.user.canUseAlerts()) {
                    alertsLink = route.triggeredAlerts(this.model.application.get('root'), this.model.application.get('locale'), app);
                }

                // if we are currently in the system namespace, route job link through search namespace
                //  job_management page cannot be loaded within system namespace
                if (app == 'system') {
                    jobLink = route.page(
                        this.model.application.get('root'),
                        this.model.application.get('locale'),
                        'search',
                        'job_management'
                    );
                }

                if (isAdmin) {
                    // only build statusLink if the user is admin
                    statusLink = route.page(
                        this.model.application.get('root'),
                        this.model.application.get('locale'),
                        'search',
                        'status_index');
                }
                
                var html = this.compiledTemplate({jobLink:jobLink, alertsLink:alertsLink, statusLink:statusLink});
                this.$el.html(html);

                this.children.popdown = new Popdown({el:this.el, mode: 'dialog'});

                return this;
            }
        }
    });
});


define('contrib/text!views/shared/AboutDialog.html',[],function () { return '<dl class="list-dotted">\n    <dt><%= _(\'Splunk Version\').t() %></dt>\n    <dd><%- version %></dd>\n    <dt><%= _(\'Splunk Build\').t() %></dt>\n    <dd><%- build %></dd>\n</dl>\n<% if (!isLite) { %>\n<dl class="list-dotted">\n    <dt><%= _(\'Current App\').t() %></dt>\n    <dd><%- currentApp %></dd>\n    <% if (appVersion) { %>\n        <dt><%= _(\'App Version\').t() %></dt>\n        <dd><%- appVersion %></dd>\n    <% } %>\n    <% if (appBuild) { %>\n        <dt><%= _(\'App Build\').t() %></dt>\n        <dd><%- appBuild %></dd>\n    <% } %>\n</dl>\n<% } %>\n<% if (listOfProducts && !isLite) { %>\n<dl class="list-dotted">\n    <dt><%= _(\'List of Products:\').t() %></dt>\n    <dd><%- listOfProducts %></dd>\n</dl>\n<% } %>\n<dl class="list-dotted">\n    <dt><%= _(\'Server Name\').t() %></dt>\n    <dd><%- serverName %></dd>\n</dl>\n<p>\n    &copy; <%- copyrightYear %> <%= _(\'Splunk Inc.  All rights reserved.\').t()%>\n</p>\n<p>\n    <% var licenseLink = sprintf(\'<a href="http://www.splunk.com/en_us/legal/splunk-software-license-agreement.html" target="_blank">%s</a>\', _(\'Splunk Software License Agreement\').t()); %>\n    <% var termsLink =  _(\'terms and conditions\').t(); %>\n    <% if (isCloud) { %>\n        <% var termsLink = sprintf(\'<a href="http://www.splunk.com/en_us/legal/terms/splunk-cloud-terms-of-service.html" target="_blank">%s</a>\', _(\'Terms and Conditions\').t()); %>\n    <% } %>\n    <%= sprintf(_(\'All use of this Software is subject to the %s of the %s.\').t(), termsLink, licenseLink) %>\n</p>\n<h3><%= _(\'Trademarks\').t() %></h3>\n<p>\n    <%= _(\'Splunk&reg;, Splunk&gt;&reg;, Listen to Your Data&reg;, The Engine for Machine Data&reg;, Hunk&reg;, Splunk Cloud&#8482;, Splunk Storm&reg; and SPL&#8482; are registered trademarks or trademarks of Splunk Inc., and/or its subsidiaries and/or affiliates. All other brand names, product names or trademarks belong to their respective owners.\').t() %>\n</p>\n<h3><%= _(\'Patents\').t() %></h3>\n<p>\n    <% var patentLink = sprintf(\'<a href="http://www.splunk.com/en_us/legal/patents.html" target="_blank">%s</a>\', _(\'here\').t()); %>\n    <%= sprintf(_(\'Certain features and functionalities of this Software are or may be protected by patents owned by Splunk Inc. that are listed %s.\').t(), patentLink) %>\n</p>\n<h3>\n    <a href="<%- thirdPartyCredits %>" target="_blank"><%= _(\'Third-Party Software Credits and Attributions\').t() %></a>\n</h3>\n';});

/**
 * Global functions for defining classes and managing resources.
 * 
 * The following functions are declared globally:
 * 
 *     jg_namespace
 *     jg_import
 *     jg_extend
 *     jg_static
 *     jg_mixin
 *     jg_has_mixin
 * 
 * Copyright (c) 2012 Jason Gatt
 * 
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 */
(function(global, evalScript)
{

  // prevent duplicate definitions
  if (global.jg_namespace && global.jg_import)
    return;

	// Private Variables

	var _namespaces = {};
	var _imported = {};
	var _loading = {};
	var _sourcePaths = {};
	var _resourceTypeInfo = {};
	var _resourceInfo = {};
	var _resourceDependencyList = [];
	var _mixinCount = 0;
	var _mixinDependencies = null;

	// Private Functions

	var _normalizePath = function(path)
	{
		return (path.substring(path.length - 6) === ":class") ? path.substring(0, path.length - 6) : path;
	};

	var _getPathInfo = function(path)
	{
		var pathInfo = {};
		pathInfo.path = path;

		var typeIndex = path.indexOf(":");
		pathInfo.classPath = (typeIndex < 0) ? path : path.substring(0, typeIndex);
		pathInfo.type = (typeIndex < 0) ? "class" : path.substring(typeIndex + 1);
		if (!pathInfo.classPath || !pathInfo.type)
			return null;

		var namespaceIndex = pathInfo.classPath.lastIndexOf(".");
		pathInfo.namespace = (namespaceIndex < 0) ? "" : pathInfo.classPath.substring(0, namespaceIndex);
		pathInfo.className = (namespaceIndex < 0) ? pathInfo.classPath : pathInfo.classPath.substring(namespaceIndex + 1);
		pathInfo.name = (pathInfo.type === "class") ? pathInfo.className : (pathInfo.className + ":" + pathInfo.type);

		return pathInfo;
	};

	var _getSourcePath = function(path)
	{
		path += ".";

		var sourcePathList = [];
		var sourcePath;
		var url;

		for (sourcePath in _sourcePaths)
		{
			if (_sourcePaths.hasOwnProperty(sourcePath))
				sourcePathList.push(sourcePath);
		}
		sourcePathList.sort();

		for (var i = sourcePathList.length - 1; i >= 0; i--)
		{
			sourcePath = sourcePathList[i];
			if (path.substring(0, sourcePath.length) === sourcePath)
			{
				url = _sourcePaths[sourcePath] + path.substring(sourcePath.length).replace(/\./g, "/");
				return url.substring(0, url.length - 1);
			}
		}

		url = path.replace(/\./g, "/");
		return url.substring(0, url.length - 1);
	};

	var _appendConstructor = function(baseConstructor, mixinConstructor)
	{
		var constructor = function()
		{
			baseConstructor.apply(this, arguments);
			mixinConstructor.call(this);
		};
		return constructor;
	};

	// Global Functions

	var jg_namespace = global.jg_namespace = function(path, closure)
	{
		if (path == null)
			throw new Error("Parameter path must be non-null.");
		if (typeof path !== "string")
			throw new Error("Parameter path must be a string.");
		if ((closure != null) && (typeof closure !== "function"))
			throw new Error("Parameter closure must be a function.");

		var ns = _namespaces[path];
		if (!ns)
		{
			var subPaths = path ? path.split(".") : [];
			var subPath;
			var scope;

			ns = global;
			for (var i = 0, l = subPaths.length; i < l; i++)
			{
				subPath = subPaths[i];
				scope = ns[subPath];
				if (!scope)
					scope = ns[subPath] = {};
				ns = scope;
			}

			_namespaces[path] = ns;
		}

		if (closure)
			closure.call(ns, ns);

		return ns;
	};

	var jg_import = global.jg_import = function(path)
	{
		if (path == null)
			throw new Error("Parameter path must be non-null.");
		if (typeof path !== "string")
			throw new Error("Parameter path must be a string.");
		if (!path)
			throw new Error("Parameter path must be non-empty.");

		path = _normalizePath(path);

		var resource = _imported[path];
		if (resource == null)
		{
			if (_loading[path])
				throw new Error("Recursive dependency on resource " + path + ".");

			var resourceInfo = _getPathInfo(path);
			if (!resourceInfo)
				throw new Error("Invalid resource path \"" + path + "\".");

			var ns = jg_namespace(resourceInfo.namespace);
			resource = ns[resourceInfo.name];
			if (resource == null)
			{
				var typeInfo = _resourceTypeInfo[resourceInfo.type];
				if (!typeInfo)
					throw new Error("Unknown resource type \"" + resourceInfo.type + "\". Ensure the resource type is registered via jg_import.registerResourceType().");

				try
				{
					_loading[path] = true;

					resourceInfo.url = _getSourcePath(resourceInfo.classPath) + typeInfo.extension;
					resourceInfo.source = null;

					try
					{
						var xhr = global.ActiveXObject ? new global.ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();
						xhr.open("GET", resourceInfo.url, false);
						xhr.send(null);
						if ((xhr.status == 200) || (xhr.status == 0))
							resourceInfo.source = xhr.responseText;
					}
					catch (e)
					{
					}

					if (resourceInfo.source == null)
						throw new Error("Failed to load resource " + path + " from url " + resourceInfo.url + ". Ensure the correct source path is set for this resource via jg_import.setSourcePath().");

					var resourceInfoCopy = {};
					for (var p in resourceInfo)
					{
						if (resourceInfo.hasOwnProperty(p))
							resourceInfoCopy[p] = resourceInfo[p];
					}

					try
					{
						var result = typeInfo.parser.call(resourceInfoCopy, resourceInfoCopy);
						resource = ns[resourceInfo.name];
						if (resource == null)
							resource = result;
					}
					catch (e)
					{
						if ((e != null) && e.__jg_import_Error)
							throw e;

						var message = (e instanceof Error) ? e.message : String(e);
						e = new Error("Error in resource " + path + ": " + message);
						e.__jg_import_Error = true;
						throw e;
					}

					if (resource == null)
						throw new Error("Failed to define resource " + path + ".");

					ns[resourceInfo.name] = resource;
				}
				finally
				{
					delete _loading[path];
				}
			}

			resourceInfo.resource = resource;

			_resourceInfo[path] = resourceInfo;
			_resourceDependencyList.push(path);

			_imported[path] = resource;
		}

		return resource;
	};

	jg_import.define = function(path, closure)
	{
		if (path == null)
			throw new Error("Parameter path must be non-null.");
		if (typeof path !== "string")
			throw new Error("Parameter path must be a string.");
		if (!path)
			throw new Error("Parameter path must be non-empty.");
		if (closure == null)
			throw new Error("Parameter closure must be non-null.");
		if (typeof closure !== "function")
			throw new Error("Parameter closure must be a function.");

		path = _normalizePath(path);

		var resource = _imported[path];
		if (resource == null)
		{
			var resourceInfo = _getPathInfo(path);
			if (!resourceInfo)
				throw new Error("Invalid resource path \"" + path + "\".");

			var ns = jg_namespace(resourceInfo.namespace);
			resource = ns[resourceInfo.name];
			if (resource == null)
			{
				var result = closure.call(ns, ns);
				resource = ns[resourceInfo.name];
				if (resource == null)
					resource = result;

				if (resource == null)
					throw new Error("Failed to define resource " + path + ".");

				ns[resourceInfo.name] = resource;
			}

			if (!_loading[path] && (_imported[path] == null))
			{
				resourceInfo.resource = resource;

				_resourceInfo[path] = resourceInfo;
				_resourceDependencyList.push(path);

				_imported[path] = resource;
			}
		}

		return resource;
	};

	jg_import.setSourcePath = function(path, url)
	{
		if (path == null)
			throw new Error("Parameter path must be non-null.");
		if (typeof path !== "string")
			throw new Error("Parameter path must be a string.");
		if (url == null)
			throw new Error("Parameter url must be non-null.");
		if (typeof url !== "string")
			throw new Error("Parameter url must be a string.");

		if (path && (path.charAt(path.length - 1) !== "."))
			path += ".";
		if (url && (url.charAt(url.length - 1) !== "/"))
			url += "/";

		_sourcePaths[path] = url;
	};

	jg_import.registerResourceType = function(type, extension, parser)
	{
		if (type == null)
			throw new Error("Parameter type must be non-null.");
		if (typeof type !== "string")
			throw new Error("Parameter type must be a string.");
		if (!type)
			throw new Error("Parameter type must be non-empty.");
		if (extension == null)
			throw new Error("Parameter extension must be non-null.");
		if (typeof extension !== "string")
			throw new Error("Parameter extension must be a string.");
		if (parser == null)
			throw new Error("Parameter parser must be non-null.");
		if (typeof parser !== "function")
			throw new Error("Parameter parser must be a function.");

		var typeInfo = {};
		typeInfo.extension = extension;
		typeInfo.parser = parser;

		_resourceTypeInfo[type] = typeInfo;
	};

	jg_import.getResourceInfo = function(path)
	{
		if ((path != null) && (typeof path !== "string"))
			throw new Error("Parameter path must be a string.");

		if (!path)
		{
			var resourceInfoList = [];
			for (var i = 0, l = _resourceDependencyList.length; i < l; i++)
				resourceInfoList.push(jg_import.getResourceInfo(_resourceDependencyList[i]));
			return resourceInfoList;
		}

		path = _normalizePath(path);

		var resourceInfo = _resourceInfo[path];
		if (!resourceInfo)
			return null;

		var resourceInfoCopy = {};
		for (var p in resourceInfo)
		{
			if (resourceInfo.hasOwnProperty(p))
				resourceInfoCopy[p] = resourceInfo[p];
		}

		return resourceInfoCopy;
	};

	var jg_extend = global.jg_extend = function(baseClass, closure)
	{
		if (baseClass == null)
			throw new Error("Parameter baseClass must be non-null.");
		if (typeof baseClass !== "function")
			throw new Error("Parameter baseClass must be a class.");
		if ((closure != null) && (typeof closure !== "function"))
			throw new Error("Parameter closure must be a function.");

		var constructor = baseClass;
		var base = baseClass.prototype;

		baseClass = function(){};
		baseClass.prototype = base;

		var c = function()
		{
			constructor.apply(this, arguments);
		};
		var proto = c.prototype = new baseClass();
		proto.constructor = c;

		if (closure)
		{
			closure.call(proto, c, base, proto);

			if (c.prototype !== proto)
				throw new Error("Class member \"prototype\" cannot be overridden.");

			if (proto.constructor !== c)
			{
				if (typeof proto.constructor !== "function")
					throw new Error("Instance member \"constructor\" must be a function.");

				constructor = proto.constructor;
				proto.constructor = c;
			}
		}

		return c;
	};

	var jg_static = global.jg_static = function(closure)
	{
		if ((closure != null) && (typeof closure !== "function"))
			throw new Error("Parameter closure must be a function.");

		var c = {};

		if (closure)
			closure.call(c, c);

		return c;
	};

	var jg_mixin = global.jg_mixin = function(target, source, base)
	{
		if (target == null)
			throw new Error("Parameter target must be non-null.");
		if (source == null)
			throw new Error("Parameter source must be non-null.");

		var id = source.__jg_mixin_id;
		if (!id)
			id = source.__jg_mixin_id = "m" + (++_mixinCount);

		id = "__jg_has_mixin_" + id;

		if (target[id])
			return base;

		var baseConstructor = ((base != null) && base.hasOwnProperty("constructor") && (typeof base.constructor === "function")) ? base.constructor : function(){};
		var baseClass = function(){};
		baseClass.prototype = (base != null) ? base : Object.prototype;

		base = new baseClass();
		base.constructor = baseConstructor;

		var member;

		var mixin = source.mixin;
		if ((mixin != null) && (typeof mixin === "function"))
		{
			var mixinBase = new baseClass();
			for (member in target)
			{
				if (target.hasOwnProperty(member))
					mixinBase[member] = target[member];
			}
			mixinBase.constructor = baseConstructor;

			try
			{
				if (!_mixinDependencies)
					_mixinDependencies = [];

				_mixinDependencies.push(base);

				var constructor = target.constructor;

				mixin.call(target, mixinBase, target);

				if (target.constructor !== constructor)
					throw new Error("Target member \"constructor\" cannot be overridden.");
			}
			finally
			{
				_mixinDependencies.pop();
				if (_mixinDependencies.length == 0)
					_mixinDependencies = null;
			}
		}

		for (member in source)
		{
			if (source.hasOwnProperty(member) && (member !== "mixin") && (member !== "constructor") && (member.substring(0, 2) !== "__"))
				target[member] = source[member];
		}

		for (member in target)
		{
			if (target.hasOwnProperty(member) && (member !== "constructor"))
				base[member] = target[member];
		}

		var sourceConstructor = (source.hasOwnProperty("constructor") && (typeof source.constructor === "function")) ? source.constructor : null;
		if (sourceConstructor)
		{
			base.constructor = _appendConstructor(base.constructor, sourceConstructor);

			if (_mixinDependencies)
			{
				var dependentMixin;
				for (var i = _mixinDependencies.length - 1; i >= 0; i--)
				{
					dependentMixin = _mixinDependencies[i];
					dependentMixin.constructor = _appendConstructor(dependentMixin.constructor, sourceConstructor);
				}
			}
		}

		target[id] = true;

		return base;
	};

	var jg_has_mixin = global.jg_has_mixin = function(target, source)
	{
		if (target == null)
			throw new Error("Parameter target must be non-null.");
		if (source == null)
			throw new Error("Parameter source must be non-null.");

		var id = source.__jg_mixin_id;
		if (!id)
			return false;

		id = "__jg_has_mixin_" + id;

		return (target[id] == true);
	};

	// Register class resource type

	jg_import.registerResourceType("class", ".js", function(resourceInfo)
	{
		evalScript(global, resourceInfo.source);
	});

})(this, function(global, script) { eval.call(global, script); });

define("jg_global", (function (global) {
    return function () {
        var ret, fn;
       fn = function () {
                this.jg_globals = {
                    jg_namespace: this.jg_namespace,
                    jg_extend: this.jg_extend,
                    jg_static: this.jg_static,
                    jg_mixin: this.jg_mixin,
                    jg_has_mixin: this.jg_has_mixin
                };
                return this.jg_globals;
            };
        ret = fn.apply(global, arguments);
        return ret || global.jg_globals;
    };
}(this)));

/**
 * Copyright (c) 2012 Jason Gatt
 * 
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 */

jg_import.define("jgatt.events.EventData", function()
{
jg_namespace("jgatt.events", function()
{

	this.EventData = jg_extend(Object, function(EventData, base)
	{

		// Public Properties

		this.event = null;
		this.target = null;
		this.currentEvent = null;
		this.currentTarget = null;

		// Private Properties

		this._isPropagationStopped = false;
		this._isImmediatePropagationStopped = false;
		this._isDefaultPrevented = false;

		// Constructor

		this.constructor = function()
		{
		};

		// Public Methods

		this.stopPropagation = function()
		{
			this._isPropagationStopped = true;
		};

		this.stopImmediatePropagation = function()
		{
			this._isPropagationStopped = true;
			this._isImmediatePropagationStopped = true;
		};

		this.preventDefault = function()
		{
			this._isDefaultPrevented = true;
		};

		this.isPropagationStopped = function()
		{
			return this._isPropagationStopped;
		};

		this.isImmediatePropagationStopped = function()
		{
			return this._isImmediatePropagationStopped;
		};

		this.isDefaultPrevented = function()
		{
			return this._isDefaultPrevented;
		};

	});

});
});

jg_import.define("jgatt.utils.TypeUtils", function()
{
jg_namespace("jgatt.utils", function()
{

	this.TypeUtils = jg_static(function(TypeUtils)
	{

		// Public Static Methods

		TypeUtils.isTypeOf = function(value, type)
		{
			if (value == null)
				return false;

			if (type === Object)
				return true;

			switch (typeof value)
			{
				case "number":
					return (type === Number);
				case "boolean":
					return (type === Boolean);
				case "string":
					return (type === String);
				default:
					return (value instanceof type);
			}
		};

		TypeUtils.isSubclassOf = function(c, type)
		{
			return ((c != null) && (c.prototype != null) && (c.prototype instanceof type));
		};

	});

});
});

jg_import.define("jgatt.properties.Property", function()
{
jg_namespace("jgatt.properties", function()
{

	var TypeUtils = jg_import("jgatt.utils.TypeUtils");

	this.Property = jg_extend(Object, function(Property, base)
	{

		// Private Properties

		this._name = null;
		this._type = null;
		this._defaultValue = null;
		this._readOnly = false;
		this._getter = null;
		this._setter = null;
		this._readFilter = null;
		this._writeFilter = null;
		this._onRead = null;
		this._onWrite = null;

		// Constructor

		this.constructor = function(name, type, defaultValue, readOnly)
		{
			if (name == null)
				throw new Error("Parameter name must be non-null.");
			if (typeof name !== "string")
				throw new Error("Parameter name must be a string.");
			if (type == null)
				throw new Error("Parameter type must be non-null.");
			if (typeof type !== "function")
				throw new Error("Parameter type must be a class.");

			this._name = name;
			this._type = type;

			defaultValue = this.assertType(defaultValue, "Parameter defaultValue is incompatible with property type.");

			if ((readOnly != null) && (typeof readOnly !== "boolean"))
				throw new Error("Parameter readOnly must be a boolean.");

			this._defaultValue = defaultValue;
			this._readOnly = (readOnly === true);
		};

		// Public Getters/Setters

		this.name = function()
		{
			return this._name;
		};

		this.type = function()
		{
			return this._type;
		};

		this.defaultValue = function()
		{
			return this._defaultValue;
		};

		this.readOnly = function()
		{
			return this._readOnly;
		};

		this.getter = function(value)
		{
			if (arguments.length == 0)
				return this._getter;

			if ((value != null) && (typeof value !== "function"))
				throw new Error("Parameter getter must be a function.");

			this._getter = value ? value : null;

			return this;
		};

		this.setter = function(value)
		{
			if (arguments.length == 0)
				return this._setter;

			if ((value != null) && (typeof value !== "function"))
				throw new Error("Parameter setter must be a function.");

			this._setter = value ? value : null;

			return this;
		};

		this.readFilter = function(value)
		{
			if (arguments.length == 0)
				return this._readFilter;

			if ((value != null) && (typeof value !== "function"))
				throw new Error("Parameter readFilter must be a function.");

			this._readFilter = value ? value : null;

			return this;
		};

		this.writeFilter = function(value)
		{
			if (arguments.length == 0)
				return this._writeFilter;

			if ((value != null) && (typeof value !== "function"))
				throw new Error("Parameter writeFilter must be a function.");

			this._writeFilter = value ? value : null;

			return this;
		};

		this.onRead = function(value)
		{
			if (arguments.length == 0)
				return this._onRead;

			if ((value != null) && (typeof value !== "function"))
				throw new Error("Parameter onRead must be a function.");

			this._onRead = value ? value : null;

			return this;
		};

		this.onWrite = function(value)
		{
			if (arguments.length == 0)
				return this._onWrite;

			if ((value != null) && (typeof value !== "function"))
				throw new Error("Parameter onWrite must be a function.");

			this._onWrite = value ? value : null;

			return this;
		};

		// Public Methods

		this.get = function(target, propertyMap)
		{
			if (this._onRead)
				this._onRead.call(target);

			var value = this.getInternal(target, propertyMap);

			if (this._readFilter)
			{
				var value2 = this._readFilter.call(target, value);
				if (value2 !== value)
					value = this.assertType(value2, "Value returned from readFilter for property " + this._name + " is incompatible with property type.");
			}

			return value;
		};

		this.set = function(target, propertyMap, value)
		{
			if (this._readOnly)
				throw new Error("Property " + this._name + " is read-only.");

			value = this.assertType(value, "Value assigned to property " + this._name + " is incompatible with property type.");

			if (this._writeFilter)
			{
				var value2 = this._writeFilter.call(target, value);
				if (value2 !== value)
					value = this.assertType(value2, "Value returned from writeFilter for property " + this._name + " is incompatible with property type.");
			}

			if (!this.setInternal(target, propertyMap, value))
				return false;

			if (this._onWrite)
				this._onWrite.call(target);

			return true;
		};

		this.getInternal = function(target, propertyMap)
		{
			var propertyInfo = propertyMap.get(this);
			if (!propertyInfo)
				propertyInfo = propertyMap.set(this, this.createPropertyInfo(this, target));

			var value = propertyInfo.value;

			if (this._getter)
			{
				var value2 = this._getter.call(target);
				if (value2 !== value)
					value = propertyInfo.value = this.assertType(value2, "Value returned from getter for property " + this._name + " is incompatible with property type.");
			}

			return value;
		};

		this.setInternal = function(target, propertyMap, value)
		{
			value = this.assertType(value, "Value assigned to property " + this._name + " is incompatible with property type.");

			var propertyInfo = propertyMap.get(this);
			if (!propertyInfo)
				propertyInfo = propertyMap.set(this, this.createPropertyInfo(this, target));

			if (this._setter)
				this._setter.call(target, value);

			propertyInfo.value = value;

			return true;
		};

		// Protected Methods

		this.assertType = function(value, message)
		{
			var type = this._type;

			if ((value != null) && !TypeUtils.isTypeOf(value, type))
				throw new Error(message);

			if (value == null)
			{
				if (type === Number)
					value = 0;
				else if (type === Boolean)
					value = false;
				else
					value = null;
			}

			return value;
		};

		this.createPropertyInfo = function(property, target)
		{
			return new Property.PropertyInfo(property, target);
		};

	});

	this.Property.PropertyInfo = jg_extend(Object, function(PropertyInfo, base)
	{

		// Public Properties

		this.property = null;
		this.target = null;
		this.value = null;

		// Constructor

		this.constructor = function(property, target)
		{
			this.property = property;
			this.target = target;
			this.value = property._defaultValue;
		};

	});

});
});

jg_import.define("jgatt.utils.Dictionary", function()
{
jg_namespace("jgatt.utils", function()
{

	this.Dictionary = jg_extend(Object, function(Dictionary, base)
	{

		// Private Static Constants

		var _HASH_KEY = "__jgatt_utils_Dictionary_hash";

		// Private Static Properties

		var _hashCount = 0;

		// Private Static Methods

		var _hash = function(value)
		{
			if (value === null)
				return "null";
			switch (typeof value)
			{
				case "object":
				case "function":
					if (value.hasOwnProperty(_HASH_KEY))
						return value[_HASH_KEY];
					var hash = value[_HASH_KEY] = "#" + (++_hashCount);
					return hash;
				case "string":
					return "\"" + value + "\"";
				default:
					return value + "";
			}
		};

		// Private Properties

		this._kvs = null;
		this._size = 0;

		// Constructor

		this.constructor = function()
		{
			this._kvs = {};
		};

		// Public Methods

		this.size = function()
		{
			return this._size;
		};

		this.get = function(key)
		{
			var hash = _hash(key);
			if (this._kvs.hasOwnProperty(hash))
				return this._kvs[hash].v;
			return undefined;
		};

		this.set = function(key, value)
		{
			var hash = _hash(key);
			if (this._kvs.hasOwnProperty(hash))
			{
				this._kvs[hash].v = value;
				return value;
			}
			this._kvs[hash] = { k: key, v: value };
			this._size++;
			return value;
		};

		this.del = function(key)
		{
			var hash = _hash(key);
			if (this._kvs.hasOwnProperty(hash))
			{
				var value = this._kvs[hash].v;
				delete this._kvs[hash];
				this._size--;
				return value;
			}
			return undefined;
		};

		this.has = function(key)
		{
			var hash = _hash(key);
			return this._kvs.hasOwnProperty(hash);
		};

		this.keys = function()
		{
			var keys = [];
			var kvs = this._kvs;
			for (var hash in kvs)
			{
				if (kvs.hasOwnProperty(hash))
					keys.push(kvs[hash].k);
			}
			return keys;
		};

		this.values = function()
		{
			var values = [];
			var kvs = this._kvs;
			for (var hash in kvs)
			{
				if (kvs.hasOwnProperty(hash))
					values.push(kvs[hash].v);
			}
			return values;
		};

	});

});
});

jg_import.define("jgatt.properties.MPropertyTarget", function()
{
jg_namespace("jgatt.properties", function()
{

	var Property = jg_import("jgatt.properties.Property");
	var Dictionary = jg_import("jgatt.utils.Dictionary");

	this.MPropertyTarget = jg_static(function(MPropertyTarget)
	{

		// Private Static Methods

		var _resolveProperty = function(target, property)
		{
			if (property == null)
				throw new Error("Parameter property must be non-null.");

			if (property instanceof Property)
				return property;

			if (typeof property !== "string")
				throw new Error("Parameter property must be a string or an instance of jgatt.properties.Property.");

			var targetProperty = target[property];
			if (!(targetProperty instanceof Property))
				throw new Error("Unknown property \"" + property + "\".");

			return targetProperty;
		};

		// Private Properties

		this._propertyMap = null;

		// Constructor

		this.constructor = function()
		{
			this._propertyMap = new Dictionary();
		};

		// Public Methods

		this.get = function(property)
		{
			property = _resolveProperty(this, property);
			return property.get(this, this._propertyMap);
		};

		this.set = function(property, value)
		{
			property = _resolveProperty(this, property);
			return property.set(this, this._propertyMap, value);
		};

		this.getInternal = function(property)
		{
			property = _resolveProperty(this, property);
			return property.getInternal(this, this._propertyMap);
		};

		this.setInternal = function(property, value)
		{
			property = _resolveProperty(this, property);
			return property.setInternal(this, this._propertyMap, value);
		};

	});

});
});

jg_import.define("jgatt.utils.ErrorUtils", function()
{
jg_namespace("jgatt.utils", function()
{

	this.ErrorUtils = jg_static(function(ErrorUtils)
	{

		// Public Static Methods

		ErrorUtils.asyncThrow = function(e)
		{
			setTimeout(function() { throw e; }, 1);
		};

	});

});
});

jg_import.define("jgatt.events.Event", function()
{
jg_namespace("jgatt.events", function(ns)
{

	var EventData = jg_import("jgatt.events.EventData");
	var MPropertyTarget = jg_import("jgatt.properties.MPropertyTarget");
	var Property = jg_import("jgatt.properties.Property");
	var Dictionary = jg_import("jgatt.utils.Dictionary");
	var ErrorUtils = jg_import("jgatt.utils.ErrorUtils");
	var TypeUtils = jg_import("jgatt.utils.TypeUtils");

	this.Event = jg_extend(Object, function(Event, base)
	{

		// Private Static Methods

		var _listenerInfoComparator = function(info1, info2)
		{
			if (info1.priority > info2.priority)
				return -1;
			if (info1.priority < info2.priority)
				return 1;
			if (info1.index < info2.index)
				return -1;
			if (info2.index > info2.index)
				return 1;
			return 0;
		};

		// Private Properties

		this._name = null;
		this._type = null;
		this._bubbles = false;
		this._cancelable = false;

		// Constructor

		this.constructor = function(name, type, bubbles, cancelable)
		{
			if (name == null)
				throw new Error("Parameter name must be non-null.");
			if (typeof name !== "string")
				throw new Error("Parameter name must be a string.");
			if (type == null)
				throw new Error("Parameter type must be non-null.");
			if (typeof type !== "function")
				throw new Error("Parameter type must be a class.");
			if ((type !== EventData) && !TypeUtils.isSubclassOf(type, EventData))
				throw new Error("Parameter type must be a subclass of jgatt.events.EventData.");
			if ((bubbles != null) && (typeof bubbles !== "boolean"))
				throw new Error("Parameter bubbles must be a boolean.");
			if ((cancelable != null) && (typeof cancelable !== "boolean"))
				throw new Error("Parameter cancelable must be a boolean.");

			this._name = name;
			this._type = type;
			this._bubbles = (bubbles === true);
			this._cancelable = (cancelable === true);
		};

		// Public Getters/Setters

		this.name = function()
		{
			return this._name;
		};

		this.type = function()
		{
			return this._type;
		};

		this.bubbles = function()
		{
			return this._bubbles;
		};

		this.cancelable = function()
		{
			return this._cancelable;
		};

		// Public Methods

		this.addEventListener = function(target, eventMap, listener, priority)
		{
			if (listener == null)
				throw new Error("Parameter listener must be non-null.");
			if (typeof listener !== "function")
				throw new Error("Parameter listener must be a function.");
			if ((priority != null) && (typeof priority !== "number"))
				throw new Error("Parameter priority must be a number.");

			if ((priority == null) || isNaN(priority))
				priority = 0;

			var eventInfo = eventMap.get(this);
			if (!eventInfo)
				eventInfo = eventMap.set(this, { map: new Dictionary(), list: null, index: 0 });

			var listenerMap = eventInfo.map;
			var listenerInfo = listenerMap.get(listener);
			if (!listenerInfo)
				listenerInfo = listenerMap.set(listener, { listener: listener });
			else if (listenerInfo.priority === priority)
				return;

			listenerInfo.priority = priority;
			listenerInfo.index = eventInfo.index;

			eventInfo.list = null;
			eventInfo.index++;
		};

		this.removeEventListener = function(target, eventMap, listener)
		{
			if (listener == null)
				throw new Error("Parameter listener must be non-null.");
			if (typeof listener !== "function")
				throw new Error("Parameter listener must be a function.");

			var eventInfo = eventMap.get(this);
			if (!eventInfo)
				return;

			var listenerMap = eventInfo.map;
			if (!listenerMap.has(listener))
				return;

			listenerMap.del(listener);

			eventInfo.list = null;
		};

		this.hasEventListener = function(target, eventMap)
		{
			var eventInfo = eventMap.get(this);
			if (!eventInfo)
				return false;

			return (eventInfo.map.size() > 0);
		};

		this.dispatchEvent = function(target, eventMap, eventData)
		{
			if (eventData == null)
				throw new Error("Parameter eventData must be non-null.");
			if (!(eventData instanceof this._type))
				throw new Error("Parameter eventData is incompatible with event type.");

			if (eventData.isPropagationStopped())
				return (!this._cancelable || !eventData.isDefaultPrevented());

			if (eventData.event == null)
				eventData.event = this;
			if (eventData.target == null)
				eventData.target = target;
			eventData.currentEvent = this;
			eventData.currentTarget = target;

			var eventInfo = eventMap.get(this);
			if (eventInfo)
			{
				var listenerList = eventInfo.list;
				if (!listenerList)
				{
					var listenerMap = eventInfo.map;
					if (listenerMap.size() > 0)
					{
						listenerList = eventInfo.list = listenerMap.values();
						listenerList.sort(_listenerInfoComparator);
					}
				}

				if (listenerList)
				{
					var listenerInfo;
					for (var i = 0, l = listenerList.length; i < l; i++)
					{
						listenerInfo = listenerList[i];
						try
						{
							eventData.currentEvent = this;
							eventData.currentTarget = target;
							listenerInfo.listener.call(target, eventData);
							if (eventData.isImmediatePropagationStopped())
								break;
						}
						catch (e)
						{
							ErrorUtils.asyncThrow(e);
						}
					}
				}
			}

			if (this._bubbles && !eventData.isPropagationStopped())
			{
				var parent = target.parent;
				if (parent != null)
				{
					if ((parent instanceof Property) && jg_has_mixin(target, MPropertyTarget))
						parent = target.get(parent);
				}
				else
				{
					parent = target.parentNode;
				}

				if ((parent != null) && ns.MEventTarget && jg_has_mixin(parent, ns.MEventTarget))
					parent.dispatchEvent(this, eventData);
			}

			return (!this._cancelable || !eventData.isDefaultPrevented());
		};

	});

});
});

jg_import.define("jgatt.events.ChainedEvent", function()
{
jg_namespace("jgatt.events", function()
{

	var Event = jg_import("jgatt.events.Event");
	var TypeUtils = jg_import("jgatt.utils.TypeUtils");

	this.ChainedEvent = jg_extend(Event, function(ChainedEvent, base)
	{

		// Private Properties

		this._parentEvent = null;

		// Constructor

		this.constructor = function(name, parentEvent, type, bubbles, cancelable)
		{
			if (parentEvent == null)
				throw new Error("Parameter parentEvent must be non-null.");
			if (!(parentEvent instanceof Event))
				throw new Error("Parameter parentEvent must be an instance of jgatt.events.Event.");

			var parentType = parentEvent._type;
			if (type == null)
				type = parentType;
			else if (typeof type !== "function")
				throw new Error("Parameter type must be a class.");
			else if ((type !== parentType) && !TypeUtils.isSubclassOf(type, parentType))
				throw new Error("Parameter type must be a subclass of parentEvent type.");

			base.constructor.call(this, name, type, bubbles, cancelable);

			this._parentEvent = parentEvent;
		};

		// Public Getters/Setters

		this.parentEvent = function()
		{
			return this._parentEvent;
		};

		// Public Methods

		this.dispatchEvent = function(target, eventMap, eventData)
		{
			base.dispatchEvent.call(this, target, eventMap, eventData);

			if (!eventData.isPropagationStopped())
				this._parentEvent.dispatchEvent(target, eventMap, eventData);

			return (!this._cancelable || !eventData.isDefaultPrevented());
		};

	});

});
});

jg_import.define("jgatt.events.MEventTarget", function()
{
jg_namespace("jgatt.events", function()
{

	var Event = jg_import("jgatt.events.Event");
	var Dictionary = jg_import("jgatt.utils.Dictionary");

	this.MEventTarget = jg_static(function(MEventTarget)
	{

		// Private Static Methods

		var _resolveEvent = function(target, event)
		{
			if (event == null)
				throw new Error("Parameter event must be non-null.");

			if (event instanceof Event)
				return event;

			if (typeof event !== "string")
				throw new Error("Parameter event must be a string or an instance of jgatt.events.Event.");

			var targetEvent = target._eventNameMap[event];
			if (!targetEvent)
			{
				var eventPath = event.split(".");
				targetEvent = target;
				for (var i = 0, l = eventPath.length; i < l; i++)
				{
					targetEvent = targetEvent[eventPath[i]];
					if (targetEvent == null)
						break;
				}
				if (!(targetEvent instanceof Event))
					throw new Error("Unknown event \"" + event + "\".");
				target._eventNameMap[event] = targetEvent;
			}

			return targetEvent;
		};

		// Private Properties

		this._eventMap = null;
		this._eventNameMap = null;

		// Constructor

		this.constructor = function()
		{
			this._eventMap = new Dictionary();
			this._eventNameMap = {};
		};

		// Public Methods

		this.addEventListener = function(event, listener, priority)
		{
			event = _resolveEvent(this, event);
			event.addEventListener(this, this._eventMap, listener, priority);
		};

		this.removeEventListener = function(event, listener)
		{
			event = _resolveEvent(this, event);
			event.removeEventListener(this, this._eventMap, listener);
		};

		this.hasEventListener = function(event)
		{
			event = _resolveEvent(this, event);
			return event.hasEventListener(this, this._eventMap);
		};

		this.dispatchEvent = function(event, eventData)
		{
			event = _resolveEvent(this, event);
			return event.dispatchEvent(this, this._eventMap, eventData);
		};

	});

});
});

jg_import.define("jgatt.events.MObservable", function()
{
jg_namespace("jgatt.events", function()
{

	var Event = jg_import("jgatt.events.Event");
	var EventData = jg_import("jgatt.events.EventData");
	var MEventTarget = jg_import("jgatt.events.MEventTarget");

	this.MObservable = jg_static(function(MObservable)
	{

		// Mixin

		this.mixin = function(base)
		{
			base = jg_mixin(this, MEventTarget, base);
		};

		// Public Events

		this.changed = new Event("changed", EventData);

	});

});
});

jg_import.define("jgatt.geom.Point", function()
{
jg_namespace("jgatt.geom", function()
{

	this.Point = jg_extend(Object, function(Point, base)
	{

		// Public Properties

		this.x = 0;
		this.y = 0;

		// Constructor

		this.constructor = function(x, y)
		{
			this.x = (x !== undefined) ? x : 0;
			this.y = (y !== undefined) ? y : 0;
		};

		// Public Methods

		this.length = function()
		{
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};

		this.hasNaN = function()
		{
			return (isNaN(this.x) ||
			        isNaN(this.y));
		};

		this.hasInfinity = function()
		{
			return ((this.x == Infinity) || (this.x == -Infinity) ||
			        (this.y == Infinity) || (this.y == -Infinity));
		};

		this.hasPositiveInfinity = function()
		{
			return ((this.x == Infinity) ||
			        (this.y == Infinity));
		};

		this.hasNegativeInfinity = function()
		{
			return ((this.x == -Infinity) ||
			        (this.y == -Infinity));
		};

		this.isFinite = function()
		{
			return (((this.x - this.x) === 0) &&
			        ((this.y - this.y) === 0));
		};

		this.equals = function(point)
		{
			return ((this.x == point.x) &&
			        (this.y == point.y));
		};

		this.clone = function()
		{
			return new Point(this.x, this.y);
		};

		this.toString = function()
		{
			return "(" + this.x + ", " + this.y + ")";
		};

	});

});
});

jg_import.define("jgatt.geom.Matrix", function()
{
jg_namespace("jgatt.geom", function()
{

	var Point = jg_import("jgatt.geom.Point");

	this.Matrix = jg_extend(Object, function(Matrix, base)
	{

		// Public Properties

		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.tx = 0;
		this.ty = 0;

		// Constructor

		this.constructor = function(a, b, c, d, tx, ty)
		{
			this.a = (a !== undefined) ? a : 1;
			this.b = (b !== undefined) ? b : 0;
			this.c = (c !== undefined) ? c : 0;
			this.d = (d !== undefined) ? d : 1;
			this.tx = (tx !== undefined) ? tx : 0;
			this.ty = (ty !== undefined) ? ty : 0;
		};

		// Public Methods

		this.transformPoint = function(point)
		{
			var x = this.a * point.x + this.c * point.y + this.tx;
			var y = this.b * point.x + this.d * point.y + this.ty;
			return new Point(x, y);
		};

		this.translate = function(x, y)
		{
			this.tx += x;
			this.ty += y;
		};

		this.scale = function(scaleX, scaleY)
		{
			this.a *= scaleX;
			this.b *= scaleY;
			this.c *= scaleX;
			this.d *= scaleY;
			this.tx *= scaleX;
			this.ty *= scaleY;
		};

		this.rotate = function(angle)
		{
			angle = (angle / 180) * Math.PI;

			var cosAngle = Math.cos(angle);
			var sinAngle = Math.sin(angle);
			var a = this.a;
			var b = this.b;
			var c = this.c;
			var d = this.d;
			var tx = this.tx;
			var ty = this.ty;

			this.a = a * cosAngle - b * sinAngle;
			this.b = b * cosAngle + a * sinAngle;
			this.c = c * cosAngle - d * sinAngle;
			this.d = d * cosAngle + c * sinAngle;
			this.tx = tx * cosAngle - ty * sinAngle;
			this.ty = ty * cosAngle + tx * sinAngle;
		};

		this.skew = function(skewX, skewY)
		{
			skewX = (skewX / 180) * Math.PI;
			skewY = (skewY / 180) * Math.PI;

			var tanSkewX = Math.tan(skewX);
			var tanSkewY = Math.tan(skewY);
			var a = this.a;
			var b = this.b;
			var c = this.c;
			var d = this.d;
			var tx = this.tx;
			var ty = this.ty;

			this.a = a + b * tanSkewX;
			this.b = b + a * tanSkewY;
			this.c = c + d * tanSkewX;
			this.d = d + c * tanSkewY;
			this.tx = tx + ty * tanSkewX;
			this.ty = ty + tx * tanSkewY;
		};

		this.concat = function(matrix)
		{
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;
			var tx1 = this.tx;
			var ty1 = this.ty;

			var a2 = matrix.a;
			var b2 = matrix.b;
			var c2 = matrix.c;
			var d2 = matrix.d;
			var tx2 = matrix.tx;
			var ty2 = matrix.ty;

			this.a = a1 * a2 + b1 * c2;
			this.b = b1 * d2 + a1 * b2;
			this.c = c1 * a2 + d1 * c2;
			this.d = d1 * d2 + c1 * b2;
			this.tx = tx1 * a2 + ty1 * c2 + tx2;
			this.ty = ty1 * d2 + tx1 * b2 + ty2;
		};

		this.invert = function()
		{
			var det = this.determinant();
			var a = this.a / det;
			var b = this.b / det;
			var c = this.c / det;
			var d = this.d / det;
			var tx = this.tx;
			var ty = this.ty;

			this.a = d;
			this.b = -b;
			this.c = -c;
			this.d = a;
			this.tx = c * ty - d * tx;
			this.ty = b * tx - a * ty;
		};

		this.identity = function()
		{
			this.a = 1;
			this.b = 0;
			this.c = 0;
			this.d = 1;
			this.tx = 0;
			this.ty = 0;
		};

		this.determinant = function()
		{
			return (this.a * this.d) - (this.b * this.c);
		};

		this.hasInverse = function()
		{
			var det = Math.abs(this.determinant());
			return ((det > 0) && (det < Infinity));
		};

		this.hasNaN = function()
		{
			return (isNaN(this.a) ||
		        	isNaN(this.b) ||
			        isNaN(this.c) ||
			        isNaN(this.d) ||
			        isNaN(this.tx) ||
		        	isNaN(this.ty));
		};

		this.hasInfinity = function()
		{
			return ((this.a == Infinity) || (this.a == -Infinity) ||
		        	(this.b == Infinity) || (this.b == -Infinity) ||
			        (this.c == Infinity) || (this.c == -Infinity) ||
			        (this.d == Infinity) || (this.d == -Infinity) ||
			        (this.tx == Infinity) || (this.tx == -Infinity) ||
		        	(this.ty == Infinity) || (this.ty == -Infinity));
		};

		this.hasPositiveInfinity = function()
		{
			return ((this.a == Infinity) ||
		        	(this.b == Infinity) ||
			        (this.c == Infinity) ||
			        (this.d == Infinity) ||
			        (this.tx == Infinity) ||
		        	(this.ty == Infinity));
		};

		this.hasNegativeInfinity = function()
		{
			return ((this.a == -Infinity) ||
		        	(this.b == -Infinity) ||
			        (this.c == -Infinity) ||
			        (this.d == -Infinity) ||
			        (this.tx == -Infinity) ||
		        	(this.ty == -Infinity));
		};

		this.isFinite = function()
		{
			return (((this.a - this.a) === 0) &&
			        ((this.b - this.b) === 0) &&
			        ((this.c - this.c) === 0) &&
			        ((this.d - this.d) === 0) &&
			        ((this.tx - this.tx) === 0) &&
			        ((this.ty - this.ty) === 0));
		};

		this.isIdentity = function()
		{
			return ((this.a == 1) &&
		        	(this.b == 0) &&
			        (this.c == 0) &&
			        (this.d == 1) &&
			        (this.tx == 0) &&
		        	(this.ty == 0));
		};

		this.equals = function(matrix)
		{
			return ((this.a == matrix.a) &&
		        	(this.b == matrix.b) &&
			        (this.c == matrix.c) &&
			        (this.d == matrix.d) &&
			        (this.tx == matrix.tx) &&
		        	(this.ty == matrix.ty));
		};

		this.clone = function()
		{
			return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
		};

		this.toString = function()
		{
			return "(" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.tx + ", " + this.ty + ")";
		};

	});

});
});

jg_import.define("jgatt.geom.Rectangle", function()
{
jg_namespace("jgatt.geom", function()
{

	this.Rectangle = jg_extend(Object, function(Rectangle, base)
	{

		// Public Properties

		this.x = 0;
		this.y = 0;
		this.width = 0;
		this.height = 0;

		// Constructor

		this.constructor = function(x, y, width, height)
		{
			this.x = (x !== undefined) ? x : 0;
			this.y = (y !== undefined) ? y : 0;
			this.width = (width !== undefined) ? width : 0;
			this.height = (height !== undefined) ? height : 0;
		};

		// Public Methods

		this.hasNaN = function()
		{
			return (isNaN(this.x) ||
			        isNaN(this.y) ||
			        isNaN(this.width) ||
			        isNaN(this.height));
		};

		this.hasInfinity = function()
		{
			return ((this.x == Infinity) || (this.x == -Infinity) ||
			        (this.y == Infinity) || (this.y == -Infinity) ||
			        (this.width == Infinity) || (this.width == -Infinity) ||
			        (this.height == Infinity) || (this.height == -Infinity));
		};

		this.hasPositiveInfinity = function()
		{
			return ((this.x == Infinity) ||
			        (this.y == Infinity) ||
			        (this.width == Infinity) ||
			        (this.height == Infinity));
		};

		this.hasNegativeInfinity = function()
		{
			return ((this.x == -Infinity) ||
			        (this.y == -Infinity) ||
			        (this.width == -Infinity) ||
			        (this.height == -Infinity));
		};

		this.isFinite = function()
		{
			return (((this.x - this.x) === 0) &&
			        ((this.y - this.y) === 0) &&
			        ((this.width - this.width) === 0) &&
			        ((this.height - this.height) === 0));
		};

		this.equals = function(rectangle)
		{
			return ((this.x == rectangle.x) &&
			        (this.y == rectangle.y) &&
			        (this.width == rectangle.width) &&
			        (this.height == rectangle.height));
		};

		this.clone = function()
		{
			return new Rectangle(this.x, this.y, this.width, this.height);
		};

		this.toString = function()
		{
			return "(" + this.x + ", " + this.y + ", " + this.width + ", " + this.height + ")";
		};

	});

});
});

jg_import.define("jgatt.graphics.Caps", function()
{
jg_namespace("jgatt.graphics", function()
{

	this.Caps = jg_static(function(Caps)
	{

		// Public Static Constants

		Caps.NONE = "none";
		Caps.ROUND = "round";
		Caps.SQUARE = "square";

	});

});
});

jg_import.define("jgatt.utils.NumberUtils", function()
{
jg_namespace("jgatt.utils", function()
{

	this.NumberUtils = jg_static(function(NumberUtils)
	{

		// Public Static Constants

		NumberUtils.EPSILON = (function()
		{
			var eps = 1;
			var temp = 1;
			while ((1 + temp) > 1)
			{
				eps = temp;
				temp /= 2;
			}
			return eps;
		})();

		NumberUtils.PRECISION = (function()
		{
			var prec = 0;
			var temp = 9;
			while ((temp % 10) == 9)
			{
				prec++;
				temp = temp * 10 + 9;
			}
			return prec;
		})();

		// Public Static Methods

		NumberUtils.parseNumber = function(value)
		{
			if (value == null)
				return NaN;

			switch (typeof value)
			{
				case "number":
					return value;
				case "string":
					return value ? Number(value) : NaN;
				case "boolean":
					return value ? 1 : 0;
			}

			return NaN;
		};

		NumberUtils.toPrecision = function(n, precision)
		{
			precision = (precision !== undefined) ? precision : 0;

			if (precision < 1)
				precision = NumberUtils.PRECISION + precision;

			if (precision < 1)
				precision = 1;
			else if (precision > 21)
				precision = 21;

			return Number(n.toPrecision(precision));
		};

		NumberUtils.toFixed = function(n, decimalDigits)
		{
			decimalDigits = (decimalDigits !== undefined) ? decimalDigits : 0;

			if (decimalDigits < 0)
				decimalDigits = 0;
			else if (decimalDigits > 20)
				decimalDigits = 20;

			return Number(n.toFixed(decimalDigits));
		};

		NumberUtils.roundTo = function(n, units)
		{
			units = (units !== undefined) ? units : 1;

			return NumberUtils.toPrecision(Math.round(n / units) * units, -1);
		};

		NumberUtils.minMax = function(n, min, max)
		{
			if (n < min)
				n = min;
			if (n > max)
				n = max;
			return n;
		};

		NumberUtils.maxMin = function(n, max, min)
		{
			if (n > max)
				n = max;
			if (n < min)
				n = min;
			return n;
		};

		NumberUtils.interpolate = function(n1, n2, f)
		{
			return n1 * (1 - f) + n2 * f;
		};

		NumberUtils.approxZero = function(n, threshold)
		{
			if (n == 0)
				return true;

			threshold = (threshold !== undefined) ? threshold : NaN;
			if (isNaN(threshold))
				threshold = NumberUtils.EPSILON;

			return (n < 0) ? (-n < threshold) : (n < threshold);
		};

		NumberUtils.approxOne = function(n, threshold)
		{
			if (n == 1)
				return true;

			n -= 1;

			threshold = (threshold !== undefined) ? threshold : NaN;
			if (isNaN(threshold))
				threshold = NumberUtils.EPSILON;

			return (n < 0) ? (-n < threshold) : (n < threshold);
		};

		NumberUtils.approxEqual = function(n1, n2, threshold)
		{
			if (n1 == n2)
				return true;

			n1 -= n2;

			threshold = (threshold !== undefined) ? threshold : NaN;
			if (isNaN(threshold))
				threshold = NumberUtils.EPSILON;

			return (n1 < 0) ? (-n1 < threshold) : (n1 < threshold);
		};

		NumberUtils.approxLessThan = function(n1, n2, threshold)
		{
			return ((n1 < n2) && !NumberUtils.approxEqual(n1, n2, threshold));
		};

		NumberUtils.approxLessThanOrEqual = function(n1, n2, threshold)
		{
			return ((n1 < n2) || NumberUtils.approxEqual(n1, n2, threshold));
		};

		NumberUtils.approxGreaterThan = function(n1, n2, threshold)
		{
			return ((n1 > n2) && !NumberUtils.approxEqual(n1, n2, threshold));
		};

		NumberUtils.approxGreaterThanOrEqual = function(n1, n2, threshold)
		{
			return ((n1 > n2) || NumberUtils.approxEqual(n1, n2, threshold));
		};

	});

});
});

jg_import.define("jgatt.graphics.ColorUtils", function()
{
jg_namespace("jgatt.graphics", function()
{

	var NumberUtils = jg_import("jgatt.utils.NumberUtils");

	this.ColorUtils = jg_static(function(ColorUtils)
	{

		// Public Static Methods

		ColorUtils.toRGB = function(color)
		{
			var rgb = {};
			rgb.r = (color >> 16) & 0xFF;
			rgb.g = (color >> 8) & 0xFF;
			rgb.b = color & 0xFF;
			return rgb;
		};

		ColorUtils.fromRGB = function(rgb)
		{
			return ((rgb.r << 16) | (rgb.g << 8) | rgb.b);
		};

		ColorUtils.brightness = function(color, brightness)
		{
			var rgb = ColorUtils.toRGB(color);
			var c;

			if (brightness < 0)
			{
				brightness = -brightness;
				c = 0x00;
			}
			else
			{
				c = 0xFF;
			}

			if (brightness > 1)
				brightness = 1;

			rgb.r += Math.round((c - rgb.r) * brightness);
			rgb.g += Math.round((c - rgb.g) * brightness);
			rgb.b += Math.round((c - rgb.b) * brightness);

			return ColorUtils.fromRGB(rgb);
		};

		ColorUtils.interpolate = function(color1, color2, f)
		{
			var rgb1 = ColorUtils.toRGB(color1);
			var rgb2 = ColorUtils.toRGB(color2);

			var rgb = {};
			rgb.r = Math.round(NumberUtils.interpolate(rgb1.r, rgb2.r, f));
			rgb.g = Math.round(NumberUtils.interpolate(rgb1.g, rgb2.g, f));
			rgb.b = Math.round(NumberUtils.interpolate(rgb1.b, rgb2.b, f));

			return ColorUtils.fromRGB(rgb);
		};

	});

});
});

jg_import.define("jgatt.graphics.GradientType", function()
{
jg_namespace("jgatt.graphics", function()
{

	this.GradientType = jg_static(function(GradientType)
	{

		// Public Static Constants

		GradientType.LINEAR = "linear";
		GradientType.RADIAL = "radial";

	});

});
});

jg_import.define("jgatt.graphics.Graphics", function()
{
jg_namespace("jgatt.graphics", function()
{

	var Matrix = jg_import("jgatt.geom.Matrix");
	var Point = jg_import("jgatt.geom.Point");

	this.Graphics = jg_extend(Object, function(Graphics, base)
	{

		// Private Properties

		this._width = 1;
		this._height = 1;
		this._strokeStyle = null;
		this._strokeCommands = null;
		this._fillCommands = null;
		this._drawingStack = null;
		this._drawingStackIndex = 0;
		this._penX = 0;
		this._penY = 0;

		this._element = null;
		this._canvas = null;
		this._context = null;

		// Constructor

		this.constructor = function(width, height)
		{
			this._width = ((width > 1) && (width < Infinity)) ? Math.floor(width) : 1;
			this._height = ((height > 1) && (height < Infinity)) ? Math.floor(height) : 1;
			this._strokeStyle = { thickness: 1, caps: "none", joints: "miter", miterLimit: 10, pixelHinting: true };
			this._drawingStack = [];
		};

		// Public Methods

		this.appendTo = function(element)
		{
			if (!element)
				throw new Error("Parameter element must be non-null.");

			if (element === this._element)
				return true;

			this.remove();

			var canvas = document.createElement("canvas");
			if (!canvas)
				return false;

			if (typeof canvas.getContext !== "function")
				return false;

			var context = canvas.getContext("2d");
			if (!context)
				return false;

			canvas.style.position = "absolute";
			canvas.width = this._width;
			canvas.height = this._height;

			element.appendChild(canvas);

			this._element = element;
			this._canvas = canvas;
			this._context = context;

			this._draw(true);

			return true;
		};

		this.remove = function()
		{
			if (!this._element)
				return false;

			var context = this._context;
			context.clearRect(0, 0, context.canvas.width, context.canvas.height);
			context.beginPath();

			var canvas = this._canvas;
			var parentNode = canvas.parentNode;
			if (parentNode)
				parentNode.removeChild(canvas);

			this._element = null;
			this._canvas = null;
			this._context = null;

			return true;
		};

		this.setSize = function(width, height)
		{
			width = ((width > 1) && (width < Infinity)) ? Math.floor(width) : 1;
			height = ((height > 1) && (height < Infinity)) ? Math.floor(height) : 1;

			if ((width === this._width) && (height === this._height))
				return;

			this._width = width;
			this._height = height;

			var canvas = this._canvas;
			if (!canvas)
				return;

			canvas.width = width;
			canvas.height = height;

			this._draw(true);
		};

		this.setStrokeStyle = function(thickness, caps, joints, miterLimit, pixelHinting)
		{
			if ((caps != null) && (caps !== "none") && (caps !== "round") && (caps !== "square"))
				throw new Error("Parameter caps must be one of \"none\", \"round\", or \"square\".");
			if ((joints != null) && (joints !== "miter") && (joints !== "round") && (joints !== "bevel"))
				throw new Error("Parameter joints must be one of \"miter\", \"round\", or \"bevel\".");

			thickness *= 1;
			thickness = ((thickness > 0) && (thickness < Infinity)) ? thickness : 1;

			caps = caps ? caps : "none";

			joints = joints ? joints : "miter";

			miterLimit *= 1;
			miterLimit = ((miterLimit > 0) && (miterLimit < Infinity)) ? miterLimit : 10;

			pixelHinting = (pixelHinting != false);

			this._strokeStyle = { thickness: thickness, caps: caps, joints: joints, miterLimit: miterLimit, pixelHinting: pixelHinting };
		};

		this.beginSolidStroke = function(color, alpha)
		{
			this.endStroke();

			color = !isNaN(color) ? Math.min(Math.max(Math.floor(color), 0x000000), 0xFFFFFF) : 0x000000;

			alpha = !isNaN(alpha) ? Math.min(Math.max(alpha, 0), 1) : 1;

			var strokeCommands = this._strokeCommands = [];
			strokeCommands.push({ name: "solidStroke", strokeStyle: this._strokeStyle, color: color, alpha: alpha });
			strokeCommands.push({ name: "moveTo", x: this._penX, y: this._penY });
		};

		this.beginGradientStroke = function(type, colors, alphas, ratios, matrix, focalPointRatio)
		{
			if (type == null)
				throw new Error("Parameter type must be non-null.");
			if ((type !== "linear") && (type !== "radial"))
				throw new Error("Parameter type must be one of \"linear\" or \"radial\".");
			if (colors == null)
				throw new Error("Parameter colors must be non-null.");
			if (!(colors instanceof Array))
				throw new Error("Parameter colors must be an array.");
			if (alphas == null)
				throw new Error("Parameter alphas must be non-null.");
			if (!(alphas instanceof Array))
				throw new Error("Parameter alphas must be an array.");
			if (ratios == null)
				throw new Error("Parameter ratios must be non-null.");
			if (!(ratios instanceof Array))
				throw new Error("Parameter ratios must be an array.");
			if ((matrix != null) && !(matrix instanceof Matrix))
				throw new Error("Parameter matrix must be an instance of jgatt.geom.Matrix.");

			this.endStroke();

			var numStops = Math.min(colors.length, alphas.length, ratios.length);
			colors = colors.slice(0, numStops);
			alphas = alphas.slice(0, numStops);
			ratios = ratios.slice(0, numStops);
			var color;
			var alpha;
			var ratio;
			for (var i = 0; i < numStops; i++)
			{
				color = colors[i];
				colors[i] = !isNaN(color) ? Math.min(Math.max(Math.floor(color), 0x000000), 0xFFFFFF) : 0x000000;

				alpha = alphas[i];
				alphas[i] = !isNaN(alpha) ? Math.min(Math.max(alpha, 0), 1) : 1;

				ratio = ratios[i];
				ratios[i] = !isNaN(ratio) ? Math.min(Math.max(ratio, 0), 1) : 0;
			}

			if (matrix)
			{
				matrix = new Matrix(matrix.a * 1, matrix.b * 1, matrix.c * 1, matrix.d * 1, matrix.tx * 1, matrix.ty * 1);
				if ((matrix.tx - matrix.tx) !== 0)
					matrix.tx = 0;
				if ((matrix.ty - matrix.ty) !== 0)
					matrix.ty = 0;
				if (!matrix.hasInverse())
					matrix = null;
			}

			focalPointRatio = !isNaN(focalPointRatio) ? Math.min(Math.max(focalPointRatio, -1), 1) : 0;

			var strokeCommands = this._strokeCommands = [];
			strokeCommands.push({ name: "gradientStroke", strokeStyle: this._strokeStyle, type: type, colors: colors, alphas: alphas, ratios: ratios, matrix: matrix, focalPointRatio: focalPointRatio });
			strokeCommands.push({ name: "moveTo", x: this._penX, y: this._penY });
		};

		this.beginImageStroke = function(image, matrix, repeat)
		{
		};

		this.endStroke = function()
		{
			if (!this._strokeCommands)
				return;

			this._drawingStack.push(this._strokeCommands);
			this._strokeCommands = null;

			this._draw();
		};

		this.beginSolidFill = function(color, alpha)
		{
			this.endFill();

			color = !isNaN(color) ? Math.min(Math.max(Math.floor(color), 0x000000), 0xFFFFFF) : 0x000000;

			alpha = !isNaN(alpha) ? Math.min(Math.max(alpha, 0), 1) : 1;

			var fillCommands = this._fillCommands = [];
			fillCommands.push({ name: "solidFill", color: color, alpha: alpha });
			fillCommands.push({ name: "moveTo", x: this._penX, y: this._penY });
		};

		this.beginGradientFill = function(type, colors, alphas, ratios, matrix, focalPointRatio)
		{
			if (type == null)
				throw new Error("Parameter type must be non-null.");
			if ((type !== "linear") && (type !== "radial"))
				throw new Error("Parameter type must be one of \"linear\" or \"radial\".");
			if (colors == null)
				throw new Error("Parameter colors must be non-null.");
			if (!(colors instanceof Array))
				throw new Error("Parameter colors must be an array.");
			if (alphas == null)
				throw new Error("Parameter alphas must be non-null.");
			if (!(alphas instanceof Array))
				throw new Error("Parameter alphas must be an array.");
			if (ratios == null)
				throw new Error("Parameter ratios must be non-null.");
			if (!(ratios instanceof Array))
				throw new Error("Parameter ratios must be an array.");
			if ((matrix != null) && !(matrix instanceof Matrix))
				throw new Error("Parameter matrix must be an instance of jgatt.geom.Matrix.");

			this.endFill();

			var numStops = Math.min(colors.length, alphas.length, ratios.length);
			colors = colors.slice(0, numStops);
			alphas = alphas.slice(0, numStops);
			ratios = ratios.slice(0, numStops);
			var color;
			var alpha;
			var ratio;
			for (var i = 0; i < numStops; i++)
			{
				color = colors[i];
				colors[i] = !isNaN(color) ? Math.min(Math.max(Math.floor(color), 0x000000), 0xFFFFFF) : 0x000000;

				alpha = alphas[i];
				alphas[i] = !isNaN(alpha) ? Math.min(Math.max(alpha, 0), 1) : 1;

				ratio = ratios[i];
				ratios[i] = !isNaN(ratio) ? Math.min(Math.max(ratio, 0), 1) : 0;
			}

			if (matrix)
			{
				matrix = new Matrix(matrix.a * 1, matrix.b * 1, matrix.c * 1, matrix.d * 1, matrix.tx * 1, matrix.ty * 1);
				if ((matrix.tx - matrix.tx) !== 0)
					matrix.tx = 0;
				if ((matrix.ty - matrix.ty) !== 0)
					matrix.ty = 0;
				if (!matrix.hasInverse())
					matrix = null;
			}

			focalPointRatio = !isNaN(focalPointRatio) ? Math.min(Math.max(focalPointRatio, -1), 1) : 0;

			var fillCommands = this._fillCommands = [];
			fillCommands.push({ name: "gradientFill", type: type, colors: colors, alphas: alphas, ratios: ratios, matrix: matrix, focalPointRatio: focalPointRatio });
			fillCommands.push({ name: "moveTo", x: this._penX, y: this._penY });
		};

		this.beginImageFill = function(image, matrix, repeat)
		{
		};

		this.endFill = function()
		{
			if (!this._fillCommands)
				return;

			this._drawingStack.push(this._fillCommands);
			this._fillCommands = null;

			this._draw();
		};

		this.moveTo = function(x, y)
		{
			x *= 1;
			if ((x - x) !== 0)
				x = 0;
			y *= 1;
			if ((y - y) !== 0)
				y = 0;

			this._penX = x;
			this._penY = y;

			var command = { name: "moveTo", x: x, y: y };
			if (this._strokeCommands)
				this._strokeCommands.push(command);
			if (this._fillCommands)
				this._fillCommands.push(command);
		};

		this.lineTo = function(x, y)
		{
			x *= 1;
			if ((x - x) !== 0)
				x = 0;
			y *= 1;
			if ((y - y) !== 0)
				y = 0;

			this._penX = x;
			this._penY = y;

			var command = { name: "lineTo", x: x, y: y };
			if (this._strokeCommands)
				this._strokeCommands.push(command);
			if (this._fillCommands)
				this._fillCommands.push(command);
		};

		this.curveTo = function(controlX, controlY, anchorX, anchorY)
		{
			controlX *= 1;
			if ((controlX - controlX) !== 0)
				controlX = 0;
			controlY *= 1;
			if ((controlY - controlY) !== 0)
				controlY = 0;
			anchorX *= 1;
			if ((anchorX - anchorX) !== 0)
				anchorX = 0;
			anchorY *= 1;
			if ((anchorY - anchorY) !== 0)
				anchorY = 0;

			this._penX = anchorX;
			this._penY = anchorY;

			var command = { name: "curveTo", controlX: controlX, controlY: controlY, anchorX: anchorX, anchorY: anchorY };
			if (this._strokeCommands)
				this._strokeCommands.push(command);
			if (this._fillCommands)
				this._fillCommands.push(command);
		};

		this.clear = function()
		{
			this._strokeCommands = null;
			this._fillCommands = null;
			this._drawingStack = [];

			this._draw(true);
		};

		// Private Methods

		this._draw = function(redraw)
		{
			var context = this._context;
			if (!context)
				return;

			if (redraw == true)
			{
				this._drawingStackIndex = 0;

				context.clearRect(0, 0, context.canvas.width, context.canvas.height);
				context.beginPath();
			}

			var drawingStack = this._drawingStack;
			var drawingStackSize = drawingStack.length;
			var commands;
			var i;
			for (i = this._drawingStackIndex; i < drawingStackSize; i++)
			{
				commands = drawingStack[i];
				switch (commands[0].name)
				{
					case "solidStroke":
					case "gradientStroke":
						this._drawStroke(commands);
						break;
					case "solidFill":
					case "gradientFill":
						this._drawFill(commands);
						break;
				}
			}
			this._drawingStackIndex = i;
		};

		this._drawStroke = function(commands)
		{
			var context = this._context;
			if (!context)
				return;

			var numCommands = commands.length;
			var command = commands[0];
			var strokeStyle = command.strokeStyle;
			var offset = strokeStyle.pixelHinting ? (strokeStyle.thickness % 2) / 2 : 0;
			var hasPath = false;
			var startX;
			var startY;
			var endX;
			var endY;
			var gradient;
			var numStops;
			var colors;
			var alphas;
			var ratios;
			var color;
			var alpha;
			var ratio;
			var matrix;
			var i;

			context.beginPath();
			for (i = 1; i < numCommands; i++)
			{
				command = commands[i];
				if (command.name === "moveTo")
				{
					if (hasPath && (startX === endX) && (startY === endY))
						context.closePath();
					hasPath = false;
					startX = command.x;
					startY = command.y;
					context.moveTo(startX + offset, startY + offset);
				}
				else if (command.name === "lineTo")
				{
					hasPath = true;
					endX = command.x;
					endY = command.y;
					context.lineTo(endX + offset, endY + offset);
				}
				else if (command.name === "curveTo")
				{
					hasPath = true;
					endX = command.anchorX;
					endY = command.anchorY;
					context.quadraticCurveTo(command.controlX + offset, command.controlY + offset, endX + offset, endY + offset);
				}
			}
			if (hasPath && (startX === endX) && (startY === endY))
				context.closePath();

			context.save();
			context.lineWidth = strokeStyle.thickness;
			context.lineCap = (strokeStyle.caps === "none") ? "butt" : strokeStyle.caps;
			context.lineJoin = strokeStyle.joints;
			context.miterLimit = strokeStyle.miterLimit;
			command = commands[0];
			if (command.name === "solidStroke")
			{
				color = command.color;
				alpha = command.alpha;
				context.strokeStyle = "rgba(" + ((color >> 16) & 0xFF) + ", " + ((color >> 8) & 0xFF) + ", " + (color & 0xFF) + ", " + alpha + ")";
			}
			else if (command.name === "gradientStroke")
			{
				if (command.type === "radial")
					gradient = context.createRadialGradient(0.5 + 0.49 * command.focalPointRatio, 0.5, 0, 0.5, 0.5, 0.5);
				else
					gradient = context.createLinearGradient(0, 0, 1, 0);
				colors = command.colors;
				alphas = command.alphas;
				ratios = command.ratios;
				numStops = colors.length;
				for (i = 0; i < numStops; i++)
				{
					color = colors[i];
					alpha = alphas[i];
					ratio = ratios[i];
					gradient.addColorStop(ratio, "rgba(" + ((color >> 16) & 0xFF) + ", " + ((color >> 8) & 0xFF) + ", " + (color & 0xFF) + ", " + alpha + ")");
				}
				matrix = command.matrix;
				if (matrix)
					context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
				context.strokeStyle = gradient;
			}
			context.stroke();
			context.restore();
			context.beginPath();
		};

		this._drawFill = function(commands)
		{
			var context = this._context;
			if (!context)
				return;

			var numCommands = commands.length;
			var command;
			var gradient;
			var numStops;
			var colors;
			var alphas;
			var ratios;
			var color;
			var alpha;
			var ratio;
			var matrix;
			var i;

			context.beginPath();
			for (i = 1; i < numCommands; i++)
			{
				command = commands[i];
				if (command.name === "moveTo")
					context.moveTo(command.x, command.y);
				else if (command.name === "lineTo")
					context.lineTo(command.x, command.y);
				else if (command.name === "curveTo")
					context.quadraticCurveTo(command.controlX, command.controlY, command.anchorX, command.anchorY);
			}

			context.save();
			command = commands[0];
			if (command.name === "solidFill")
			{
				color = command.color;
				alpha = command.alpha;
				context.fillStyle = "rgba(" + ((color >> 16) & 0xFF) + ", " + ((color >> 8) & 0xFF) + ", " + (color & 0xFF) + ", " + alpha + ")";
			}
			else if (command.name === "gradientFill")
			{
				if (command.type === "radial")
					gradient = context.createRadialGradient(0.5 + 0.49 * command.focalPointRatio, 0.5, 0, 0.5, 0.5, 0.5);
				else
					gradient = context.createLinearGradient(0, 0, 1, 0);
				colors = command.colors;
				alphas = command.alphas;
				ratios = command.ratios;
				numStops = colors.length;
				for (i = 0; i < numStops; i++)
				{
					color = colors[i];
					alpha = alphas[i];
					ratio = ratios[i];
					gradient.addColorStop(ratio, "rgba(" + ((color >> 16) & 0xFF) + ", " + ((color >> 8) & 0xFF) + ", " + (color & 0xFF) + ", " + alpha + ")");
				}
				matrix = command.matrix;
				if (matrix)
					context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
				context.fillStyle = gradient;
			}
			context.fill();
			context.restore();
			context.beginPath();
		};

	});

});
});

jg_import.define("jgatt.graphics.Joints", function()
{
jg_namespace("jgatt.graphics", function()
{

	this.Joints = jg_static(function(Joints)
	{

		// Public Static Constants

		Joints.MITER = "miter";
		Joints.ROUND = "round";
		Joints.BEVEL = "bevel";

	});

});
});

jg_import.define("jgatt.properties.PropertyEventData", function()
{
jg_namespace("jgatt.properties", function()
{

	var EventData = jg_import("jgatt.events.EventData");

	this.PropertyEventData = jg_extend(EventData, function(PropertyEventData, base)
	{

		// Public Properties

		this.property = null;
		this.oldValue = null;
		this.newValue = null;

		// Constructor

		this.constructor = function(property, oldValue, newValue)
		{
			this.property = property;
			this.oldValue = oldValue;
			this.newValue = newValue;
		};

	});

});
});

jg_import.define("jgatt.graphics.brushes.Brush", function()
{
jg_namespace("jgatt.graphics.brushes", function()
{

	var MObservable = jg_import("jgatt.events.MObservable");
	var Matrix = jg_import("jgatt.geom.Matrix");
	var Point = jg_import("jgatt.geom.Point");
	var Graphics = jg_import("jgatt.graphics.Graphics");
	var MPropertyTarget = jg_import("jgatt.properties.MPropertyTarget");
	var Property = jg_import("jgatt.properties.Property");
	var PropertyEventData = jg_import("jgatt.properties.PropertyEventData");

	this.Brush = jg_extend(Object, function(Brush, base)
	{

		base = jg_mixin(this, MObservable, base);
		base = jg_mixin(this, MPropertyTarget, base);

		// Private Properties

		this._properties = null;
		this._commands = null;
		this._graphics = null;
		this._matrix = null;
		this._bounds = null;

		// Constructor

		this.constructor = function()
		{
			base.constructor.call(this);

			this.addEventListener(this.changed, this._self_changed, Infinity);
		};

		// Public Methods

		this.beginBrush = function(graphics, matrix, bounds)
		{
			if (!graphics)
				throw new Error("Parameter graphics must be non-null.");
			if (!(graphics instanceof Graphics))
				throw new Error("Parameter graphics must be an instance of jgatt.graphics.Graphics.");
			if ((matrix != null) && !(matrix instanceof Matrix))
				throw new Error("Parameter matrix must be an instance of jgatt.geom.Matrix.");
			if ((bounds != null) && !(bounds instanceof Array))
				throw new Error("Parameter bounds must be an array.");

			this.endBrush();

			if (!this._properties)
				this._properties = this._getProperties();
			this._commands = [];
			this._graphics = graphics;
			this._matrix = matrix ? matrix.clone() : null;
			if (bounds)
			{
				var bounds2 = this._bounds = [];
				var numPoints = bounds.length;
				var point;
				for (var i = 0; i < numPoints; i++)
				{
					point = bounds[i];
					if (point instanceof Point)
						bounds2.push(point.clone());
				}
			}
		};

		this.endBrush = function()
		{
			if (!this._graphics)
				return;

			this.draw(this._properties, this._commands, this._graphics, this._matrix, this._bounds);

			this._commands = null;
			this._graphics = null;
			this._matrix = null;
			this._bounds = null;
		};

		this.moveTo = function(x, y)
		{
			if (!this._graphics)
				return;

			this._commands.push({ name: "moveTo", x: x, y: y });
		};

		this.lineTo = function(x, y)
		{
			if (!this._graphics)
				return;

			this._commands.push({ name: "lineTo", x: x, y: y });
		};

		this.curveTo = function(controlX, controlY, anchorX, anchorY)
		{
			if (!this._graphics)
				return;

			this._commands.push({ name: "curveTo", controlX: controlX, controlY: controlY, anchorX: anchorX, anchorY: anchorY });
		};

		// Protected Methods

		this.draw = function(properties, commands, graphics, matrix, bounds)
		{
		};

		// Private Methods

		this._getProperties = function()
		{
			var properties = {};
			var property;
			for (var p in this)
			{
				property = this[p];
				if (property instanceof Property)
					properties[p] = this.getInternal(property);
			}
			return properties;
		};

		this._self_changed = function(e)
		{
			if ((e.target === this) && (e instanceof PropertyEventData))
				this._properties = null;
		};

	});

});
});

jg_import.define("jgatt.graphics.brushes.DrawingUtils", function()
{
jg_namespace("jgatt.graphics.brushes", function()
{

	var Point = jg_import("jgatt.geom.Point");
	var Brush = jg_import("jgatt.graphics.brushes.Brush");

	this.DrawingUtils = jg_static(function(DrawingUtils)
	{

		// Public Static Methods

		DrawingUtils.arcTo = function(brush, startX, startY, startAngle, arcAngle, radius, radiusY)
		{
			if (brush == null)
				throw new Error("Parameter brush must be non-null.");
			if (!(brush instanceof Brush))
				throw new Error("Parameter brush must be an instance of jgatt.graphics.brushes.Brush.");

			if (arcAngle > 360)
				arcAngle = 360;
			else if (arcAngle < -360)
				arcAngle = -360;

			if (radiusY === undefined)
				radiusY = radius;

			var segs = Math.ceil(Math.abs(arcAngle) / 45);
			var segAngle = arcAngle / segs;
			var theta = (segAngle / 180) * Math.PI;
			var cosThetaMid = Math.cos(theta / 2);
			var angle = (startAngle / 180) * Math.PI;
			var angleMid;
			var ax = startX - Math.cos(angle) * radius;
			var ay = startY - Math.sin(angle) * radiusY;
			var bx;
			var by;
			var cx;
			var cy;
			var i;

			for (i = 0; i < segs; i++)
			{
				angle += theta;
				angleMid = angle - (theta / 2);
				bx = ax + Math.cos(angle) * radius;
				by = ay + Math.sin(angle) * radiusY;
				cx = ax + Math.cos(angleMid) * (radius / cosThetaMid);
				cy = ay + Math.sin(angleMid) * (radiusY / cosThetaMid);
				brush.curveTo(cx, cy, bx, by);
			}

			return new Point(bx, by);
		};

		DrawingUtils.drawRectangle = function(brush, x, y, width, height)
		{
			if (brush == null)
				throw new Error("Parameter brush must be non-null.");
			if (!(brush instanceof Brush))
				throw new Error("Parameter brush must be an instance of jgatt.graphics.brushes.Brush.");

			var x2 = x + width;
			var y2 = y + height;

			brush.moveTo(x, y);
			brush.lineTo(x2, y);
			brush.lineTo(x2, y2);
			brush.lineTo(x, y2);
			brush.lineTo(x, y);
		};

		DrawingUtils.drawEllipse = function(brush, x, y, radiusX, radiusY)
		{
			if (brush == null)
				throw new Error("Parameter brush must be non-null.");
			if (!(brush instanceof Brush))
				throw new Error("Parameter brush must be an instance of jgatt.graphics.brushes.Brush.");

			x += radiusX;

			brush.moveTo(x, y);
			DrawingUtils.arcTo(brush, x, y, 0, 360, radiusX, radiusY);
		};

	});

});
});

jg_import.define("jgatt.utils.FunctionUtils", function()
{
jg_namespace("jgatt.utils", function()
{

	this.FunctionUtils = jg_static(function(FunctionUtils)
	{

		// Public Static Methods

		FunctionUtils.bind = function(f, scope)
		{
			if (f == null)
				throw new Error("Parameter f must be non-null.");
			if (typeof f !== "function")
				throw new Error("Parameter f must be a function.");

			return function() { return f.apply(scope, arguments); };
		};

	});

});
});

jg_import.define("jgatt.properties.ObservableProperty", function()
{
jg_namespace("jgatt.properties", function()
{

	var ChainedEvent = jg_import("jgatt.events.ChainedEvent");
	var Event = jg_import("jgatt.events.Event");
	var EventData = jg_import("jgatt.events.EventData");
	var MObservable = jg_import("jgatt.events.MObservable");
	var Property = jg_import("jgatt.properties.Property");
	var PropertyEventData = jg_import("jgatt.properties.PropertyEventData");
	var Dictionary = jg_import("jgatt.utils.Dictionary");
	var FunctionUtils = jg_import("jgatt.utils.FunctionUtils");

	this.ObservableProperty = jg_extend(Property, function(ObservableProperty, base)
	{

		// Private Static Methods

		var _defaultChangedComparator = function(oldValue, newValue)
		{
			if (oldValue === newValue)
				return false;

			// handle NaN
			if ((oldValue !== oldValue) && (newValue !== newValue))
				return false;

			return true;
		};

		// Public Events

		this.changed = null;

		// Private Properties

		this._noChaining = false;
		this._changedComparator = null;
		this._onChanged = null;

		// Constructor

		this.constructor = function(name, type, defaultValue, readOnly, noChaining)
		{
			base.constructor.call(this, name, type, defaultValue, readOnly);

			if ((noChaining != null) && (typeof noChaining !== "boolean"))
				throw new Error("Parameter noChaining must be a boolean.");

			this._noChaining = (noChaining === true);

			this.changed = this._noChaining ? new Event("changed", EventData) : new ChainedEvent("changed", MObservable.changed);
		};

		// Public Getters/Setters

		this.noChaining = function()
		{
			return this._noChaining;
		};

		this.changedComparator = function(value)
		{
			if (arguments.length == 0)
				return this._changedComparator;

			if ((value != null) && (typeof value !== "function"))
				throw new Error("Parameter changedComparator must be a function.");

			this._changedComparator = value ? value : null;

			return this;
		};

		this.onChanged = function(value)
		{
			if (arguments.length == 0)
				return this._onChanged;

			if ((value != null) && (typeof value !== "function"))
				throw new Error("Parameter onChanged must be a function.");

			this._onChanged = value ? value : null;

			return this;
		};

		// Public Methods

		this.setInternal = function(target, propertyMap, value)
		{
			value = this.assertType(value, "Value assigned to property " + this._name + " is incompatible with property type.");

			var propertyInfo = propertyMap.get(this);
			if (!propertyInfo)
				propertyInfo = propertyMap.set(this, this.createPropertyInfo(this, target));

			if (propertyInfo.isChanging)
				return false;

			try
			{
				propertyInfo.isChanging = true;

				var oldValue = propertyInfo.value;

				if (this._changedComparator)
				{
					if (!this._changedComparator.call(target, oldValue, value))
						return false;
				}
				else if (!_defaultChangedComparator(oldValue, value))
				{
					return false;
				}

				if (this._setter)
					this._setter.call(target, value);

				propertyInfo.value = value;
				propertyInfo.setupValueChain();

				if (propertyInfo.isObservable)
					target.dispatchEvent(this.changed, new PropertyEventData(this, oldValue, value));
			}
			finally
			{
				propertyInfo.isChanging = false;
			}

			return true;
		};

		// Protected Methods

		this.createPropertyInfo = function(property, target)
		{
			return new ObservableProperty.PropertyInfo(property, target);
		};

	});

	this.ObservableProperty.PropertyInfo = jg_extend(Property.PropertyInfo, function(PropertyInfo, base)
	{

		// Public Properties

		this.cachedValue = null;
		this.isObservable = false;
		this.isChanging = false;
		this.isValueChangingMap = null;

		// Constructor

		this.constructor = function(property, target)
		{
			base.constructor.call(this, property, target);

			this.isObservable = jg_has_mixin(target, MObservable);
			this.isValueChangingMap = new Dictionary();

			this.value_changed = FunctionUtils.bind(this.value_changed, this);

			if (property._onChanged && this.isObservable)
				target.addEventListener(property.changed, property._onChanged, Infinity);
		};

		// Public Methods

		this.setupValueChain = function()
		{
			this.clearValueChain();

			var value = this.value;
			if ((value == null) || !jg_has_mixin(value, MObservable))
				return;

			this.cachedValue = value;

			value.addEventListener(value.changed, this.value_changed, -Infinity);
		};

		this.clearValueChain = function()
		{
			var value = this.cachedValue;
			if (value == null)
				return;

			value.removeEventListener(value.changed, this.value_changed);

			this.cachedValue = null;
		};

		this.value_changed = function(e)
		{
			if (!this.isObservable || this.isChanging || this.isValueChangingMap.has(e) || e.isPropagationStopped())
				return;

			try
			{
				this.isValueChangingMap.set(e, true);

				this.target.dispatchEvent(this.property.changed, e);
			}
			finally
			{
				this.isValueChangingMap.del(e);
			}
		};

	});

});
});

jg_import.define("jgatt.graphics.brushes.TileBrush", function()
{
jg_namespace("jgatt.graphics.brushes", function()
{

	var Matrix = jg_import("jgatt.geom.Matrix");
	var Point = jg_import("jgatt.geom.Point");
	var Brush = jg_import("jgatt.graphics.brushes.Brush");
	var ObservableProperty = jg_import("jgatt.properties.ObservableProperty");

	this.TileBrush = jg_extend(Brush, function(TileBrush, base)
	{

		// Public Properties

		this.stretchMode = new ObservableProperty("stretchMode", String, "fill")
			.writeFilter(function(value)
			{
				switch (value)
				{
					case "none":
					case "fill":
					case "uniform":
					case "uniformToFill":
					case "uniformToWidth":
					case "uniformToHeight":
						return value;
					default:
						return "fill";
				}
			});

		this.alignmentX = new ObservableProperty("alignmentX", Number, 0.5)
			.writeFilter(function(value)
			{
				return ((value > -Infinity) && (value < Infinity)) ? value : 0.5;
			});

		this.alignmentY = new ObservableProperty("alignmentY", Number, 0.5)
			.writeFilter(function(value)
			{
				return ((value > -Infinity) && (value < Infinity)) ? value : 0.5;
			});

		this.tileTransform = new ObservableProperty("tileTransform", Matrix, null)
			.readFilter(function(value)
			{
				return value ? value.clone() : null;
			})
			.writeFilter(function(value)
			{
				return value ? value.clone() : null;
			});

		this.renderTransform = new ObservableProperty("renderTransform", Matrix, null)
			.readFilter(function(value)
			{
				return value ? value.clone() : null;
			})
			.writeFilter(function(value)
			{
				return value ? value.clone() : null;
			});

		this.fitToDrawing = new ObservableProperty("fitToDrawing", Boolean, false);

		// Constructor

		this.constructor = function(stretchMode, alignmentX, alignmentY, tileTransform, renderTransform, fitToDrawing)
		{
			base.constructor.call(this);

			if (stretchMode != null)
				this.set(this.stretchMode, stretchMode);
			if (alignmentX != null)
				this.set(this.alignmentX, alignmentX);
			if (alignmentY != null)
				this.set(this.alignmentY, alignmentY);
			if (tileTransform != null)
				this.set(this.tileTransform, tileTransform);
			if (renderTransform != null)
				this.set(this.renderTransform, renderTransform);
			if (fitToDrawing != null)
				this.set(this.fitToDrawing, fitToDrawing);
		};

		// Protected Methods

		this.computeTileMatrix = function(tileWidth, tileHeight, properties, commands, matrix, bounds)
		{
			var tileMatrix;

			var tileTransform = properties.tileTransform;
			if (tileTransform)
			{
				tileMatrix = tileTransform.clone();

				var p1 = new Point(0, 0);
				var p2 = new Point(tileWidth, 0);
				var p3 = new Point(tileWidth, tileHeight);
				var p4 = new Point(0, tileHeight);

				p1 = tileMatrix.transformPoint(p1);
				p2 = tileMatrix.transformPoint(p2);
				p3 = tileMatrix.transformPoint(p3);
				p4 = tileMatrix.transformPoint(p4);

				var left = Math.min(p1.x, p2.x, p3.x, p4.x);
				var right = Math.max(p1.x, p2.x, p3.x, p4.x);
				var top = Math.min(p1.y, p2.y, p3.y, p4.y);
				var bottom = Math.max(p1.y, p2.y, p3.y, p4.y);

				tileWidth = right - left;
				tileHeight = bottom - top;
				tileMatrix.translate(-left, -top);
			}
			else
			{
				tileMatrix = new Matrix();
			}

			var invertedMatrix;
			if (matrix && matrix.hasInverse())
			{
				invertedMatrix = matrix.clone();
				invertedMatrix.invert();
			}

			var minX = Infinity;
			var minY = Infinity;
			var maxX = -Infinity;
			var maxY = -Infinity;
			var point;
			var i;

			if (bounds && !properties.fitToDrawing)
			{
				var numPoints = bounds.length;
				for (i = 0; i < numPoints; i++)
				{
					point = bounds[i];

					if (invertedMatrix)
						point = invertedMatrix.transformPoint(point);

					minX = Math.min(point.x, minX);
					minY = Math.min(point.y, minY);
					maxX = Math.max(point.x, maxX);
					maxY = Math.max(point.y, maxY);
				}
			}
			else
			{
				var numCommands = commands.length;
				var command;
				for (i = 0; i < numCommands; i++)
				{
					command = commands[i];
					if (command.name == "moveTo")
						point = new Point(command.x, command.y);
					else if (command.name == "lineTo")
						point = new Point(command.x, command.y);
					else if (command.name == "curveTo")
						point = new Point(command.anchorX, command.anchorY);  // control point tangents need to be properly computed
					else
						continue;

					if (invertedMatrix)
						point = invertedMatrix.transformPoint(point);

					minX = Math.min(point.x, minX);
					minY = Math.min(point.y, minY);
					maxX = Math.max(point.x, maxX);
					maxY = Math.max(point.y, maxY);
				}
			}

			if (minX == Infinity)
				minX = minY = maxX = maxY = 0;

			var width = maxX - minX;
			var height = maxY - minY;
			var scaleX;
			var scaleY;
			var offsetX;
			var offsetY;

			switch (properties.stretchMode)
			{
				case "none":
					offsetX = (width - tileWidth) * properties.alignmentX;
					offsetY = (height - tileHeight) * properties.alignmentY;
					tileMatrix.translate(offsetX, offsetY);
					break;
				case "uniform":
					scaleX = (tileWidth > 0) ? (width / tileWidth) : 1;
					scaleY = (tileHeight > 0) ? (height / tileHeight) : 1;
					scaleX = scaleY = Math.min(scaleX, scaleY);
					offsetX = (width - tileWidth * scaleX) * properties.alignmentX;
					offsetY = (height - tileHeight * scaleY) * properties.alignmentY;
					tileMatrix.scale(scaleX, scaleY);
					tileMatrix.translate(offsetX, offsetY);
					break;
				case "uniformToFill":
					scaleX = (tileWidth > 0) ? (width / tileWidth) : 1;
					scaleY = (tileHeight > 0) ? (height / tileHeight) : 1;
					scaleX = scaleY = Math.max(scaleX, scaleY);
					offsetX = (width - tileWidth * scaleX) * properties.alignmentX;
					offsetY = (height - tileHeight * scaleY) * properties.alignmentY;
					tileMatrix.scale(scaleX, scaleY);
					tileMatrix.translate(offsetX, offsetY);
					break;
				case "uniformToWidth":
					scaleX = scaleY = (tileWidth > 0) ? (width / tileWidth) : 1;
					offsetX = (width - tileWidth * scaleX) * properties.alignmentX;
					offsetY = (height - tileHeight * scaleY) * properties.alignmentY;
					tileMatrix.scale(scaleX, scaleY);
					tileMatrix.translate(offsetX, offsetY);
					break;
				case "uniformToHeight":
					scaleX = scaleY = (tileHeight > 0) ? (height / tileHeight) : 1;
					offsetX = (width - tileWidth * scaleX) * properties.alignmentX;
					offsetY = (height - tileHeight * scaleY) * properties.alignmentY;
					tileMatrix.scale(scaleX, scaleY);
					tileMatrix.translate(offsetX, offsetY);
					break;
				default:  // "fill"
					scaleX = (tileWidth > 0) ? (width / tileWidth) : 1;
					scaleY = (tileHeight > 0) ? (height / tileHeight) : 1;
					tileMatrix.scale(scaleX, scaleY);
					break;
			}

			var renderTransform = properties.renderTransform;
			if (renderTransform)
				tileMatrix.concat(renderTransform);

			tileMatrix.translate(minX, minY);

			if (matrix)
				tileMatrix.concat(matrix);

			return tileMatrix;
		};

	});

});
});

jg_import.define("jgatt.properties.ObservableArrayProperty", function()
{
jg_namespace("jgatt.properties", function()
{

	var MObservable = jg_import("jgatt.events.MObservable");
	var ObservableProperty = jg_import("jgatt.properties.ObservableProperty");
	var TypeUtils = jg_import("jgatt.utils.TypeUtils");

	this.ObservableArrayProperty = jg_extend(ObservableProperty, function(ObservableArrayProperty, base)
	{

		// Private Properties

		this._elementType = null;

		// Constructor

		this.constructor = function(name, elementType, defaultValue, readOnly, noChaining)
		{
			if (elementType == null)
				throw new Error("Parameter elementType must be non-null.");
			if (typeof elementType !== "function")
				throw new Error("Parameter elementType must be a class.");

			this._elementType = elementType;

			base.constructor.call(this, name, Array, defaultValue, readOnly, noChaining);
		};

		// Public Getters/Setters

		this.elementType = function()
		{
			return this._elementType;
		};

		// Protected Methods

		this.assertType = function(value, message)
		{
			if (value == null)
				return null;

			if (!(value instanceof Array))
				throw new Error(message);

			var elementType = this._elementType;
			if (elementType === Object)
				return value;

			var elementValue;
			for (var i = 0, l = value.length; i < l; i++)
			{
				elementValue = value[i];
				if ((elementValue == null) || !TypeUtils.isTypeOf(elementValue, elementType))
					throw new Error(message);
			}

			return value;
		};

		this.createPropertyInfo = function(property, target)
		{
			return new ObservableArrayProperty.PropertyInfo(property, target);
		};

	});

	this.ObservableArrayProperty.PropertyInfo = jg_extend(ObservableProperty.PropertyInfo, function(PropertyInfo, base)
	{

		// Public Properties

		this.cachedElementValues = null;

		// Constructor

		this.constructor = function(property, target)
		{
			base.constructor.call(this, property, target);
		};

		// Public Methods

		this.setupValueChain = function()
		{
			this.clearValueChain();

			var value = this.value;
			if (value == null)
				return;

			if (jg_has_mixin(value, MObservable))
			{
				this.cachedValue = value;
				value.addEventListener(value.changed, this.value_changed, -Infinity);
			}

			if (value.length == 0)
				return;

			var elementValues = this.cachedElementValues = [];
			var elementValue;
			for (var i = 0, l = value.length; i < l; i++)
			{
				elementValue = value[i];
				if (jg_has_mixin(elementValue, MObservable))
				{
					elementValues.push(elementValue);
					elementValue.addEventListener(elementValue.changed, this.value_changed, -Infinity);
				}
			}
		};

		this.clearValueChain = function()
		{
			var elementValues = this.cachedElementValues;
			if (elementValues)
			{
				var elementValue;
				for (var i = elementValues.length - 1; i >= 0; i--)
				{
					elementValue = value[i];
					elementValue.removeEventListener(elementValue.changed, this.value_changed);
				}
				this.cachedElementValues = null;
			}

			var value = this.cachedValue;
			if (value != null)
			{
				value.removeEventListener(value.changed, this.value_changed);
				this.cachedValue = null;
			}
		};

	});

});
});

jg_import.define("jgatt.graphics.brushes.GradientFillBrush", function()
{
jg_namespace("jgatt.graphics.brushes", function()
{

	var Matrix = jg_import("jgatt.geom.Matrix");
	var TileBrush = jg_import("jgatt.graphics.brushes.TileBrush");
	var ObservableArrayProperty = jg_import("jgatt.properties.ObservableArrayProperty");
	var ObservableProperty = jg_import("jgatt.properties.ObservableProperty");
	var NumberUtils = jg_import("jgatt.utils.NumberUtils");

	this.GradientFillBrush = jg_extend(TileBrush, function(GradientFillBrush, base)
	{

		// Public Properties

		this.type = new ObservableProperty("type", String, "linear")
			.writeFilter(function(value)
			{
				switch (value)
				{
					case "linear":
					case "radial":
						return value;
					default:
						return "linear";
				}
			});

		this.colors = new ObservableArrayProperty("colors", Number, [])
			.readFilter(function(value)
			{
				return value.concat();
			})
			.writeFilter(function(value)
			{
				return value ? value.concat() : [];
			});

		this.alphas = new ObservableArrayProperty("alphas", Number, [])
			.readFilter(function(value)
			{
				return value.concat();
			})
			.writeFilter(function(value)
			{
				return value ? value.concat() : [];
			});

		this.ratios = new ObservableArrayProperty("ratios", Number, [])
			.readFilter(function(value)
			{
				return value.concat();
			})
			.writeFilter(function(value)
			{
				return value ? value.concat() : [];
			});

		this.focalPointRatio = new ObservableProperty("focalPointRatio", Number, 0)
			.writeFilter(function(value)
			{
				return !isNaN(value) ? NumberUtils.minMax(value, -1, 1) : 0;
			});

		this.gradientWidth = new ObservableProperty("gradientWidth", Number, 100)
			.writeFilter(function(value)
			{
				return ((value > 0) && (value < Infinity)) ? value : 100;
			});

		this.gradientHeight = new ObservableProperty("gradientHeight", Number, 100)
			.writeFilter(function(value)
			{
				return ((value > 0) && (value < Infinity)) ? value : 100;
			});

		// Constructor

		this.constructor = function(type, colors, alphas, ratios, focalPointRatio)
		{
			base.constructor.call(this);

			if (type != null)
				this.set(this.type, type);
			if (colors != null)
				this.set(this.colors, colors);
			if (alphas != null)
				this.set(this.alphas, alphas);
			if (ratios != null)
				this.set(this.ratios, ratios);
			if (focalPointRatio != null)
				this.set(this.focalPointRatio, focalPointRatio);
		};

		// Protected Methods

		this.draw = function(properties, commands, graphics, matrix, bounds)
		{
			var gradientWidth = properties.gradientWidth;
			var gradientHeight = properties.gradientHeight;

			var tileMatrix = new Matrix(gradientWidth, 0, 0, gradientHeight);
			tileMatrix.concat(this.computeTileMatrix(gradientWidth, gradientHeight, properties, commands, matrix, bounds));

			graphics.beginGradientFill(properties.type, properties.colors, properties.alphas, properties.ratios, tileMatrix, properties.focalPointRatio);

			var numCommands = commands.length;
			var command;
			for (var i = 0; i < numCommands; i++)
			{
				command = commands[i];
				if (command.name === "moveTo")
					graphics.moveTo(command.x, command.y);
				else if (command.name === "lineTo")
					graphics.lineTo(command.x, command.y);
				else if (command.name === "curveTo")
					graphics.curveTo(command.controlX, command.controlY, command.anchorX, command.anchorY);
			}

			graphics.endFill();
		};

	});

});
});

jg_import.define("jgatt.graphics.brushes.GroupBrush", function()
{
jg_namespace("jgatt.graphics.brushes", function()
{

	var Brush = jg_import("jgatt.graphics.brushes.Brush");
	var ObservableArrayProperty = jg_import("jgatt.properties.ObservableArrayProperty");

	this.GroupBrush = jg_extend(Brush, function(GroupBrush, base)
	{

		// Public Properties

		this.brushes = new ObservableArrayProperty("brushes", Brush, [])
			.readFilter(function(value)
			{
				return value.concat();
			})
			.writeFilter(function(value)
			{
				return value ? value.concat() : [];
			});

		// Constructor

		this.constructor = function(brushes)
		{
			base.constructor.call(this);

			if (brushes != null)
				this.set(this.brushes, brushes);
		};

		// Protected Methods

		this.draw = function(properties, commands, graphics, matrix, bounds)
		{
			var brushes = properties.brushes;
			var numBrushes = brushes.length;
			var brush;
			var numCommands = commands.length;
			var command;
			var i;
			var j;

			for (i = 0; i < numBrushes; i++)
			{
				brush = brushes[i];
				brush.beginBrush(graphics, matrix, bounds);
				for (j = 0; j < numCommands; j++)
				{
					command = commands[j];
					if (command.name === "moveTo")
						brush.moveTo(command.x, command.y);
					else if (command.name === "lineTo")
						brush.lineTo(command.x, command.y);
					else if (command.name === "curveTo")
						brush.curveTo(command.controlX, command.controlY, command.anchorX, command.anchorY);
				}
				brush.endBrush();
			}
		};

	});

});
});

jg_import.define("jgatt.graphics.brushes.SolidFillBrush", function()
{
jg_namespace("jgatt.graphics.brushes", function()
{

	var Brush = jg_import("jgatt.graphics.brushes.Brush");
	var ObservableProperty = jg_import("jgatt.properties.ObservableProperty");
	var NumberUtils = jg_import("jgatt.utils.NumberUtils");

	this.SolidFillBrush = jg_extend(Brush, function(SolidFillBrush, base)
	{

		// Public Properties

		this.color = new ObservableProperty("color", Number, 0x000000)
			.writeFilter(function(value)
			{
				return !isNaN(value) ? NumberUtils.minMax(Math.floor(value), 0x000000, 0xFFFFFF) : 0x000000;
			});

		this.alpha = new ObservableProperty("alpha", Number, 1)
			.writeFilter(function(value)
			{
				return !isNaN(value) ? NumberUtils.minMax(value, 0, 1) : 1;
			});

		// Constructor

		this.constructor = function(color, alpha)
		{
			base.constructor.call(this);

			if (color != null)
				this.set(this.color, color);
			if (alpha != null)
				this.set(this.alpha, alpha);
		};

		// Protected Methods

		this.draw = function(properties, commands, graphics, matrix, bounds)
		{
			graphics.beginSolidFill(properties.color, properties.alpha);

			var numCommands = commands.length;
			var command;
			for (var i = 0; i < numCommands; i++)
			{
				command = commands[i];
				if (command.name === "moveTo")
					graphics.moveTo(command.x, command.y);
				else if (command.name === "lineTo")
					graphics.lineTo(command.x, command.y);
				else if (command.name === "curveTo")
					graphics.curveTo(command.controlX, command.controlY, command.anchorX, command.anchorY);
			}

			graphics.endFill();
		};

	});

});
});

jg_import.define("jgatt.graphics.brushes.SolidStrokeBrush", function()
{
jg_namespace("jgatt.graphics.brushes", function()
{

	var Brush = jg_import("jgatt.graphics.brushes.Brush");
	var ObservableProperty = jg_import("jgatt.properties.ObservableProperty");
	var NumberUtils = jg_import("jgatt.utils.NumberUtils");

	this.SolidStrokeBrush = jg_extend(Brush, function(SolidStrokeBrush, base)
	{

		// Public Properties

		this.color = new ObservableProperty("color", Number, 0x000000)
			.writeFilter(function(value)
			{
				return !isNaN(value) ? NumberUtils.minMax(Math.floor(value), 0x000000, 0xFFFFFF) : 0x000000;
			});

		this.alpha = new ObservableProperty("alpha", Number, 1)
			.writeFilter(function(value)
			{
				return !isNaN(value) ? NumberUtils.minMax(value, 0, 1) : 1;
			});

		this.thickness = new ObservableProperty("thickness", Number, 1)
			.writeFilter(function(value)
			{
				return ((value > 0) && (value < Infinity)) ? value : 1;
			});

		this.caps = new ObservableProperty("caps", String, "none")
			.writeFilter(function(value)
			{
				switch (value)
				{
					case "none":
					case "round":
					case "square":
						return value;
					default:
						return "none";
				}
			});

		this.joints = new ObservableProperty("joints", String, "miter")
			.writeFilter(function(value)
			{
				switch (value)
				{
					case "miter":
					case "round":
					case "bevel":
						return value;
					default:
						return "miter";
				}
			});

		this.miterLimit = new ObservableProperty("miterLimit", Number, 10)
			.writeFilter(function(value)
			{
				return ((value > 0) && (value < Infinity)) ? value : 10;
			});

		this.pixelHinting = new ObservableProperty("pixelHinting", Boolean, true);

		// Constructor

		this.constructor = function(color, alpha, thickness, caps, joints, miterLimit, pixelHinting)
		{
			base.constructor.call(this);

			if (color != null)
				this.set(this.color, color);
			if (alpha != null)
				this.set(this.alpha, alpha);
			if (thickness != null)
				this.set(this.thickness, thickness);
			if (caps != null)
				this.set(this.caps, caps);
			if (joints != null)
				this.set(this.joints, joints);
			if (miterLimit != null)
				this.set(this.miterLimit, miterLimit);
			if (pixelHinting != null)
				this.set(this.pixelHinting, pixelHinting);
		};

		// Protected Methods

		this.draw = function(properties, commands, graphics, matrix, bounds)
		{
			graphics.setStrokeStyle(properties.thickness, properties.caps, properties.joints, properties.miterLimit, properties.pixelHinting);
			graphics.beginSolidStroke(properties.color, properties.alpha);

			var numCommands = commands.length;
			var command;
			for (var i = 0; i < numCommands; i++)
			{
				command = commands[i];
				if (command.name === "moveTo")
					graphics.moveTo(command.x, command.y);
				else if (command.name === "lineTo")
					graphics.lineTo(command.x, command.y);
				else if (command.name === "curveTo")
					graphics.curveTo(command.controlX, command.controlY, command.anchorX, command.anchorY);
			}

			graphics.endStroke();
		};

	});

});
});

jg_import.define("jgatt.graphics.brushes.StretchMode", function()
{
jg_namespace("jgatt.graphics.brushes", function()
{

	this.StretchMode = jg_static(function(StretchMode)
	{

		// Public Static Constants

		StretchMode.NONE = "none";
		StretchMode.FILL = "fill";
		StretchMode.UNIFORM = "uniform";
		StretchMode.UNIFORM_TO_FILL = "uniformToFill";
		StretchMode.UNIFORM_TO_WIDTH = "uniformToWidth";
		StretchMode.UNIFORM_TO_HEIGHT = "uniformToHeight";

	});

});
});

jg_import.define("jgatt.motion.easers.Easer", function()
{
jg_namespace("jgatt.motion.easers", function()
{

	this.Easer = jg_extend(Object, function(Easer, base)
	{

		// Public Properties

		this.direction = 1;

		// Constructor

		this.constructor = function(direction)
		{
			this.direction = (direction !== undefined) ? direction : 1;
		};

		// Public Methods

		this.ease = function(position)
		{
			if (this.direction > 0)
				return this.easeOverride(position);
			else if (this.direction < 0)
				return 1 - this.easeOverride(1 - position);

			if (position < 0.5)
				return this.easeOverride(position * 2) / 2;
			return 0.5 + (1 - this.easeOverride(2 - position * 2)) / 2;
		};

		// Protected Methods

		this.easeOverride = function(position)
		{
			return position;
		};

	});

});
});

jg_import.define("jgatt.motion.Tween", function()
{
jg_namespace("jgatt.motion", function()
{

	var Event = jg_import("jgatt.events.Event");
	var EventData = jg_import("jgatt.events.EventData");
	var MEventTarget = jg_import("jgatt.events.MEventTarget");
	var Easer = jg_import("jgatt.motion.easers.Easer");
	var MPropertyTarget = jg_import("jgatt.properties.MPropertyTarget");
	var Property = jg_import("jgatt.properties.Property");

	this.Tween = jg_extend(Object, function(Tween, base)
	{

		base = jg_mixin(this, MEventTarget, base);
		base = jg_mixin(this, MPropertyTarget, base);

		// Public Events

		this.begin = new Event("begin", EventData);
		this.end = new Event("end", EventData);
		this.update = new Event("update", EventData);

		// Public Properties

		this.easer = new Property("easer", Easer, null)
			.onWrite(function()
			{
				this.endTween();
			});

		// Private Properties

		this._runningEaser = null;
		this._isRunning = false;

		// Constructor

		this.constructor = function(easer)
		{
			base.constructor.call(this);

			if (easer != null)
				this.set(this.easer, easer);
		};

		// Public Methods

		this.beginTween = function()
		{
			this.endTween();

			if (!this.beginTweenOverride())
				return false;

			this._runningEaser = this.getInternal(this.easer);
			this._isRunning = true;

			this.dispatchEvent(this.begin, new EventData());

			return true;
		};

		this.endTween = function()
		{
			if (!this._isRunning)
				return false;

			this.endTweenOverride();

			this._isRunning = false;

			this.dispatchEvent(this.end, new EventData());

			return true;
		};

		this.updateTween = function(position)
		{
			if (!this._isRunning)
				return false;

			var easer = this._runningEaser;
			if (easer)
				position = easer.ease(position);

			if (!this.updateTweenOverride(position))
				return false;

			this.dispatchEvent(this.update, new EventData());

			return true;
		};

		// Protected Methods

		this.beginTweenOverride = function()
		{
			return false;
		};

		this.endTweenOverride = function()
		{
		};

		this.updateTweenOverride = function(position)
		{
			return false;
		};

	});

});
});

jg_import.define("jgatt.properties.ArrayProperty", function()
{
jg_namespace("jgatt.properties", function()
{

	var Property = jg_import("jgatt.properties.Property");
	var TypeUtils = jg_import("jgatt.utils.TypeUtils");

	this.ArrayProperty = jg_extend(Property, function(ArrayProperty, base)
	{

		// Private Properties

		this._elementType = null;

		// Constructor

		this.constructor = function(name, elementType, defaultValue, readOnly)
		{
			if (elementType == null)
				throw new Error("Parameter elementType must be non-null.");
			if (typeof elementType !== "function")
				throw new Error("Parameter elementType must be a class.");

			this._elementType = elementType;

			base.constructor.call(this, name, Array, defaultValue, readOnly);
		};

		// Public Getters/Setters

		this.elementType = function()
		{
			return this._elementType;
		};

		// Protected Methods

		this.assertType = function(value, message)
		{
			if (value == null)
				return null;

			if (!(value instanceof Array))
				throw new Error(message);

			var elementType = this._elementType;
			if (elementType === Object)
				return value;

			var elementValue;
			for (var i = 0, l = value.length; i < l; i++)
			{
				elementValue = value[i];
				if ((elementValue == null) || !TypeUtils.isTypeOf(elementValue, elementType))
					throw new Error(message);
			}

			return value;
		};

	});

});
});

jg_import.define("jgatt.motion.GroupTween", function()
{
jg_namespace("jgatt.motion", function()
{

	var Tween = jg_import("jgatt.motion.Tween");
	var ArrayProperty = jg_import("jgatt.properties.ArrayProperty");

	this.GroupTween = jg_extend(Tween, function(GroupTween, base)
	{

		// Public Properties

		this.tweens = new ArrayProperty("tweens", Tween, [])
			.readFilter(function(value)
			{
				return value.concat();
			})
			.writeFilter(function(value)
			{
				return value ? value.concat() : [];
			})
			.onWrite(function()
			{
				this.endTween();
			});

		// Private Properties

		this._runningTweens = null;

		// Constructor

		this.constructor = function(tweens, easer)
		{
			base.constructor.call(this, easer);

			if (tweens != null)
				this.set(this.tweens, tweens);
		};

		// Protected Methods

		this.beginTweenOverride = function()
		{
			var runningTweens = [];
			var tweens = this.getInternal(this.tweens);
			var tween;

			for (var i = 0, l = tweens.length; i < l; i++)
			{
				tween = tweens[i];
				if (tween.beginTween())
					runningTweens.push(tween);
			}

			if (runningTweens.length == 0)
				return false;

			this._runningTweens = runningTweens;

			return true;
		};

		this.endTweenOverride = function()
		{
			var runningTweens = this._runningTweens;

			for (var i = 0, l = runningTweens.length; i < l; i++)
				runningTweens[i].endTween();

			this._runningTweens = null;
		};

		this.updateTweenOverride = function(position)
		{
			var runningTweens = this._runningTweens;
			var numTweens = runningTweens.length;
			var tween;

			for (var i = 0; i < numTweens; i++)
			{
				tween = runningTweens[i];
				if (!tween.updateTween(position))
				{
					tween.endTween();
					runningTweens.splice(i, 1);
					i--;
					numTweens--;
				}
			}

			return (runningTweens.length > 0);
		};

	});

});
});

jg_import.define("jgatt.motion.interpolators.Interpolator", function()
{
jg_namespace("jgatt.motion.interpolators", function()
{

	this.Interpolator = jg_extend(Object, function(Interpolator, base)
	{

		// Public Methods

		this.interpolate = function(value1, value2, position)
		{
			return (position < 0.5) ? value1 : value2;
		};

	});

});
});

jg_import.define("jgatt.motion.interpolators.NumberInterpolator", function()
{
jg_namespace("jgatt.motion.interpolators", function()
{

	var Interpolator = jg_import("jgatt.motion.interpolators.Interpolator");
	var NumberUtils = jg_import("jgatt.utils.NumberUtils");

	this.NumberInterpolator = jg_extend(Interpolator, function(NumberInterpolator, base)
	{

		// Public Properties

		this.snap = 0;

		// Constructor

		this.constructor = function(snap)
		{
			this.snap = (snap !== undefined) ? snap : 0;
		};

		// Public Methods

		this.interpolate = function(value1, value2, position)
		{
			var number1 = Number(value1);
			var number2 = Number(value2);

			var number = NumberUtils.interpolate(number1, number2, position);

			var snap = this.snap;
			if (snap > 0)
				number = Math.round(number / snap) * snap;

			return number;
		};

	});

});
});

jg_import.define("jgatt.motion.MethodTween", function()
{
jg_namespace("jgatt.motion", function()
{

	var Tween = jg_import("jgatt.motion.Tween");
	var Interpolator = jg_import("jgatt.motion.interpolators.Interpolator");
	var NumberInterpolator = jg_import("jgatt.motion.interpolators.NumberInterpolator");
	var Property = jg_import("jgatt.properties.Property");
	var Dictionary = jg_import("jgatt.utils.Dictionary");

	this.MethodTween = jg_extend(Tween, function(MethodTween, base)
	{

		// Private Static Constants

		var _DEFAULT_INTERPOLATOR = new NumberInterpolator();

		// Private Static Properties

		var _runningTargets = new Dictionary();

		// Public Properties

		this.target = new Property("target", Object, null)
			.onWrite(function()
			{
				this.endTween();
			});

		this.getter = new Property("getter", Function, null)
			.onWrite(function()
			{
				this.endTween();
			});

		this.setter = new Property("setter", Function, null)
			.onWrite(function()
			{
				this.endTween();
			});

		this.startValue = new Property("startValue", Object, null)
			.onWrite(function()
			{
				this.endTween();
			});

		this.endValue = new Property("endValue", Object, null)
			.onWrite(function()
			{
				this.endTween();
			});

		this.interpolator = new Property("interpolator", Interpolator, null)
			.onWrite(function()
			{
				this.endTween();
			});

		// Private Properties

		this._runningTarget = null;
		this._runningGetter = null;
		this._runningSetter = null;
		this._runningStartValue = null;
		this._runningEndValue = null;
		this._runningInterpolator= null;

		// Constructor

		this.constructor = function(target, getter, setter, startValue, endValue, easer, interpolator)
		{
			base.constructor.call(this, easer);

			if (target != null)
				this.set(this.target, target);
			if (getter != null)
				this.set(this.getter, getter);
			if (setter != null)
				this.set(this.setter, setter);
			if (startValue != null)
				this.set(this.startValue, startValue);
			if (endValue != null)
				this.set(this.endValue, endValue);
			if (interpolator != null)
				this.set(this.interpolator, interpolator);
		};

		// Protected Methods

		this.beginTweenOverride = function()
		{
			var target = this.getInternal(this.target);
			if (target == null)
				return false;

			var getter = this.getInternal(this.getter);
			if (getter == null)
				return false;

			var setter = this.getInternal(this.setter);
			if (setter == null)
				return false;

			var endValue = this.getInternal(this.endValue);
			if (endValue == null)
				return false;

			var startValue = this.getInternal(this.startValue);
			if (startValue == null)
			{
				try
				{
					startValue = getter.call(target);
				}
				catch (e)
				{
					return false;
				}
			}

			var interpolator = this.getInternal(this.interpolator);
			if (!interpolator)
				interpolator = _DEFAULT_INTERPOLATOR;

			this._runningTarget = target;
			this._runningGetter = getter;
			this._runningSetter = setter;
			this._runningStartValue = startValue;
			this._runningEndValue = endValue;
			this._runningInterpolator = interpolator;

			var runningSetters = _runningTargets.get(target);
			if (!runningSetters)
				runningSetters = _runningTargets.set(target, new Dictionary());

			var runningTween = runningSetters.get(setter);
			runningSetters.set(setter, this);

			if (runningTween)
				runningTween.endTween();

			return true;
		};

		this.endTweenOverride = function()
		{
			var target = this._runningTarget;
			var setter = this._runningSetter;

			this._runningTarget = null;
			this._runningGetter = null;
			this._runningSetter = null;
			this._runningStartValue = null;
			this._runningEndValue = null;
			this._runningInterpolator = null;

			var runningSetters = _runningTargets.get(target);
			if (runningSetters.get(setter) !== this)
				return;

			runningSetters.del(setter);

			if (runningSetters.size() > 0)
				return;

			_runningTargets.del(target);
		};

		this.updateTweenOverride = function(position)
		{
			var value = this._runningInterpolator.interpolate(this._runningStartValue, this._runningEndValue, position);

			try
			{
				this._runningSetter.call(this._runningTarget, value);
			}
			catch (e)
			{
				return false;
			}

			return true;
		};

	});

});
});

jg_import.define("jgatt.motion.PropertyTween", function()
{
jg_namespace("jgatt.motion", function()
{

	var Tween = jg_import("jgatt.motion.Tween");
	var Interpolator = jg_import("jgatt.motion.interpolators.Interpolator");
	var NumberInterpolator = jg_import("jgatt.motion.interpolators.NumberInterpolator");
	var MPropertyTarget = jg_import("jgatt.properties.MPropertyTarget");
	var Property = jg_import("jgatt.properties.Property");
	var Dictionary = jg_import("jgatt.utils.Dictionary");

	this.PropertyTween = jg_extend(Tween, function(PropertyTween, base)
	{

		// Private Static Constants

		var _DEFAULT_INTERPOLATOR = new NumberInterpolator();

		// Private Static Properties

		var _runningTargets = new Dictionary();

		// Public Properties

		this.target = new Property("target", Object, null)
			.writeFilter(function(value)
			{
				if ((value != null) && !jg_has_mixin(value, MPropertyTarget))
					throw new Error("Parameter target must have the mixin jgatt.properties.MPropertyTarget.");
				return value;
			})
			.onWrite(function()
			{
				this.endTween();
			});

		this.property = new Property("property", Object, null)
			.writeFilter(function(value)
			{
				if ((value != null) && (typeof value !== "string") && !(value instanceof Property))
					throw new Error("Parameter property must be a string or an instance of jgatt.properties.Property.");
				return value;
			})
			.onWrite(function()
			{
				this.endTween();
			});

		this.startValue = new Property("startValue", Object, null)
			.onWrite(function()
			{
				this.endTween();
			});

		this.endValue = new Property("endValue", Object, null)
			.onWrite(function()
			{
				this.endTween();
			});

		this.interpolator = new Property("interpolator", Interpolator, null)
			.onWrite(function()
			{
				this.endTween();
			});

		// Private Properties

		this._runningTarget = null;
		this._runningProperty = null;
		this._runningStartValue = null;
		this._runningEndValue = null;
		this._runningInterpolator= null;

		// Constructor

		this.constructor = function(target, property, startValue, endValue, easer, interpolator)
		{
			base.constructor.call(this, easer);

			if (target != null)
				this.set(this.target, target);
			if (property != null)
				this.set(this.property, property);
			if (startValue != null)
				this.set(this.startValue, startValue);
			if (endValue != null)
				this.set(this.endValue, endValue);
			if (interpolator != null)
				this.set(this.interpolator, interpolator);
		};

		// Protected Methods

		this.beginTweenOverride = function()
		{
			var target = this.getInternal(this.target);
			if (target == null)
				return false;

			var property = this.getInternal(this.property);
			if (property == null)
				return false;

			if (typeof property === "string")
			{
				property = target[property];
				if (!(property instanceof Property))
					return false;
			}

			var endValue = this.getInternal(this.endValue);
			if (endValue == null)
				return false;

			var startValue = this.getInternal(this.startValue);
			if (startValue == null)
			{
				try
				{
					startValue = target.get(property);
				}
				catch (e)
				{
					return false;
				}
			}

			var interpolator = this.getInternal(this.interpolator);
			if (!interpolator)
				interpolator = _DEFAULT_INTERPOLATOR;

			this._runningTarget = target;
			this._runningProperty = property;
			this._runningStartValue = startValue;
			this._runningEndValue = endValue;
			this._runningInterpolator = interpolator;

			var runningProperties = _runningTargets.get(target);
			if (!runningProperties)
				runningProperties = _runningTargets.set(target, new Dictionary());

			var runningTween = runningProperties.get(property);
			runningProperties.set(property, this);

			if (runningTween)
				runningTween.endTween();

			return true;
		};

		this.endTweenOverride = function()
		{
			var target = this._runningTarget;
			var property = this._runningProperty;

			this._runningTarget = null;
			this._runningProperty = null;
			this._runningStartValue = null;
			this._runningEndValue = null;
			this._runningInterpolator = null;

			var runningProperties = _runningTargets.get(target);
			if (runningProperties.get(property) !== this)
				return;

			runningProperties.del(property);

			if (runningProperties.size() > 0)
				return;

			_runningTargets.del(target);
		};

		this.updateTweenOverride = function(position)
		{
			var value = this._runningInterpolator.interpolate(this._runningStartValue, this._runningEndValue, position);

			try
			{
				this._runningTarget.set(this._runningProperty, value);
			}
			catch (e)
			{
				return false;
			}

			return true;
		};

	});

});
});

jg_import.define("jgatt.motion.TweenRunner", function()
{
jg_namespace("jgatt.motion", function()
{

	var Tween = jg_import("jgatt.motion.Tween");
	var Dictionary = jg_import("jgatt.utils.Dictionary");

	this.TweenRunner = jg_static(function(TweenRunner)
	{

		// Private Static Properties

		var _tweenRunInfo = new Dictionary();
		var _tweenInterval = 0;
		var _tweenTime = 0;

		// Private Static Methods

		var _tweenStep = function()
		{
			var tweenTime = (new Date()).getTime() / 1000;

			var time = tweenTime - _tweenTime;
			if (time < 0)
				time = 0;
			else if (time > 0.1)
				time = 0.1;
			_tweenTime = tweenTime;

			var runInfos = _tweenRunInfo.values();
			var runInfo;
			var position;
			for (var i = 0, l = runInfos.length; i < l; i++)
			{
				runInfo = runInfos[i];

				runInfo.time += time;

				position = runInfo.time / runInfo.duration;
				if (position > 1)
					position = 1;

				if (!runInfo.tween.updateTween(position))
					position = 1;

				if (position == 1)
					TweenRunner.stop(runInfo.tween);
			}
		};

		// Public Static Methods

		TweenRunner.start = function(tween, duration)
		{
			if (tween == null)
				throw new Error("Parameter tween must be non-null.");
			if (!(tween instanceof Tween))
				throw new Error("Parameter tween must be an instance of jgatt.motion.Tween.");

			TweenRunner.stop(tween);

			if (!tween.beginTween())
				return false;

			if (!tween.updateTween(0))
			{
				tween.endTween();
			}
			else if (duration > 0)
			{
				var runInfo = _tweenRunInfo.set(tween, { tween: tween, duration: duration, time: 0 });
				if (_tweenRunInfo.size() == 1)
				{
					_tweenInterval = setInterval(_tweenStep, 1000 / 30);
					_tweenTime = (new Date()).getTime() / 1000;
				}
			}
			else
			{
				tween.updateTween(1);
				tween.endTween();
			}

			return true;
		};

		TweenRunner.stop = function(tween)
		{
			if (tween == null)
				throw new Error("Parameter tween must be non-null.");
			if (!(tween instanceof Tween))
				throw new Error("Parameter tween must be an instance of jgatt.motion.Tween.");

			var runInfo = _tweenRunInfo.get(tween);
			if (!runInfo)
				return false;

			_tweenRunInfo.del(tween);

			if (_tweenRunInfo.size() == 0)
				clearInterval(_tweenInterval);

			tween.endTween();

			return true;
		};

	});

});
});

jg_import.define("jgatt.motion.easers.CubicEaser", function()
{
jg_namespace("jgatt.motion.easers", function()
{

	var Easer = jg_import("jgatt.motion.easers.Easer");

	this.CubicEaser = jg_extend(Easer, function(CubicEaser, base)
	{

		// Constructor

		this.constructor = function(direction)
		{
			base.constructor.call(this, direction);
		};

		// Protected Methods

		this.easeOverride = function(position)
		{
			return position * position * position;
		};

	});

});
});

jg_import.define("jgatt.motion.easers.EaseDirection", function()
{
jg_namespace("jgatt.motion.easers", function()
{

	this.EaseDirection = jg_static(function(EaseDirection)
	{

		// Public Static Constants

		EaseDirection.IN = 1;
		EaseDirection.OUT = -1;
		EaseDirection.IN_OUT = 0;

	});

});
});

jg_import.define("jgatt.utils.Comparator", function()
{
jg_namespace("jgatt.utils", function()
{

	this.Comparator = jg_extend(Object, function(Comparator, base)
	{

		// Public Methods

		this.compare = function(value1, value2)
		{
			return 0;
		};

	});

});
});

jg_import.define("jgatt.utils.AlphabeticComparator", function()
{
jg_namespace("jgatt.utils", function()
{

	var Comparator = jg_import("jgatt.utils.Comparator");

	this.AlphabeticComparator = jg_extend(Comparator, function(AlphabeticComparator, base)
	{

		// Public Methods

		this.compare = function(value1, value2)
		{
			var str1 = String(value1).toLowerCase();
			var str2 = String(value2).toLowerCase();
			if (str1 < str2)
				return -1;
			if (str1 > str2)
				return 1;
			return 0;
		};

	});

});
});

jg_import.define("jgatt.utils.NaturalComparator", function()
{
jg_namespace("jgatt.utils", function()
{

	var Comparator = jg_import("jgatt.utils.Comparator");

	this.NaturalComparator = jg_extend(Comparator, function(NaturalComparator, base)
	{

		// Public Methods

		this.compare = function(value1, value2)
		{
			if (value1 < value2)
				return -1;
			if (value1 > value2)
				return 1;
			return 0;
		};

	});

});
});

jg_import.define("jgatt.utils.ArrayUtils", function()
{
jg_namespace("jgatt.utils", function()
{

	var Comparator = jg_import("jgatt.utils.Comparator");
	var NaturalComparator = jg_import("jgatt.utils.NaturalComparator");

	this.ArrayUtils = jg_static(function(ArrayUtils)
	{

		// Private Static Constants

		var _NATURAL_COMPARATOR = new NaturalComparator();

		// Public Static Methods

		ArrayUtils.indexOf = function(a, value)
		{
			if (a == null)
				throw new Error("Parameter a must be non-null.");
			if (!(a instanceof Array))
				throw new Error("Parameter a must be an array.");

			for (var i = 0, l = a.length; i < l; i++)
			{
				if (a[i] === value)
					return i;
			}

			return -1;
		};

		ArrayUtils.lastIndexOf = function(a, value)
		{
			if (a == null)
				throw new Error("Parameter a must be non-null.");
			if (!(a instanceof Array))
				throw new Error("Parameter a must be an array.");

			for (var i = a.length - 1; i >= 0; i--)
			{
				if (a[i] === value)
					return i;
			}

			return -1;
		};

		ArrayUtils.sort = function(a, comparator)
		{
			if (a == null)
				throw new Error("Parameter a must be non-null.");
			if (!(a instanceof Array))
				throw new Error("Parameter a must be an array.");
			if ((comparator != null) && !(comparator instanceof Comparator))
				throw new Error("Parameter comparator must be an instance of jgatt.utils.Comparator.");

			if (!comparator)
				comparator = _NATURAL_COMPARATOR;

			// use delegate so comparator has scope
			var compare = function(value1, value2)
			{
				return comparator.compare(value1, value2);
			};

			a.sort(compare);
		};

		ArrayUtils.binarySearch = function(a, value, comparator)
		{
			if (a == null)
				throw new Error("Parameter a must be non-null.");
			if (!(a instanceof Array))
				throw new Error("Parameter a must be an array.");
			if ((comparator != null) && !(comparator instanceof Comparator))
				throw new Error("Parameter comparator must be an instance of jgatt.utils.Comparator.");

			var high = a.length - 1;
			if (high < 0)
				return -1;

			if (!comparator)
				comparator = _NATURAL_COMPARATOR;

			var low = 0;
			var mid;
			var comp;

			while (low <= high)
			{
				mid = low + Math.floor((high - low) / 2);
				comp = comparator.compare(value, a[mid]);
				if (comp < 0)
					high = mid - 1;
				else if (comp > 0)
					low = mid + 1;
				else
					return mid;
			}

			return -low - 1;
		};

	});

});
});

jg_import.define("jgatt.utils.FunctionComparator", function()
{
jg_namespace("jgatt.utils", function()
{

	var Comparator = jg_import("jgatt.utils.Comparator");

	this.FunctionComparator = jg_extend(Comparator, function(FunctionComparator, base)
	{

		// Private Properties

		this._f = null;

		// Constructor

		this.constructor = function(f)
		{
			if (f == null)
				throw new Error("Parameter f must be non-null.");
			if (typeof f !== "function")
				throw new Error("Parameter f must be a function.");

			this._f = f;
		};

		// Public Methods

		this.compare = function(value1, value2)
		{
			return this._f(value1, value2);
		};

	});

});
});

jg_import.define("jgatt.utils.GroupComparator", function()
{
jg_namespace("jgatt.utils", function()
{

	var Comparator = jg_import("jgatt.utils.Comparator");

	this.GroupComparator = jg_extend(Comparator, function(GroupComparator, base)
	{

		// Private Properties

		this._comparators = null;

		// Constructor

		this.constructor = function(comparators)
		{
			if (comparators == null)
				throw new Error("Parameter comparators must be non-null.");
			if (!(comparators instanceof Array))
				throw new Error("Parameter comparators must be an array.");

			var comparatorsCopy = [];
			var comparator;
			for (var i = 0, l = comparators.length; i < l; i++)
			{
				comparator = comparators[i];
				if (comparator != null)
				{
					if (!(comparator instanceof Comparator))
						throw new Error("Parameter comparators must be an array containing only instances of jgatt.utils.Comparator.");
					comparatorsCopy.push(comparator);
				}
			}

			this._comparators = comparatorsCopy;
		};

		// Public Methods

		this.compare = function(value1, value2)
		{
			var comparators = this._comparators;
			var comparator;
			var result;
			for (var i = 0, l = comparators.length; i < l; i++)
			{
				comparator = comparators[i];
				result = comparator.compare(value1, value2);
				if (result != 0)
					return result;
			}
			return 0;
		};

	});

});
});

jg_import.define("jgatt.utils.NumericComparator", function()
{
jg_namespace("jgatt.utils", function()
{

	var Comparator = jg_import("jgatt.utils.Comparator");
	var NumberUtils = jg_import("jgatt.utils.NumberUtils");

	this.NumericComparator = jg_extend(Comparator, function(NumericComparator, base)
	{

		// Public Methods

		this.compare = function(value1, value2)
		{
			var num1 = NumberUtils.parseNumber(value1);
			var num2 = NumberUtils.parseNumber(value2);
			if (num1 < num2)
				return -1;
			if (num1 > num2)
				return 1;
			return 0;
		};

	});

});
});

jg_import.define("jgatt.utils.PropertyComparator", function()
{
jg_namespace("jgatt.utils", function()
{

	var MPropertyTarget = jg_import("jgatt.properties.MPropertyTarget");
	var Property = jg_import("jgatt.properties.Property");
	var Comparator = jg_import("jgatt.utils.Comparator");
	var NaturalComparator = jg_import("jgatt.utils.NaturalComparator");

	this.PropertyComparator = jg_extend(Comparator, function(PropertyComparator, base)
	{

		// Private Static Methods

		var _getValue = function(target, property)
		{
			if (target == null)
				return undefined;

			if (typeof property === "string")
			{
				var value = target[property];
				if (value instanceof Property)
					property = value;
				else
					return value;
			}

			if (jg_has_mixin(target, MPropertyTarget))
				return target.get(property);

			return undefined;
		};

		// Private Properties

		this._property = null;
		this._comparator = null;

		// Constructor

		this.constructor = function(property, comparator)
		{
			if (property == null)
				throw new Error("Parameter property must be non-null.");
			if ((typeof property !== "string") && !(property instanceof Property))
				throw new Error("Parameter property must be a string or an instance of jgatt.properties.Property.");
			if ((comparator != null) && !(comparator instanceof Comparator))
				throw new Error("Parameter comparator must be an instance of jgatt.utils.Comparator.");

			this._property = property;
			this._comparator = comparator || new NaturalComparator();
		};

		// Public Methods

		this.compare = function(value1, value2)
		{
			var property = this._property;
			value1 = _getValue(value1, property);
			value2 = _getValue(value2, property);
			return this._comparator.compare(value1, value2);
		};

	});

});
});

jg_import.define("jgatt.utils.ReverseComparator", function()
{
jg_namespace("jgatt.utils", function()
{

	var Comparator = jg_import("jgatt.utils.Comparator");
	var NaturalComparator = jg_import("jgatt.utils.NaturalComparator");

	this.ReverseComparator = jg_extend(Comparator, function(ReverseComparator, base)
	{

		// Private Properties

		this._comparator = null;

		// Constructor

		this.constructor = function(comparator)
		{
			if ((comparator != null) && !(comparator instanceof Comparator))
				throw new Error("Parameter comparator must be an instance of jgatt.utils.Comparator.");

			this._comparator = comparator || new NaturalComparator();
		};

		// Public Methods

		this.compare = function(value1, value2)
		{
			return -this._comparator.compare(value1, value2);
		};

	});

});
});

jg_import.define("jgatt.utils.SequentialNumericComparator", function()
{
jg_namespace("jgatt.utils", function()
{

	var Comparator = jg_import("jgatt.utils.Comparator");

	this.SequentialNumericComparator = jg_extend(Comparator, function(SequentialNumericComparator, base)
	{

		// Private Static Constants

		var _NUMERIC_PATTERN = /\d+/g;

		// Public Methods

		this.compare = function(value1, value2)
		{
			var str1 = String(value1);
			var str2 = String(value2);
			var arr1 = str1.match(_NUMERIC_PATTERN);
			var arr2 = str2.match(_NUMERIC_PATTERN);
			var len1 = arr1.length;
			var len2 = arr2.length;
			var len = (len1 < len2) ? len1 : len2;
			var num1;
			var num2;
			for (var i = 0; i < len; i++)
			{
				num1 = Number(arr1[i]);
				num2 = Number(arr2[i]);
				if (num1 < num2)
					return -1;
				if (num1 > num2)
					return 1;
			}
			if (len1 < len2)
				return -1;
			if (len1 > len2)
				return 1;
			return 0;
		};

	});

});
});

jg_import.define("jgatt.utils.StringUtils", function()
{
jg_namespace("jgatt.utils", function()
{

	this.StringUtils = jg_static(function(StringUtils)
	{

		// Public Static Methods

		StringUtils.escapeHTML = function(str)
		{
			if (str == null)
				return str;

			str = String(str);

			return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
		};

	});

});
});

jg_import.define("jgatt.validation.ValidateEventData", function()
{
jg_namespace("jgatt.validation", function()
{

	var EventData = jg_import("jgatt.events.EventData");

	this.ValidateEventData = jg_extend(EventData, function(ValidateEventData, base)
	{

		// Private Properties

		this.pass = null;

		// Constructor

		this.constructor = function(pass)
		{
			this.pass = pass;
		};

	});

});
});

jg_import.define("jgatt.validation.ValidatePass", function()
{
jg_namespace("jgatt.validation", function(ns)
{

	var ChainedEvent = jg_import("jgatt.events.ChainedEvent");
	var Event = jg_import("jgatt.events.Event");
	var Comparator = jg_import("jgatt.utils.Comparator");
	var ValidateEventData = jg_import("jgatt.validation.ValidateEventData");

	this.ValidatePass = jg_extend(Object, function(ValidatePass, base)
	{

		// Public Events

		this.invalidated = null;
		this.validated = null;

		// Private Properties

		this._methodName = null;
		this._priority = 0;
		this._targetComparator = null;

		// Constructor

		this.constructor = function(methodName, priority, targetComparator)
		{
			if (methodName == null)
				throw new Error("Parameter methodName must be non-null.");
			if (typeof methodName !== "string")
				throw new Error("Parameter methodName must be a string.");
			if (priority == null)
				throw new Error("Parameter priority must be non-null.");
			if (typeof priority !== "number")
				throw new Error("Parameter priority must be a number.");
			if (isNaN(priority))
				throw new Error("Parameter priority must be a valid number.");
			if ((targetComparator != null) && !(targetComparator instanceof Comparator))
				throw new Error("Parameter targetComparator must be an instance of jgatt.utils.Comparator.");

			this._methodName = methodName;
			this._priority = priority;
			this._targetComparator = targetComparator ? targetComparator : null;

			this.invalidated = ns.MValidateTarget ? new ChainedEvent("invalidated", ns.MValidateTarget.invalidated) : new Event("invalidated", ValidateEventData);
			this.validated = ns.MValidateTarget ? new ChainedEvent("validated", ns.MValidateTarget.validated) : new Event("validated", ValidateEventData);
		};

		// Public Getters/Setters

		this.methodName = function()
		{
			return this._methodName;
		};

		this.priority = function()
		{
			return this._priority;
		};

		this.targetComparator = function()
		{
			return this._targetComparator;
		};

	});

});
});

jg_import.define("jgatt.validation.ValidateQueue", function()
{
jg_namespace("jgatt.validation", function()
{

	var ArrayUtils = jg_import("jgatt.utils.ArrayUtils");
	var Dictionary = jg_import("jgatt.utils.Dictionary");
	var ErrorUtils = jg_import("jgatt.utils.ErrorUtils");

	this.ValidateQueue = jg_static(function(ValidateQueue)
	{

		// Private Static Properties

		var _passesMap = new Dictionary();
		var _passesList = [];
		var _validateInterval = 0;
		var _validateIndex = -1;
		var _isValidating = false;

		// Public Static Methods

		ValidateQueue.enqueue = function(target, pass)
		{
			var targetsMap = _passesMap.get(pass);
			if (!targetsMap)
			{
				targetsMap = _passesMap.set(pass, new Dictionary());

				var passPriority = pass.priority();
				var passAdded = false;
				var pass2;
				for (var i = 0, l = _passesList.length; i < l; i++)
				{
					pass2 = _passesList[i];
					if (passPriority < pass2.priority())
					{
						_passesList.splice(i, 0, pass);
						if (i <= _validateIndex)
							_validateIndex++;
						passAdded = true;
						break;
					}
				}
				if (!passAdded)
					_passesList.push(pass);

				if (!_validateInterval)
					_validateInterval = setInterval(ValidateQueue.validateAll, 1);
			}

			targetsMap.set(target, true);
		};

		ValidateQueue.dequeue = function(target, pass)
		{
			var targetsMap = _passesMap.get(pass);
			if (!targetsMap)
				return;

			targetsMap.del(target);
		};

		ValidateQueue.contains = function(target, pass)
		{
			var targetsMap = _passesMap.get(pass);
			if (!targetsMap)
				return false;

			return targetsMap.has(target);
		};

		ValidateQueue.validateAll = function()
		{
			if (_isValidating)
				return false;

			try
			{
				_isValidating = true;

				var targetsMap;
				var targetsList;
				var target;
				var targetComparator;
				var pass;
				var i;
				var l;

				// validate passes
				for (_validateIndex = 0; _validateIndex < _passesList.length; _validateIndex++)
				{
					pass = _passesList[_validateIndex];
					targetsMap = _passesMap.get(pass);
					targetsList = targetsMap.keys();

					targetComparator = pass.targetComparator();
					if (targetComparator)
						ArrayUtils.sort(targetsList, targetComparator);

					for (i = 0, l = targetsList.length; i < l; i++)
					{
						try
						{
							targetsList[i].validate(pass);
						}
						catch (e)
						{
							ErrorUtils.asyncThrow(e);
						}
					}
				}
				_validateIndex = -1;

				// dequeue passes that contain no targets
				for (i = _passesList.length - 1; i >= 0; i--)
				{
					pass = _passesList[i];
					targetsMap = _passesMap.get(pass);
					if (!targetsMap || (targetsMap.size() == 0))
					{
						_passesMap.del(pass);
						_passesList.splice(i, 1);
					}
				}

				// stop validating if no passes are enqueued
				if (_passesList.length == 0)
				{
					clearInterval(_validateInterval);
					_validateInterval = 0;
				}
			}
			catch (e)
			{
				clearInterval(_validateInterval);
				_validateInterval = 0;
				throw e;
			}
			finally
			{
				_isValidating = false;
			}

			return true;
		};

		ValidateQueue.isValidating = function()
		{
			return _isValidating;
		};

	});

});
});

jg_import.define("jgatt.validation.MValidateTarget", function()
{
jg_namespace("jgatt.validation", function()
{

	var Event = jg_import("jgatt.events.Event");
	var MEventTarget = jg_import("jgatt.events.MEventTarget");
	var Dictionary = jg_import("jgatt.utils.Dictionary");
	var ErrorUtils = jg_import("jgatt.utils.ErrorUtils");
	var ValidateEventData = jg_import("jgatt.validation.ValidateEventData");
	var ValidatePass = jg_import("jgatt.validation.ValidatePass");
	var ValidateQueue = jg_import("jgatt.validation.ValidateQueue");

	this.MValidateTarget = jg_static(function(MValidateTarget)
	{

		// Mixin

		this.mixin = function(base)
		{
			base = jg_mixin(this, MEventTarget, base);
		};

		// Private Static Methods

		var _resolvePass = function(target, pass)
		{
			if (pass == null)
				throw new Error("Parameter pass must be non-null.");

			if (pass instanceof ValidatePass)
				return pass;

			if (typeof pass !== "string")
				throw new Error("Parameter pass must be a string or an instance of jgatt.validation.ValidatePass.");

			var targetPass = target[pass];
			if (!(targetPass instanceof ValidatePass))
				throw new Error("Unknown pass \"" + pass + "\".");

			return targetPass;
		};

		var _passComparator = function(pass1, pass2)
		{
			var priority1 = pass1.priority();
			var priority2 = pass2.priority();
			if (priority1 < priority2)
				return -1;
			if (priority1 > priority2)
				return 1;
			return 0;
		};

		var _batchValidate = function(target, endPass)
		{
			if (target._batchValidateList)
				return false;

			var invalidPasses = target._invalidPasses;
			if (invalidPasses.size() == 0)
				return false;

			var result = false;

			try
			{
				target._batchValidateEndPass = endPass;

				var passesList = target._batchValidateList = invalidPasses.keys();
				var pass;
				var i;

				// remove passes with priorities greater than or equal to endPass priority
				if (endPass)
				{
					var endPassPriority = endPass.priority();
					for (i = passesList.length - 1; i >= 0; i--)
					{
						pass = passesList[i];
						if (pass.priority() >= endPassPriority)
							passesList.splice(i, 1);
					}
				}

				// sort passes by priority
				passesList.sort(_passComparator);

				// validate passes
				i = target._batchValidateIndex = 0;
				while (i < passesList.length)
				{
					pass = passesList[i];
					if (invalidPasses.has(pass))
					{
						try
						{
							result = target.validate(pass) || result;
						}
						catch (e)
						{
							ErrorUtils.asyncThrow(e);
						}
					}
					i = ++target._batchValidateIndex;
				}
			}
			finally
			{
				target._batchValidateList = null;
				target._batchValidateIndex = -1;
				target._batchValidateEndPass = null;
			}

			return result;
		};

		// Public Events

		this.invalidated = new Event("invalidated", ValidateEventData);
		this.validated = new Event("validated", ValidateEventData);

		// Private Properties

		this._invalidPasses = null;
		this._validatingPasses = null;
		this._batchValidateList = null;
		this._batchValidateIndex = -1;
		this._batchValidateEndPass = null;

		// Constructor

		this.constructor = function()
		{
			this._invalidPasses = new Dictionary();
			this._validatingPasses = new Dictionary();
		};

		// Public Methods

		this.invalidate = function(pass)
		{
			pass = _resolvePass(this, pass);

			if (this._invalidPasses.has(pass))
				return false;

			if (this._batchValidateList)
			{
				var passPriority = pass.priority();
				var pass2 = this._batchValidateEndPass;
				if (!pass2 || (passPriority < pass2.priority()))
				{
					var passesList = this._batchValidateList;
					var validateIndex = this._batchValidateIndex;
					var needsAppend = true;
					for (var i = validateIndex, l = passesList.length; i < l; i++)
					{
						pass2 = passesList[i];
						if (passPriority < pass2.priority())
						{
							if (i > validateIndex)
								passesList.splice(i, 0, pass);
							needsAppend = false;
							break;
						}
					}
					if (needsAppend)
						passesList.push(pass);
				}
			}

			this._invalidPasses.set(pass, true);
			ValidateQueue.enqueue(this, pass);
			this.dispatchEvent(pass.invalidated, new ValidateEventData(pass));

			return true;
		};

		this.validate = function(pass)
		{
			if (pass == null)
				return _batchValidate(this);

			pass = _resolvePass(this, pass);

			if (this._validatingPasses.has(pass))
				return false;

			this.validatePreceding(pass);

			if (!this._invalidPasses.has(pass))
				return false;

			this._validatingPasses.set(pass, true);

			var result = false;
			try
			{
				var methodName = pass.methodName();
				var method = this[methodName];
				if (typeof method !== "function")
					throw new Error("Unknown method \"" + methodName + "\".");

				method.call(this);
				result = true;
			}
			catch (e)
			{
				ErrorUtils.asyncThrow(e);
			}

			this.setValid(pass);

			return result;
		};

		this.validatePreceding = function(pass)
		{
			pass = _resolvePass(this, pass);

			if (ValidateQueue.isValidating() || this._batchValidateList)
				return false;

			return _batchValidate(this, pass);
		};

		this.setValid = function(pass)
		{
			if (pass == null)
			{
				var passesList = this._invalidPasses.keys();
				passesList.sort(_passComparator);

				var result = false;
				for (var i = 0, l = passesList.length; i < l; i++)
				{
					pass = passesList[i];
					if (invalidPasses.has(pass))
						result = this.setValid(pass) || result;
				}
				return result;
			}

			pass = _resolvePass(this, pass);

			if (!this._invalidPasses.has(pass))
				return false;

			this._invalidPasses.del(pass);
			this._validatingPasses.del(pass);
			ValidateQueue.dequeue(this, pass);
			this.dispatchEvent(pass.validated, new ValidateEventData(pass));

			return true;
		};

		this.isValid = function(pass)
		{
			if (pass == null)
				return (this._invalidPasses.size() == 0);

			pass = _resolvePass(this, pass);

			return !this._invalidPasses.has(pass);
		};

	});

});
});

define("jgatt", ["jg_global"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.jgatt;
    };
}(this)));

/**
 * Requires:
 * jg_global
 * jg_library
 */

jg_import.define("splunk.time.TimeZone", function()
{
jg_namespace("splunk.time", function()
{

	this.TimeZone = jg_extend(Object, function(TimeZone, base)
	{

		// Public Methods

		this.getStandardOffset = function()
		{
			return 0;
		};

		this.getOffset = function(time)
		{
			return 0;
		};

	});

});
});

jg_import.define("splunk.time.SimpleTimeZone", function()
{
jg_namespace("splunk.time", function()
{

	var TimeZone = jg_import("splunk.time.TimeZone");

	this.SimpleTimeZone = jg_extend(TimeZone, function(SimpleTimeZone, base)
	{

		// Private Properties

		this._offset = 0;

		// Constructor

		this.constructor = function(offset)
		{
			this._offset = (offset !== undefined) ? offset : 0;
		};

		// Public Methods

		this.getStandardOffset = function()
		{
			return this._offset;
		};

		this.getOffset = function(time)
		{
			return this._offset;
		};

	});

});
});

jg_import.define("splunk.time.LocalTimeZone", function()
{
jg_namespace("splunk.time", function()
{

	var TimeZone = jg_import("splunk.time.TimeZone");

	this.LocalTimeZone = jg_extend(TimeZone, function(LocalTimeZone, base)
	{

		// Public Methods

		this.getStandardOffset = function()
		{
			var date = new Date(0);
			return -date.getTimezoneOffset() * 60;
		};

		this.getOffset = function(time)
		{
			var date = new Date(time * 1000);
			return -date.getTimezoneOffset() * 60;
		};

	});

});
});

jg_import.define("splunk.time.TimeZones", function()
{
jg_namespace("splunk.time", function()
{

	var LocalTimeZone = jg_import("splunk.time.LocalTimeZone");
	var SimpleTimeZone = jg_import("splunk.time.SimpleTimeZone");

	this.TimeZones = jg_static(function(TimeZones)
	{

		// Public Static Constants

		TimeZones.LOCAL = new LocalTimeZone();
		TimeZones.UTC = new SimpleTimeZone(0);

	});

});
});

jg_import.define("splunk.time.DateTime", function()
{
jg_namespace("splunk.time", function()
{

	var SimpleTimeZone = jg_import("splunk.time.SimpleTimeZone");
	var TimeZone = jg_import("splunk.time.TimeZone");
	var TimeZones = jg_import("splunk.time.TimeZones");

	this.DateTime = jg_extend(Object, function(DateTime, base)
	{

		// Private Static Constants

		var _ISO_DATE_TIME_PATTERN = /([\+\-])?(\d{4,})(?:(?:\-(\d{2}))(?:(?:\-(\d{2}))(?:(?:[T ](\d{2}))(?:(?:\:(\d{2}))(?:(?:\:(\d{2}(?:\.\d+)?)))?)?(?:(Z)|([\+\-])(\d{2})(?:\:(\d{2}))?)?)?)?)?/;

		// Private Static Methods

		var _normalizePrecision = function(value)
		{
			return Number(value.toFixed(6));
		};

		var _pad = function(value, digits, fractionDigits)
		{
			/*jsl:ignore*/
			// this comparison triggers the 'useless comparison' error
			if (value != value)
				return "NaN";
			/*jsl:end*/
			if (value == Infinity)
				return "Infinity";
			if (value == -Infinity)
				return "-Infinity";

			digits = (digits !== undefined) ? digits : 0;
			fractionDigits = (fractionDigits !== undefined) ? fractionDigits : 0;

			var str = value.toFixed(20);

			var decimalIndex = str.indexOf(".");
			if (decimalIndex < 0)
				decimalIndex = str.length;
			else if (fractionDigits < 1)
				str = str.substring(0, decimalIndex);
			else
				str = str.substring(0, decimalIndex) + "." + str.substring(decimalIndex + 1, decimalIndex + fractionDigits + 1);

			for (var i = decimalIndex; i < digits; i++)
				str = "0" + str;

			return str;
		};

		// Private Properties

		this._year = 0;
		this._month = 1;
		this._day = 1;
		this._weekday = 0;
		this._hours = 0;
		this._minutes = 0;
		this._seconds = 0;
		this._timeZone = TimeZones.LOCAL;
		this._timeZoneOffset = 0;
		this._time = 0;

		this._isValid = true;

		// Constructor

		this.constructor = function(yearOrTimevalue, month, day, hours, minutes, seconds, timeZone)
		{
			switch (arguments.length)
			{
				case 0:
					var now = new Date();
					this._time = now.getTime() / 1000;
					this._updateProperties();
					break;
				case 1:
					if (typeof yearOrTimevalue === "number")
					{
						this._time = yearOrTimevalue;
						this._updateProperties();
					}
					else if (typeof yearOrTimevalue === "string")
					{
						var matches = _ISO_DATE_TIME_PATTERN.exec(yearOrTimevalue);
						var numMatches = matches ? matches.length : 0;
						var match;

						match = (numMatches > 1) ? matches[1] : null;
						var yearSign = (match == "-") ? -1 : 1;

						match = (numMatches > 2) ? matches[2] : null;
						this._year = match ? yearSign * Number(match) : 0;

						match = (numMatches > 3) ? matches[3] : null;
						this._month = match ? Number(match) : 1;

						match = (numMatches > 4) ? matches[4] : null;
						this._day = match ? Number(match) : 1;

						match = (numMatches > 5) ? matches[5] : null;
						this._hours = match ? Number(match) : 0;

						match = (numMatches > 6) ? matches[6] : null;
						this._minutes = match ? Number(match) : 0;

						match = (numMatches > 7) ? matches[7] : null;
						this._seconds = match ? Number(match) : 0;

						match = (numMatches > 8) ? matches[8] : null;
						var timeZoneUTC = (match == "Z");

						match = (numMatches > 9) ? matches[9] : null;
						var timeZoneSign = (match == "-") ? -1 : 1;

						match = (numMatches > 10) ? matches[10] : null;
						var timeZoneHours = match ? Number(match) : NaN;

						match = (numMatches > 11) ? matches[11] : null;
						var timeZoneMinutes = match ? Number(match) : NaN;

						if (timeZoneUTC)
							this._timeZone = TimeZones.UTC;
						else if (!isNaN(timeZoneHours) && !isNaN(timeZoneMinutes))
							this._timeZone = new SimpleTimeZone(timeZoneSign * (timeZoneHours * 60 + timeZoneMinutes) * 60);
						else
							this._timeZone = TimeZones.LOCAL;

						this._updateTime();
					}
					else
					{
						this._time = NaN;
						this._updateProperties();
					}
					break;
				default:
					if (typeof yearOrTimevalue === "number")
					{
						this._year = yearOrTimevalue;
						this._month = (month !== undefined) ? month : 1;
						this._day = (day !== undefined) ? day : 1;
						this._hours = (hours !== undefined) ? hours : 0;
						this._minutes = (minutes !== undefined) ? minutes : 0;
						this._seconds = (seconds !== undefined) ? seconds : 0;
						this._timeZone = (timeZone instanceof TimeZone) ? timeZone : TimeZones.LOCAL;
						this._updateTime();
					}
					else
					{
						this._time = NaN;
						this._updateProperties();
					}
					break;
			}
		};

		// Public Getters/Setters

		this.getYear = function()
		{
			return this._year;
		};
		this.setYear = function(value)
		{
			this._year = value;
			this._updateTime();
		};

		this.getMonth = function()
		{
			return this._month;
		};
		this.setMonth = function(value)
		{
			this._month = value;
			this._updateTime();
		};

		this.getDay = function()
		{
			return this._day;
		};
		this.setDay = function(value)
		{
			this._day = value;
			this._updateTime();
		};

		this.getWeekday = function()
		{
			return this._weekday;
		};

		this.getHours = function()
		{
			return this._hours;
		};
		this.setHours = function(value)
		{
			this._hours = value;
			this._updateTime();
		};

		this.getMinutes = function()
		{
			return this._minutes;
		};
		this.setMinutes = function(value)
		{
			this._minutes = value;
			this._updateTime();
		};

		this.getSeconds = function()
		{
			return this._seconds;
		};
		this.setSeconds = function(value)
		{
			this._seconds = value;
			this._updateTime();
		};

		this.getTimeZone = function()
		{
			return this._timeZone;
		};
		this.setTimeZone = function(value)
		{
			this._timeZone = (value instanceof TimeZone) ? value : TimeZones.LOCAL;
			this._updateTime();
		};

		this.getTimeZoneOffset = function()
		{
			return this._timeZoneOffset;
		};

		this.getTime = function()
		{
			return this._time;
		};
		this.setTime = function(value)
		{
			this._time = value;
			this._updateProperties();
		};

		// Public Methods

		this.toUTC = function()
		{
			return this.toTimeZone(TimeZones.UTC);
		};

		this.toLocal = function()
		{
			return this.toTimeZone(TimeZones.LOCAL);
		};

		this.toTimeZone = function(timeZone)
		{
			var date = new DateTime();
			date.setTimeZone(timeZone);
			date.setTime(this._time);
			return date;
		};

		this.clone = function()
		{
			var date = new DateTime();
			date.setTimeZone(this._timeZone);
			date.setTime(this._time);
			return date;
		};

		this.equals = function(toCompare)
		{
			return ((this._time === toCompare._time) && (this._timeZoneOffset === toCompare._timeZoneOffset));
		};

		this.toString = function()
		{
			if (!this._isValid)
				return "Invalid Date";

			var str = "";
			if (this._year < 0)
				str += "-" + _pad(-this._year, 4);
			else
				str += _pad(this._year, 4);
			str += "-" + _pad(this._month, 2) + "-" + _pad(this._day, 2);
			str += "T" + _pad(this._hours, 2) + ":" + _pad(this._minutes, 2) + ":" + _pad(this._seconds, 2, 3);

			var timeZoneOffset = this._timeZoneOffset / 60;
			if (timeZoneOffset == 0)
			{
				str += "Z";
			}
			else
			{
				if (timeZoneOffset < 0)
					str += "-";
				else
					str += "+";
				if (timeZoneOffset < 0)
					timeZoneOffset = -timeZoneOffset;
				var timeZoneHours = Math.floor(timeZoneOffset / 60);
				var timeZoneMinutes = Math.floor(timeZoneOffset % 60);
				str += _pad(timeZoneHours, 2) + ":" + _pad(timeZoneMinutes, 2);
			}

			return str;
		};

		this.valueOf = function()
		{
			return this._time;
		};

		// Private Methods

		this._updateTime = function()
		{
			if (this._validate())
			{
				var years = this._year;
				var months = this._month - 1;
				var days = this._day - 1;
				var hours = this._hours;
				var minutes = this._minutes;
				var seconds = this._seconds;

				var secondsPerMinute = 60;
				var secondsPerHour = secondsPerMinute * 60;
				var secondsPerDay = secondsPerHour * 24;

				var totalMonths = months + years * 12;
				var wholeMonths = Math.floor(totalMonths);
				var subMonths = totalMonths - wholeMonths;

				var totalSeconds = seconds + (minutes * secondsPerMinute) + (hours * secondsPerHour) + (days * secondsPerDay);
				var wholeSeconds = Math.floor(totalSeconds);
				var subSeconds = totalSeconds - wholeSeconds;

				var date = new Date(0);
				date.setUTCFullYear(0);
				date.setUTCMonth(wholeMonths);

				if (subMonths != 0)
				{
					date.setUTCMonth(date.getUTCMonth() + 1);
					date.setUTCDate(0);

					var monthsTotalSeconds = date.getUTCDate() * subMonths * secondsPerDay;
					var monthsWholeSeconds = Math.floor(monthsTotalSeconds);
					var monthsSubSeconds = monthsTotalSeconds - monthsWholeSeconds;

					wholeSeconds += monthsWholeSeconds;
					subSeconds += monthsSubSeconds;
					if (subSeconds >= 1)
					{
						subSeconds--;
						wholeSeconds++;
					}

					date.setUTCDate(1);
				}

				date.setUTCSeconds(wholeSeconds);

				var time = (date.getTime() / 1000) + subSeconds;
				var timeZone = this._timeZone;

				this._time = time - timeZone.getOffset(time - timeZone.getStandardOffset());

				this._updateProperties();
			}
		};

		this._updateProperties = function()
		{
			if (this._validate())
			{
				var time = _normalizePrecision(this._time);
				var timeZoneOffset = _normalizePrecision(this._timeZone.getOffset(time));

				var totalSeconds = time + timeZoneOffset;
				var wholeSeconds = Math.floor(totalSeconds);
				var subSeconds = _normalizePrecision(totalSeconds - wholeSeconds);
				if (subSeconds >= 1)
				{
					subSeconds = 0;
					wholeSeconds++;
				}

				var date = new Date(wholeSeconds * 1000);

				this._year = date.getUTCFullYear();
				this._month = date.getUTCMonth() + 1;
				this._day = date.getUTCDate();
				this._weekday = date.getUTCDay();
				this._hours = date.getUTCHours();
				this._minutes = date.getUTCMinutes();
				this._seconds = date.getUTCSeconds() + subSeconds;

				this._time = time;
				this._timeZoneOffset = timeZoneOffset;

				this._validate();
			}
		};

		this._validate = function()
		{
			if (this._isValid)
			{
				this._year *= 1;
				this._month *= 1;
				this._day *= 1;
				this._weekday *= 1;
				this._hours *= 1;
				this._minutes *= 1;
				this._seconds *= 1;
				this._timeZoneOffset *= 1;
				this._time *= 1;
				var checksum = this._year + this._month + this._day + this._weekday + this._hours + this._minutes + this._seconds + this._timeZoneOffset + this._time;
				if (isNaN(checksum) || (checksum == Infinity) || (checksum == -Infinity) || !this._timeZone)
					this._isValid = false;
			}
			else
			{
				this._year *= 1;
				this._time *= 1;
				if ((this._year > -Infinity) && (this._year < Infinity))
				{
					this._month = 1;
					this._day = 1;
					this._hours = 0;
					this._minutes = 0;
					this._seconds = 0;
					this._isValid = true;
				}
				else if ((this._time > -Infinity) && (this._time < Infinity))
				{
					this._isValid = true;
				}
			}

			if (!this._isValid)
			{
				this._year = NaN;
				this._month = NaN;
				this._day = NaN;
				this._weekday = NaN;
				this._hours = NaN;
				this._minutes = NaN;
				this._seconds = NaN;
				this._timeZoneOffset = NaN;
				this._time = NaN;
			}

			return this._isValid;
		};

	});

});
});

jg_import.define("splunk.time.Duration", function()
{
jg_namespace("splunk.time", function()
{

	this.Duration = jg_extend(Object, function(Duration, base)
	{

		// Private Static Constants

		var _ISO_DURATION_PATTERN = /P(?:(\-?\d+(?:\.\d+)?)Y)?(?:(\-?\d+(?:\.\d+)?)M)?(?:(\-?\d+(?:\.\d+)?)D)?(?:T(?:(\-?\d+(?:\.\d+)?)H)?(?:(\-?\d+(?:\.\d+)?)M)?(?:(\-?\d+(?:\.\d+)?)S)?)?/;

		// Public Properties

		this.years = 0;
		this.months = 0;
		this.days = 0;
		this.hours = 0;
		this.minutes = 0;
		this.seconds = 0;

		// Constructor

		this.constructor = function(yearsOrTimestring, months, days, hours, minutes, seconds)
		{
			if ((arguments.length == 1) && (typeof yearsOrTimestring === "string"))
			{
				var matches = _ISO_DURATION_PATTERN.exec(yearsOrTimestring);
				var numMatches = matches ? matches.length : 0;
				var match;

				match = (numMatches > 1) ? matches[1] : null;
				this.years = match ? Number(match) : 0;

				match = (numMatches > 2) ? matches[2] : null;
				this.months = match ? Number(match) : 0;

				match = (numMatches > 3) ? matches[3] : null;
				this.days = match ? Number(match) : 0;

				match = (numMatches > 4) ? matches[4] : null;
				this.hours = match ? Number(match) : 0;

				match = (numMatches > 5) ? matches[5] : null;
				this.minutes = match ? Number(match) : 0;

				match = (numMatches > 6) ? matches[6] : null;
				this.seconds = match ? Number(match) : 0;
			}
			else
			{
				this.years = (typeof yearsOrTimestring === "number") ? yearsOrTimestring : 0;
				this.months = (months !== undefined) ? months : 0;
				this.days = (days !== undefined) ? days : 0;
				this.hours = (hours !== undefined) ? hours : 0;
				this.minutes = (minutes !== undefined) ? minutes : 0;
				this.seconds = (seconds !== undefined) ? seconds : 0;
			}
		};

		// Public Methods

		this.clone = function()
		{
			return new Duration(this.years, this.months, this.days, this.hours, this.minutes, this.seconds);
		};

		this.equals = function(toCompare)
		{
			return ((this.years == toCompare.years) &&
			        (this.months == toCompare.months) &&
			        (this.days == toCompare.days) &&
			        (this.hours == toCompare.hours) &&
			        (this.minutes == toCompare.minutes) &&
			        (this.seconds == toCompare.seconds));
		};

		this.toString = function()
		{
			var str = "";
			str += "P" + this.years + "Y" + this.months + "M" + this.days + "D";
			str += "T" + this.hours + "H" + this.minutes + "M" + this.seconds + "S";
			return str;
		};

	});

});
});

jg_import.define("splunk.time.SplunkTimeZone", function()
{
jg_namespace("splunk.time", function()
{

	var ArrayUtils = jg_import("jgatt.utils.ArrayUtils");
	var TimeZone = jg_import("splunk.time.TimeZone");

	this.SplunkTimeZone = jg_extend(TimeZone, function(SplunkTimeZone, base)
	{

		// Private Properties

		this._standardOffset = 0;
		this._serializedTimeZone = null;

		this._isConstant = false;
		this._offsetList = null;
		this._timeList = null;
		this._indexList = null;

		// Constructor

		this.constructor = function(serializedTimeZone)
		{
			if (serializedTimeZone == null)
				throw new Error("Parameter serializedTimeZone must be non-null.");
			if (typeof serializedTimeZone !== "string")
				throw new Error("Parameter serializedTimeZone must be a string.");

			this._serializedTimeZone = serializedTimeZone;

			this._offsetList = [];
			this._timeList = [];
			this._indexList = [];

			this._parseSerializedTimeZone(serializedTimeZone);
		};

		// Public Methods

		this.getSerializedTimeZone = function()
		{
			return this._serializedTimeZone;
		};

		this.getStandardOffset = function()
		{
			return this._standardOffset;
		};

		this.getOffset = function(time)
		{
			if (this._isConstant)
				return this._standardOffset;

			var offsetList = this._offsetList;
			var numOffsets = offsetList.length;
			if (numOffsets == 0)
				return 0;

			if (numOffsets == 1)
				return offsetList[0];

			var timeList = this._timeList;
			var numTimes = timeList.length;
			if (numTimes == 0)
				return 0;

			var timeIndex;
			if (numTimes == 1)
			{
				timeIndex = 0;
			}
			else
			{
				timeIndex = ArrayUtils.binarySearch(timeList, time);
				if (timeIndex < -1)
					timeIndex = -timeIndex - 2;
				else if (timeIndex == -1)
					timeIndex = 0;
			}

			var offsetIndex = this._indexList[timeIndex];
			return offsetList[offsetIndex];
		};

		// Private Methods

		this._parseSerializedTimeZone = function(serializedTimeZone)
		{
			// ### SERIALIZED TIMEZONE FORMAT 1.0
			// Y-25200 YW 50 44 54
			// Y-28800 NW 50 53 54
			// Y-25200 YW 50 57 54
			// Y-25200 YG 50 50 54
			// @-1633269600 0
			// @-1615129200 1
			// @-1601820000 0
			// @-1583679600 1

			// ### SERIALIZED TIMEZONE FORMAT 1.0
			// C0
			// Y0 NW 47 4D 54

			if (!serializedTimeZone)
				return;

			var entries = serializedTimeZone.split(";");
			var entry;
			for (var i = 0, l = entries.length; i < l; i++)
			{
				entry = entries[i];
				if (entry)
				{
					switch (entry.charAt(0))
					{
						case "C":
							if (this._parseC(entry.substring(1, entry.length)))
								return;
							break;
						case "Y":
							this._parseY(entry.substring(1, entry.length));
							break;
						case "@":
							this._parseAt(entry.substring(1, entry.length));
							break;
					}
				}
			}

			this._standardOffset = this.getOffset(0);
		};

		this._parseC = function(entry)
		{
			// 0

			if (!entry)
				return false;

			var time = Number(entry);
			if (isNaN(time))
				return false;

			this._standardOffset = time;
			this._isConstant = true;

			return true;
		};

		this._parseY = function(entry)
		{
			// -25200 YW 50 44 54

			if (!entry)
				return;

			var elements = entry.split(" ");
			if (elements.length < 1)
				return;

			var element = elements[0];
			if (!element)
				return;

			var offset = Number(element);
			if (isNaN(offset))
				return;

			this._offsetList.push(offset);
		};

		this._parseAt = function(entry)
		{
			// -1633269600 0

			if (!entry)
				return;

			var elements = entry.split(" ");
			if (elements.length < 2)
				return;

			var element = elements[0];
			if (!element)
				return;

			var time = Number(element);
			if (isNaN(time))
				return;

			element = elements[1];
			if (!element)
				return;

			var index = Number(element);
			if (isNaN(index))
				return;

			index = Math.floor(index);
			if ((index < 0) || (index >= this._offsetList.length))
				return;

			this._timeList.push(time);
			this._indexList.push(index);
		};

	});

});
});

jg_import.define("splunk.time.TimeUtils", function()
{
jg_namespace("splunk.time", function()
{

	var DateTime = jg_import("splunk.time.DateTime");
	var Duration = jg_import("splunk.time.Duration");
	var SimpleTimeZone = jg_import("splunk.time.SimpleTimeZone");
	var TimeZones = jg_import("splunk.time.TimeZones");

	this.TimeUtils = jg_static(function(TimeUtils)
	{

		// Public Static Constants

		TimeUtils.EPOCH = new DateTime(0).toUTC();

		// Public Static Methods

		TimeUtils.daysInMonth = function(date)
		{
			date = new DateTime(date.getYear(), date.getMonth() + 1, 0, 0, 0, 0, TimeZones.UTC);
			return date.getDay();
		};

		TimeUtils.addDurations = function(duration1, duration2)
		{
			return new Duration(duration1.years + duration2.years, duration1.months + duration2.months, duration1.days + duration2.days, duration1.hours + duration2.hours, duration1.minutes + duration2.minutes, duration1.seconds + duration2.seconds);
		};

		TimeUtils.addDateDuration = function(date, duration)
		{
			if ((duration.years == 0) && (duration.months == 0) && (duration.days == 0))
				date = date.clone();
			else
				date = new DateTime(date.getYear() + duration.years, date.getMonth() + duration.months, date.getDay() + duration.days, date.getHours(), date.getMinutes(), date.getSeconds(), date.getTimeZone());
			date.setTime(date.getTime() + (duration.hours * 3600 + duration.minutes * 60 + duration.seconds));
			return date;
		};

		TimeUtils.subtractDates = function(date1, date2)
		{
			date2 = date2.toTimeZone(date1.getTimeZone());

			var isNegative = (date1.getTime() < date2.getTime());
			if (isNegative)
			{
				var temp = date1;
				date1 = date2;
				date2 = temp;
			}

			var sameTimeZoneOffset = (date1.getTimeZoneOffset() == date2.getTimeZoneOffset());

			var years;
			var months;
			var days;
			var hours;
			var minutes;
			var seconds;

			var date3;
			if (sameTimeZoneOffset)
			{
				date3 = date1;
			}
			else if ((date1.getYear() == date2.getYear()) && (date1.getMonth() == date2.getMonth()) && (date1.getDay() == date2.getDay()))
			{
				date3 = date2;
			}
			else
			{
				date3 = new DateTime(date1.getYear(), date1.getMonth(), date1.getDay(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getTimeZone());
				if (date3.getTime() > date1.getTime())
				{
					date3 = new DateTime(date1.getYear(), date1.getMonth(), date1.getDay() - 1, date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getTimeZone());
					if ((date3.getTime() < date2.getTime()) || ((date3.getYear() == date2.getYear()) && (date3.getMonth() == date2.getMonth()) && (date3.getDay() == date2.getDay())))
						date3 = date2;
				}
			}

			years = date3.getYear() - date2.getYear();
			months = date3.getMonth() - date2.getMonth();
			days = date3.getDay() - date2.getDay();

			if (sameTimeZoneOffset)
			{
				hours = date3.getHours() - date2.getHours();
				minutes = date3.getMinutes() - date2.getMinutes();
				seconds = date3.getSeconds() - date2.getSeconds();

				if (seconds < 0)
				{
					seconds += 60;
					minutes--;
				}

				if (minutes < 0)
				{
					minutes += 60;
					hours--;
				}

				if (hours < 0)
				{
					hours += 24;
					days--;
				}

				seconds = _normalizePrecision(seconds);
			}
			else
			{
				seconds = date1.getTime() - date3.getTime();
				var wholeSeconds = Math.floor(seconds);
				var subSeconds = _normalizePrecision(seconds - wholeSeconds);
				if (subSeconds >= 1)
				{
					subSeconds = 0;
					wholeSeconds++;
				}

				minutes = Math.floor(wholeSeconds / 60);
				seconds = (wholeSeconds % 60) + subSeconds;

				hours = Math.floor(minutes / 60);
				minutes %= 60;
			}

			if (days < 0)
			{
				date3 = new DateTime(date2.getYear(), date2.getMonth() + 1, 0, 0, 0, 0, TimeZones.UTC);
				days += date3.getDay();
				months--;
			}

			if (months < 0)
			{
				months += 12;
				years--;
			}

			if (isNegative)
			{
				years = -years;
				months = -months;
				days = -days;
				hours = -hours;
				minutes = -minutes;
				seconds = -seconds;
			}

			return new Duration(years, months, days, hours, minutes, seconds);
		};

		TimeUtils.subtractDurations = function(duration1, duration2)
		{
			return new Duration(duration1.years - duration2.years, duration1.months - duration2.months, duration1.days - duration2.days, duration1.hours - duration2.hours, duration1.minutes - duration2.minutes, duration1.seconds - duration2.seconds);
		};

		TimeUtils.subtractDateDuration = function(date, duration)
		{
			if ((duration.years == 0) && (duration.months == 0) && (duration.days == 0))
				date = date.clone();
			else
				date = new DateTime(date.getYear() - duration.years, date.getMonth() - duration.months, date.getDay() - duration.days, date.getHours(), date.getMinutes(), date.getSeconds(), date.getTimeZone());
			date.setTime(date.getTime() - (duration.hours * 3600 + duration.minutes * 60 + duration.seconds));
			return date;
		};

		TimeUtils.multiplyDuration = function(duration, scalar)
		{
			return new Duration(duration.years * scalar, duration.months * scalar, duration.days * scalar, duration.hours * scalar, duration.minutes * scalar, duration.seconds * scalar);
		};

		TimeUtils.divideDuration = function(duration, scalar)
		{
			return new Duration(duration.years / scalar, duration.months / scalar, duration.days / scalar, duration.hours / scalar, duration.minutes / scalar, duration.seconds / scalar);
		};

		TimeUtils.ceilDate = function(date, units)
		{
			var date2 = date.toTimeZone(new SimpleTimeZone(date.getTimeZoneOffset()));
			_ceilDateInternal(date2, units);
			return _toTimeZoneStable(date2, date.getTimeZone());
		};

		TimeUtils.ceilDuration = function(duration, units, referenceDate)
		{
			if (!referenceDate)
				referenceDate = TimeUtils.EPOCH;

			var date = TimeUtils.addDateDuration(referenceDate, duration);
			var isNegative = (date.getTime() < referenceDate.getTime());
			duration = isNegative ? TimeUtils.subtractDates(referenceDate, date) : TimeUtils.subtractDates(date, referenceDate);

			if (!units)
			{
				units = new Duration();
				if (duration.years > 0)
					units.years = 1;
				else if (duration.months > 0)
					units.months = 1;
				else if (duration.days > 0)
					units.days = 1;
				else if (duration.hours > 0)
					units.hours = 1;
				else if (duration.minutes > 0)
					units.minutes = 1;
				else if (duration.seconds > 0)
					units.seconds = 1;
			}

			if (isNegative)
			{
				_floorDurationInternal(duration, units, date);
				return TimeUtils.multiplyDuration(duration, -1);
			}

			_ceilDurationInternal(duration, units, referenceDate);
			return duration;
		};

		TimeUtils.floorDate = function(date, units)
		{
			var date2 = date.toTimeZone(new SimpleTimeZone(date.getTimeZoneOffset()));
			_floorDateInternal(date2, units);
			return _toTimeZoneStable(date2, date.getTimeZone());
		};

		TimeUtils.floorDuration = function(duration, units, referenceDate)
		{
			if (!referenceDate)
				referenceDate = TimeUtils.EPOCH;

			var date = TimeUtils.addDateDuration(referenceDate, duration);
			var isNegative = (date.getTime() < referenceDate.getTime());
			duration = isNegative ? TimeUtils.subtractDates(referenceDate, date) : TimeUtils.subtractDates(date, referenceDate);

			if (!units)
			{
				units = new Duration();
				if (duration.years > 0)
					units.years = 1;
				else if (duration.months > 0)
					units.months = 1;
				else if (duration.days > 0)
					units.days = 1;
				else if (duration.hours > 0)
					units.hours = 1;
				else if (duration.minutes > 0)
					units.minutes = 1;
				else if (duration.seconds > 0)
					units.seconds = 1;
			}

			if (isNegative)
			{
				_ceilDurationInternal(duration, units, date);
				return TimeUtils.multiplyDuration(duration, -1);
			}

			_floorDurationInternal(duration, units, referenceDate);
			return duration;
		};

		TimeUtils.roundDate = function(date, units)
		{
			var date2 = date.toTimeZone(new SimpleTimeZone(date.getTimeZoneOffset()));
			_roundDateInternal(date2, units);
			return _toTimeZoneStable(date2, date.getTimeZone());
		};

		TimeUtils.roundDuration = function(duration, units, referenceDate)
		{
			if (!referenceDate)
				referenceDate = TimeUtils.EPOCH;

			var date = TimeUtils.addDateDuration(referenceDate, duration);
			var isNegative = (date.getTime() < referenceDate.getTime());
			duration = isNegative ? TimeUtils.subtractDates(referenceDate, date) : TimeUtils.subtractDates(date, referenceDate);

			if (!units)
			{
				units = new Duration();
				if (duration.years > 0)
					units.years = 1;
				else if (duration.months > 0)
					units.months = 1;
				else if (duration.days > 0)
					units.days = 1;
				else if (duration.hours > 0)
					units.hours = 1;
				else if (duration.minutes > 0)
					units.minutes = 1;
				else if (duration.seconds > 0)
					units.seconds = 1;
			}

			if (isNegative)
			{
				_roundDurationInternal(duration, units, date);
				return TimeUtils.multiplyDuration(duration, -1);
			}

			_roundDurationInternal(duration, units, referenceDate);
			return duration;
		};

		TimeUtils.normalizeDuration = function(duration, referenceDate)
		{
			if (!referenceDate)
				referenceDate = TimeUtils.EPOCH;

			var date = TimeUtils.addDateDuration(referenceDate, duration);
			return TimeUtils.subtractDates(date, referenceDate);
		};

		TimeUtils.durationToSeconds = function(duration, referenceDate)
		{
			if (!referenceDate)
				referenceDate = TimeUtils.EPOCH;

			var date = TimeUtils.addDateDuration(referenceDate, duration);
			return _normalizePrecision(date.getTime() - referenceDate.getTime());
		};

		TimeUtils.secondsToDuration = function(seconds, referenceDate)
		{
			if (!referenceDate)
				referenceDate = TimeUtils.EPOCH;

			var date = new DateTime(referenceDate.getTime() + seconds).toTimeZone(referenceDate.getTimeZone());
			return TimeUtils.subtractDates(date, referenceDate);
		};

		// Private Static Methods

		var _ceilDateInternal = function(date, units)
		{
			var ceilYear = (units.years > 0);
			var ceilMonth = ceilYear || (units.months > 0);
			var ceilDay = ceilMonth || (units.days > 0);
			var ceilHours = ceilDay || (units.hours > 0);
			var ceilMinutes = ceilHours || (units.minutes > 0);
			var ceilSeconds = ceilMinutes || (units.seconds > 0);

			if (!ceilSeconds)
				return;

			if (date.getSeconds() > 0)
			{
				if (units.seconds > 0)
					date.setSeconds(Math.min(Math.ceil(date.getSeconds() / units.seconds) * units.seconds, 60));
				else
					date.setSeconds(60);
			}

			if (!ceilMinutes)
				return;

			if (date.getMinutes() > 0)
			{
				if (units.minutes > 0)
					date.setMinutes(Math.min(Math.ceil(date.getMinutes() / units.minutes) * units.minutes, 60));
				else
					date.setMinutes(60);
			}

			if (!ceilHours)
				return;

			if (date.getHours() > 0)
			{
				if (units.hours > 0)
					date.setHours(Math.min(Math.ceil(date.getHours() / units.hours) * units.hours, 24));
				else
					date.setHours(24);
			}

			if (!ceilDay)
				return;

			if (date.getDay() > 1)
			{
				var daysInMonth = TimeUtils.daysInMonth(date);
				if (units.days > 0)
					date.setDay(Math.min(Math.ceil((date.getDay() - 1) / units.days) * units.days, daysInMonth) + 1);
				else
					date.setDay(daysInMonth + 1);
			}

			if (!ceilMonth)
				return;

			if (date.getMonth() > 1)
			{
				if (units.months > 0)
					date.setMonth(Math.min(Math.ceil((date.getMonth() - 1) / units.months) * units.months, 12) + 1);
				else
					date.setMonth(12 + 1);
			}

			if (!ceilYear)
				return;

			if (units.years > 0)
				date.setYear(Math.ceil(date.getYear() / units.years) * units.years);
		};

		var _ceilDurationInternal = function(duration, units, referenceDate)
		{
			var ceilYears = (units.years > 0);
			var ceilMonths = ceilYears || (units.months > 0);
			var ceilDays = ceilMonths || (units.days > 0);
			var ceilHours = ceilDays || (units.hours > 0);
			var ceilMinutes = ceilHours || (units.minutes > 0);
			var ceilSeconds = ceilMinutes || (units.seconds > 0);

			var daysInMonth = TimeUtils.daysInMonth(referenceDate);

			if (!ceilSeconds)
				return;

			if (duration.seconds > 0)
			{
				if (units.seconds > 0)
					duration.seconds = Math.min(Math.ceil(duration.seconds / units.seconds) * units.seconds, 60);
				else
					duration.seconds = 60;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!ceilMinutes)
				return;

			if (duration.minutes > 0)
			{
				if (units.minutes > 0)
					duration.minutes = Math.min(Math.ceil(duration.minutes / units.minutes) * units.minutes, 60);
				else
					duration.minutes = 60;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!ceilHours)
				return;

			if (duration.hours > 0)
			{
				if (units.hours > 0)
					duration.hours = Math.min(Math.ceil(duration.hours / units.hours) * units.hours, 24);
				else
					duration.hours = 24;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!ceilDays)
				return;

			if (duration.days > 0)
			{
				if (units.days > 0)
					duration.days = Math.min(Math.ceil(duration.days / units.days) * units.days, daysInMonth);
				else
					duration.days = daysInMonth;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!ceilMonths)
				return;

			if (duration.months > 0)
			{
				if (units.months > 0)
					duration.months = Math.min(Math.ceil(duration.months / units.months) * units.months, 12);
				else
					duration.months = 12;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!ceilYears)
				return;

			if (units.years > 0)
			{
				duration.years = Math.ceil(duration.years / units.years) * units.years;
				_normalizeDuration(duration, daysInMonth);
			}
		};

		var _floorDateInternal = function(date, units)
		{
			var floorYear = (units.years > 0);
			var floorMonth = floorYear || (units.months > 0);
			var floorDay = floorMonth || (units.days > 0);
			var floorHours = floorDay || (units.hours > 0);
			var floorMinutes = floorHours || (units.minutes > 0);
			var floorSeconds = floorMinutes || (units.seconds > 0);

			if (!floorSeconds)
				return;

			if (date.getSeconds() > 0)
			{
				if (units.seconds > 0)
					date.setSeconds(Math.floor(date.getSeconds() / units.seconds) * units.seconds);
				else
					date.setSeconds(0);
			}

			if (!floorMinutes)
				return;

			if (date.getMinutes() > 0)
			{
				if (units.minutes > 0)
					date.setMinutes(Math.floor(date.getMinutes() / units.minutes) * units.minutes);
				else
					date.setMinutes(0);
			}

			if (!floorHours)
				return;

			if (date.getHours() > 0)
			{
				if (units.hours > 0)
					date.setHours(Math.floor(date.getHours() / units.hours) * units.hours);
				else
					date.setHours(0);
			}

			if (!floorDay)
				return;

			if (date.getDay() > 1)
			{
				if (units.days > 0)
					date.setDay(Math.floor((date.getDay() - 1) / units.days) * units.days + 1);
				else
					date.setDay(1);
			}

			if (!floorMonth)
				return;

			if (date.getMonth() > 1)
			{
				if (units.months > 0)
					date.setMonth(Math.floor((date.getMonth() - 1) / units.months) * units.months + 1);
				else
					date.setMonth(1);
			}

			if (!floorYear)
				return;

			if (units.years > 0)
				date.setYear(Math.floor(date.getYear() / units.years) * units.years);
		};

		var _floorDurationInternal = function(duration, units, referenceDate)
		{
			var floorYears = (units.years > 0);
			var floorMonths = floorYears || (units.months > 0);
			var floorDays = floorMonths || (units.days > 0);
			var floorHours = floorDays || (units.hours > 0);
			var floorMinutes = floorHours || (units.minutes > 0);
			var floorSeconds = floorMinutes || (units.seconds > 0);

			var daysInMonth = TimeUtils.daysInMonth(referenceDate);

			if (!floorSeconds)
				return;

			if (duration.seconds > 0)
			{
				if (units.seconds > 0)
					duration.seconds = Math.floor(duration.seconds / units.seconds) * units.seconds;
				else
					duration.seconds = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!floorMinutes)
				return;

			if (duration.minutes > 0)
			{
				if (units.minutes > 0)
					duration.minutes = Math.floor(duration.minutes / units.minutes) * units.minutes;
				else
					duration.minutes = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!floorHours)
				return;

			if (duration.hours > 0)
			{
				if (units.hours > 0)
					duration.hours = Math.floor(duration.hours / units.hours) * units.hours;
				else
					duration.hours = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!floorDays)
				return;

			if (duration.days > 0)
			{
				if (units.days > 0)
					duration.days = Math.floor(duration.days / units.days) * units.days;
				else
					duration.days = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!floorMonths)
				return;

			if (duration.months > 0)
			{
				if (units.months > 0)
					duration.months = Math.floor(duration.months / units.months) * units.months;
				else
					duration.months = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!floorYears)
				return;

			if (units.years > 0)
			{
				duration.years = Math.floor(duration.years / units.years) * units.years;
				_normalizeDuration(duration, daysInMonth);
			}
		};

		var _roundDateInternal = function(date, units)
		{
			var roundYear = (units.years > 0);
			var roundMonth = roundYear || (units.months > 0);
			var roundDay = roundMonth || (units.days > 0);
			var roundHours = roundDay || (units.hours > 0);
			var roundMinutes = roundHours || (units.minutes > 0);
			var roundSeconds = roundMinutes || (units.seconds > 0);

			if (!roundSeconds)
				return;

			if (date.getSeconds() > 0)
			{
				if (units.seconds > 0)
					date.setSeconds(Math.min(Math.round(date.getSeconds() / units.seconds) * units.seconds, 60));
				else if (date.getSeconds() >= 30)
					date.setSeconds(60);
				else
					date.setSeconds(0);
			}

			if (!roundMinutes)
				return;

			if (date.getMinutes() > 0)
			{
				if (units.minutes > 0)
					date.setMinutes(Math.min(Math.round(date.getMinutes() / units.minutes) * units.minutes, 60));
				else if (date.getMinutes() >= 30)
					date.setMinutes(60);
				else
					date.setMinutes(0);
			}

			if (!roundHours)
				return;

			if (date.getHours() > 0)
			{
				if (units.hours > 0)
					date.setHours(Math.min(Math.round(date.getHours() / units.hours) * units.hours, 24));
				else if (date.getHours() >= 12)
					date.setHours(24);
				else
					date.setHours(0);
			}

			if (!roundDay)
				return;

			if (date.getDay() > 1)
			{
				var daysInMonth = TimeUtils.daysInMonth(date);
				if (units.days > 0)
					date.setDay(Math.min(Math.round((date.getDay() - 1) / units.days) * units.days, daysInMonth) + 1);
				else if (date.getDay() >= Math.floor(daysInMonth / 2 + 1))
					date.setDay(daysInMonth + 1);
				else
					date.setDay(1);
			}

			if (!roundMonth)
				return;

			if (date.getMonth() > 1)
			{
				if (units.months > 0)
					date.setMonth(Math.min(Math.round((date.getMonth() - 1) / units.months) * units.months, 12) + 1);
				else if (date.getMonth() >= (6 + 1))
					date.setMonth(12 + 1);
				else
					date.setMonth(1);
			}

			if (!roundYear)
				return;

			if (units.years > 0)
				date.setYear(Math.round(date.getYear() / units.years) * units.years);
		};

		var _roundDurationInternal = function(duration, units, referenceDate)
		{
			var roundYears = (units.years > 0);
			var roundMonths = roundYears || (units.months > 0);
			var roundDays = roundMonths || (units.days > 0);
			var roundHours = roundDays || (units.hours > 0);
			var roundMinutes = roundHours || (units.minutes > 0);
			var roundSeconds = roundMinutes || (units.seconds > 0);

			var daysInMonth = TimeUtils.daysInMonth(referenceDate);

			if (!roundSeconds)
				return;

			if (duration.seconds > 0)
			{
				if (units.seconds > 0)
					duration.seconds = Math.min(Math.round(duration.seconds / units.seconds) * units.seconds, 60);
				else if (duration.seconds >= 30)
					duration.seconds = 60;
				else
					duration.seconds = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!roundMinutes)
				return;

			if (duration.minutes > 0)
			{
				if (units.minutes > 0)
					duration.minutes = Math.min(Math.round(duration.minutes / units.minutes) * units.minutes, 60);
				else if (duration.minutes >= 30)
					duration.minutes = 60;
				else
					duration.minutes = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!roundHours)
				return;

			if (duration.hours > 0)
			{
				if (units.hours > 0)
					duration.hours = Math.min(Math.round(duration.hours / units.hours) * units.hours, 24);
				else if (duration.hours >= 12)
					duration.hours = 24;
				else
					duration.hours = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!roundDays)
				return;

			if (duration.days > 0)
			{
				if (units.days > 0)
					duration.days = Math.min(Math.round(duration.days / units.days) * units.days, daysInMonth);
				else if (duration.days >= Math.floor(daysInMonth / 2))
					duration.days = daysInMonth;
				else
					duration.days = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!roundMonths)
				return;

			if (duration.months > 0)
			{
				if (units.months > 0)
					duration.months = Math.min(Math.round(duration.months / units.months) * units.months, 12);
				else if (duration.months >= 6)
					duration.months = 12;
				else
					duration.months = 0;
				_normalizeDuration(duration, daysInMonth);
			}

			if (!roundYears)
				return;

			if (units.years > 0)
			{
				duration.years = Math.round(duration.years / units.years) * units.years;
				_normalizeDuration(duration, daysInMonth);
			}
		};

		var _toTimeZoneStable = function(date, timeZone)
		{
			var date2 = date.toTimeZone(timeZone);
			if ((date2.getYear() == date.getYear()) && (date2.getMonth() == date.getMonth()) && (date2.getDay() == date.getDay()) &&
			    (date2.getHours() == date.getHours()) && (date2.getMinutes() == date.getMinutes()) && (date2.getSeconds() == date.getSeconds()))
				return date2;

			var date3 = date.clone();
			date3.setTimeZone(timeZone);
			if ((date3.getYear() == date.getYear()) && (date3.getMonth() == date.getMonth()) && (date3.getDay() == date.getDay()) &&
			    (date3.getHours() == date.getHours()) && (date3.getMinutes() == date.getMinutes()) && (date3.getSeconds() == date.getSeconds()))
				return date3;

			return date2;
		};

		var _normalizeDuration = function(duration, daysInMonth)
		{
			var years = duration.years;
			var wholeYears = Math.floor(years);
			var subYears = years - wholeYears;

			var months = duration.months + subYears * 12;
			var wholeMonths = Math.floor(months);
			var subMonths = months - wholeMonths;

			var days = duration.days + subMonths * daysInMonth;
			var wholeDays = Math.floor(days);
			var subDays = days - wholeDays;

			var hours = duration.hours + subDays * 24;
			var wholeHours = Math.floor(hours);
			var subHours = hours - wholeHours;

			var minutes = duration.minutes + subHours * 60;
			var wholeMinutes = Math.floor(minutes);
			var subMinutes = minutes - wholeMinutes;

			var seconds = duration.seconds + subMinutes * 60;
			var wholeSeconds = Math.floor(seconds);
			var subSeconds = _normalizePrecision(seconds - wholeSeconds);
			if (subSeconds >= 1)
			{
				subSeconds = 0;
				wholeSeconds++;
			}

			wholeMinutes += Math.floor(wholeSeconds / 60);
			wholeSeconds %= 60;

			wholeHours += Math.floor(wholeMinutes / 60);
			wholeMinutes %= 60;

			wholeDays += Math.floor(wholeHours / 24);
			wholeHours %= 24;

			wholeMonths += Math.floor(wholeDays / daysInMonth);
			wholeDays %= daysInMonth;

			wholeYears += Math.floor(wholeMonths / 12);
			wholeMonths %= 12;

			duration.years = wholeYears;
			duration.months = wholeMonths;
			duration.days = wholeDays;
			duration.hours = wholeHours;
			duration.minutes = wholeMinutes;
			duration.seconds = wholeSeconds + subSeconds;
		};

		var _normalizePrecision = function(value)
		{
			return Number(value.toFixed(6));
		};

	});

});
});

define("splunk.time", ["jg_global","jgatt"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.splunk.time;
    };
}(this)));

define('views/shared/AboutDialog',[
    'underscore',
    'module',
    'uri/route',
    'views/Base',
    'views/shared/Modal',
    'contrib/text!views/shared/AboutDialog.html',
    'splunk.time',
    'splunk.util'
],
function(
    _,
    module,
    route,
    Base,
    Modal,
    Template,
    Time,
    util
){
    return Modal.extend({
        moduleId: module.id,
        template: Template,
        initialize: function() {
            Modal.prototype.initialize.apply(this, arguments);
            var currentAppName = this.model.applicationModel.get('app'),
                currentApp,
                date = new Time.DateTime();

            this.year = date.getYear();
            if (currentAppName === 'launcher') {
                this.currentAppLabel = _('Home').t();
            }
            else {
                if (this.collection) {
                    currentApp = this.collection.find(function(app) {
                        return app.entry.get('name') === currentAppName;
                    });
                }
                this.currentAppLabel = currentApp ? currentApp.entry.content.get('label') : _('N/A').t();
            }
            this.model.serverInfo.on('change reset', function() {
                this.render();
            }, this);
        },
        getListOfProducts: function() {
            var addOns = this.model.serverInfo.getAddOns(),
                result;
            if (addOns && !$.isEmptyObject(addOns)) {
                result = _(addOns).keys().join(', ');
            }
            return result;
        },
        render: function() {
            this.$el.html(Modal.TEMPLATE);
            this.$(Modal.HEADER_TITLE_SELECTOR).html('splunk<span class="prompt">&gt;&#x00AE;'+this.model.serverInfo.getProductLogo()+'</span>');
            var isLite = this.model.serverInfo.isLite(),
                isLiteFree = this.model.serverInfo.isLiteFree(),
                versionNumberText = this.model.serverInfo.getVersion() || _('N/A').t(),
                liteVersionText = (isLiteFree) ? _('Splunk Light Free Version ').t() + versionNumberText : _('Splunk Light Version ').t() + versionNumberText,
                versionText = (isLite) ? liteVersionText : versionNumberText,
                template = this.compiledTemplate({
                    serverName: this.model.serverInfo.getServerName() || _('N/A').t(),
                    version: versionText,
                    isEnterprise: this.model.serverInfo.isEnterprise(),
                    build: this.model.serverInfo.getBuild() || _('N/A').t(),
                    appVersion: this.model.appLocal.entry.content.get('version') || null,
                    appBuild: this.model.appLocal.entry.content.get('build') || null,
                    listOfProducts: this.getListOfProducts(),
                    currentApp: this.currentAppLabel,
                    isLite: isLite,
                    isCloud: this.model.serverInfo.isCloud(),
                    thirdPartyCredits: route.docHelp(this.model.applicationModel.get('root'), this.model.applicationModel.get('locale'), 'ReleaseNotes.Credits'),
                    copyrightYear: this.year,
                    sprintf: util.sprintf
                });
            this.$(Modal.BODY_SELECTOR).html(template);
            this.$(Modal.FOOTER_SELECTOR).remove();

            return this;
        }
    });
});


define('contrib/text!views/shared/whatsnewdialog/Master.html',[],function () { return '<h2><%=_("Platform").t()%></h2>\n\n<div class="feature">\n    <h3><%=_("Search Parallelization").t()%></h3>\n    <p><%=_("Optimized CPU utilization for faster search execution.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.searchparallelization" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Index Parallelization").t()%></h3>\n    <p><%=_("Optimized CPU utilization for faster data ingestion.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.indexparallelization" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Intelligent Job Scheduling").t()%></h3>\n    <p><%=_("Intelligent job scheduling provides improved system utilization and predictable performance.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.jobscheduling" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Data Integrity Control").t()%></h3>\n    <p><%=_("Data integrity control ensures that indexed data has not been modified.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.dataintegrity" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Single Sign-On Using SAML").t()%></h3>\n    <p><%=_("Support for SAML 2.0 for single sign-on using Ping Federate as the Identity Provider.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.ssosaml" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Search Head Clustering Improvements").t()%></h3>\n    <p><%=_("Performance optimization, scalability, and management improvements. Support for Windows OS.").t()%></p>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Indexer Clustering Improvements").t()%></h3>\n    <p><%=_("Ability to turn off search affinity.").t()%></p>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("HTTP Event Collector").t()%></h3>\n    <p><%=_("Indexing of high-volume JSON-based application and IOT data sent directly via a secure, scalable HTTP endpoint. No Forwarder required.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.httpinput" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Custom Alert Actions").t()%></h3>\n    <p><%=_("Customizable alert actions and packaged integrations with popular third-party applications or messaging systems.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.customalert" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Key Value Store - Distributed Lookups").t()%></h3>\n    <p><%=_("Allows App developers to do KV Store lookups on remote indexers to improve efficiency in large scale distributed environments.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.kvstoredistrlookups" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Key Value Store - Lookup Filtering").t()%></h3>\n    <p><%=_("Allows App developers to filter lookup data without requiring subsequent searches.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.kvstorelookupfiltering" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n<h2><%=_("Management & Admin").t()%></h2>\n\n<div class="feature">\n    <h3><%=_("HTTP Event Collector Configuration").t()%></h3>\n    <p><%=_("Create and manage configurations for the HTTP Event Collector.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.httpinputconf" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Source Type Manager").t()%></h3>\n    <p><%=_("Create and manage source type configurations independent of getting data in, and search within the source type picker.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.sourcetypemanager" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Powershell Input").t()%></h3>\n    <p><%=_("Native support for data ingestion of data retrieved by Powershell scripts.").t()%></p>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("App Browsing Interface").t()%></h3>\n    <p><%=_("Automates and simplifies app and add-on discovery within Splunk Web.").t()%></p>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Indexer Auto-Discovery").t()%></h3>\n    <p><%=_("Forwarders now dynamically retrieve indexer lists from cluster master to enable elastic deployments.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.indexerautodiscovery" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Distributed Management Console").t()%></h3>\n    <p><%=_("New topology views, status, and alerting for Splunk platform deployments including: indexers, search heads, forwarders, and storage utilization.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.deploymentmonitoring" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Field Extractor Enhancements").t()%></h3>\n    <p><%=_("Simplified field extraction via delimiter and header selection. Displays field extractions within the event preview.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.fieldextractor" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n<h2><%=_("Usability").t()%></h2>\n\n<div class="feature">\n    <h3><%=_("Single Value Display").t()%></h3>\n    <p><%=_("Support for at-a-glance, single-value indicators with historical context and change indicators.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.newsinglevalue" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Geospatial Visualization").t()%></h3>\n    <p><%=_("Support for choropleth maps to visualize how a metric varies across a customizable geographic area.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.geospatialviz" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Dashboard Enhancements").t()%></h3>\n    <p><%=_("More powerful dashboards with extended search and token management.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.dashboardenhancements" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Search History").t()%></h3>\n    <p><%=_("View and interact with ad hoc search command history.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.searchhistory" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Anomaly Detection").t()%></h3>\n    <p><%=_("New SPL command that offers histogram based approach for detecting anomalies. Also includes the capabilities of existing anomalousvalue and outlier SPL commands.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.anomalydetection" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Search Helper Improvements").t()%></h3>\n    <p><%=_("Re-architected to Improve responsiveness").t()%></p>\n</div>\n\n<h2><%=_("Developers View").t()%></h2>\n\n<div class="feature">\n    <h3><%=_("Java Logger Support for HTTP Event Collector").t()%></h3>\n    <p><%=_("Adds support for log4j, logback and java.util.logging to allow logging from Java apps over HTTP.").t()%></p>\n</div>\n\n\n<div class="feature">\n    <h3><%=_(".NET Logger Support for HTTP Event Logger").t()%></h3>\n    <p><%=_("Adds support for the .NET Trace Listener API and SLAB (Semantic Logging Application Block) to allow logging from apps over HTTP.").t()%></p>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Custom Alert Actions").t()%></h3>\n    <p><%=_("Allows developers to build, package, and integrate custom alert actions as native to Splunk software.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.customalerts" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Key Value Store - Distributed Lookups").t()%></h3>\n    <p><%=_("Allows App developers to do KV Store lookups on remote indexers to improve efficiency in large scale distributed environments.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.kvstoredistrlookups" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>\n\n\n<div class="feature">\n    <h3><%=_("Key Value Store - Lookup Filtering").t()%></h3>\n    <p><%=_("Allows App developers to filter lookup data without requiring subsequent searches.").t()%></p>\n    <a href="<%=docLink%>whatsnew-6.3.kvstorelookupfiltering" class="external" target="_blank"><%=_("Documentation").t()%></a>\n</div>';});

define(
'views/shared/whatsnewdialog/Master',[
    'jquery',
    'underscore',
    'module',
    'views/Base',
    'views/shared/Modal',
    'uri/route',
    'splunk.util',
    'contrib/text!views/shared/whatsnewdialog/Master.html'
],
function(
    $,
    _,
    module,
    Base,
    Modal,
    route,
    splunk_util,
    Template
){
    return Modal.extend({
        moduleId: module.id,
        template: Template,
        initialize: function() {
            Modal.prototype.initialize.apply(this, arguments);
            var self = this;
            this.on('hidden', function(){
                self.$el.remove();
                self.modalWrapper.remove();
            });
            this.render();
        },
        render: function() {
            var imgPath = splunk_util.make_url('/static/img/');
            var docLink = route.docHelp(this.model.application.get("root"), this.model.application.get("locale"), '');
            var template = this.compiledTemplate({imgPath: imgPath, docLink: docLink});

            this.$el.html(Modal.TEMPLATE);
            this.$(Modal.HEADER_TITLE_SELECTOR).html(_("What's new in 6.3").t());
            this.$(Modal.BODY_SELECTOR).html(template);
            this.modalWrapper = $('<div class="splunk-components"></div>');
            $(this.el).appendTo(this.modalWrapper);
            this.modalWrapper.appendTo('body');
            this.show();
            return this;
        }
    });
});


define('contrib/text!views/shared/splunkbar/HelpMenu.html',[],function () { return '<a href="#" class="dropdown-toggle">\n    <% if (isLite || isCloud) { %>\n        <i class="icon icon-question-circle"></i>\n    <% } %>\n    <%- label %><b class="caret"></b>\n</a>\n<div class="dropdown-menu" id="global-help-menu">\n    <div class="arrow"></div>\n    <ul>\n        <% if (isCloud) { %>\n            <li><a class="external" href="http://www.splunk.com/en_us/search.html?query=search" target="_blank"><%- _("Search Splunk").t() %></a></li>\n            <li><a class="external" href="https://splunkcommunities.force.com/customers/home/home.jsp" target="_blank"><%- _("Customer Portal").t() %></a></li>\n            <li><a class="external" href="http://answers.splunk.com/" target="_blank"><%- _("Splunk Answers").t() %></a></li>\n            <% if (!isLite) { %>\n                <li><a class="external" href="https://splunkbase.splunk.com" target="_blank"><%- _("Splunkbase").t() %></a></li>\n            <% } %>\n            <li><a class="external" href="<%- docLink %>" target="_blank"><%- _("Help for this page").t() %></a></li>\n            <li><a class="external" href="https://www.splunk.com/en_us/support-and-services.html" target="_blank"><%- _("Support & Services").t() %></a></li>\n            <li><a class="external" href="http://www.splunk.com/en_us/about-us/contact.html#customer-support" target="_blank"><%- _("Customer Support").t() %></a></li>\n            <% if (isLite && hasTours) { %>\n                <li><a class="splunk-tours" href="#"><%- _("Product Tours").t() %></a></li>\n            <% } %>\n            <li><a class="about-splunk" href="#"><%- _("About").t() %></a></li>\n            <% if (!isLite) { %>\n                <li><a class="whatsnew" href="#"><%- _("What\'s New in 6.3").t() %></a></li>\n            <% } %>\n        <% } else{ %>\n            <% if (!isLite) { %>\n                <li><a class="whatsnew" href="#"><%- _("What\'s New in 6.3").t() %></a></li>\n                <li><a class="external" href="<%- makeDocLink(\'search_app.tutorial\') %>" target="_blank"><%- _("Tutorials").t() %></a></li>\n            <% } %>\n            <li><a class="external" href="http://splunk-base.splunk.com/" target="_blank"><%- _("Splunk Answers").t() %></a></li>\n            <li><a class="external" href="http://www.splunk.com/support" target="_blank"><%- _("Contact Support").t() %></a></li>\n            <li><a class="external" href="<%- docLink %>" target="_blank"><%- _("Help for this page").t() %></a></li>\n            <% if (isLite && hasTours) { %>\n                <li><a class="splunk-tours" href="#"><%- _("Product Tours").t() %></a></li>\n            <% } %>\n            <li><a class="about-splunk" href="#"><%- _("About").t() %></a></li>\n        <% } %>\n    </ul>\n    <% if (!isLite) { %>\n        <form class="form-search" action="#help" method="get"></form>\n    <% } %>\n</div>\n';});

define(
'views/shared/splunkbar/HelpMenu',[
    'underscore',
    'jquery',
    'module',
    'views/Base',
    'views/shared/delegates/Popdown',
    'views/shared/AboutDialog',
    'views/shared/controls/TextControl',
    'views/shared/whatsnewdialog/Master',
    'contrib/text!views/shared/splunkbar/HelpMenu.html',
    'uri/route'
],
function(
    _,
    $,
    module,
    BaseView,
    Popdown,
    AboutDialogView, 
    TextControl,
    WhatsNewDialogView,
    helpMenuTemplate,
    route
){
    return BaseView.extend({
        moduleId: module.id,
        template: helpMenuTemplate,
        tagName: 'li',
        className: 'dropdown help',
        initialize: function(){
            BaseView.prototype.initialize.apply(this, arguments);
            this.children.searchInput = new TextControl({
                placeholder: _('Search Documentation').t(),
                inputClassName: 'input-medium search-query'
            });
            this.model.appLocal.on('change reset', this.debouncedRender, this);
            this.hasTours = false;
            this.debouncedRender();
        },
        events: {
            'keypress input': "onDocsSearch",
            'click .whatsnew': 'onWhatsNew',
            'click .dropdown-menu a': 'closePopdown', 
            'click .about-splunk': function(e) {
                this.children.aboutDialog = new AboutDialogView({
                    collection: this.collection.apps,
                    model: {
                        applicationModel: this.model.application,
                        appLocal: this.model.appLocal,
                        serverInfo: this.model.serverInfo
                    },
                    onHiddenRemove: true
                });

                //for compatibility with the module system, this needs to be wrapped in an extra div.
                this.modalWrapper = $('<div class="splunk-components">').appendTo("body").append(this.children.aboutDialog.render().el);
                        
                this.children.aboutDialog.show();
                e.preventDefault();
            }
        },
        render: function(){
            var isCloud = this.model.serverInfo.isCloud(),
                isLite = this.model.serverInfo.isLite(),
                html = this.compiledTemplate({
                    docLink: this.makeDocLinkForPage(),
                    makeDocLink: this.makeDocLink.bind(this),
                    isLite: isLite,
                    isCloud: isCloud,
                    hasTours: this.hasTours,
                    label: isCloud ? _("Support & Services").t() : _("Help").t()
                });
            this.$el.html(html);

            var popup = this.$('#global-help-menu');
            popup.find('.form-search').append(this.children.searchInput.render().el);
            this.children.popdown = new Popdown({el:popup.parent(), mode: 'dialog'});
            return this;
        },
        onDocsSearch: function(evt){
            if (evt.keyCode === 13){ //ENTER
                var s = $(evt.target).val();
                evt.preventDefault();
                evt.stopPropagation();
                $.when(this.serverInfoDfd).then(function(){
                    var url = route.docSearch(this.model.application.get('locale'), this.model.serverInfo.getVersion(), this.model.serverInfo.isFreeLicense(), this.model.serverInfo.isTrial(), s);
                    window.open(url);
                }.bind(this));
                $(evt.target).val('');
                this.closePopdown();
                evt.preventDefault();
            }
        },
        makeDocLink: function(location) {
            return route.docHelpInAppContext(
                this.model.application.get("root"),
                this.model.application.get("locale"),
                location,
                this.model.application.get("app"),
                this.model.appLocal.entry.content.get('version'),
                this.model.appLocal.appAllowsDisable(),
                this.model.appLocal.entry.content.get('docs_section_override')
            );
        },
        makeDocLinkForPage: function() {
            //this is the generic doc link based on the current location
            var link = '/help',
                location;

            if(this.model.application.get('page') === '_admin'){
                // making help link for manager page
                location = 'manager';
                if(window && window.location && typeof window.location.pathname === 'string'){
                    //get the location from the browser
                    var pathname = window.location.pathname;
                    //remove '/manager/' and all characters before
                    pathname = pathname.substring(pathname.indexOf('/manager/')+9);
                    //next we should have app namespace to remove
                    pathname = pathname.substring(pathname.indexOf('/')+1);
                    //change slashes to dots
                    pathname = pathname.replace(new RegExp('/', 'g'), '.');
                    location += '.'+pathname;
                }

                link = route.docHelp(
                    this.model.application.get("root"),
                    this.model.application.get("locale"),
                    location
                );

            }else{
                // making help link for app page
                // location is in form: app.<app_name>.<page_name>
                location = [
                    'app',
                    this.model.application.get('app'),
                    this.model.application.get('page')
                ].join(".");

                link = this.makeDocLink(location);

            }
            return link;
        },
        onWhatsNew: function(e){
            if(e){
                e.preventDefault();
            }
            this.children.whatsNewDialog = new WhatsNewDialogView({
                model: this.model
            });
        },
        closePopdown: function(e){
            this.children.popdown.hide();
        }
    });
});

/**
 * PopTart.show() now has the following signature: 
 * 
 * show($pointTo[, options]) 
 * 
 * Where the options are: 
 * 
 * $toggle: Clicking on this element will trigger opening and closing of the PopTart. Defaults to the $pointTo element. 
 * $onOpenFocus: When the PopTart opens, this element is then given focus. Defaults to the first anchor element inside the opened PopTart. 
 * $onCloseFocus: When the PopTart closes, this element is then given focus. Defaults to the $toggle element. 
 * $onClickCloseFocus: When the PopTart closes via a click event, this element is then given focus. Defaults to the $onCloseFocus element. 
 */
 
define(
    'views/shared/PopTart',[
        'underscore',
        'module',
        'views/Base',
        'views/shared/delegates/PopdownDialog'
    ],
    function(_, module, Base, PopdownDialogDelegate) {
        return Base.extend({
            moduleId: module.id,
            className: 'popdown-dialog',
            initialize: function(options) {
                options = options || {};
                var defaults = {
                    direction:'auto',
                    adjustPosition: true
                };
                _.defaults(options, defaults);
                
                Base.prototype.initialize.apply(this, arguments);
                this.children.popdownDialogDelegate = new PopdownDialogDelegate({
                    el: this.el,
                    ignoreClasses: this.options.ignoreClasses, 
                    adjustPosition: this.options.adjustPosition,
                    show: this.options.show,
                    mode: this.options.mode, // "menu" or "dialog"
                    direction: this.options.direction,
                    arrow: this.options.arrow,
                    minMargin: this.options.minMargin,
                    allowPopUp: this.options.allowPopUp,
                    scrollContainer: this.options.scrollContainer,
                    /**
                     * If ignoreToggleMouseDown is enabled, the PopTart will take no action when
                     * clicking on the PopTart's toggle activator element. This allows the 
                     * creator of the PopTart to fully manage closing the opened PopTart.
                     */
                    ignoreToggleMouseDown: this.options.ignoreToggleMouseDown
                });
                this.activate();
            },
            startListening: function() {
                this.listenTo(this.children.popdownDialogDelegate, 'all', function() {
                    this.trigger.apply(this, arguments);
                });
                this.listenTo(this, 'shown', function() {
                    this.shown = true;
                    if (this.$onOpenFocus) {
                        this.$onOpenFocus.focus();
                    } else {
                        this.children.popdownDialogDelegate.$el.find('a').first().focus();
                    }

                    $(window).on("resize." + this.cid, function() {
                        this.children.popdownDialogDelegate.adjustPosition(this.$pointTo);
                    }.bind(this));
                });
                this.listenTo(this, 'hidden', function(e) {
                    this.shown = false;
                    if (this.options.onHiddenRemove) {
                        this.remove();
                    }

                    $(window).off("resize." + this.cid);

                    //Focus on activator
                    var x = window.pageXOffset,
                        y = window.pageYOffset;
                    if (e && e.type === 'click') {
                        this.$onClickCloseFocus.focus();
                    } else {
                        this.$onCloseFocus.focus();
                    }
                    window.scrollTo(x, y);
                });
            },
            toggle: function() {
                return this.children.popdownDialogDelegate.toggle();
            },
            show: function($pointTo, options) {
                options = options || {};
                
                this.$pointTo = $pointTo;
                this.$toggle = options.$toggle || this.$pointTo;
                this.$onOpenFocus = options.$onOpenFocus;
                this.$onCloseFocus = options.$onCloseFocus || this.$toggle;
                this.$onClickCloseFocus = options.$onClickCloseFocus || this.$onCloseFocus;

                this.children.popdownDialogDelegate.show(this.$pointTo, this.$toggle);
            },
            hide: function(e) {
                this.children.popdownDialogDelegate.hide(e);
            },
            render: function() {
                this.el.innerHTML = this.template;
                return this;
            },
            remove: function() {
                if (this.shown) {
                    this.hide();
                }
                Base.prototype.remove.apply(this, arguments);
            },
            template: '\
                <div class="arrow"></div>\
                <div class="popdown-dialog-body popdown-dialog-padded"></div>\
            ',
            template_menu: '\
                <div class="arrow"></div>\
            '
        });
    }
);


define('contrib/text!views/shared/splunkbar/find/results/DashboardResults.html',[],function () { return '<div class="findbar-results-header"><%- _(\'Dashboards\').t() %></div>\n<ul class="dashboards">\n    <% dashboards.each(function(dash) { %>\n        <% var appName = dash.entry.content.get(\'eai:appName\'); %>\n        <% var dashApp = _.find(apps.models, function(app) {return app.entry.get(\'name\') === appName;}); %>\n        <% var openInApp = dashApp && dashApp.entry.content.get("visible") ? appName : alternateApp; %>\n        <li class=\'findbar-results-row\'>\n            <a class="primary-link" href="<%- route.page(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        openInApp,\n                        dash.entry.get(\'name\')) %>">\n                <i class="icon-dashboard findbar-results-icon"></i>\n                <%- dash.meta.get(\'label\') %>\n            </a>\n            <a class="secondary-link" href="<%- route.page(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        openInApp,\n                        dash.entry.get(\'name\')) %>" target="_blank">\n                <i class="icon-external"></i>    \n            </a>\n        </li>\n    <% }); %>\n    <% if (dashboards.models[0].paging.get(\'perPage\') < dashboards.models[0].paging.get(\'total\')) { %>\n        <li class="findbar-more-link">\n            <a class="primary-link" href="<%- route.manager(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        \'system\',\n                        [\'dashboards\'],\n                        {data: {search: search, rawSearch: rawSearch}}) %>">\n                <%- _(\'More Dashboard results\').t() %>\n            </a>\n            <a class="secondary-link" href="<%- route.manager(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        \'system\',\n                        [\'dashboards\'],\n                        {data: {search: search, rawSearch: rawSearch}}) %>" target="_blank">\n                <i class="icon-external"></i>\n            </a>\n        </li>\n    <% } %>\n</ul>';});

define(
'views/shared/splunkbar/find/results/DashboardResults',[
    'underscore',
    'jquery',
    'module',
    'views/Base',
    'contrib/text!views/shared/splunkbar/find/results/DashboardResults.html', 
    'uri/route'
],
function(
    _,
    $,
    module,
    BaseView,
    dashboardResultsTemplate,
    route
){
    return BaseView.extend({
        moduleId: module.id,
        template: dashboardResultsTemplate,
        className: 'dashboardResults',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
        },
        render: function() {
            var html = this.compiledTemplate({
                _: _,
                dashboards: this.collection.dashboards,
                app: this.model.application,
                route: route,
                search: this.model.state.get('search') || '',
                rawSearch: this.model.rawSearch.get('rawSearch') || '',
                apps: this.collection.apps,
                alternateApp: this.options.alternateApp
            });
            
            this.$el.html(html);
            return this;
        }
    });
});

define('contrib/text!views/shared/splunkbar/find/results/ReportResults.html',[],function () { return '<div class="findbar-results-header"><%- _(\'Reports\').t() %></div>\n<ul class="reports">\n    <% reports.each(function(report) { %>\n        <% var appName = report.entry.acl.get(\'app\'); %>\n        <% var reportApp = _.find(apps.models, function(app) {return app.entry.get(\'name\') === appName;}); %>\n        <% var openInApp = reportApp && reportApp.entry.content.get("visible") ? appName : alternateApp; %>\n        <li class=\'findbar-results-row\'>\n            <a class="primary-link" href="<%- route.report(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        openInApp,\n                        {data: {s: report.id }}) %>">\n                <i class="icon-report findbar-results-icon"></i>\n                <%- report.entry.get(\'name\') %>\n            </a>\n            <a class="secondary-link" href="<%- route.report(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        openInApp,\n                        {data: {s: report.id }}) %>" target="_blank">\n                <i class="icon-external"></i>    \n            </a>\n        </li>\n    <% }); %>\n    <% if (reports.models[0].paging.get(\'perPage\') < reports.models[0].paging.get(\'total\')) { %>\n        <li class="findbar-more-link">\n            <a class="primary-link" href="<%- route.manager(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        \'system\',\n                        [\'reports\'],\n                        {data: {search: search, rawSearch: rawSearch}}) %>">\n                <%- _(\'More Report results\').t() %>\n            </a>\n            <a class="secondary-link" href="<%- route.manager(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        \'system\',\n                        [\'reports\'],\n                        {data: {search: search, rawSearch: rawSearch}}) %>" target="_blank">\n                <i class="icon-external"></i>\n            </a>\n        </li>\n    <% } %>\n</ul>';});

define(
'views/shared/splunkbar/find/results/ReportResults',[
    'underscore',
    'jquery',
    'module',
    'views/Base',
    'contrib/text!views/shared/splunkbar/find/results/ReportResults.html', 
    'uri/route'
],
function(
    _,
    $,
    module,
    BaseView,
    reportResultsTemplate,
    route
){
    return BaseView.extend({
        moduleId: module.id,
        template: reportResultsTemplate,
        className: 'reportResults',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
        },
        render: function() {
            var html = this.compiledTemplate({
                _: _,
                reports: this.collection.reports,
                app: this.model.application,
                route: route,
                search: this.model.state.get('search') || '',
                rawSearch: this.model.rawSearch.get('rawSearch') || '',
                apps: this.collection.apps,
                alternateApp: this.options.alternateApp
            });
            
            this.$el.html(html);
            return this;
        }
    });
});

define('contrib/text!views/shared/splunkbar/find/results/AlertResults.html',[],function () { return '<div class="findbar-results-header"><%- _(\'Alerts\').t() %></div>\n<ul class="alerts">\n    <% alerts.each(function(alert) { %>\n        <% var appName = alert.entry.acl.get(\'app\'); %>\n        <% var alertApp = _.find(apps.models, function(app) {return app.entry.get(\'name\') === appName;}); %>\n        <% var openInApp = alertApp && alertApp.entry.content.get("visible") ? appName : alternateApp; %>\n        <li class=\'findbar-results-row\'>\n            <a class="primary-link" href="<%- route.alert(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        openInApp,\n                        {data: {s: alert.id }}) %>">\n                <i class="icon-bell findbar-results-icon"></i>\n                <%- alert.entry.get(\'name\') %>\n            </a>\n            <a class="secondary-link" href="<%- route.alert(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        openInApp,\n                        {data: {s: alert.id }}) %>" target="_blank">\n                <i class="icon-external"></i>    \n            </a>\n        </li>\n    <% }); %>\n    <% if (alerts.models[0].paging.get(\'perPage\') < alerts.models[0].paging.get(\'total\')) { %>\n        <li class="findbar-more-link">\n            <a class="primary-link" href="<%- route.manager(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        \'system\',\n                        [\'alerts\'],\n                        {data: {search: search, rawSearch: rawSearch}}) %>">\n                <%- _(\'More Alert results\').t() %>\n            </a>\n            <a class="secondary-link" href="<%- route.manager(\n                        app.get(\'root\'),\n                        app.get(\'locale\'),\n                        \'system\',\n                        [\'alerts\'],\n                        {data: {search: search, rawSearch: rawSearch}}) %>" target="_blank">\n                <i class="icon-external"></i>\n            </a>\n        </li>\n    <% } %>\n</ul>';});

define(
'views/shared/splunkbar/find/results/AlertResults',[
    'underscore',
    'jquery',
    'module',
    'views/Base',
    'contrib/text!views/shared/splunkbar/find/results/AlertResults.html', 
    'uri/route'
],
function(
    _,
    $,
    module,
    BaseView,
    alertResultsTemplate,
    route
){
    return BaseView.extend({
        moduleId: module.id,
        template: alertResultsTemplate,
        className: 'alertResults',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
        },
        render: function() {
            var html = this.compiledTemplate({
                _: _,
                alerts: this.collection.alerts,
                app: this.model.application,
                route: route,
                search: this.model.state.get('search') || '',
                rawSearch: this.model.rawSearch.get('rawSearch') || '',
                apps: this.collection.apps,
                alternateApp: this.options.alternateApp
            });
            
            this.$el.html(html);
            return this;
        }
    });
});

define('contrib/text!views/shared/splunkbar/find/results/DataModelResults.html',[],function () { return '<div class="findbar-results-header"><%- _(\'Data Models\').t() %></div>\n<ul class="datamodels">\n    <% datamodels.each(function(data) { %>\n        <% var appName = data.entry.acl.get(\'app\'); %>\n        <% var dataApp = _.find(apps.models, function(app) {return app.entry.get(\'name\') === appName;}); %>\n        <% var openInApp = dataApp && dataApp.entry.content.get("visible") ? appName : alternateApp; %>\n        <li class=\'findbar-results-row\'>\n            <a class="primary-link" href="<%- route.pivot(\n                        appRoot,\n                        appLocale,\n                        openInApp,\n                        {data: {model: data.get(\'id\')}}) %>">\n                <i class="icon-data findbar-results-icon"></i>\n                <%- data.entry.content.get(\'displayName\') %>\n            </a>\n            <a class="secondary-link" href="<%- route.pivot(\n                        appRoot,\n                        appLocale,\n                        openInApp,\n                        {data: {model: data.get(\'id\')}}) %>" target="_blank">\n                <i class="icon-external"></i>    \n            </a>\n        </li>\n    <% }); %>\n    <% if (datamodels.models[0].paging.get(\'perPage\') < datamodels.models[0].paging.get(\'total\')) { %>\n        <li class="findbar-more-link">\n            <a class="primary-link" href="<%- route.data_model_manager(\n                        appRoot,\n                        appLocale,\n                        managerApp,\n                        {data: {owner: \'*\', nameFilter: rawSearch, app: \'-\'}}) %>">\n                <%- _(\'More Data Model results\').t() %>\n            </a>\n            <a class="secondary-link" href="<%- route.data_model_manager(\n                        appRoot,\n                        appLocale,\n                        managerApp,\n                        {data: {owner: \'*\', nameFilter: rawSearch, app: \'-\'}}) %>" target="_blank">\n                <i class="icon-external"></i>\n            </a>\n        </li>\n    <% } %>\n</ul>';});

define(
'views/shared/splunkbar/find/results/DataModelResults',[
    'underscore',
    'jquery',
    'module',
    'views/Base',
    'contrib/text!views/shared/splunkbar/find/results/DataModelResults.html', 
    'uri/route'
],
function(
    _,
    $,
    module,
    BaseView,
    dataModelResultsTemplate,
    route
){
    return BaseView.extend({
        moduleId: module.id,
        template: dataModelResultsTemplate,
        className: 'dataModelResults',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
        },
        render: function() {
            var appRoot = this.model.application.get('root'),
                appLocale = this.model.application.get('locale'),
                managerApp = (this.model.application.get('app') === 'system') ? 'launcher' : this.model.application.get('app');
            var html = this.compiledTemplate({
                _: _,
                datamodels: this.collection.datamodels,
                route: route,
                search: this.model.state.get('search') || '',
                rawSearch: this.model.rawSearch.get('rawSearch') || '',
                appRoot: appRoot,
                appLocale: appLocale,
                managerApp: managerApp,
                apps: this.collection.apps,
                alternateApp: this.options.alternateApp
            });
            
            this.$el.html(html);
            return this;
        }
    });
});
define(
'views/shared/splunkbar/find/results/Master',[
    'underscore',
    'jquery',
    'module',
    'views/shared/PopTart',
    'views/shared/splunkbar/find/results/DashboardResults',
    'views/shared/splunkbar/find/results/ReportResults',
    'views/shared/splunkbar/find/results/AlertResults',
    'views/shared/splunkbar/find/results/DataModelResults',
    'uri/route',
    'splunk.util'
],
function(
    _,
    $,
    module,
    PopTartView,
    DashboardResults,
    ReportResults,
    AlertResults,
    DataModelResults,
    route,
    splunkUtils
){
    return PopTartView.extend({
        moduleId: module.id,
        className: 'dropdown-menu',
            /**
             * @param {Object} options {
             *     collection: {
             *         dashboards: <collections.shared.Dashboards>,
             *         reports: <collections.search.Reports>,
             *         alerts: <collections.search.Reports>,
             *         datamodels: <collections.services.datamodel.DataModels>,
             *         apps: <collections.services.appLocal>
             *     model: {
             *         state: <models.State>,
             *         application: <models.shared.Application>,
             *         rawSearch: <models.Base>
             *     },
             *     mode: <string>,
             *     onHiddenRemove: <Boolean>
             * }
             */
        initialize: function() {
            PopTartView.prototype.initialize.apply(this, arguments);
        },
        render: function() {
            this.el.innerHTML = PopTartView.prototype.template_menu;
            
            if (!this.collection.reports.size() &&
                !this.collection.dashboards.size() &&
                !this.collection.alerts.size() &&
                !this.collection.datamodels.size()) {
                this.$el.append('<div class="no-results">' + _("No Results for this search.").t() + '</div>');
            }
            var currentApp = this.model.application.get('app'),
                alternateApp = currentApp !== 'system' ? currentApp : 'search';
            var searchApp = _.find(this.collection.apps.models, function(app) {
                return app.entry.get('name') === 'search';
            });
            if (alternateApp === 'search' && searchApp && searchApp.entry.content.get("disabled")) {
                this.collection.apps.sortWithString(this.model.userPref.entry.content.get('appOrder'));
                alternateApp = this.collection.apps.models[0].entry.get('name');
            }
            
            // Report Results
            if (this.collection.reports.size()) {
                this.children.reportResults = new ReportResults({
                    collection: {
                        reports: this.collection.reports,
                        apps: this.collection.apps
                    },
                    model: {
                        application: this.model.application,
                        state: this.model.state,
                        rawSearch: this.model.rawSearch
                    },
                    alternateApp: alternateApp
                });
                this.$el.append(this.children.reportResults.render().el);
            }
            
            // Dashboard Results
            if ( this.collection.dashboards.size()) {
                this.children.dashboardResults = new DashboardResults({
                    collection: {
                        dashboards: this.collection.dashboards,
                        apps: this.collection.apps
                    },
                    model: {
                        application: this.model.application,
                        state: this.model.state,
                        rawSearch: this.model.rawSearch
                    },
                    alternateApp: alternateApp
                });
                this.$el.append(this.children.dashboardResults.render().el);
            }
                            
            // Alert Results
            if (this.collection.alerts.size()) {
                this.children.alertResults = new AlertResults({
                    collection: {
                        alerts: this.collection.alerts,
                        apps: this.collection.apps
                    },
                    model: {
                        application: this.model.application,
                        state: this.model.state,
                        rawSearch: this.model.rawSearch
                    },
                    alternateApp: alternateApp
                });
                this.$el.append(this.children.alertResults.render().el);
            }
            
            // Data Model Results
            if (this.collection.datamodels.size()) {
                this.children.dataModelResults = new DataModelResults({
                    collection: {
                        datamodels: this.collection.datamodels,
                        apps: this.collection.apps
                    },
                    model: {
                        application: this.model.application,
                        state: this.model.state,
                        rawSearch: this.model.rawSearch
                    },
                    alternateApp: alternateApp
                });
                this.$el.append(this.children.dataModelResults.render().el);
            }
            
            // Open "keyword" in new search
            var searchLink = route.search(
                    this.model.application.get('root'),
                    this.model.application.get('locale'),
                    'search',
                    {data: {q: this.model.rawSearch.get('rawSearch')}}
                );

            var html = this.compiledTemplate({
                _: _,
                splunkUtils: splunkUtils,
                searchLink: searchLink,
                rawSearch: this.model.rawSearch.get('rawSearch')
            });
            this.$el.append(html);

            return this;
        },
        template: '\
        <ul><li>\
            <a class="primary-link search-link" href="<%- searchLink %>">\
                <i class="icon-search-thin findbar-results-icon"></i>\
                <%- splunkUtils.sprintf(_("Open %s in search").t(), rawSearch) %>\
            </a>\
            <a class="secondary-link search-link" href="<%- searchLink %>" target="_blank">\
                <i class="icon-external"></i>\
            </a>\
        </li></ul>\
        '
    });
});
define('views/shared/WaitSpinner',['underscore', 'module', 'views/Base'], function(_, module, BaseView, splunkUtil) {
    
    
    return BaseView.extend({
        moduleId: module.id,
        tagName: 'div',
        initialize: function(){
            var defaults = {
              size: 'small',
              color: 'gray',
              frameWidth: 14, //px
              frameCount: 8,
              fps: 10
            };
            
            _.defaults(this.options, defaults);
        
            BaseView.prototype.initialize.apply(this, arguments);
            
            this.$el.addClass('spinner-' + this.options.size + '-' + this.options.color);
            this.frame=0;
        },
        stop:  function() {
            this.active=false;
            this.interval && window.clearInterval(this.interval);
            return this;
        },
        start:  function() {
            this.active=true;
            this.interval && window.clearInterval(this.interval);
            this.interval=setInterval(this.step.bind(this), 1000/this.options.fps);
            return this;
        },
        step:  function() {
            this.$el.css('backgroundPosition', '-' + (this.frame * this.options.frameWidth) + 'px top ');
            
            this.frame++;
            this.frame = this.frame == this.options.frameCount ? 0 : this.frame; 
        
            return this;
        },
        remove: function() {
            this.stop();
            BaseView.prototype.remove.apply(this, arguments);
        },
        render: function() {
            return this;
        }
    });
});

define(
'views/shared/splunkbar/find/ProgressSpinner',[
    'underscore',
    'module',
    'views/shared/WaitSpinner',
    'splunk.util'],
function(
    _,
    module,
    SpinnerView,
    splunkutil
){
    return SpinnerView.extend({
        className: 'center',
        moduleId: module.id,
        initialize: function() {
           SpinnerView.prototype.initialize.apply(this, arguments);
        },
        render: function() {
            this.$el.show()['addClass']('active');
            this.start();
            this.spinning = true;
            return this;
        }
    });
});

define(
'views/shared/splunkbar/find/FindProgress',[
    'underscore',
    'jquery',
    'module',
    'views/shared/PopTart',
    'views/shared/splunkbar/find/ProgressSpinner',
    'uri/route',
    'splunk.util'
],
function(
    _,
    $,
    module,
    PopTartView,
    ProgressSpinner,
    route,
    splunkUtils
){
    return PopTartView.extend({
        moduleId: module.id,
        className: 'dropdown-menu',
        initialize: function() {
            PopTartView.prototype.initialize.apply(this, arguments);
        },
        render: function() {
            this.el.innerHTML = PopTartView.prototype.template_menu;
            
            // Open "keyword" in new search
            var searchLink = route.search(
                    this.model.application.get('root'),
                    this.model.application.get('locale'),
                    'search',
                    {data: {q: this.model.state.get('rawSearch')}}
                );
                
            var html = this.compiledTemplate({
                _: _,
                splunkUtils: splunkUtils,
                searchLink: searchLink,
                rawSearch: this.model.state.get('rawSearch')
            });
            this.$el.append(html);

            this.children.spinner = new ProgressSpinner();
            this.$('.findbar-results-spinner').append(this.children.spinner.render().el);
            
            return this;
        },
        template: '\
        <div class="findbar-results-spinner"></div>\
        <ul><li>\
            <a class="primary-link search-link" href="<%- searchLink %>">\
                <i class="icon-search-thin findbar-results-icon"></i>\
                <%- splunkUtils.sprintf(_("Open %s in search").t(), rawSearch) %>\
            </a>\
            <a class="secondary-link search-link" href="<%- searchLink %>" target="_blank">\
                <i class="icon-external"></i>\
            </a>\
        </li></ul>\
        '
    });
});
define(
    'models/services/data/ui/View',[
     'jquery',
     'splunk.util',
     'models/SplunkDBase',
     'underscore',
     'util/xml'
    ],
    function($, splunkutil, SplunkDBaseModel, _, XML) {
        return SplunkDBaseModel.extend({
            url: "data/ui/views",
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
            },
            isXML: function() {
                return this.entry.content.get('eai:type') === 'views';
            },
            isHTML: function() {
                return this.entry.content.get('eai:type') === 'html';
            },
            getViewType: function() {
                var typeLabel = 'n/a';
                if(this.isXML()) {
                    typeLabel = 'XML';
                } else if(this.isHTML()) {
                    typeLabel = 'HTML';
                }
                return typeLabel;
            },
            getLabel: function() {
                return this.entry.content.get('label') || this.entry.get('name');
            },
            isRoot: function(nodeName) {
                if(!this.isXML()) {
                    return false;
                }
                var $xmlDoc = this.get$XML();
                var rootNode = XML.root($xmlDoc)[0];
                if (!rootNode) { 
                    return false;
                }
                function lower(s){ return (s && s.toLowerCase()) || s; }
                return arguments.length > 1 ?
                        _.any(arguments, function(nodeName){ return lower(rootNode.nodeName) === lower(nodeName); }) :
                        lower(rootNode.nodeName) === lower(nodeName);
            },
            isAdvanced: function(visibility) {
                var $xmlDoc, $root, type, isVisible;
                if (!this.isRoot('view')) { 
                    return false; 
                }
                if (visibility) {
                    $xmlDoc = this.get$XML();
                    $root = XML.root($xmlDoc);
                    type = $root.attr('type');
                    isVisible = $root.attr('isVisible');
                    if (type && type=='html') {
                        return false;
                    }
                    if (isVisible && !splunkutil.normalizeBoolean(isVisible)){
                        return false;
                    }
                }
                return true;
            },
            get$XML: function() {
                var data = (this.isXML() && this.entry.content.get('eai:data')) || '<dashboard/>';
                var xmlDoc;
                try {
                    xmlDoc = XML.parse(data);
                } catch (e) {
                    xmlDoc = XML.parse('<dashboard/>');
                }
                // SPL-68158 Prevent any kind of XSS when modifying XML using jQuery
                xmlDoc.find('script').remove();
                return xmlDoc;
            },
            isDashboard: function() {
                return this.isRoot('dashboard');
            },
            isForm: function() {
                return this.isRoot('form');
            },
            isSimpleXML: function() {
                return this.isXML() && this.isRoot('dashboard', 'form');
            },
            isValidXML: function() {
                if (!this.isXML()) {
                    return false;
                }
                try {
                    XML.parse(this.entry.content.get('eai:data'));
                } catch (e) {
                    return false;
                }
                return true;
            }
        });
    }
);

define(
    'collections/services/data/ui/Views',[
        'jquery',
        'backbone',
        'models/services/data/ui/View',
        'collections/SplunkDsBase',
        'splunk.util'
    ],
    function($, Backbone, ViewModel, SplunkDsBaseCollection, splunk_utils) {
        return SplunkDsBaseCollection.extend({
            url: 'data/ui/views',
            model: ViewModel,
            initialize: function() {
                SplunkDsBaseCollection.prototype.initialize.apply(this, arguments);
            }
        });
    }
);

define(
    'models/search/Dashboard',[
        'jquery',
        'underscore',
        'splunk.util',
        'models/services/data/ui/View',
        'util/xml',
        'util/splunkd_utils',
        'models/Base'
   ],
   function($, _, splunkutil, ViewModel, XML, splunkDUtils, BaseModel) {
        var HTML_PANEL_TYPE = 'html',
            CHART_PANEL_TYPE = 'chart',
            EVENT_PANEL_TYPE = 'event',
            SINGLE_PANEL_TYPE = 'single',
            MAP_PANEL_TYPE = 'map',
            TABLE_PANEL_TYPE = 'table',
            NON_HTML_PANEL_TYPES = [CHART_PANEL_TYPE, EVENT_PANEL_TYPE, SINGLE_PANEL_TYPE, MAP_PANEL_TYPE, TABLE_PANEL_TYPE];

        /**
         * Transient Dashboard Metadata Model
         *
         * Attributes:
         * - label
         * - description
         *
         */
        var DashboardMetadata = BaseModel.extend({
            constructor: function(dashboard) {
                this._dash = dashboard;
                BaseModel.prototype.constructor.call(this);
            },
            //validation: {},
            apply: function(){
                this._dash._applyMetadata(this.toJSON());
            },
            save: function() {
                if(arguments.length) {
                    this.set.apply(this, arguments);
                }
                this._dash._applyMetadata(this.toJSON());
                return this._dash.save.apply(this._dash, arguments);
            },
            fetch: function() {
                var m = this._dash._extractMetadata();
                this.set(m);
                var dfd = $.Deferred();
                dfd.resolve(this);
                return dfd;
            }
        });

        var Dashboard = ViewModel.extend({
            /**
             * model {Object} 
             * options {
             *     indent: <boolean> (default: true)
             * }
             */
            initialize: function(model, options) {
                ViewModel.prototype.initialize.apply(this, arguments);
                this.indent = (options || {}).indent !== false;
            },
            initializeAssociated: function() {
                ViewModel.prototype.initializeAssociated.apply(this, arguments);
                var meta = this.meta = this.meta || new DashboardMetadata(this);
                this.entry.content.on('change:eai:data', function(){
                    meta.fetch();
                }, this);
                meta.fetch();
            },
            associatedOff: function(e, cb, ctx) {
                ViewModel.prototype.associatedOff.apply(this, arguments);
                this.meta.off(e, cb, ctx);
            },
            set$XML: function($xml) {
                this.setXML(XML.serializeDashboardXML($xml, this.indent));
            },
            setXML: function(raw) {
                this.entry.content.set('eai:data', raw);
                this.entry.content.set('eai:type', 'views');
            },
            setHTML: function(raw) {
                this.entry.content.set('eai:data', raw);
                this.entry.content.set('eai:type', 'html');
            },
            _extractMetadata: function() {
                var isXML = this.isXML(), $xml = isXML ? this.get$XML() : null;
                var label = this.entry.content.get('label') || this.entry.get('name');
                if (label != null) {
                    label = label.trim();
                }
                var description = (isXML && XML.root($xml).children('description:first').text()) || '';
                return {
                    label: label,
                    description: description.trim()
                };
            },
            _applyMetadata: function(metadata) {
                var $xml = this.get$XML();
                var root = XML.root($xml);
                var $label = root.children('label');
                var $description = root.children('description');

                if(!$label.length && metadata.label) {
                    $label = XML.$node('<label/>');
                    XML.root($xml).prepend($label);
                }
                if(!$description.length && metadata.description) {
                    $description = XML.$node('<description/>');
                    XML.inject({
                        node: $description,
                        where: 'after',
                        container: root,
                        selectors: ['label'],
                        fallback: 'prepend'
                    });
                }
                if (metadata.label) {
                    $label.text(metadata.label || '');
                    this.entry.content.set("label", metadata.label);
                }
                if (metadata.description) {
                    $description.text(metadata.description || '');
                }

                this.set$XML($xml);
            },
            getLabel: function() {
                var result = this.meta.get('label');
                return result === undefined ? "" : result;
            },
            setLabel: function(value) {
                this.setLabelAndDescription(value, undefined);
            },       
            getDescription: function() {
                return this.meta.get('description');
            },
            setDescription: function(value) {
                this.setLabelAndDescription(undefined, value);
            },
            setLabelAndDescription: function(label, description) {
                this._applyMetadata({ label: label, description: description });
            },
            get$Rows: function() {
                return XML.root(this.get$XML()).children('row');
            },
            createPrivateUserClone: function(owner, app, options) {
                options = options || {};
                var clone = new Dashboard();
                clone.setXML(this.entry.content.get('eai:data'));
                clone.meta.set(this.meta.toJSON());
                var data = {
                    sharing: splunkDUtils.USER, 
                    owner: owner, 
                    app: app
                }; 
                clone.entry.content.set('name', 'dashboard'); 
                clone.save({}, {data: data, 
                    success: function(model, response) {
                        if (options.deferred) {
                            options.deferred.resolve();
                        }
                    }.bind(this)
                });
                return clone;
            },
            appendNewPanel: function(panelType, properties) {
                var isNonHTML = (_.indexOf(NON_HTML_PANEL_TYPES, panelType) != -1),
                    isHTML = (panelType === HTML_PANEL_TYPE),
                    panel, $xml;

                if (isNonHTML || isHTML) {
                    if (isNonHTML) {
                        panel = _.template(this.nonHTMLPanelTemplate, {
                            panelType: panelType,
                            properties: properties
                        });
                    } else {
                        panel = _.template(this.HTMLPanelTemplate, {
                            properties: properties
                        });
                    }

                    $xml = this.get$XML();
                    var rowNode = XML.$node('<row/>');
                    var panelNode = XML.$node('<panel/>').appendTo(rowNode);
                    $(panelNode).append(XML.$node(panel));
                    $xml.find(':eq(0)').append(rowNode);
                    this.set$XML($xml);
                }
            },
            nonHTMLPanelTemplate: '\
                <<%- panelType %>>\
                    <% if (properties.title) { %>\
                        <title><%- properties.title %></title>\
                    <% } %>\
                    <% if (properties.searchString) { %>\
                        <search>\
                            <query><%- properties.searchString %></query>\
                        <% if (properties.earliestTime !== undefined) { %>\
                            <earliest><%- properties.earliestTime %></earliest>\
                        <% } %>\
                        <% if (properties.latestTime !== undefined) { %>\
                            <latest><%- properties.latestTime %></latest>\
                        <% } %>\
                        </search>\
                    <% } else if (properties.searchName) { %>\
                        <search ref="<%- properties.searchName %>" />\
                    <% } %>\
                    <% if (properties.fields) { %>\
                        <fields><%- properties.fields %></fields>\
                    <% } %>\
                    <% _.each(properties.options, function(value, key) { %>\
                        <option name="<%- key %>"><%- value %></option>\
                    <% }) %>\
                </<%- panelType %>>\
            ',
            HTMLPanelTemplate: '<html><%= properties.html %></html>'
        },
        {
            reportToPropertiesFromPanelType: function(panelType, reportModel, isInline){
                var isNonHTML = (_.indexOf(NON_HTML_PANEL_TYPES, panelType) != -1),
                properties = {},
                search, searchName, earliestTime, latestTime;

                if (isNonHTML){
                    if (!reportModel.isNew() && !isInline){
                        properties.searchName = reportModel.entry.get('name');
                    } else {
                        properties.searchString = reportModel.entry.content.get("search");

                        earliestTime = reportModel.entry.content.get("dispatch.earliest_time");
                        if (earliestTime !== undefined) {
                            properties.earliestTime = earliestTime;
                        }

                        latestTime = reportModel.entry.content.get("dispatch.latest_time");
                        if (latestTime !== undefined) {
                            properties.latestTime = latestTime;
                        }
                        
                        if (panelType === CHART_PANEL_TYPE) {
                            properties.options = reportModel.entry.content.filterByWildcards(
                                ["^display\\.visualizations\\.charting\\..*"],
                                {
                                    strip:'display.visualizations.'
                                }
                            );
                        } else if (panelType === SINGLE_PANEL_TYPE) {
                            properties.options = reportModel.entry.content.filterByWildcards(
                                ["^display\\.visualizations\\.singlevalue\\..*"],
                                {
                                    strip:'display.visualizations.singlevalue.'
                                }
                            );
                        } else if (panelType === MAP_PANEL_TYPE) {
                            properties.options = reportModel.entry.content.filterByWildcards(
                                ["^display\\.visualizations\\.mapping\\..*"],
                                {
                                    strip:'display.visualizations.'
                                }
                            );
                            // Remove the 'mapping.data.bounds' property which is not intended to be persisted (SPL-79034).
                            delete properties.options['mapping.data.bounds'];
                        }
                    }
                } else {
                    throw("Unsupported panel type");
                }

                return properties;
            }
        });

        // break the shared reference to Entry
        Dashboard.Entry = Dashboard.Entry.extend({});
        // now we can safely extend Entry.Content
        var Content = Dashboard.Entry.Content;
        Dashboard.Entry.Content = Content.extend({
            initialize: function() {
                Content.prototype.initialize.apply(this, arguments);
            },
            validate: function(attributes) {
                var eaiData = attributes["eai:data"],
                    xml, dashboard;

                if (eaiData != void(0)){
                    xml = $.parseXML(eaiData);

                    dashboard = xml.firstChild;
                    if (dashboard.nodeName !== 'dashboard' && dashboard.nodeName !== 'form'){
                        return {
                            'eai:data': "You must declare a dashboard node."
                        };
                    }
                }
            }
        });
        
        return Dashboard;
    }
);

define(
    'collections/shared/Dashboards',[
        'jquery',
        'underscore',
        'backbone',
        'collections/services/data/ui/Views',
        'models/search/Dashboard'
    ],
    function($, _, Backbone, ViewsCollection, DashboardModel) {
        return ViewsCollection.extend({
            model: DashboardModel,
            initialize: function() {
                ViewsCollection.prototype.initialize.apply(this, arguments);
            },
            sync: function(method, collection, options) {
                options = options || {};
                options.data = options.data || {};
                var baseSearch = '(isDashboard=1 AND isVisible=1)';
                if (!options.data.search) {
                    options.data.search = baseSearch;
                } else {
                    options.data.search = '(' + baseSearch + ' AND ' + options.data.search + ')';
                }
                return ViewsCollection.prototype.sync.call(this, method, collection, options);
            },
            fetchSafe: function(options) {
                var defaults = { 
                    data: {
                        sort_dir: 'asc',
                        sort_key: 'label',
                        sort_mode: 'natural',
                        count: 1000,
                        digest: '1'
                    }
                };

                $.extend(true, defaults, options || {});
                
                var eaiApp = defaults.data["eai:acl.app"] || '*';
                delete defaults.data["eai:acl.app"];

                var baseSearch = '(eai:acl.can_write="1" AND (NOT name="pdf_activity") AND eai:acl.app="' + eaiApp  + '")';
                if (options && options.data && options.data.search) {
                    defaults.data.search = '(' + baseSearch + ' AND ' + options.data.search + ')';
                } else {
                    defaults.data.search = baseSearch;
                }
                return this.fetch(defaults);
            }
        });
    }
);

define(
    'models/services/saved/Search',[
		'jquery',
		'backbone',
		'util/splunkd_utils',
		'models/Base',
		'models/SplunkDBase',
		'underscore',
		'splunk.util'
    ],
    function($, Backbone, splunkd_utils, BaseModel, SplunkDBaseModel, _, splunkUtil) {
        var Embed = BaseModel.extend({
            initialize: function(attributes, options) {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            sync: function(method, model, options) {
                var defaults = {
                    data: {
                        output_mode: 'json'
                    }
                };
                switch(method) {
                    case 'update':
                        defaults.processData = true;
                        defaults.type = 'POST';
                        defaults.url = splunkd_utils.fullpath(model.id);
                        $.extend(true, defaults, options);
                        break;
                    default:
                        throw new Error('invalid method: ' + method);
                }
                return Backbone.sync.call(this, method, model, defaults);
            }
        });
        return SplunkDBaseModel.extend({
            url: 'saved/searches',
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
                this.on('change:id', function() {
                    var shareLink,
                        unshareLink;
                    if (this.id) {
                        shareLink = this.id + '/embed';
                        unshareLink = this.id + '/unembed';
                    }
                    this.embed.set('id', shareLink);
                    this.unembed.set('id', unshareLink); 
                }, this);
                this.embed.on('sync', function() {
                    this.safeFetch();
                }, this);
                this.unembed.on('sync', function() {
                    this.safeFetch();
                }, this);
            },
            initializeAssociated: function() {
                SplunkDBaseModel.prototype.initializeAssociated.apply(this, arguments);
                this.embed = this.embed || new this.constructor.Embed();
                this.associated.embed = this.embed;
                this.unembed = this.unembed || new this.constructor.Embed();
                this.associated.unembed = this.unembed;
            },
            parse: function(response, options) {
                options = options || {};
                response = this.migrateAttributes(response, options);
                _.extend(options, {skipClone: true});
                this.initializeAssociated();
                if (splunkd_utils.isExistingEntity(response)) { 
                    var id = response.entry[0].links.alternate;
                    this.embed.set('id', id + '/embed');
                    this.unembed.set('id', id + '/unembed'); 
                }
                return SplunkDBaseModel.prototype.parse.call(this, response, options);
            },
            setFromSplunkD: function(payload, options) {
                options = options || {};
                payload = this.migrateAttributes(payload, options);
                _.extend(options, {skipClone: true});
            	if (splunkd_utils.isExistingEntity(payload)) {
                    var id = payload.entry[0].links.alternate;  
                    this.embed.set('id', id + '/embed');
                    this.unembed.set('id', id + '/unembed');
                }
                return SplunkDBaseModel.prototype.setFromSplunkD.call(this, payload, options);
            },
            migrateAttributes: function(response, options) {
                options = options || {};
                if (!options.skipClone) {
                    response = $.extend(true, {}, response);
                }
                
                if (response && response.entry && response.entry[0].content) {
                    var content = response.entry[0].content,
                        format = content['action.email.format'];

                    if (_.indexOf(['html', 'plain', 'pdf'], format) != -1) {
                        // for backwards compatibility for SPL-79585
                        response.entry[0].content['action.email.format'] = 'table';
                        if (format !== 'pdf') {
                            response.entry[0].content['action.email.content_type'] = format;
                        }
                    } else if (format ==='csv' && splunkUtil.normalizeBoolean(content['action.email.sendresults']) &&
                            !(splunkUtil.normalizeBoolean(content['action.email.sendcsv']) ||
                                splunkUtil.normalizeBoolean(content['action.email.sendpdf']) ||
                                splunkUtil.normalizeBoolean(content['action.email.inline']))) {
                        // for backwards compatibility for SPL-79561
                        response.entry[0].content['action.email.sendcsv'] = '1';
                    }
                }
                return response;
            }
        }, 
        {
            Embed: Embed
        });
    }
);

define(
    'models/services/data/ui/Viewstate',[
        'underscore',
        'models/SplunkDBase',
        'util/splunkd_utils',
        'splunk.util'
    ],
    function(
        _,
        BaseModel,
        splunkd_utils,
        splunkUtil
    ) {
        return BaseModel.extend({
            url: 'data/ui/viewstates',
            initialize: function() {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            getFlattenedAndDedupedModules: function() {
                var content = this.entry.content.toJSON(),
                    flattenedModules = {};
                
                delete content['eai:acl'];
                delete content['eai:appName'];
                delete content['eai:userName'];
                delete content['disabled'];
            
                //flatten the contents
                _.each(content, function(value, module){
                    var keySplit = module.split("."),
                        key = keySplit[0].split("_")[0],
                        child = keySplit[1];
                    
                    if (!flattenedModules[key]) {
                        flattenedModules[key] = {};
                    }
                    
                    if (!flattenedModules[key][child]) {
                        flattenedModules[key][child] = value;
                    }
                });

                return flattenedModules;
            },
            convertToReportPoperties: function() {
                var flattenedModules = this.getFlattenedAndDedupedModules(),
                    props = {},
                    eventsTabSelected, statsTabSelected, vizTabSelected,
                    buttonSwitcher, count, softWrap, segmentation, fields, rowNumbers;
                
                /*
                 * AxisScaleFormatter.default => display.visualizations.charting.axisY.scale
                 * ChartTitleFormatter.default => NOT IMPLEMENTED
                 * ChartTypeFormatter.default => display.visualizations.charting.chart
                 * FancyChartTypeFormatter.default => display.visualizations.charting.chart
                 * LegendFormatter.default => display.visualizations.charting.legend.placement
                 * LineMarkerFormatter.default => display.visualizations.charting.axisX.markers (MISSING)
                 * NullValueFormatter.default => display.visualizations.charting.chart.nullValueMode
                 * SplitModeFormatter.default => NOT IMPLEMENTED
                 * StackModeFormatter.default => display.visualizations.charting.chart.stackMode
                 * XAxisTitleFormatter.default => display.visualizations.charting.axisTitleX.text
                 * YAxisRangeMaximumFormatter.default => display.visualizations.charting.axisY.maximumNumber
                 * YAxisRangeMinimumFormatter.default => display.visualizations.charting.axisY.minimumNumber
                 * YAxisTitleFormatter.default => display.visualizations.charting.axisTitleY.text
                 * FlashChart.height => display.visualizations.chartHeight
                 * FlashTimeline.height => NOT IMPLEMENTED
                 * FlashTimeline.minimized => display.page.search.timeline.format = [hidden|compact|full] (MUST REMAP FROM BOOLEAN)
                 * FlashWrapper.height => NOT IMPLEMENTED
                 * JSChart.height => display.visualizations.chartHeight
                 * Count.default OR Count.count => display.prefs.statistics.count OR display.prefs.events.count
                 * DataOverlay.default OR DataOverlay.dataOverlayMode => display.statistics.overlay
                 * HiddenSoftWrap.enable => display.events.list.wrap OR display.events.table.wrap OR display.statistics.wrap
                 * SoftWrap.enable => display.events.list.wrap OR display.events.table.wrap OR display.statistics.wrap
                 * MaxLines.default OR MaxLines.maxLines => display.events.maxLines
                 * RowNumbers.default OR RowNumbers.displayRowNumbers => display.events.rowNumbers OR display.statistics.rowNumbers
                 * Segmentation.default OR Segmentation.segmentation => display.events.raw.drilldown OR display.events.list.drilldown OR display.statistics.drilldown
                 * FieldPicker.fields => display.events.fields
                 * FieldPicker.sidebarDisplay => display.page.search.showFields
                 * ButtonSwitcher.selected => display.general.type REQUIRES REMAPPING
                 * 
                 * 
                Possible values from flashtimeline:
                |    ButtonSwitcher_0_9_0.selected =  "splIcon-results-table"
                |    ChartTypeFormatter_0_14_0.default =  "column"
                |    Count_0_8_1.default =  "50"
                |    DataOverlay_0_14_0.dataOverlayMode =  "none"
                |    DataOverlay_0_14_0.default =  "heatmap"
                |    FieldPicker_0_6_0.fields =  "host,sourcetype,source"
                |    FieldPicker_0_6_0.sidebarDisplay =  "True"
                |    FlashTimeline_0_4_1.height =  "95px"
                |    FlashTimeline_0_4_1.minimized =  "False"
                |    JSChart_0_14_1.height =  "300px"
                |    LegendFormatter_0_20_0.default =  "top"
                |    MaxLines_0_14_0.default =  "10"
                |    MaxLines_0_14_0.maxLines =  "10"
                |    NullValueFormatter_0_19_0.default =  "gaps"
                |    RowNumbers_0_13_0.default =  "true"
                |    RowNumbers_0_13_0.displayRowNumbers =  "true"
                |    RowNumbers_1_13_0.default =  "true"
                |    RowNumbers_1_13_0.displayRowNumbers =  "true"
                |    Segmentation_0_15_0.default =  "full"
                |    Segmentation_0_15_0.segmentation =  "full"
                |    SoftWrap_0_12_0.enable =  "True"
                |    SplitModeFormatter_0_18_0.default =  "false"
                |    StackModeFormatter_0_17_0.default =  "default"
                
                From Report Builder:
                |    ChartTypeFormatter_0_4_0.default =  "column"
                |    DataOverlay_0_5_0.dataOverlayMode =  "none"
                |    DataOverlay_0_5_0.default =  "none"
                |    JSChart_0_4_1.height =  "300px"
                |    LegendFormatter_0_10_0.default =  "right"
                |    LineMarkerFormatter_0_7_0.default =  "false"
                |    NullValueFormatter_0_9_0.default =  "gaps"
                |    SplitModeFormatter_0_8_0.default =  "false"
                |    StackModeFormatter_0_7_0.default =  "default"
                
                From Advanced Charting:
                |    ChartTypeFormatter_0_7_0.default =  "line"
                |    JSChart_0_7_1.height =  "300px"
                |    LegendFormatter_0_13_0.default =  "right"
                |    LineMarkerFormatter_0_10_0.default =  "false"
                |    NullValueFormatter_0_12_0.default =  "gaps"
                |    SplitModeFormatter_0_11_0.default =  "false"
                |    StackModeFormatter_0_10_0.default =  "default"
                 * 
                 */
                
                if (flattenedModules['ButtonSwitcher']) {
                    buttonSwitcher = flattenedModules['ButtonSwitcher']['selected'];
                    if (buttonSwitcher === "splIcon-results-table") {
                        props['display.general.type'] = 'statistics';
                        statsTabSelected = true;
                    } else if (buttonSwitcher === "splIcon-events-list") {
                        props['display.general.type'] = 'events';
                        eventsTabSelected = true;
                    }
                } else {
                    props['display.general.type'] = 'visualizations';
                    vizTabSelected = true;
                }
                
                if (flattenedModules['AxisScaleFormatter']) {
                    props['display.visualizations.charting.axisY.scale'] = flattenedModules['AxisScaleFormatter']['default'];
                }
                if (flattenedModules['FancyChartTypeFormatter']) {
                    props['display.visualizations.type'] = 'charting';
                    props['display.visualizations.charting.chart'] = flattenedModules['FancyChartTypeFormatter']['default'];
                }
                if (flattenedModules['ChartTypeFormatter']) {
                    //unfancy wins
                    props['display.visualizations.type'] = 'charting';
                    props['display.visualizations.charting.chart'] = flattenedModules['ChartTypeFormatter']['default'];
                }
                if (flattenedModules['LegendFormatter']) {
                    props['display.visualizations.charting.legend.placement'] = flattenedModules['LegendFormatter']['default'];
                }
                if (flattenedModules['LineMarkerFormatter']) {
                    props['display.visualizations.charting.axisX.markers'] = splunkd_utils.normalizeBooleanTo01String(flattenedModules['LineMarkerFormatter']['default']);
                }
                if (flattenedModules['NullValueFormatter']) {
                    props['display.visualizations.charting.chart.nullValueMode'] = flattenedModules['NullValueFormatter']['default'];
                }
                if (flattenedModules['StackModeFormatter']) {
                    props['display.visualizations.charting.chart.stackMode'] = flattenedModules['StackModeFormatter']['default'];
                }
                if (flattenedModules['XAxisTitleFormatter']) {
                    props['display.visualizations.charting.axisTitleX.text'] = flattenedModules['XAxisTitleFormatter']['default'];
                }
                if (flattenedModules['YAxisRangeMaximumFormatter']) {
                    props['display.visualizations.charting.axisY.maximumNumber'] = flattenedModules['YAxisRangeMaximumFormatter']['default'];
                }
                if (flattenedModules['YAxisRangeMinimumFormatter']) {
                    props['display.visualizations.charting.axisY.minimumNumber'] = flattenedModules['YAxisRangeMinimumFormatter']['default'];
                }
                if (flattenedModules['YAxisRangeMinimumFormatter']) {
                    props['display.visualizations.charting.axisY.minimumNumber'] = flattenedModules['YAxisRangeMinimumFormatter']['default'];
                }
                if (flattenedModules['YAxisTitleFormatter']) {
                    props['display.visualizations.charting.axisTitleY.text'] = flattenedModules['YAxisTitleFormatter']['default'];
                }
                if (flattenedModules['FlashChart']) {
                    props['display.visualizations.chartHeight'] = (flattenedModules['FlashChart']['height']).replace('px', '');
                }
                if (flattenedModules['JSChart']) {
                    //The viewstate will have either FlashChart OR JSChart
                    props['display.visualizations.chartHeight'] = (flattenedModules['JSChart']['height']).replace('px', '');
                }                
                if (flattenedModules['FlashTimeline']) {
                    if (splunkUtil.normalizeBoolean(flattenedModules['FlashTimeline']['minimized'])) {
                        props['display.page.search.timeline.format'] = 'compact';
                    } else {
                        props['display.page.search.timeline.format'] = 'hidden';
                    }
                }
                if (flattenedModules['Count']) {
                    count = flattenedModules['Count']['default'] || flattenedModules['Count']['count'];
                    
                    if (statsTabSelected || vizTabSelected) {
                        props['display.prefs.statistics.count'] = count;
                    } else {
                        props['display.prefs.events.count'] = count;
                    }    
                }
                if (flattenedModules['DataOverlay']) {
                    props['display.statistics.overlay'] = flattenedModules['DataOverlay']['default'] || flattenedModules['DataOverlay']['dataOverlayMode'];
                }
                if (flattenedModules['HiddenSoftWrap']) {
                    softWrap = splunkd_utils.normalizeBooleanTo01String(flattenedModules['HiddenSoftWrap']['enable']);
                    
                    if (statsTabSelected || vizTabSelected) {
                        props['display.statistics.wrap'] = softWrap;
                    } else {
                        props['display.events.list.wrap'] = softWrap;
                        props['display.events.table.wrap'] = softWrap;                       
                    }
                }
                if (flattenedModules['SoftWrap']) {
                    //non hidden wins
                    softWrap = splunkd_utils.normalizeBooleanTo01String(flattenedModules['SoftWrap']['enable']);
                    
                    if (statsTabSelected || vizTabSelected) {
                        props['display.statistics.wrap'] = softWrap;
                    } else {
                        props['display.events.list.wrap'] = softWrap;
                        props['display.events.table.wrap'] = softWrap;                        
                    }
                }
                if (flattenedModules['MaxLines']) {
                    props['display.events.maxLines'] = flattenedModules['MaxLines']['default'] || flattenedModules['MaxLines']['maxLines'];
                }
                if (flattenedModules['RowNumbers']) {
                    rowNumbers = flattenedModules['RowNumbers']['default'] || flattenedModules['RowNumbers']['displayRowNumbers'];
                    rowNumbers = splunkd_utils.normalizeBooleanTo01String(rowNumbers);
                    
                    if (statsTabSelected || vizTabSelected) {
                        props['display.statistics.rowNumbers'] = rowNumbers;
                    } else {
                        props['display.events.rowNumbers'] = rowNumbers;
                    }
                }
                if (flattenedModules['Segmentation']) {
                    segmentation = flattenedModules['Segmentation']['default'] || flattenedModules['Segmentation']['segmentation'];
                    
                    if (statsTabSelected || vizTabSelected) {
                        if (['row', 'cell', 'none'].indexOf(segmentation) > -1) {
                            props['display.statistics.drilldown'] = segmentation;
                        }
                    } else {
                        if (['inner', 'outer', 'full', 'none'].indexOf(segmentation) > -1) {
                            props['display.events.list.drilldown'] = segmentation;
                            props['display.events.raw.drilldown'] = segmentation;
                        }
                    }
                }
                if (flattenedModules['FieldPicker']) {
                    //example: display.events.fields":"[\"host\",\"source\",\"sourcetype\"]"
                    fields = flattenedModules['FieldPicker']['fields'].split(',');
                    props['display.events.fields'] = '[\"' + fields.join('\",\"') + '\"]';
                    props['display.page.search.showFields'] = splunkd_utils.normalizeBooleanTo01String(flattenedModules['FieldPicker']['sidebarDisplay']);
                }
                
                return props;
            }
        });
    }
);
define(
    'models/services/search/jobs/Control',[
         'jquery',
         'backbone',
         'models/Base',
         'util/splunkd_utils'
     ],
     function($, Backbone, BaseModel, splunkDUtils) {
        return BaseModel.extend({
            initialize: function(attributes, options) {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            sync: function(method, model, options) {
                var defaults = {
                    data: {
                        output_mode: 'json'
                    }
                };
                switch(method) {
                case 'update':
                    defaults.processData = true;
                    defaults.type = 'POST';
                    defaults.url = splunkDUtils.fullpath(model.id);
                    $.extend(true, defaults, options);
                    break;
                default:
                    throw new Error('invalid method: ' + method);
                }
                return Backbone.sync.call(this, method, model, defaults);
            }
        });
    }
);

// TODO: a lot of repeated code here and SplunkDBaseV2, consider making this a subclass of SplunkDBaseV2

define(
    'models/services/search/Job',[
        'jquery',
        'underscore',
        'backbone',
        'models/Base',
        'models/config',
        'models/ACLReadOnly',
        'models/services/ACL',
        'models/services/search/jobs/Control',
        'util/splunkd_utils',
        'util/general_utils',
        'splunk.util',
        'util/console'
    ],
    function($, _, Backbone, BaseModel, configModel, ACLReadOnlyModel, ACLModel, ControlModel, splunkd_utils, general_utils, splunkUtil, console) {

        //private sync CRUD methods
        var syncCreate = function(model, options){
            var rootOptions = options,
                rootModel = model,
                deferredResponse = $.Deferred(),
                createModel = new BaseModel(),
                fetchModel = new BaseModel(),
                //TODO: we have some defaults but in reality people should be responsible for passing these
                //in options.data like they are responsible for app and owner
                //Simon asks: does the endpoint set any of these defaults for us????
                createDefaults = {
                    data: {
                        rf: "*",
                        auto_cancel: Model.DEFAULT_AUTO_CANCEL,
                        status_buckets: 300,
                        output_mode: 'json'
                    }
                },
                app_and_owner = {},
                customAttrs = this.getCustomDataPayload();
                       
            options = options || {};
            options.data = options.data || {};
            app_and_owner = $.extend(app_and_owner, { //JQuery purges undefined
                app: options.data.app || undefined,
                owner: options.data.owner || undefined,
                sharing: options.data.sharing || undefined
            });
            
            var url = splunkd_utils.fullpath(model.url, app_and_owner);
            
            //append the values from the entry.content.custom model
            $.extend(true, createDefaults.data, customAttrs || {});
            $.extend(true, createDefaults.data, options.data);
            delete createDefaults.data.app;
            delete createDefaults.data.owner;
            delete createDefaults.data.sharing;
            
            //add the leading search command if it isn't present
            if (createDefaults.data.search) {
                createDefaults.data.search = splunkUtil.addLeadingSearchCommand(createDefaults.data.search, true);
            }
            
            //reset options.data to only the app and owner
            options.data = $.extend(true, {}, app_and_owner);
            
            model.trigger('request', model, deferredResponse, options);
            
            //TODO: Maybe we should be faithful to SplunkD here and make it the consumer's responsibility to fetch after create
            //this would mean that parse would need to handle the sid only payload and the full object payload
            var  createDeferred = createModel.save({}, {
                url: url,
                processData: true,
                data: createDefaults.data,
                success: function(createModel, response, options) {
                    // need an id so that in case of an empty response we don't blow up
                    rootModel.set('id', createModel.get('sid'));
                    var fetchDeferred = fetchModel.fetch({
                        url: url + "/" + encodeURIComponent(createModel.get("sid")),
                        data: {
                            output_mode: "json"
                        },
                        success: function(fetchModel, response, options) {
                            rootOptions.success(response);
                        },
                        error: function(fetchModel, response, options) {
                            rootOptions.error(response);
                        }
                    });
                    fetchDeferred.done(function() {
                        deferredResponse.resolve.apply(deferredResponse, arguments);
                    });
                    fetchDeferred.fail(function() {
                        deferredResponse.reject.apply(deferredResponse, arguments);
                    });
                },
                error: function(createModel, response, options) {
                    rootOptions.error(response);
                }
            });
            createDeferred.fail(function() {
                deferredResponse.reject.apply(deferredResponse, arguments);
            });
            return deferredResponse.promise();
        },
        syncRead = function(model, options){
            var defaults = {
                    data: {
                        output_mode: 'json'
                    }
                },
                app_and_owner = {};

            if (model.isNew()){
                throw new Error('You cannot read a job without an id.');
            }
            
            if (options && options.data){
                app_and_owner = $.extend(app_and_owner, { //JQuery purges undefined
                    app: options.data.app || undefined,
                    owner: options.data.owner || undefined,
                    sharing: options.data.sharing || undefined
                });
            }

            defaults.url = splunkd_utils.fullpath(model.url + "/" + encodeURIComponent(model.id), app_and_owner);
            $.extend(true, defaults, options || {});
            
            delete defaults.data.app;
            delete defaults.data.owner;
            delete defaults.data.sharing;
            
            return Backbone.sync.call(this, "read", model, defaults);
        },
        syncUpdate = function(model, options){
            var defaults = {data: {output_mode: 'json'}},
                app_and_owner = {},
                customAttrs = this.getCustomDataPayload();
            
            if (options && options.data){
                app_and_owner = $.extend(app_and_owner, { //JQuery purges undefined
                    app: options.data.app || undefined,
                    owner: options.data.owner || undefined,
                    sharing: options.data.sharing || undefined
                });
            }
            
            //append the values from the entry.content.custom model
            $.extend(true, defaults.data, customAttrs || {});

            defaults.url = splunkd_utils.fullpath(model.url + "/" + encodeURIComponent(model.id), app_and_owner);
            defaults.processData = true;
            defaults.type = 'POST';
            
            $.extend(true, defaults, options || {});
            
            delete defaults.data.app;
            delete defaults.data.owner;
            delete defaults.data.sharing;
            
            return Backbone.sync.call(this, "update", model, defaults);
        },
        syncDelete = function(model, options){
            var defaults = {data: {output_mode: 'json'}},
                url = model.url + "/" + encodeURIComponent(model.id);

            if(options.data && options.data.output_mode){
                //add layering of url if specified by user
                defaults.url = splunkd_utils.fullpath(url, {}) + '?output_mode=' + encodeURIComponent(options.data.output_mode);
                delete options.data.output_mode;
            } else {
                //add layering of url if specified by user
                defaults.url = splunkd_utils.fullpath(url, {}) + '?output_mode=' + encodeURIComponent(defaults.data.output_mode);
                delete defaults.data.output_mode;
            }
            $.extend(true, defaults, options);
            defaults.processData = true;

            return Backbone.sync.call(this, "delete", model, defaults);
        };
        
        var Model = BaseModel.extend({
            url: "search/jobs",
            initialize: function(attributes, options) {
                BaseModel.prototype.initialize.apply(this, arguments);
                
                this.initializeAssociated();
                
                this.entry.links.on("change:control", function() {
                    this.control.set('id', this.entry.links.get('control'));
                }, this);

                this.entry.links.on("change:alternate", function() {
                    var alt = this.entry.links.get('alternate');
                    if (alt) {
                        alt = alt + "/acl";
                    }
                    this.acl.set('id', alt);
                }, this);

                if (options && options.splunkDPayload){
                    this.setFromSplunkD(options.splunkDPayload, {silent: true});
                }
            },
            parseSplunkDMessages: function(response) {
                var messages = BaseModel.prototype.parseSplunkDMessages.call(this, response);
                if(response && response.entry && response.entry.length > 0) {
                    var entry = response.entry[0],
                        content = entry.content || {};

                    messages = _.union(
                        messages,
                        splunkd_utils.parseMessagesObject(entry.messages),
                        splunkd_utils.parseMessagesObject(content.messages)
                    );
                    // handle zombie jobs, which often show up without any associated messages
                    if(content.isZombie) {
                        messages.push(splunkd_utils.createMessageObject(splunkd_utils.FATAL, 'Job terminated unexpectedly'));
                    }
                }
                return messages;
            },
            initializeAssociated: function() {
                // do a dynamic lookup of the current constructor so that this method is inheritance-friendly
                var RootClass = this.constructor;
                this.associated = this.associated || {};

                //instance level models
                this.links = this.links || new RootClass.Links();
                this.associated.links = this.links;
                
                this.generator = this.generator || new RootClass.Generator();
                this.associated.generator = this.generator;
                
                this.paging = this.paging || new RootClass.Paging();
                this.associated.paging = this.paging;

                //nested instance level on entry
                if (!this.entry){
                    this.entry = new RootClass.Entry();

                    this.entry.links = new RootClass.Entry.Links();
                    this.entry.associated.links = this.entry.links;

                    this.entry.acl = new RootClass.Entry.ACL();
                    this.entry.associated.acl = this.entry.acl;

                    //nested on content
                    this.entry.content = new RootClass.Entry.Content();

                    this.entry.content.performance = new RootClass.Entry.Content.Performance();
                    this.entry.content.associated.performance = this.entry.content.performance;

                    this.entry.content.request = new RootClass.Entry.Content.Request();
                    this.entry.content.associated.request = this.entry.content.request;
                    
                    this.entry.content.runtime = new RootClass.Entry.Content.Runtime();
                    this.entry.content.associated.runtime = this.entry.content.runtime;
                    
                    this.entry.content.custom = new RootClass.Entry.Content.Custom();
                    this.entry.content.associated.custom = this.entry.content.custom;
                    
                    this.entry.associated.content = this.entry.content;
                }
                this.associated.entry = this.entry;
                
                //associated EAI endpoint models
                this.control = this.control || new ControlModel();
                this.associated.control = this.control;
                
                this.acl = this.acl || new ACLModel();
                this.associated.acl = this.acl;
            },
            sync: function(method, model, options) {
                switch(method){
                    case 'create':
                        return syncCreate.call(this, model, options);
                    case 'read':
                        return syncRead.call(this, model, options);
                    case 'update':
                        return syncUpdate.call(this, model, options);
                    case 'delete':
                        return syncDelete.call(this, model, options);
                    default:
                        throw new Error('invalid method: ' + method);
                }
            },
            parse: function(response) {
                // make a defensive copy of response since we are going to modify it
                response = $.extend(true, {}, response);
                //when called from the collection fetch we will need to ensure that our
                //associated models are initialized because parse is called before
                //initialize
                this.initializeAssociated();
                
                if (!response || !response.entry || response.entry.length === 0) {
                    console.log('Response has no content to parse');
                    return;
                }
                var response_entry = response.entry[0];

                //id
                //this needs to be the first thing so that people can get !isNew()
                this.set(this.idAttribute, response_entry.content.sid);
                response.id = response_entry.content.sid;

                //top-level
                this.links.set(response.links);
                delete response.links;
                this.generator.set(response.generator);
                delete response.generator;
                this.paging.set(response.paging);
                delete response.paging;
                
                //sub-entry
                this.entry.links.set(response_entry.links);
                delete response_entry.links;
                
                this.entry.acl.set(response_entry.acl);
                delete response_entry.acl;
                
                //sub-content
                this.entry.content.performance.set(response_entry.content.performance);
                delete response_entry.content.performance;
                
                this.entry.content.request.set(response_entry.content.request);
                delete response_entry.content.request;
                
                this.entry.content.runtime.set(response_entry.content.runtime);
                delete response_entry.content.runtime;
                
                this.entry.content.custom.set(response_entry.content.custom);
                delete response_entry.content.custom;
                
                //content remainder
                this.entry.content.set(response_entry.content);
                delete response_entry.content;
                
                //entry remainder
                this.entry.set(response_entry);
                delete response.entry;
                return response;
            },
            setFromSplunkD: function(payload, options) {
                this.attributes = {};
                var cloned_payload = $.extend(true, {}, payload);
                var oldId = this.id;

                //object assignment
                if (cloned_payload) {
                    if (cloned_payload.entry && cloned_payload.entry[0]) {
                        var payload_entry = cloned_payload.entry[0];

                        if(payload_entry.content){
                            //id
                            //this needs to be the first thing so that people can get !isNew()
                            this.set({id: payload_entry.content.sid}, {silent: true});
                            cloned_payload.id = payload_entry.content.sid;

                            if (payload_entry.content.performance) {
                                this.entry.content.performance.set(payload_entry.content.performance, options);
                                delete payload_entry.content.performance;
                            }

                            if (payload_entry.content.request) {
                                this.entry.content.request.set(payload_entry.content.request, options);
                                delete payload_entry.content.request;
                            }
                            
                            if (payload_entry.content.runtime) {
                                this.entry.content.runtime.set(payload_entry.content.runtime, options);
                                delete payload_entry.content.runtime;
                            }
                            
                            if (payload_entry.content.custom) {
                                this.entry.content.custom.set(payload_entry.content.custom, options);
                                delete payload_entry.content.custom;
                            }

                            this.entry.content.set(payload_entry.content, options);
                            delete payload_entry.content;
                        }

                        if(payload_entry.links){
                            this.entry.links.set(payload_entry.links, options);
                            if (payload_entry.links.control) {
                                this.control.set('id', payload_entry.links.control, options);
                            }
                            if (payload_entry.links.alternate) {
                                this.acl.set('id', payload_entry.links.alternate + "/acl", options);
                            }
                            delete payload_entry.links;
                        }

                        if(payload_entry.acl){
                            this.entry.acl.set(payload_entry.acl, options);
                            delete payload_entry.acl;
                        }
                        
                        this.entry.set(payload_entry, options);
                        delete cloned_payload.entry;
                    }
                    if(cloned_payload.links) {
                        this.links.set(cloned_payload.links, options);
                        delete cloned_payload.links;
                    }
                    if(cloned_payload.generator) {
                        this.generator.set(cloned_payload.generator, options);
                        delete cloned_payload.generator;
                    }
                    if(cloned_payload.paging) {
                        this.paging.set(cloned_payload.paging, options);
                        delete cloned_payload.paging;
                    }
                    
                    //reset the internal root model due to pre-init routine
                    this.set(cloned_payload, options);
                    if(this.id !== oldId) {
                        this.trigger('change:' + this.idAttribute);
                    }
                }
            },
            toSplunkD: function() {
                var payload = {};

                payload = $.extend(true, {}, this.toJSON());

                payload.links = $.extend(true, {}, this.links.toJSON());
                payload.generator = $.extend(true, {}, this.generator.toJSON());
                payload.paging = $.extend(true, {}, this.paging.toJSON());
                payload.entry = [$.extend(true, {}, this.entry.toJSON())];

                payload.entry[0].links = $.extend(true, {}, this.entry.links.toJSON());
                payload.entry[0].acl = $.extend(true, {}, this.entry.acl.toJSON());
                payload.entry[0].content = $.extend(true, {}, this.entry.content.toJSON());

                payload.entry[0].content.performance = $.extend(true, {}, this.entry.content.performance.toJSON());
                payload.entry[0].content.request = $.extend(true, {}, this.entry.content.request.toJSON());
                payload.entry[0].content.runtime = $.extend(true, {}, this.entry.content.runtime.toJSON());
                payload.entry[0].content.custom = $.extend(true, {}, this.entry.content.custom.toJSON());

                //cleanup
                delete payload.id;

                return payload;
            },
            getCustomDataPayload: function() {
                var payload = $.extend(true, {}, this.entry.content.custom.toJSON()),
                    keys = _.keys(payload);
                
                _.each(keys, function(key){
                    var newKey = "custom." + key;
                    payload[newKey] = payload[key];
                    delete payload[key];
                });
                
                return payload;
            }
        },
        {
            // constants for the dispatch states
            QUEUED: 'QUEUED',
            PARSING: 'PARSING',
            RUNNING: 'RUNNING',
            PAUSED: 'PAUSED',
            FINALIZING: 'FINALIZING',
            FAILED: 'FAILED',
            DONE: 'DONE',
            CANCELED: 'CANCELED',
            
            //constants for the polling and intervals
            //seconds
            DEFAULT_AUTO_CANCEL: 30,
            DEFAULT_AUTO_PAUSE: 30,
            
            getAutoPauseInterval: function(val) {
                var parsed = general_utils.parseBooleanOrInt(val);
                
                if (_.isBoolean(parsed)) {
                   if (parsed) {
                       return Model.DEFAULT_AUTO_PAUSE;
                   }
                   return 0;
                }
                
                return parsed;
            },
            
            //milliseconds
            JOB_MIN_POLLING_INTERVAL: configModel.get('JOB_MIN_POLLING_INTERVAL') || 100,
            JOB_MAX_POLLING_INTERVAL: configModel.get('JOB_MAX_POLLING_INTERVAL') || 1000,
            DEFAULT_METADATA_POLLING_INTERVAL: 3000,
            DEFAULT_KEEP_ALIVE_INTERVAL: 15000,

            Links: BaseModel,
            Generator: BaseModel,
            Paging: BaseModel,
            Entry: BaseModel.extend(
                {
                    initialize: function() {
                        BaseModel.prototype.initialize.apply(this, arguments);
                    }
                },
                {
                    Links: BaseModel,
                    ACL: ACLReadOnlyModel,
                    Content: BaseModel.extend(
                        {
                            initialize: function() {
                                BaseModel.prototype.initialize.apply(this, arguments);
                            }
                        }, 
                        {
                            Performance: BaseModel,
                            Request: BaseModel,
                            Runtime: BaseModel,
                            Custom: BaseModel
                        }
	                )
                }
            )
        });

        return Model;
    }
);

/*
 * Intended for use via the class-level API in models/shared/Job.js
 *
 * A helper to manage relationships between a running job and its "search artifacts".  Artifacts include
 * results, events, timeline, and summary information.
 *
 * The intention is that by providing a static helper API to associate jobs and search artifacts, some
 * internal caching logic can be included at the "sync" level (not tied to a particular job instance,
 * but based on the job's sid).
 *
 * This helper is not responsible for polling the job itself, only ensuring that as the job shows progress,
 * the related artifacts are also kept up-to-date.
 */

define('helpers/search/ArtifactFetchManager',[
            'jquery',
            'underscore',
            'backbone'
        ],
        function(
            $,
            _,
            Backbone
        ) {

    var cache = [];

    /*
     * The next two methods are intentionally defined anonymously but intended to be called
     * in the scope of an artifact model.  This allows us to use Backbone's event API to unbind
     * listeners for only a certain artifact model, without having to maintain a registry of
     * which artifact model has bound to which job.
     */

    var jobProgressHandler = function(link, job) {
        if (shouldFetchArtifact(job)) {
            this.safeFetch();
        }
    };

    var jobLinkChangeHandler = function(linkModel, newValue) {
        this.set(this.idAttribute, newValue);
    };

    var shouldFetchArtifact = function(job) {
        return job.entry.content.get('isPreviewEnabled') || job.isDone();
    };

    var ArtifactFetchManager = $.extend({}, Backbone.Events, {

        /**
         * @param artifactModel - can be any model that has an internal `fetchData` model and implements `safeFetch`
         * @param job <models/search/Job> - an instance of an existing job
         * @param linkKey - a valid job.entry.links key ("results", "results_preview", "events", etc.)
         */

        registerArtifactModel: function(artifactModel, job, linkKey) {
            job.on('jobProgress:' + linkKey, jobProgressHandler, artifactModel);
            job.entry.links.on('change:' + linkKey, jobLinkChangeHandler, artifactModel);
            this.listenToOnce(job, 'destroy', this._jobDestroyHandler);
            this.listenTo(artifactModel, 'request', function(artifactModel, response, fetchOptions) {
                this._artifactRequestHandler(artifactModel, response, fetchOptions, job);
            });

            if (job.entry.links.has(linkKey)) {
                artifactModel.set(artifactModel.idAttribute, job.entry.links.get(linkKey));
                var cachedPayload = this._getCachedPayload(artifactModel);
                if (cachedPayload) {
                    // Consumers might not expect this call to synchronously populate the model,
                    // so defer the operation to make it async.
                    _.defer(function() {
                        artifactModel.set(
                            artifactModel.parse($.extend(true, {}, cachedPayload))
                        );
                    });
                }
                else if(!job.isPreparing() && shouldFetchArtifact(job)) {
                    artifactModel.safeFetch();
                }
            }
        },

        unregisterArtifactModel: function(artifactModel, job) {
            job.off(null, jobProgressHandler, artifactModel);
            job.entry.links.off(null, jobLinkChangeHandler, artifactModel);
            artifactModel.fetchAbort();
            this.stopListening(artifactModel);
        },

        _jobDestroyHandler: function(job) {
            cache = _(cache).reject(function(entry) {
                return job.entry.links.has(entry.link);
            });
            job.off(null, jobProgressHandler);
            job.entry.links.off(null, jobLinkChangeHandler);
        },

        _artifactRequestHandler: function(artifactModel, request, fetchOptions, job) {
            if (job.isDone()) {
                request.done(_(function(response) {
                    this._writeToCache(artifactModel, response, fetchOptions);
                }).bind(this));
            }
        },

        _getCachedPayload: function(artifactModel) {
            var matchingEntry = this._findMatchingCacheEntry(artifactModel, artifactModel.fetchData.toJSON());
            return matchingEntry && matchingEntry.payload;
        },

        _writeToCache: function(artifactModel, response, fetchOptions) {
            var fetchData = fetchOptions.data,
                matchingEntry = this._findMatchingCacheEntry(artifactModel, fetchData);

            if (matchingEntry) {
                cache = [matchingEntry].concat(_(cache).without(matchingEntry));
            } else {
                var newEntry = {
                    link: artifactModel.id,
                    payload: $.extend(true, {}, response),
                    fetchParams: $.extend(true, {}, fetchData)
                };
                cache = [newEntry].concat(cache.slice(0, ArtifactFetchManager.CACHE_SIZE_LIMIT - 1));
            }
        },

        _findMatchingCacheEntry: function(artifactModel, fetchData) {
            return _(cache).find(function(entry) {
                return (
                    this._normalizeArtifactId(entry.link) === this._normalizeArtifactId(artifactModel.id) &&
                    _.isEqual(entry.fetchParams, fetchData)
                );
            }, this);
        },

        _normalizeArtifactId: function(link) {
            return link.replace(/^\/services\//, '/servicesNS/nobody/search/');
        },

        // FOR TESTING ONLY
        _clearCache: function() {
            cache = [];
        }

    });

    // VISIBLE FOR TESTING ONLY
    ArtifactFetchManager.CACHE_SIZE_LIMIT = 5;

    return ArtifactFetchManager;

});
define(
    'models/search/Job',[
        'jquery',
        'underscore',
        'backbone',
        'models/services/search/Job',
        'util/splunkd_utils',
        'util/time',
        'util/console',
        'splunk.util',
        'helpers/Session',
        'helpers/search/ArtifactFetchManager',
        'util/Ticker'
    ],
    function($, _, Backbone, SearchJob, splunkd_utils, time_utils, console, splunkUtil, Session, ArtifactFetchManager, Ticker) {
        
        var JobModel = SearchJob.extend({
            initialize: function(attributes, options) {
                SearchJob.prototype.initialize.apply(this, arguments);
                this.options = options || {};

                this.setInstanceDefaults();

                this.entry.content.on('change', function() {
                    var changedAttributes = this.entry.content.changedAttributes(),
                        previousAttributes = this.entry.content.previousAttributes();

                    this.handleJobProgress(changedAttributes, previousAttributes);
                }, this);
                
                this.entry.content.on("change:dispatchState", function() {
                    if (this.entry.content.get('dispatchState') && !this.isPreparing() && !this.prepared) {
                        this.prepared = true;
                        this.trigger("prepared");
                    }

                    //stop polling when the job is done
                    if (this.isDone() || this.entry.content.get('isFailed')) {
                        this.stopPolling();
                    }

                }, this);

                this.entry.content.on("change:isDone", function() {
                    if (this.isDone()) {
                        this.trigger('done');
                    }
                }, this);
                    
                //poll aggressively to begin with
                this.ticker = new Ticker({interval:this.aggressivePollingDelay});
                this.ticker.on('tick', function() {
                    this.safeFetch({
                        data: {
                            app: this.entry.acl.get('app'),
                            owner: this.entry.acl.get('owner'),
                            sharing: this.entry.acl.get('sharing')
                        }
                    });
                }, this);

                this.on("startPolling", function() {     
                    var _private_progress = function() {
                        var count;
                        this.aggressivePollingDelay *= 1.5;
                        this.aggressivePollingDelay = Math.round(this.aggressivePollingDelay);

                        if (this.isDone() || this.entry.content.get('isFailed')) {
                            this.off('sync', _private_progress, this);
                            return;
                        }

                        if (this.isReportSearch()) {
                            if (this.entry.content.get('isPreviewEnabled')) {
                                count = this.entry.content.get('resultPreviewCount');
                            } else {
                                count = this.entry.content.get('resultCount');
                            }
                        } else {
                            count = this.entry.content.get('eventAvailableCount');
                        }

                        if ((count > 0) || (this.aggressivePollingDelay >= this.pollingDelay)) {
                            this.off('sync', _private_progress, this);
                            this.trigger('slowDownPoller');
                        } else {
                            if (this._poll) {
                                this.ticker.restart({
                                    interval: this.aggressivePollingDelay
                                });
                            }                            
                        }

                    }.bind(this);

                    this.on('slowDownPoller', function() {
                        if (this._poll) {
                            this.ticker.restart({
                                interval: this.pollingDelay
                            });
                        }
                    }, this);

                    this.on('sync', _private_progress, this);
                }, this);
                
                this.on("error", function(){
                    if (splunkd_utils.messagesContainsOneOfTypes(this.error.get("messages"), [splunkd_utils.NOT_FOUND, splunkd_utils.FATAL])) {
                        this.handleJobDestroy();
                    }
                }, this);
                
                this.entry.content.on("change:isFailed", function(){
                    if (this.entry.content.get("isFailed")) {
                        this.handleJobDestroy();
                    }
                }, this);
                
                this.on('destroy', this.handleJobDestroy, this);
            },
            setInstanceDefaults: function() {
                //poller setup
                this._poll = false;
                this.pollingDelay = this.options.delay || SearchJob.JOB_MAX_POLLING_INTERVAL;
                this.aggressivePollingDelay = this.options.aggressiveDelay || SearchJob.JOB_MIN_POLLING_INTERVAL;
                
                this.prepared = (this.entry.content.get('dispatchState') && !this.isPreparing());
                this.processKeepAlive = this.options.processKeepAlive || false;
                this.keepAlivePoller = null;
                this.keepAliveInterval = this.options.keepAliveInterval || SearchJob.DEFAULT_KEEP_ALIVE_INTERVAL;
            },
            clear: function() {
                SearchJob.prototype.clear.apply(this, arguments);
                this.handleJobDestroy();
                this.setInstanceDefaults();
                return this;
            },
            handleJobProgress: function(changed, previous) {
                if (this.isNew()) {
                    return false;
                }
                
                var jobIsRealTime = this.entry.content.get('isRealTimeSearch'),
                    jobIsReportSearch = this.entry.content.get('reportSearch'),
                    jobAdHocModeIsVerbose = (this.getAdhocSearchMode() === splunkd_utils.VERBOSE),
                    jobPreviewEnabled = this.entry.content.get('isPreviewEnabled'),
                    jobIsDoneInModel = this.isDone(),
                    changeIsEmpty = _.isEmpty(changed);
                
                // if the job is not previewable and also not done, ignore the progress 
                if (
                    changeIsEmpty ||
                    (!jobIsDoneInModel && jobIsReportSearch && !jobPreviewEnabled && !jobAdHocModeIsVerbose)
                ) {
                    return false;
                }
                
                // examine changes to the job model and determine if the child objects should be updated
                var scanCountChanged = !_(changed.scanCount).isUndefined() && (changed.scanCount > previous.scanCount),
                    eventCountChanged = !_(changed.eventCount).isUndefined(),
                    resultCountChanged = !_(changed.resultCount).isUndefined(),
                    jobIsDone = !_(changed.isDone).isUndefined() && (changed.isDone === true),
                    jobIsUpdated = scanCountChanged || eventCountChanged || resultCountChanged || jobIsDone || jobIsRealTime;

                if (!jobIsUpdated) {
                    return false;
                }
                
                //we have determined that the job has been updated, so trigger all relevant events
                //we could be smarter about this, for now always notifying each sub-endpoint on every progress event
                this.trigger("jobProgress");
                var links = this.entry.links;
                this.trigger("jobProgress:" + JobModel.RESULTS_PREVIEW, links.get(JobModel.RESULTS_PREVIEW), this);
                this.trigger("jobProgress:" + JobModel.RESULTS, links.get(JobModel.RESULTS), this);
                this.trigger("jobProgress:" + JobModel.SUMMARY, links.get(JobModel.SUMMARY), this);
                this.trigger("jobProgress:" + JobModel.TIMELINE, links.get(JobModel.TIMELINE), this);
                this.trigger("jobProgress:" + JobModel.EVENTS, links.get(JobModel.EVENTS), this);
                
                if (jobIsDone && this.processKeepAlive) {
                    this.startKeepAlive();
                }
                
                return true;
            },
            
            registerJobProgressLinksChild: function(linksKey, child, callback, scope) {
                // NOTE: Only register after the job has been created/fetched!
                var id = this.entry.links.get(linksKey);
                if (id) {
                    child.set("id", id);
                    callback.call(scope);
                    this.on("jobProgress", callback, scope);
                    return true;
                }
                console.warn('Search Job Model: You attempted to register a child model with a links key that doesn\'t exist. Have you fetched your job lately? Key:', linksKey);
                return false;
            },
            
            unregisterJobProgressLinksChild: function(callback, scope) {
                this.off("jobProgress", callback, scope);
            },
            
            handleJobDestroy: function() {
                this.stopPolling();
                this.processKeepAlive = false;
                this.stopKeepAlive();
                this.fetchAbort();
                this.control.fetchAbort();
            },
            
            startKeepAlive: function() {
                //remove/add session observers to start/stop the keep alive poller based on UI session
                this.stopPolling();
                Session.on('timeout', this.stopKeepAlive, this);
                Session.on('start', this.startKeepAlive, this);
                
                this.stopKeepAlive();//ensure you never create more than one keep alive poller
                this.keepAlivePoller = new Ticker({interval:this.keepAliveInterval});
                this.keepAlivePoller.on('tick', function() {
                    this.control.save({}, {
                        data: {
                            action: 'touch' 
                        },
                        success: function(model, response, options) {
                            console.log('touched job:', model.id);
                        }.bind(this),
                        error: function(model, response, options) {
                            if (response.hasOwnProperty('status') && (response.status == 0 || response.status == 12029)) {
                                return;
                            }
                            console.log("error touching job (stopping keep alive):", model.id);
                            this.stopKeepAlive();
                        }.bind(this)
                    });
                }, this);
                this.keepAlivePoller.start();
            },
            
            stopKeepAlive: function() {
                if (this.keepAlivePoller) {
                    this.keepAlivePoller.stop();
                    this.keepAlivePoller.off();
                }
            },
            
            startPolling: function(force) {
                if (!this._poll || force) {
                    this._poll = true;
                    
                    //remove/add session observers to start/stop the job poller based on UI session
                    Session.off('timeout', null, this);
                    Session.off('start', null, this);
                    Session.on('timeout', this.stopPolling, this);
                    Session.on('start', function() {
                        this.startPolling(true);//force a new update from the server
                    }, this);
                    
                    if (force || (!this.isDone() && !this.entry.content.get('isFailed'))) {
                        this.ticker.start(true);
                        this.trigger("startPolling");
                    }
                }
            },
            
            stopPolling: function() {
                if (this._poll) {
                    this._poll = false;
                    Session.off('timeout', null, this);
                    Session.off('start', null, this);
                    this.ticker.stop();
                    this.aggressivePollingDelay = this.options.aggressiveDelay || SearchJob.JOB_MIN_POLLING_INTERVAL;
                    console.log("stopPolling has been triggered.");
                }
            },
            
            noParamControlUpdate: function(action, options) {
                if(options && options.data) {
                    delete options.data;
                }
                return this.control.save({}, $.extend(true, options, { data: { action: action } }));                
            },

            pause: function(options) {
                return this.noParamControlUpdate("pause", options);
            },

            unpause: function(options) {
                return this.noParamControlUpdate("unpause", options);
            },

            finalize: function(options) {
                return this.noParamControlUpdate("finalize", options);
            },
            
            cancel: function(options) {
                return this.noParamControlUpdate("cancel", options);
            },
            
            touch: function(options) {
                return this.noParamControlUpdate("touch", options);
            },
            
            setTTL: function(ttl, options) {
                if(options && options.data) {
                    delete options.data;
                }
                return this.control.save({}, $.extend(true, options, { data: { action: 'setttl', ttl: ttl} }));
            },
            
            setPriority: function(priority, options) {
                if(options && options.data) {
                    delete options.data;
                }
                return this.control.save({}, $.extend(true, options, { data: { action: 'setpriority', priority: priority} } ));
            },
            
            enablePreview: function(options) {
                return this.noParamControlUpdate("enablepreview", options);
            },
            
            disablePreview: function(options) {
                return this.noParamControlUpdate("disablepreview", options);
            },
            
            setPreview: function(preview, options) {
                var currentPreview = this.entry.content.get('isPreviewEnabled');
                if (preview !== currentPreview) {
                    if (preview) {
                        return this.enablePreview(options);
                    }
                    return this.disablePreview(options);
                }
                if (options && options.success && _.isFunction(options.success)) {
                    options.success(this, {}, options);
                }
                return $.Deferred().resolve();
            },
            
            saveControlUpdate: function(action, options) {
                options = options || {};
                options.data = options.data || {};
                
                var data = {
                    action: action,
                    auto_cancel: options.data.auto_cancel,
                    auto_pause: options.data.auto_pause,
                    email_list: options.data.email_list,
                    email_subject: options.data.email_subject,
                    email_results: options.data.email_results,
                    ttl: options.data.ttl
                }; 
                
                if(options && options.data) {
                    delete options.data;
                }
                
                return this.control.save({}, $.extend(true, options, {data: data}));               
            },
            
            saveJob: function(options) {                
                return this.saveControlUpdate("save", options);
            },
            
            unsaveJob: function(options) {
                return this.saveControlUpdate("unsave", options);
            },
            
            makeWorldReadable: function(options) {
                var owner = this.entry.acl.get("owner"),
                    data = {
                        sharing: splunkd_utils.GLOBAL,
                        owner: this.entry.acl.get("owner"),
                        'perms.read': "*"                
                    };
                
                if (options && options.data) {
                    delete options.data;
                }
                
                return this.acl.save({}, $.extend(true, options, { data: data }));                
            },
            
            undoWorldReadable: function(options) {
                var owner = this.entry.acl.get("owner"),
                    data = {
                        sharing: splunkd_utils.GLOBAL,
                        owner: owner,
                        'perms.read': ""              
                    };
                
                if (options && options.data) {
                    delete options.data;
                }
                
                return this.acl.save({}, $.extend(true, options, { data: data }));                
            },
            
            isSharedAccordingToTTL: function(defaultSaveTTL) {
                var perms = this.entry.acl.permsToObj();
                if ((perms.read.indexOf("*") != -1) && (this.entry.content.get("ttl") === defaultSaveTTL)) {
                    return true;
                }
                return false;
            },
            
            saveIsBackground: function(options) {
                this.entry.content.custom.set("isBackground", "1");
                return this.save({}, options);
            },
            
            isBackground: function() {
                return splunkUtil.normalizeBoolean(this.entry.content.custom.get("isBackground"));
            },
            
            resultCountSafe: function() {
                return (this.entry.content.get('isPreviewEnabled') && !this.isDone()) ? this.entry.content.get('resultPreviewCount') : this.entry.content.get('resultCount');
            },
            
            eventAvailableCountSafe: function() {
                return (this.entry.content.get('statusBuckets') == 0) ? this.resultCountSafe() : this.entry.content.get('eventAvailableCount');
            },


            // a job can be dispatched without a latest time, in which case return the published time
            latestTimeSafe: function() {
                var entry = this.entry;
                return entry.content.get('latestTime') || entry.get('published');
            },
            
            isQueued: function() {
                return this.checkUppercaseValue('dispatchState', JobModel.QUEUED);
            },
            
            isParsing: function() {
                return this.checkUppercaseValue('dispatchState', JobModel.PARSING);
            },
            
            isFinalizing: function() {
                return this.checkUppercaseValue('dispatchState', JobModel.FINALIZING);
            },

            isDone: function() {
                return splunkUtil.normalizeBoolean(this.entry.content.get('isDone'));
            },
            
            isPreparing: function() {
                return this.isQueued() || this.isParsing();
            },
            
            isRunning: function() {
                return !this.isNew() && !this.entry.content.get('isPaused') && !this.isDone() && !this.isPreparing() && !this.isFinalizing();
            },
            
            isReportSearch: function() {
                return (this.entry.content.get('reportSearch') ? true : false);
            },

            isUneventfulReportSearch: function() {
                return (this.isReportSearch() && (this.getAdhocSearchMode() !== splunkd_utils.VERBOSE));
            },

            isPatternable: function() {
                var eventCount = this.entry.content.get('eventCount');
                return this.prepared && !this.isFailed() && !this.isRealtime() &&
                    (!this.isUneventfulReportSearch() &&
                        ((eventCount >= 10000) || (this.isDone() && eventCount > 0)));
            },

            // returns true if the job was dispatched over all time, returns false for all-time real-time
            isOverAllTime: function() {
                var dispatchEarliestTime = this.getDispatchEarliestTime();
                return ((!dispatchEarliestTime || dispatchEarliestTime === '0') && !this.getDispatchLatestTime());
            },

            isRealtime: function() {
                return splunkUtil.normalizeBoolean(this.entry.content.get('isRealTimeSearch'));
            },

            isFailed: function() {
                return splunkUtil.normalizeBoolean(this.entry.content.get('isFailed'));
            },
            
            checkUppercaseValue: function(key, uc_value) {
                var value = this.entry.content.get(key);
                if (!value) {
                    return false;
                }
                return (value.toUpperCase() === uc_value);
            },
            
            getDispatchEarliestTime: function() {
                var earliest = this.entry.content.request.get('earliest_time');
                if (earliest === void(0)) {
                    return this.entry.content.get('searchEarliestTime');
                }
                return earliest;
            },
            
            getDispatchEarliestTimeOrAllTime: function() {
                if (this.entry.content.get('delegate')==='scheduler' && this.entry.content.get('searchLatestTime') !== void(0)) {
                    // windowed rt or all time rt alerts
                    return this.entry.content.get('searchEarliestTime') || '';
                } else {
                    return this.entry.content.request.get('earliest_time') || '';
                }
            },
            
            getDispatchLatestTime: function() {
                var latest = this.entry.content.request.get('latest_time');
                if (latest === void(0)) {
                    return this.entry.content.get('searchLatestTime');
                }
                return latest;
            },
            
            getDispatchLatestTimeOrAllTime: function() {
                var searchLatestTime = this.entry.content.get('searchLatestTime');
                if (this.entry.content.get('delegate')==='scheduler' && searchLatestTime !== void(0)) {
                    return searchLatestTime;
                } else {
                    return this.entry.content.request.get('latest_time') || '';
                }
            },
            
            getStrippedEventSearch: function() {
                var search = this.entry.content.get('eventSearch');
                if (search) {
                    search = splunkUtil.stripLeadingSearchCommand(search);
                }
                return search;
            },
            
            getSearch: function() {
                var search = this.entry.get('name');
                if (!search) {
                    return this.entry.content.request.get('search');
                }
                return search;
            },
            
            getAdhocSearchMode: function() {
                return this.entry.content.request.get('adhoc_search_level') || splunkd_utils.FAST;
            },
            
            canBePausedOnRemove: function() {
                if (!this.isNew() &&
                        (!this.isDone() && !this.get("cannotPauseOnRemove")) &&
                        !this.entry.content.get("isPaused") &&
                        !this.isBackground() && 
                        !this.entry.content.get("isSaved")) {
                    return true;
                }
                return false;
            },
            
            canSummarize: function() {
                return splunkUtil.normalizeBoolean(this.entry.content.get('canSummarize'));
            },
            
            searchCanBeEventType: function() {
                return splunkUtil.normalizeBoolean(this.entry.content.get('searchCanBeEventType'));
            },

            deepOff: function () {
                SearchJob.prototype.deepOff.apply(this, arguments);
                Session.off(null, null, this);
            }
            
        },
        {
            RESULTS_PREVIEW: "results_preview",
            SUMMARY: "summary",
            TIMELINE: "timeline",
            EVENTS: "events",
            RESULTS: "results",
            createMetaDataSearch: function(search, deferred, applicationModel, delay) {
                var job = new JobModel({}, {delay: delay || SearchJob.DEFAULT_METADATA_POLLING_INTERVAL});
                    
                job.save({}, {
                    data: {
                        app: applicationModel.get("app"),
                        owner: applicationModel.get("owner"),
                        search: search,
                        preview: "true",
                        earliest_time: "rt",
                        latest_time: "rt",
                        auto_cancel: SearchJob.DEFAULT_AUTO_CANCEL,
                        max_count: 100000
                    },
                    success: function(model, response) {
                        deferred.resolve();
                    },
                    error: function(model, response) {
                        deferred.resolve();
                    }
                });
                
                return job;
            },
            registerArtifactModel: function(artifactModel, job, linkKey) {
                ArtifactFetchManager.registerArtifactModel(artifactModel, job, linkKey);
            },
            unregisterArtifactModel: function(artifactModel, job) {
                ArtifactFetchManager.unregisterArtifactModel(artifactModel, job);
            }
        });
        
        return JobModel;
    }
);

define(
    'collections/services/search/Jobs',[
        "models/services/search/Job",
        "collections/SplunkDsBase"
    ],
    function(JobModel, SplunkDsBaseCollection) {
        return SplunkDsBaseCollection.extend({
            url: 'search/jobs',
            model: JobModel,
            initialize: function() {
                SplunkDsBaseCollection.prototype.initialize.apply(this, arguments);
            }
        });
    }
);
define(
    'collections/search/Jobs',[
        "underscore",
        "models/search/Job",
        "collections/services/search/Jobs"
    ],
    function(_, JobModel, JobsCollection) {
        return JobsCollection.extend({
            model: JobModel,
            comparator: function(job) {
                var date = new Date(job.entry.get('published'));
                return date.valueOf() || 0;
            },
            initialize: function() {
                JobsCollection.prototype.initialize.apply(this, arguments);
            },
            fetchNonAutoSummaryJobs: function(options) {
                //this is the port of modules/jobs/JobManager.py's generateResults()
                var omit_autosummary = '(NOT _AUTOSUMMARY AND NOT "|*summarize*action=")',
                    filters = {};
                
                options = options || {};
                options.data = options.data || {};
                options.data.count = options.data.count || 10;
                options.data.offset = options.data.offset || 0;
                options.data.sortKey = options.data.sortKey || 'dispatch_time';
                options.data.sortDir = options.data.sortDir || 'desc';
                
                //Omit _AUTOSUMMARY_ jobs and their summarization jobs
                if (options.data.search) {
                    options.data.search = omit_autosummary + ' AND (' + options.data.search + ')';
                } else {
                    options.data.search = omit_autosummary;
                }
                
                //Omit data preview jobs by adding to the search string.
                filters['NOT isDataPreview'] = '1';
                
                if (options.data.app && (options.data.app !== '*')){
                    filters['eai:acl.app'] = options.data.app;
                }
                delete options.data.app;
                
                if (options.data.owner && (options.data.owner !== '*')){
                    filters['eai:acl.owner'] = options.data.owner;
                }
                delete options.data.owner;
                
                if (options.data.label){
                    filters.label = options.data.label;
                }
                delete options.data.label;
                    
                if (options.data.jobStatus && (options.data.jobStatus !== '*')){
                    if (options.data.jobStatus === 'running') {
                        filters['isDone'] = 0;
                        filters['isPaused'] = 0;
                        filters['isFinalized'] = 0;                 
                    } else if (options.data.jobStatus === 'done') {
                        filters['isDone'] = 1;
                    } else if (options.data.jobStatus === 'paused') {
                        filters['isPaused'] = 1;
                    } else if (options.data.jobStatus === 'finalized') {
                        filters['isFinalized'] = 1;
                    }
                }
                delete options.data.jobStatus;
                
                _.each(filters, function(value, key) {
                    options.data.search = options.data.search + ' ' + key + '="' + value + '"'; 
                });
                
                return this.fetch(options);
            }
        });
    }
);
define(
    'models/search/Report',[
        'jquery',
        'underscore',
        'models/services/saved/Search',
        'models/services/data/ui/Viewstate',
        'collections/search/Jobs',
        'util/time',
        'util/splunkd_utils',
        'util/general_utils',
        'splunk.util',
        'splunk.i18n',
        'uri/route',
        'util/math_utils'
    ],
    function($, _, SavedSearch, Viewstate, JobsCollection, time_utils, splunkd_utils, general_utils, splunkUtil, i18n, route, math_utils) {
        var ReportModel = SavedSearch.extend({
            reportTree: {
                'match': { 
                    'display.general.type': {
                        'visualizations' : {
                            'match': {
                                'display.visualizations.type': {
                                    'singlevalue': {
                                        'view': 'single', icon: 'single-value', label: _('Single Value').t(), tooltip: _('Single Value').t()
                                    },
                                    'charting': {
                                        'match': {'display.visualizations.charting.chart': {
                                                'line': { 'view': 'line', icon: 'chart-line', label: _('Line').t(), tooltip: _('Line Chart').t() },
                                                'area': { 'view': 'area', icon: 'chart-area',label: _('Area').t(), tooltip: _('Area Chart').t() },
                                                'column': { 'view': 'column', icon: 'chart-column', label: _('Column').t(), tooltip: _('Column Chart').t() },
                                                'bar': { 'view': 'bar', icon: 'chart-bar', label: _('Bar').t(), tooltip: _('Bar Chart').t() },
                                                'pie': { 'view': 'pie', icon: 'chart-pie', label: _('Pie').t(), tooltip: _('Pie Chart').t() },
                                                'scatter': { 'view': 'scatter', icon: 'chart-scatter', label: _('Scatter').t(), tooltip: _('Scatter Chart').t() },
                                                'bubble': { 'view': 'bubble', icon: 'chart-bubble', label: _('Bubble').t(), tooltip: _('Bubble Chart').t() },
                                                'radialGauge': { 'view': 'radialGauge', icon: 'gauge-radial', label: _('Radial').t(), tooltip: _('Radial Gauge').t() },
                                                'fillerGauge': { 'view': 'fillerGauge', icon: 'gauge-filler', label: _('Filler').t(), tooltip: _('Filler Gauge').t() },
                                                'markerGauge': { 'view': 'markerGauge', icon: 'gauge-marker', label: _('Marker').t(), tooltip: _('Marker Gauge').t() }
                                            }
                                        }
                                    },
                                    'mapping': {
                                        'match': {
                                            'display.visualizations.mapping.type': {
                                                'marker': { 'view': 'mapping', icon: 'location', label: _('Map').t(), tooltip: _('Map').t() },
                                                'choropleth': { 'view': 'mapping', icon: 'choropleth-map', label: _('Choropleth').t(), tooltip: _('Choropleth').t() }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        'statistics': { 
                            'view': 'statistics'
                        },
                        'events': { 
                            'view': 'events'
                        }
                    }
                }
            },
            initialize: function() {
                SavedSearch.prototype.initialize.apply(this, arguments);

                //associated
                this.jobs = new JobsCollection();
                this.associated.jobs = this.jobs;
            },
            sync: function(method, model, options) {
                options = options || {};
                _.defaults(options, {migrateViewState: true});
                
                if (!options.migrateViewState || method !== 'read') {
                    return SavedSearch.prototype.sync.apply(this, arguments);
                }
                
                var deferredResponse = $.Deferred(),
                    viewstateDeferred = $.Deferred(),
                    savedSearchProxy = new SavedSearch({id: this.id}),
                    bbXHR;
                
                model.trigger('request', model, deferredResponse, options);

                bbXHR = savedSearchProxy.fetch($.extend(true, {}, options, {
                    success: function(model, savedSearchResponse) {
                        this.setFromSplunkD(savedSearchProxy.toSplunkD());
                        
                        var vsid = this.entry.content.get("vsid"),
                            displayview = this.entry.content.get("displayview"),
                            hasBeenMigrated = splunkUtil.normalizeBoolean(this.entry.content.get("display.general.migratedFromViewState")),
                            name, viewstate;
                        
                        if (vsid && displayview && !hasBeenMigrated) {
                            name = /.*:/.test(vsid) ? vsid : (displayview + ":" + vsid);
                            viewstate = new Viewstate();
                            
                            viewstate.fetch({
                                url: splunkd_utils.fullpath(
                                    viewstate.url + "/" + encodeURIComponent(name),
                                    {
                                        app: options.data.app,
                                        owner: options.data.owner                               
                                    }
                                 ),
                                 success: function(model, response) {
                                     var viewstateConversionAttrs = viewstate.convertToReportPoperties();
                                     viewstateConversionAttrs["display.general.migratedFromViewState"] = "1";
                                     
                                     //layer in the viewstate properties
                                     this.entry.content.set(viewstateConversionAttrs);
                                     
                                     options.success(savedSearchResponse);
                                     viewstateDeferred.resolve();
                                 }.bind(this),
                                 error: function(model, response) {
                                     //the viewstate could not be found. Party on, but make sure if they save we never lookup the viewstate again.
                                     this.entry.content.set("display.general.migratedFromViewState", "1");
                                     
                                     options.success(savedSearchResponse);
                                     viewstateDeferred.resolve();
                                 }.bind(this)
                            });
                        } else {
                            options.success(savedSearchResponse);
                            viewstateDeferred.resolve();
                        }                        
                    }.bind(this),
                    error: function(model, savedSearchResponse) {
                        options.error(savedSearchResponse);                       
                    }.bind(this)
                }));
                
                $.when(viewstateDeferred).then(function() {
                    bbXHR.done(function(){
                        deferredResponse.resolve.apply(deferredResponse, arguments);
                    }.bind(this));
                }.bind(this));
                
                bbXHR.fail(function() {
                    deferredResponse.reject.apply(deferredResponse, arguments);
                }.bind(this));
                
                return deferredResponse.promise();                
            },
            parse: function(response) {
                var parsedResponse = SavedSearch.prototype.parse.apply(this, arguments),
                    contentModel = this.entry.content;

                // SPL-78883 unfortunately due to some case inconsistencies there are some reports in the wild with
                // display.visualizations.type "singleValue" instead of "singlevalue"
                // to deal with this, normalize to all lower case here
                if(contentModel.has('display.visualizations.type')) {
                    contentModel.set({
                        'display.visualizations.type': contentModel.get('display.visualizations.type').toLowerCase()
                    });
                }
                return parsedResponse;
            },
            fetchJobs: function(options) {
                var label = this.entry.get('name');
                if (!label) {
                    throw "Report must have a name to associate it with Jobs";
                }

                options = options || {};
                options.data = options.data || {};
                options.data.app = this.entry.acl.get('app');
                options.data.owner = this.entry.acl.get('owner');
                options.data.label = label;

                return this.jobs.fetchNonAutoSummaryJobs(options);
            },
            // view in which to open the report to edit the search
            openInView: function (userModel) {
                if (this.isPivotReport()) {
                    if (userModel && !userModel.canPivot()) {
                        return 'search';
                    }
                    return 'pivot';
                } else {
                    return 'search';
                }
            },
            getVizType: function() {
                var that = this,
                    _vizTree = function(tree) { 
                    if (tree && tree.view){
                        return tree;
                    } else if (tree && tree.match){
                        var match;
                        _(tree.match).each(function(v, k){
                           match = v[that.entry.content.get(k)];
                        }, that);
                        if (match) return _vizTree(match);
                    } 
                };
                return _vizTree(this.reportTree.match['display.general.type'].visualizations) || { icon: 'star', tooltip: '' };
            },

            getVizTypePlusTable: function(vizType){
                var vizPlusType = {
                    'tooltip': splunkUtil.sprintf(_('%s and Statistics Table').t(), vizType.tooltip),
                    'icon': vizType.icon + '-plus-table'
                };
                return vizPlusType;
            },

                /**
                 * Sets the visualization and statistics .show values that will persist to the backend
                 * from the compound key 'display.general.reports.show
                 * 'chartandtable' : visualizations = 1, statistics = 1,
                 * 'chart; : visualizations = 1, statistics = 0,
                 * 'table : visualizations = 0, statistics = 1
                 * This must be called when using display.general.reports.show in memory attr
                 */
            setVizType: function(){
                var displayType = this.entry.content.get('display.general.reports.show');
                if (displayType === 'chart'){
                    this.entry.content.set({'display.visualizations.show': '1'});
                    this.entry.content.set({'display.statistics.show': '0'});

                } else if (displayType === 'table'){
                    this.entry.content.set({'display.visualizations.show': '0'});
                    this.entry.content.set({'display.statistics.show': '1'});

                } else {
                    this.entry.content.set({'display.visualizations.show': '1'});
                    this.entry.content.set({'display.statistics.show': '1'});
                }
            },

                /**
                 * Called to set the in memory attribute display.general.reports.show based on the backend
                 * values for display.statistics.show and display.visualizations.show
                 */
            setInmemVizType: function(){
                var viz = splunkUtil.normalizeBoolean(this.entry.content.get('display.visualizations.show'));
                var stats = splunkUtil.normalizeBoolean(this.entry.content.get('display.statistics.show'));

                if (viz && stats){
                    this.entry.content.set({'display.general.reports.show': 'chartandtable'});

                } else if (viz){
                    this.entry.content.set({'display.general.reports.show': 'chart'});

                } else {
                    this.entry.content.set({'display.general.reports.show': 'table'});
                }
            },

            isAlert: function () {
                var is_scheduled = this.entry.content.get('is_scheduled'),
                    alert_type = this.entry.content.get('alert_type'),
                    alert_track = this.entry.content.get('alert.track'),
                    actions = this.entry.content.get('actions'),
                    isRealTime = this.isRealTime();

                return is_scheduled &&
                        (alert_type !== 'always' ||
                            alert_track ||
                            (isRealTime && actions)
                        );
            },
            isRealTime: function() {
                var isEarliestRealtime = time_utils.isRealtime(this.entry.content.get('dispatch.earliest_time')),
                    isLatestRealtime = time_utils.isRealtime(this.entry.content.get('dispatch.latest_time'));

                return (isEarliestRealtime && isLatestRealtime);
            },
            // see documentation of isValidPivotSearch, this is not an exhaustive check, just a quick guess.
            isPivotReport: function() {
                return general_utils.isValidPivotSearch(this.entry.content.get('search'));
            },
            stripAlertAttributes: function(options) {
                return this.entry.content.set({
                        'alert.track': 0,
                        alert_type: 'always',
                        is_scheduled: 0,
                        actions: ''
                    }, options);
            },
            stripReportAttributesToSaveAsAlert: function(options) {
                return this.entry.content.set({
                    auto_summarize: false,
                    cron_schedule: ''
                },options);
            },
            setTimeRangeWarnings: function(reportPristine) {
                var earliest = this.entry.content.get("dispatch.earliest_time"),
                    latest = this.entry.content.get("dispatch.latest_time"),
                    messages = [],
                    pristineEarliest, pristineLatest;

                if ((!time_utils.isEmpty(earliest) && time_utils.isAbsolute(earliest)) ||
                        (!time_utils.isEmpty(latest) && time_utils.isAbsolute(latest))) {
                    messages.push(
                       splunkd_utils.createMessageObject(
                            splunkd_utils.WARNING,
                            _("Your report has an absolute time range.").t()
                        )
                    );
                }

                if (reportPristine) {
                    if (reportPristine.isAlert()) {
                        pristineEarliest = reportPristine.entry.content.get("dispatch.earliest_time");
                        pristineLatest = reportPristine.entry.content.get("dispatch.latest_time");

                        if ((earliest !== pristineEarliest) || (latest !== pristineLatest)) {
                            this.entry.content.set({
                                "dispatch.earliest_time": pristineEarliest,
                                "dispatch.latest_time": pristineLatest
                            });

                             // This attribute will be read and removed by SuccessWithAdditionalSettings.js which will show another time range warning message. 
                             // Yes we are showing the same warning twice.   
                            this.set({"did_revert_time_range": true}); 

                            messages.push(
                               splunkd_utils.createMessageObject(
                                    splunkd_utils.WARNING,
                                    _("Your changes to the time range of this alert will not be saved.").t()
                                )
                            );
                        }
                    } else if (!reportPristine.isRealTime() && (reportPristine.entry.content.get('is_scheduled')) && this.isRealTime()) {
                        this.entry.content.set({
                            "is_scheduled": false
                        });

                        messages.push(
                           splunkd_utils.createMessageObject(
                                splunkd_utils.WARNING,
                                _("Saving a scheduled report as a real-time report will remove the schedule.").t()
                            )
                        );
                    }
                }

                if (messages.length) {
                    this.error.set({
                        messages: messages
                    });
                }
            },
            setAccelerationWarning: function(canSummarize, reportPristine) {
                var isCurrentModeVerbose = this.entry.content.get('display.page.search.mode') === splunkd_utils.VERBOSE,
                    messages = [];
                if (!canSummarize){
                    messages.push(
                        splunkd_utils.createMessageObject(
                            splunkd_utils.WARNING,
                            _("This report cannot be accelerated. Acceleration will be disabled.").t()
                        )
                    );
                    this.entry.content.set('auto_summarize', false);
                }
                else if (isCurrentModeVerbose && (_.isUndefined(reportPristine) || reportPristine.entry.content.get('display.page.search.mode') === splunkd_utils.VERBOSE)) {
                    messages.push(
                        splunkd_utils.createMessageObject(
                            splunkd_utils.WARNING,
                            _("A report running in verbose mode cannot be accelerated. Your search mode will be saved as Smart Mode.").t()
                        )
                    );
                    this.entry.content.set('display.page.search.mode', splunkd_utils.SMART);
                }
                else if (isCurrentModeVerbose && !_.isUndefined(reportPristine)) {
                    messages.push(
                        splunkd_utils.createMessageObject(
                            splunkd_utils.WARNING,
                            _("A report running in verbose mode cannot be accelerated. Your search mode will not be saved.").t()
                        )
                    );
                    this.entry.content.set('display.page.search.mode', reportPristine.entry.content.get('display.page.search.mode'));
                }
                if (messages.length) {
                    this.trigger('serverValidated', false, this, messages);
                    this.error.set({
                        messages: messages
                    });
                }
            },
            setSearchTab: function(options) {
                options = options || {};
                                                                                
                var tab = this.entry.content.get('display.page.search.tab') || 'statistics',
                    type = this.entry.content.get('display.general.type'),
                    searchSpecificDefaults = options.reportSearch ? this.getSearchSpecificDefaults(options.reportSearch) : {};

                if (tab === 'patterns') {
                    if (options.canPatternDetect && !options.isUneventfulReportSearch) {
                        return;
                    }
                    tab = 'events';
                }
                
                if (type && (tab !== type)) {
                    tab = type;
                }
                    
                if (tab === 'events') {
                    if (options.isTransforming) {
                        tab = searchSpecificDefaults['display.page.search.tab'] || 'statistics';
                    }
                } else if ((tab === 'statistics') || (tab === 'visualizations')) {
                    if (!options.isTransforming){
                        tab = 'events';
                    }
                }
                
                this.entry.content.set({'display.page.search.tab': tab}, options);
            },
            setDisplayType: function(isTransforming, reportSearch, options) {
                var type = this.entry.content.get('display.general.type') || 'statistics',
                    searchSpecificDefaults = reportSearch ? this.getSearchSpecificDefaults(reportSearch) : {};

                if (type === 'events') {
                    if (isTransforming) {
                        type = searchSpecificDefaults['display.general.type'] || 'statistics';
                    }
                } else if ((type === 'statistics') || (type === 'visualizations')) {
                    if (!isTransforming){
                        type = 'events';
                    }
                }
                this.entry.content.set({'display.general.type': type}, options);
            },
            getSearchSpecificDefaults: function(reportSearch) {
                // if the search string is using 'geostats', the report should show as a map
                if (/(^geostats)|([|\s]geostats\s)/.test(reportSearch || '')) {
                    return ({
                        'display.general.type': 'visualizations',
                        'display.page.search.tab': 'visualizations',
                        'display.visualizations.type': 'mapping',
                        'display.visualizations.mapping.type': 'marker'
                    });
                }
                // if the search string is using 'geom', the report should show as a choropleth map
                if ((/\|\s*geom\s+/).test(reportSearch || '')) {
                    return ({
                        'display.general.type': 'visualizations',
                        'display.page.search.tab': 'visualizations',
                        'display.visualizations.type': 'mapping',
                        'display.visualizations.mapping.type': 'choropleth'
                    });
                }
                return {};
            },
            isDirty: function(otherReport, whitelist) {
                whitelist = whitelist || ReportModel.DIRTY_WHITELIST;
                
                var thisContent = general_utils.filterObjectByRegexes(this.entry.content.toJSON(), whitelist),
                    otherContent = general_utils.filterObjectByRegexes(otherReport.entry.content.toJSON(), whitelist);

                return !(_.isEqual(
                    this.filterInputToSaveableFields(thisContent),
                    this.filterInputToSaveableFields(otherContent)
                ));
            },
            canDelete: function() {
                return this.entry.links.get("remove") ? true : false;
            },
            canWrite: function(canScheduleSearch, canRTSearch) {
                return this.entry.acl.get('can_write') &&
                        !(this.entry.content.get('is_scheduled') && !canScheduleSearch) &&
                        !(this.isRealTime() && !canRTSearch);
            },
            canClone: function(canScheduleSearch, canRTSearch) {
                return !(this.entry.content.get('is_scheduled') && !canScheduleSearch) &&
                        !(this.isRealTime() && !canRTSearch);
            },
            canEmbed: function(canScheduleSearch, canEmbed) {
                return this.entry.acl.get('can_write') && canScheduleSearch && !this.isRealTime() && canEmbed;
            },
            getStringOfActions: function() {
                var actionArray = [];

                if (this.entry.content.get("action.email") || this.entry.content.get("action.script")) {
                    var actions = this.entry.content.get("actions");

                    if (actions.search('email') != -1) {
                        actionArray.push(_('Send Email').t());
                    }
                    if (actions.search('script') != -1) {
                        actionArray.push(_('Run a Script').t());
                    }
                }

                if (this.entry.content.get('alert.track')) {
                    actionArray.push(_('List in Triggered Alerts').t());
                }

                return actionArray.join(_(', ').t());
            },
            routeToViewReport: function(root, locale, app, sid) {
                var data = {s: this.id};
                
                if (this.isAlert()) {
                    return route.alert(root, locale, app, {data: data});
                }
                if (sid) {
                    data.sid = sid;
                }
                return route.report(root, locale, app, {data: data});
            },
            getNearestMaxlines: function() {
                var maxLines = parseInt(this.entry.content.get('display.events.maxLines'), 10);
                if (isNaN(maxLines)) {
                    maxLines = 5;
                }
                return "" + math_utils.nearestMatchAndIndexInArray(maxLines, [5, 10, 20, 50, 100, 200, 0]).value;
            },
            getSortingSearch: function() {
                var search,
                    content = this.entry.content,
                    offset = content.get('display.prefs.events.offset'),
                    count = content.get('display.prefs.events.count'),
                    sortColumn = content.get('display.events.table.sortColumn');
                    
                if (sortColumn && !_.isUndefined(offset) && !_.isUndefined(count)) {
                    search = ('| sort ' + (parseInt(offset, 10) + parseInt(count, 10)) + ((content.get('display.events.table.sortDirection') === 'desc') ? ' - ': ' ') + sortColumn);
                }
                return search;
            },
            getDisplayEventsFields: function(options) {
                options || (options={});
                var object,
                    fields = [];
                _.each(this.entry.content.toObject('display.events.fields') || [], function(value) {
                    if (options.key) {
                        object = {};
                        object[options.key] = value;
                        fields.push(object);
                    } else {
                        fields.push(value);
                    }
                });
                
                return fields;
            }
        },
        {
            DOCUMENT_TYPES: {
                ALERT: 'alert',
                PIVOT_REPORT: 'pivot-report',
                REPORT: 'report'
            },
            DIRTY_WHITELIST: [
                '^dispatch\.earliest_time$',
                '^dispatch\.latest_time$',
                '^display\.*$',
                '^search$'
            ]
        });
        return ReportModel;
    }
);

define(
    'collections/services/saved/Searches',[
        'models/services/saved/Search',
        'collections/SplunkDsBase'
    ],
    function(Model, Collection) {
        return Collection.extend({
            initialize: function() {
                Collection.prototype.initialize.apply(this, arguments);
            },
            url: 'saved/searches',
            model: Model
        },
        {
            ALERT_SEARCH_STRING: '(is_scheduled=1 AND (alert_type!=always OR alert.track=1 OR (dispatch.earliest_time="rt*" AND dispatch.latest_time="rt*" AND actions="*" AND actions!="")))'
        });
    }
);

define(
    'collections/search/Reports',[
        "models/search/Report",
        "collections/services/saved/Searches"
    ],
    function(ReportModel, SavedSearchCollection) {
        return SavedSearchCollection.extend({
            model: ReportModel,
            initialize: function() {
                SavedSearchCollection.prototype.initialize.apply(this, arguments);
            },
            sync: function(method, model, options) {
                switch (method) {
                    case 'read' :
                        options = options || {};
                        if (options.excludeAlerts) {
                            options.data = options.data || {};
                            var search = 'NOT (' + this.constructor.ALERT_SEARCH_STRING + ')';
                            if (options.data.search) {
                                search += ' AND ' + options.data.search;
                            }
                            options.data.search = search; 
                        }
                        break;
                }
                return SavedSearchCollection.prototype.sync.apply(this, arguments);
            }
        });
    }
);

define(
    'models/shared/Cron',[
        'jquery',
        'underscore',
        'models/Base',
        'splunk.util'
    ],
    function($, _, BaseModel, splunkUtil) {
        var Cron = BaseModel.extend({
            initialize: function() {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            defaults: {
                minute: '0',
                hour: '6',
                dayOfMonth: '*',
                month: '*',
                dayOfWeek: "1",
                cronType: 'weekly',
                cron_schedule: '0 6 * * 1'
            },
            validation: {
                'cron_schedule': function(value, attr, computedState) {
                    var type = computedState['ui.type'] || 'scheduled';
                    if (type === 'scheduled' && computedState['cronType'] === 'custom') {
                        if (_.isUndefined(value) || $.trim(value).length === 0) {
                            return _("Custom cron is required").t();
                        }
                        if (!splunkUtil.validateCronString(value)) {
                            return _("Invalid cron").t();
                        }
                    }
                }
            },
            setCronType: function(options) {
                var minute = this.get('minute'),
                    hour = this.get('hour'),
                    dayOfMonth = this.get('dayOfMonth'),
                    month = this.get('month'),
                    dayOfWeek = this.get('dayOfWeek');

                //outliers
                if (month !== "*") {
                    this.set('cronType', Cron.CRON_TYPES.CUSTOM, options);
                    return;
                }

                //if day of week is not * then we to test for weekly
                if (/^[0-6]$/.test(dayOfWeek)) {
                    if (
                        (minute === '0') &&
                        (/^([0-9]|1[0-9]|2[0-3])$/.test(hour)) &&
                        (dayOfMonth === '*')
                    ) {
                        this.set('cronType', Cron.CRON_TYPES.WEEKLY, options);
                        return;
                    }
                } else if (dayOfWeek === '*') {
                    //test for monthly
                    if (/^([0-9]|[1-2][0-9]|3[0-1])$/.test(dayOfMonth)) {
                        if (
                            (/^([0-9]|1[0-9]|2[0-3])$/.test(hour)) &&
                            (minute === '0')
                        ) {
                            this.set('cronType', Cron.CRON_TYPES.MONTHLY, options);
                            return;
                        }
                    } else if (dayOfMonth === '*') {
                        //test for daily by testing hour
                        if (
                            (/^([0-9]|1[0-9]|2[0-3])$/.test(hour)) &&
                            (minute === '0')
                        ) {
                            this.set('cronType', Cron.CRON_TYPES.DAILY, options);
                            return;
                        } else if (
                            hour === '*' &&
                            (/^(0|15|30|45)$/.test(minute))
                        ) {
                            this.set('cronType', Cron.CRON_TYPES.HOURLY, options);
                            return;
                        }
                    }
                }

                this.set('cronType', Cron.CRON_TYPES.CUSTOM, options);
            },
            setDefaults: function() {
                switch (this.get('cronType')) {
                    case Cron.CRON_TYPES.HOURLY:
                        this.set('minute', '0');
                        break;
                    case Cron.CRON_TYPES.DAILY:
                        this.set('hour', '0');
                        break;
                    case Cron.CRON_TYPES.WEEKLY:
                        this.set({
                            dayOfWeek: '1',
                            hour: '0'
                        });
                        break;
                    case Cron.CRON_TYPES.MONTHLY:
                        this.set({
                            dayOfMonth: '1',
                            hour: '0'
                        });
                        break;
                }
            },
            getCronString: function() {
                var minute = this.get('minute'),
                    hour = this.get('hour'),
                    dayOfMonth = this.get('dayOfMonth'),
                    month = this.get('month'),
                    dayOfWeek = this.get('dayOfWeek'),
                    cron_schedule = this.get('cron_schedule'),
                    cronType = this.get('cronType');

                switch(cronType) {
                    case Cron.CRON_TYPES.HOURLY:
                        return minute + ' * * * *';
                    case Cron.CRON_TYPES.DAILY:
                        return '0 ' + hour +  ' * * *';
                    case Cron.CRON_TYPES.WEEKLY:
                        return '0 ' + hour +  ' * * ' + dayOfWeek;
                    case Cron.CRON_TYPES.MONTHLY:
                        return '0 ' + hour + ' ' + dayOfMonth + ' * *';
                    case Cron.CRON_TYPES.CUSTOM:
                        return cron_schedule;
                }
            },
            getDayOfWeekName: function() {
                return Cron.getDayOfWeekNameFromNum(parseInt(this.get('dayOfWeek'), 10));
            },
            getScheduleString: function() {
                switch(this.get('cronType')) {
                    case 'hourly':
                        return splunkUtil.sprintf(_("Hourly, at %s minutes past the hour.").t(), this.get('minute'));
                    case 'daily':
                        return splunkUtil.sprintf(_("Daily, at %s:00.").t(), this.get('hour'));
                    case 'weekly':
                        return splunkUtil.sprintf(_("Weekly, %(dayOfWeek)s at %(hour)s:00.").t(), { dayOfWeek: this.getDayOfWeekName(), hour: this.get('hour')});
                    case 'monthly':
                        return splunkUtil.sprintf(_("Monthly, on day %(dayOfMonth)s at %(hour)s:00.").t(), { dayOfMonth: this.get('dayOfMonth'), hour: this.get('hour')});
                    case 'custom':
                        return _("Cron Schedule.").t();
                }
            }
        },
        // class-level properties
        {
            createFromCronString: function(cronString) {
                var pieces = cronString.trim().split(/\s+/);
                if(!pieces || pieces.length !== 5) {
                    throw splunkUtil.sprintf(_("Invalid cron string: %s").t(), cronString);
                }
                // the above only verifies that the time string had the correct format,
                // next make sure it also represents a valid time
                var cronModel = new Cron({
                    minute: pieces[0],
                    hour: pieces[1],
                    dayOfMonth: pieces[2],
                    month: pieces[3],
                    dayOfWeek: pieces[4],
                    cron_schedule: pieces.join(' ')
                });

                cronModel.setCronType();
                return cronModel;
            },
            getDayOfWeekNameFromNum: function(dayOfWeekNum) {
                switch(dayOfWeekNum) {
                    case 0:
                        return _("Sunday").t();
                    case 1:
                        return _("Monday").t();
                    case 2:
                        return _("Tuesday").t();
                    case 3:
                        return _("Wednesday").t();
                    case 4:
                        return _("Thursday").t();
                    case 5:
                        return _("Friday").t();
                    case 6:
                        return _("Saturday").t();
                    case 7:
                        return _("Sunday").t();
                }
            },
            CRON_TYPES : {
                HOURLY: 'hourly',
                DAILY: 'daily',
                WEEKLY: 'weekly',
                MONTHLY: 'monthly',
                CUSTOM: 'custom'
            }
        });

        return Cron;
    }
);

define(
    'models/services/search/TimeParser',[
        'jquery',
        'underscore',
        'backbone',
        'models/Base',
        'util/splunkd_utils'
    ],
    function($, _, Backbone, BaseModel, splunkd_utils) {
        return BaseModel.extend({
            initialize: function(options) {
                BaseModel.prototype.initialize.call(this, options);
            },
            sync: function(method, model, options) {
                switch (method) {
                    case 'read':
                        var syncOptions = splunkd_utils.prepareSyncOptions(options, model.url);
                        if (options.data.time === ''){
                            model.set({key: '', value: ''});
                            return;
                        }
                        return Backbone.sync.call(this, 'read', model, syncOptions);
                    default:
                        throw 'Operation not supported';
                }
            },
            url: "/services/search/timeparser",
            parse:  function(response) {
                if (!response) {
                    return {};
                }
                var key = _.keys(response)[0],
                    value = response[key];
                return {
                    key: key,
                    value: value
                };
            },
            idAttribute: 'key'
        });
    }
);
define(
    'collections/services/search/TimeParsers',[
        "underscore",
        "backbone",
        "models/services/search/TimeParser",
        "collections/Base",
        "util/splunkd_utils"
    ],
    function(_, Backbone, TimeParserModel, CollectionsBase, splunkDUtils) {
        return CollectionsBase.extend({
            model: TimeParserModel,
            intialize: function() {
                CollectionsBase.prototype.initialize.apply(this, arguments);
            },
            sync: function(method, collection, options) {
                var appOwner = {},
                    defaults = {
                        data: {output_mode: "json"},
                        traditional: true
                    };
                switch (method) {
                    case 'read':
                        if (options && options.data){
                            appOwner = $.extend(appOwner, { //JQuery purges undefined
                                app: options.data.app || undefined,
                                owner: options.data.owner || undefined
                            });
                            delete options.data.app;
                            delete options.data.owner;
                        }
                        defaults.url = splunkDUtils.fullpath(collection.url, appOwner);
                        $.extend(true, defaults, options || {});
                        return Backbone.sync.call(this, 'read', collection, defaults);
                    default:
                        throw 'Operation not supported';
                }
            },
            url: "/services/search/timeparser",
            parse: function(response) {
                var model,
                    models = [];
                for (var key in response) {
                    model = {};
                    model[key] = response[key];
                    models.push(model);
                }
                return models;
            }
        });
    }
);

define(
    'models/shared/TimeRange',[
        'jquery',
        'underscore',
        'splunk.i18n',
        'models/Base',
        'collections/services/search/TimeParsers',
        'util/splunkd_utils',
        'util/time'
    ],
    function($, _, i18n, BaseModel, TimeParsersCollection, splunkd_utils, time_utils) {
        return BaseModel.extend({
            initialize: function() {
                BaseModel.prototype.initialize.apply(this, arguments);
                this.timeParsers = new TimeParsersCollection();
                this.associated.timeParsers = this.timeParsers;
                this.units = time_utils.TIME_UNITS;
            },
            clear: function(options) {
                delete this.timeParsersXHR;
                return BaseModel.prototype.clear.apply(this, arguments);
            },
            defaults: {
                enableRealTime: true
            },
            validation: {
                earliest: [
                    {},
                    {
                        fn: 'validateTime'
                    }
                ],
                latest: [
                    {},
                    {
                        fn: 'validateTime'
                    }
                ]
            },
            validateTime: function(value, attr, computedState) {
                var earliest_time_attr = (computedState.earliest || ""),
                    latest_time_attr = (computedState.latest || ""),
                    enableRealTime = this.get('enableRealTime'),
                    is_earliest_rt = time_utils.isRealtime(earliest_time_attr),
                    is_latest_rt = time_utils.isRealtime(latest_time_attr),
                    earliest_time = time_utils.stripRTSafe(earliest_time_attr, false),
                    latest_time = time_utils.stripRTSafe(latest_time_attr, true);
                
                if (earliest_time && latest_time && (earliest_time === latest_time) && (attr === "latest")) {
                    return _("You cannot have equivalent times.").t();
                } else if (!enableRealTime) {
                    if (((is_earliest_rt && is_latest_rt) && (attr === "latest")) ||
                            ((is_earliest_rt && !is_latest_rt && (attr === "earliest")) ||
                            (is_latest_rt && !is_earliest_rt && (attr === "latest")))) {
                        return _("rt time values are not allowed").t();
                    }
                } else {
                    if (is_earliest_rt && !is_latest_rt && (attr === "latest")) {
                        return _("You must set a rt value for latest time if you set a rt value for earliest time.").t();
                    } else if (!is_earliest_rt && is_latest_rt && (attr === "earliest")) {
                        return _("You must set a rt value for earliest time if you set a rt value for latest time.").t();
                    }                    
                }
            },
            sync: function(method, model, options) {
                var deferredResponse = $.Deferred(),
                    rootModel = model,
                    rootOptions = options,
                    timeParsers,
                    timeParsersISO,
                    times = [],
                    data = {},
                    error_msg,
                    latest,
                    earliest;
                
                model.trigger('request', model, deferredResponse, options);

                switch (method) {
                    case 'create':
                        earliest = time_utils.stripRTSafe(((model.get('earliest') || '') + ''), false);
                        if (earliest) {
                            times.push(earliest);
                        }   
                        latest = time_utils.stripRTSafe(((model.get('latest') || '') + ''), true);
                        if (latest) {
                            times.push(latest);
                        }
                        if (!times.length) {
                            options.success(data);
                            deferredResponse.resolve.apply(deferredResponse);
                            return deferredResponse.promise();
                        }

                        //get epoch
                        this.timeParsers.reset([]);
                        this.timeParsersXHR = this.timeParsers.fetch({
                            data: {
                                time: times,
                                output_time_format: '%s.%Q|%Y-%m-%dT%H:%M:%S.%Q%:z'
                            },  
                            success: function() {
                                var timeParserEarliest = this.timeParsers.get(earliest),
                                    timeParserEarliestParts = timeParserEarliest ? (timeParserEarliest.get('value') || '').split('|') : [],
                                    timeParserEarliestEpoch = timeParserEarliestParts[0],
                                    timeParserEarliestISO = timeParserEarliestParts[1],
                                    timeParserLatest = this.timeParsers.get(latest),
                                    timeParserLatestParts = timeParserLatest ? (timeParserLatest.get('value') || '').split('|') : [],
                                    timeParserLatestEpoch = timeParserLatestParts[0],
                                    timeParserLatestISO = timeParserLatestParts[1];
                                if (timeParserEarliest) {
                                    data.earliest_epoch = parseFloat(timeParserEarliestEpoch);
                                }
                                if (timeParserLatest) {
                                    data.latest_epoch = parseFloat(timeParserLatestEpoch);
                                }
                                if (timeParserEarliestISO) {
                                    data.earliest_iso = timeParserEarliestISO;
                                    data.earliest_date = time_utils.isoToDateObject(timeParserEarliestISO);
                                }
                                if (timeParserLatestISO) {
                                    data.latest_iso = timeParserLatestISO;
                                    data.latest_date = time_utils.isoToDateObject(timeParserLatestISO);
                                }
                                if (timeParserEarliest && timeParserLatest) {
                                    var earliestRounded = (Math.round(data.earliest_epoch * 1000) / 1000),
                                        latestRounded = (Math.round(data.latest_epoch * 1000) / 1000);
                                    
                                    if (earliestRounded === latestRounded) {
                                        error_msg = splunkd_utils.createSplunkDMessage(
                                            splunkd_utils.ERROR,
                                            _("You cannot have equivalent times.").t()
                                        );
                                    }
                                    if (earliestRounded > latestRounded) {
                                        error_msg = splunkd_utils.createSplunkDMessage(
                                            splunkd_utils.ERROR,
                                            _("Earliest time cannot be greater than latest time.").t()
                                        );
                                    }
                                    if (error_msg) {
                                        rootOptions.error(error_msg);
                                        return;
                                    }
                                }
                                rootOptions.success(data);
                            }.bind(this),
                            error: function() {
                                var message = splunkd_utils.createSplunkDMessage(
                                    splunkd_utils.ERROR,
                                    _("You have an invalid time in your range.").t()
                                );
                                rootOptions.error(message);                                
                            }
                        });
                        
                        this.timeParsersXHR.done(function(){
                            deferredResponse.resolve.apply(deferredResponse, arguments);
                        });
                        
                        this.timeParsersXHR.fail(function(){
                            deferredResponse.reject.apply(deferredResponse, arguments);
                        });
                        
                        return deferredResponse.promise();
                    default:
                        throw 'Operation not supported';
                }
            },
            
            /**
             * Convenience pass through methods to time_utils
             */
            getTimeParse: function(attr) {
                return time_utils.parseTimeString(this.get(attr));
            },
            isRealtime: function(attr) {
                return time_utils.isRealtime(this.get(attr));
            },
            isAbsolute: function(attr) {
                return time_utils.isAbsolute(this.get(attr));
            },
            isEpoch: function(attr) {
                return time_utils.isEpoch(this.get(attr));
            },
            isWholeDay: function(attr) {
                return time_utils.timeAndJsDateIsWholeDay(this.get(attr), this.get(attr + '_date'));
            },
            latestIsNow: function() {
                return time_utils.isNow(this.get('latest'));
            },
            hasNoEarliest: function() {
                return time_utils.isEmpty(this.get('earliest'));
            },

            isRangeSnappedToSeconds: function() {
                var earliestDate = this.get('earliest_date'),
                    latestDate = this.get('latest_date');

                if (earliestDate && (earliestDate.getMilliseconds() !== 0)) {
                    return false;
                }
                if (latestDate && (latestDate.getMilliseconds() !== 0)) {
                    return false;
                }
                return true;
            },

            /**
            * presets: <collections.services.data.ui.TimesV2>
            **/
            generateLabel: function(presets) {               
                return time_utils.generateLabel(presets, this.get('earliest'), this.get("earliest_date"), this.get('latest'), this.get("latest_date"));
            },
            fetchAbort: function() {
                BaseModel.prototype.fetchAbort();
                if (this.timeParsersXHR && this.timeParsersXHR.state && this.timeParsersXHR.state()==='pending') {
                    this.timeParsersXHR.abort();
                }
            }
        });
    }
);

define(
    'models/search/Alert',[
        'jquery',
        'underscore',
        'models/Base',
        'models/ACLReadOnly',
        'models/search/Report',
        'models/shared/Cron',
        'models/shared/TimeRange',
        'util/time',
        'util/splunkd_utils',
        'splunk.util',
        'splunk.i18n',
        'util/math_utils'
    ],
    function(
        $,
        _,
        BaseModel,
        ACLReadOnlyModel,
        ReportModel,
        CronModel,
        TimeRangeModel,
        time_utils,
        splunkd_utils,
        splunkUtil,
        i18n,
        mathUtils
    ){
        var EntryContentDefaults = {
            'ui.type': 'scheduled',
            'ui.realtime.triggercondition': 'per_result',
            'ui.realtime.resultscomparator': 'greater than',
            'ui.realtime.resultstimeunit': 'm',
            'ui.realtime.resultscomparatorinput': '0',
            'ui.realtime.resultstime': '1',
            'ui.realtime.customsearch': void(0),
            'ui.scheduled.triggercondition': 'events',
            'ui.scheduled.resultscomparator': 'greater than',
            'ui.scheduled.resultsinput': '0',
            'ui.permissions': splunkd_utils.USER,
            'ui.executeactions': true,
            'ui.supresstime': 60,
            'ui.supresstimeunit': 's'
        };
        var Model = ReportModel.extend({
            initialize: function(attributes, options) {
                ReportModel.prototype.initialize.apply(this, arguments);
            },
            setFromSplunkD: function(payload, options) {
                ReportModel.prototype.setFromSplunkD.apply(this, arguments);
                this.transposeFromSavedsearch();
                return;
            },
            validateAssociated: function() {
                var validCronandWorkingTimerange = true;
                this.entry.content.validate();
                if (this.cron.get('cronType') === 'custom' &&
                    this.entry.content.get('ui.type') === 'scheduled') {
                    this.cron.validate();
                    this.workingTimeRange.validate();
                    validCronandWorkingTimerange = this.cron.isValid() && this.workingTimeRange.isValid();
                } else {
                    this.cron.clearErrors();
                    this.workingTimeRange.clearErrors();
                }
                return validCronandWorkingTimerange && this.entry.content.isValid();    
            },
            parse: function(response) {
                var parsedResponse = ReportModel.prototype.parse.apply(this, arguments);
                this.transposeFromSavedsearch();
                return parsedResponse;
            },
            sync: function(method, model, options) {
                if (method === 'create' || method === 'update') {
                    this.transposeToSavedsearch();
                    if (!this.isAlert()) {
                        throw new Error("Can not edit a report with an alert model.");
                    }
                }

                return ReportModel.prototype.sync.apply(this, arguments);
            },
            setNewAlertAttr: function() {
                this.entry.set('name', '');
                this.entry.content.set({
                    // for backwards compatibility
                    'action.email.useNSSubject': '1',
                    // should not accelerate an alert
                    'action.summary_index': '0',
                    'disabled': false,
                    'is_scheduled': 1
                });
            },
            canNotEditInUI: function() {
                // can not edit in ui if realtime alltime with trigger type other than always
                return (this.entry.content.get('dispatch.earliest_time')==='rt' ||
                        this.entry.content.get('dispatch.latest_time') ==='rt') &&
                    this.entry.content.get('alert_type') !== 'always';
            },
            initializeAssociated: function() {
                ReportModel.prototype.initializeAssociated.apply(this, arguments);
                var RootClass = this.constructor;
                this.associated = this.associated || {};
                
                this.cron = this.cron || new RootClass.Cron();
                this.associated.cron = this.cron;
                
                this.workingTimeRange = this.workingTimeRange || new RootClass.WorkingTimeRange({enableRealTime:false});
                this.associated.workingTimeRange = this.workingTimeRange;
            },
            transposeToSavedsearch: function() {
                switch(this.entry.content.get('ui.type')){
                    case 'realtime':
                        if (this.entry.content.get('ui.realtime.triggercondition') != 'per_result'){
                            if(this.entry.content.get('ui.realtime.resultstime')){
                                this.entry.content.set({
                                    'dispatch.earliest_time': 'rt-' + this.entry.content.get('ui.realtime.resultstime') + '' + this.entry.content.get('ui.realtime.resultstimeunit'),
                                    'dispatch.latest_time': 'rt-0' + this.entry.content.get('ui.realtime.resultstimeunit'),
                                    'cron_schedule': '* * * * *'
                                });
                            }
                        } else {
                            this.entry.content.set({
                                'dispatch.earliest_time': 'rt',
                                'dispatch.latest_time': 'rt',
                                'cron_schedule': '* * * * *'
                            });
                        }
                        
                        switch(this.entry.content.get('ui.realtime.triggercondition')){
                            case 'per_result':
                                this.entry.content.set('alert_type', 'always');
                                break;
                            case 'events':
                                this.entry.content.set({
                                    'alert_type': 'number of events',
                                    'alert_comparator': this.entry.content.get('ui.realtime.resultscomparator'),
                                    'alert_threshold': this.entry.content.get('ui.realtime.resultscomparatorinput')
                                });
                                break;
                            case 'hosts':
                                this.entry.content.set({
                                    'alert_type': 'number of hosts',
                                    'alert_comparator': this.entry.content.get('ui.realtime.resultscomparator'),
                                    'alert_threshold': this.entry.content.get('ui.realtime.resultscomparatorinput')
                                });
                                break;
                            case 'sources':
                                this.entry.content.set({
                                    'alert_type': 'number of sources',
                                    'alert_comparator': this.entry.content.get('ui.realtime.resultscomparator'),
                                    'alert_threshold': this.entry.content.get('ui.realtime.resultscomparatorinput')
                                });
                                break;
                            case 'custom':
                                this.entry.content.set({
                                    'alert_type': 'custom',
                                    'alert_condition': this.entry.content.get('ui.realtime.customsearch')
                                });
                                break;
                        }
                        break;
                    case 'scheduled':
                        switch(this.entry.content.get('ui.scheduled.triggercondition')){
                            case 'events':
                                this.entry.content.set({
                                    'alert_type': 'number of events',
                                    'alert_comparator': this.entry.content.get('ui.scheduled.resultscomparator'),
                                    'alert_threshold': this.entry.content.get('ui.scheduled.resultsinput')
                                });
                                break;
                            case 'hosts':
                                this.entry.content.set({
                                    'alert_type': 'number of hosts',
                                    'alert_comparator': this.entry.content.get('ui.scheduled.resultscomparator'),
                                    'alert_threshold': this.entry.content.get('ui.scheduled.resultsinput')
                                });
                                break;
                            case 'sources':
                                this.entry.content.set({
                                    'alert_type': 'number of sources',
                                    'alert_comparator': this.entry.content.get('ui.scheduled.resultscomparator'),
                                    'alert_threshold': this.entry.content.get('ui.scheduled.resultsinput')
                                });
                                break;
                            case 'custom':
                                this.entry.content.set({
                                    'alert_type': 'custom',
                                    'alert_condition': this.entry.content.get('ui.scheduled.customsearch')
                                });
                                break;
                        }
                        switch(this.cron.get('cronType')){
                            case 'hourly':
                                this.entry.content.set({
                                    'dispatch.earliest_time': '-1h',
                                    'dispatch.latest_time': 'now'
                                });
                                break;
                            case 'daily':
                                this.entry.content.set({
                                    'dispatch.earliest_time': '-1d',
                                    'dispatch.latest_time': 'now'
                                });
                                break;
                            case 'weekly':
                                this.entry.content.set({
                                    'dispatch.earliest_time': '-1w',
                                    'dispatch.latest_time': 'now'
                                });
                                break;
                            case 'monthly':
                                this.entry.content.set({
                                    'dispatch.earliest_time': '-1mon',
                                    'dispatch.latest_time': 'now'
                                });
                                break;
                            case 'custom':
                                this.entry.content.set({
                                    'dispatch.earliest_time': this.workingTimeRange.get('earliest'),
                                    'dispatch.latest_time': this.workingTimeRange.get('latest')
                                });
                                break;
                        }
                        this.entry.content.set({'cron_schedule': this.cron.getCronString()});
                        break;
                }
                
                if (this.entry.content.has('ui.executeactions') && this.entry.content.get('ui.executeactions') &&
                    !(this.entry.content.get('ui.type') === 'realtime' &&
                        this.entry.content.get('ui.realtime.triggercondition') === 'per_result')) {
                    this.entry.content.set({
                        'alert.digest_mode' : 1
                    });
                } else {
                    this.entry.content.set({
                        'alert.digest_mode' : 0
                    });
                }
                
                if (this.entry.content.get('alert.suppress')) {
                    this.entry.content.set({
                        'alert.suppress.period': this.entry.content.get('ui.supresstime') + this.entry.content.get('ui.supresstimeunit')
                    });
                    if (!(this.entry.content.get('ui.type') == 'realtime' &&
                            this.entry.content.get('ui.realtime.triggercondition') == 'per_result') &&
                        this.entry.content.get('ui.executeactions')) {
                        this.entry.content.set('alert.suppress.fields', '');
                    }
                } else {
                    // ensurse 'alert.supress' is not null
                    this.entry.content.set('alert.suppress', 0);
                }
                
                if (this.entry.content.get('action.email')) {
                    this.entry.content.set({
                        'action.email.sendresults': +(
                            splunkUtil.normalizeBoolean(this.entry.content.get('action.email.sendpdf')) || 
                            splunkUtil.normalizeBoolean(this.entry.content.get('action.email.sendcsv')) || 
                            splunkUtil.normalizeBoolean(this.entry.content.get('action.email.inline'))
                        )
                    });
                } else {
                    //SPL-100249 must not send action.email.to if action.email is not true. This way
                    //if an invalid email is enterned it is not sent and it does not remove a
                    //previously valid email
                    this.entry.content.set('action.email.to', '');
                }
                
                if (!this.entry.content.get('action.script')) {
                    //SPL-100872 must not send action.script.filename if action.script is not true. This way
                    //if an invalid filename is enterned it is not sent and it does not remove a
                    //previously valid filename
                    this.entry.content.set('action.script.filename', '');
                }
                
                var actions = [];
                 _.each(this.entry.content.attributes, function(value, attr) {
                    if (value == true) {
                        var actionName = attr.match(/^action.([^\.]*)$/);
                        if (actionName) {
                            actions.push(actionName[1]);
                        }
                    }
                });
                 
                // set actions
                this.entry.content.set('actions', actions.join(', '));
            },
            transposeFromSavedsearch: function() {
                // saving isAlert so even after changing attrs here we know what it came in as 
                var isAlert = this.isAlert();
                if (this.isNew()) {
                    // Create alert
                    if (!isAlert) {
                        // if new alert from a saved report not of type alert
                        this.stripReportAttributesToSaveAsAlert();
                    }
                    this.setNewAlertAttr();
                } else {
                    // Edit alert
                    if (!isAlert) {
                        throw new Error("Can not edit a report with an alert model.");
                    }
                }
                if (isAlert) {
                    this.transposeFromSavedsearchAlert();
                }
            },
            transposeFromSavedsearchAlert: function() {
                // Settings
                var triggercondition = this.entry.content.get('alert_type'),
                    earliestTime = this.entry.content.get('dispatch.earliest_time'),
                    latestTime = this.entry.content.get('dispatch.latest_time'),
                    type = this.isRealTime() ? 'realtime' : 'scheduled',
                    attr = {
                        'ui.type': type
                    };
                    
                this.workingTimeRange.set({
                    'earliest': earliestTime,
                    'latest': latestTime
                });
                
                switch(type){
                    case 'realtime' :
                        var timeMatch = earliestTime.match(/\d+/);
                        switch(triggercondition) {
                            case 'always' :
                                attr['ui.realtime.triggercondition'] = 'per_result';
                                break;
                            case 'number of events' :
                                attr['ui.realtime.triggercondition'] = 'events';
                                attr['ui.realtime.resultscomparator'] = this.entry.content.get('alert_comparator');
                                attr['ui.realtime.resultscomparatorinput'] = this.entry.content.get('alert_threshold');
                                attr['ui.realtime.resultstime'] = timeMatch ? timeMatch[0] : "0";
                                attr['ui.realtime.resultstimeunit'] = _.indexOf(['d', 'h', 'm'], earliestTime.match(/[a-z]$/)[0]) === -1 ? 'm' : earliestTime.match(/[a-z]$/)[0];
                                break;
                            case 'number of hosts' :
                                attr['ui.realtime.triggercondition'] = 'hosts';
                                attr['ui.realtime.resultscomparator'] = this.entry.content.get('alert_comparator');
                                attr['ui.realtime.resultscomparatorinput'] = this.entry.content.get('alert_threshold');
                                attr['ui.realtime.resultstime'] = timeMatch ? timeMatch[0] : "0";
                                attr['ui.realtime.resultstimeunit'] = _.indexOf(['d', 'h', 'm'], earliestTime.match(/[a-z]$/)[0]) === -1 ? 'm' : earliestTime.match(/[a-z]$/)[0];
                                break;
                            case 'number of sources' :
                                attr['ui.realtime.triggercondition'] = 'sources';
                                attr['ui.realtime.resultscomparator'] = this.entry.content.get('alert_comparator');
                                attr['ui.realtime.resultscomparatorinput'] = this.entry.content.get('alert_threshold');
                                attr['ui.realtime.resultstime'] = timeMatch ? timeMatch[0] : "0";
                                attr['ui.realtime.resultstimeunit'] = _.indexOf(['d', 'h', 'm'], earliestTime.match(/[a-z]$/)[0]) === -1 ? 'm' : earliestTime.match(/[a-z]$/)[0];
                                break;
                            case 'custom' :
                                attr['ui.realtime.triggercondition'] = 'custom';
                                attr['ui.realtime.customsearch'] = this.entry.content.get('alert_condition');
                                attr['ui.realtime.resultstime'] = timeMatch ? timeMatch[0] : "0";
                                attr['ui.realtime.resultstimeunit'] = _.indexOf(['d', 'h', 'm'], earliestTime.match(/[a-z]$/)[0]) === -1 ? 'm' : earliestTime.match(/[a-z]$/)[0];
                                break;
                        }
                        break;
                    case 'scheduled' :
                        if (this.entry.content.get('cron_schedule')) {
                            this.cron = CronModel.createFromCronString(this.entry.content.get('cron_schedule'));
                            //check if earliest latest are defaults if not set cronType to custom
                            switch(this.cron.get('cronType')){
                                case 'hourly':
                                    if (earliestTime !== '-1h' || latestTime !== 'now') {
                                        this.cron.set('cronType', 'custom');
                                    }
                                    break;
                                case 'daily':
                                    if (earliestTime !== '-1d' || latestTime !== 'now') {
                                        this.cron.set('cronType', 'custom');
                                    }
                                    break;
                                case 'weekly':
                                    if (earliestTime !== '-1w' || latestTime !== 'now') {
                                        this.cron.set('cronType', 'custom');
                                    }
                                    break;
                                case 'monthly':
                                    if (earliestTime !== '-1mon' || latestTime !== 'now') {
                                        this.cron.set('cronType', 'custom');
                                    }
                                    break;
                            }
                        }
                        switch(triggercondition) {
                            case 'always' :
                                    attr['ui.scheduled.triggercondition'] = 'events';
                                    attr['ui.scheduled.resultscomparator'] = 'greater than';
                                    attr['ui.scheduled.resultsinput'] = '0';
                                break;
                            case 'number of events' :
                                    attr['ui.scheduled.triggercondition'] = 'events';
                                    attr['ui.scheduled.resultscomparator'] = this.entry.content.get('alert_comparator');
                                    attr['ui.scheduled.resultsinput'] = this.entry.content.get('alert_threshold');
                                break;
                            case 'number of hosts' :
                                    attr['ui.scheduled.triggercondition'] = 'hosts';
                                    attr['ui.scheduled.resultscomparator'] = this.entry.content.get('alert_comparator');
                                    attr['ui.scheduled.resultsinput'] = this.entry.content.get('alert_threshold');
                                break;
                            case 'number of sources' :
                                    attr['ui.scheduled.triggercondition'] = 'sources';
                                    attr['ui.scheduled.resultscomparator'] = this.entry.content.get('alert_comparator');
                                    attr['ui.scheduled.resultsinput'] = this.entry.content.get('alert_threshold');
                                break;
                            case 'custom' :
                                attr['ui.scheduled.triggercondition'] = 'custom';
                                attr['ui.scheduled.customsearch'] = this.entry.content.get('alert_condition');
                                break;
                        }
                        break;
                 }
                 
                // Trigger Conditions
                attr['ui.executeactions'] = splunkUtil.normalizeBoolean(this.entry.content.get('alert.digest_mode'));
                
                // Throttle
                var supresstime = this.entry.content.get('alert.suppress.period');
                if (supresstime) {
                    attr['ui.supresstime'] = supresstime.match(/^\d*/)[0];
                    var timeUnit = supresstime.match(/s|m|h|d/);
                    attr['ui.supresstimeunit'] = timeUnit ? timeUnit[0] : 's';
                }
                
                // Sharing
                attr['ui.permissions'] = splunkd_utils.USER;
                
                this.entry.content.set(attr);
            },
            getAlertTriggerConditionString: function() {
                var type = this.entry.content.get('alert_type'),
                    earliestTime = this.entry.content.get('dispatch.earliest_time'),
                    latestTime = this.entry.content.get('dispatch.latest_time'),
                    isRealtime = (earliestTime && time_utils.isRealtime(earliestTime)) || (latestTime && time_utils.isRealtime(latestTime)),
                    threshold = this.entry.content.get('alert_threshold'),
                    timeParse = time_utils.parseTimeString(earliestTime),
                    alertCondition = this.entry.content.get('alert_condition'),
                    isAllTimeRT = earliestTime === 'rt' ||latestTime === 'rt';
                switch(type) {
                    case 'always':
                        if (isRealtime) {
                            return _('Per-Result.').t();
                        }
                        return _('Number of Results is > 0.').t();
                    case 'number of events':
                    case 'number of hosts':
                    case 'number of sources':
                        if (isAllTimeRT) {
                            return _('Unsupported.').t();
                        }
                        var typeText = {
                            'number of events': _("Results").t(),
                            'number of hosts': _("Hosts").t(),
                            'number of sources': _("Sources").t()
                        };
                        switch(this.entry.content.get('alert_comparator')){
                            case 'greater than':
                                if (isRealtime) {
                                    switch(timeParse.unit) {
                                        case 'm':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is > %(threshold)s in %(timeAmount)s minute.', 'Number of %(typetext)s is > %(threshold)s in %(timeAmount)s minutes.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                        case 'h':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is > %(threshold)s in %(timeAmount)s hour.', 'Number of %(typetext)s is > %(threshold)s in %(timeAmount)s hours.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                        case 'd':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is > %(threshold)s in %(timeAmount)s day.', 'Number of %(typetext)s is > %(threshold)s in %(timeAmount)s days.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                    }
                                } else {
                                    return splunkUtil.sprintf(_('Number of %(typetext)s is > %(threshold)s.').t(), {typetext: typeText[type], threshold:threshold});
                                }
                                break;
                            case 'less than':
                                if (isRealtime) {
                                    switch(timeParse.unit) {
                                        case 'm':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is < %(threshold)s in %(timeAmount)s minute.', 'Number of %(typetext)s is < %(threshold)s in %(timeAmount)s minutes.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                        case 'h':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is < %(threshold)s in %(timeAmount)s hour.', 'Number of %(typetext)s is < %(threshold)s in %(timeAmount)s hours.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                        case 'd':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is < %(threshold)s in %(timeAmount)s day.', 'Number of %(typetext)s is < %(threshold)s in %(timeAmount)s days.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                    }
                                } else {
                                    return splunkUtil.sprintf(_('Number of %(typetext)s is < %(threshold)s.').t(), {typetext: typeText[type], threshold:threshold});
                                }
                                break;
                            case 'equal to':
                                if (isRealtime) {
                                    switch(timeParse.unit) {
                                        case 'm':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is = %(threshold)s in %(timeAmount)s minute.', 'Number of %(typetext)s is = %(threshold)s in %(timeAmount)s minutes.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                        case 'h':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is = %(threshold)s in %(timeAmount)s hour.', 'Number of %(typetext)s is = %(threshold)s in %(timeAmount)s hours.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                        case 'd':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is = %(threshold)s in %(timeAmount)s day.', 'Number of %(typetext)s is = %(threshold)s in %(timeAmount)s days.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                    }
                                } else {
                                    return splunkUtil.sprintf(_('Number of %(typetext)s is = %(threshold)s.').t(), {typetext: typeText[type], threshold:threshold});
                                }
                                break;
                            case 'not equal to':
                                if (isRealtime) {
                                    switch(timeParse.unit) {
                                        case 'm':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is &#8800; %(threshold)s in %(timeAmount)s minute.', 'Number of %(typetext)s is &#8800; %(threshold)s in %(timeAmount)s minutes.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                        case 'h':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is &#8800; %(threshold)s in %(timeAmount)s hour.', 'Number of %(typetext)s is &#8800; %(threshold)s in %(timeAmount)s hours.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                        case 'd':
                                            return splunkUtil.sprintf(i18n.ungettext('Number of %(typetext)s is &#8800; %(threshold)s in %(timeAmount)s day.', 'Number of %(typetext)s is &#8800; %(threshold)s in %(timeAmount)s days.', timeParse.amount), {typetext: typeText[type], threshold: threshold, timeAmount: timeParse.amount});
                                    }
                                } else {
                                    return splunkUtil.sprintf(_('Number of %(typetext)s is &#8800; %(threshold)s.').t(), {typetext: typeText[type], threshold:threshold});
                                }
                                break;
                            case 'drops by':
                                // drops by is only supported for non-realtime saved searches
                                return splunkUtil.sprintf(_('Number of %(typetext)s drops by %(threshold)s.').t(), {typetext: typeText[type], threshold:threshold});
                            case 'rises by':
                                // rises by is only supported for non-realtime saved searches
                                return splunkUtil.sprintf(_('Number of %(typetext)s rises by %(threshold)s.').t(), {typetext: typeText[type], threshold:threshold});
                        }
                        break;
                    case 'custom':
                        if (isAllTimeRT) {
                            return _('Unsupported.').t();
                        }
                        if (isRealtime) {
                            switch(timeParse.unit) {
                                case 'm':
                                    return splunkUtil.sprintf(i18n.ungettext('Custom. "%(alertCondition)s" in %(timeAmount)s minute.', 'Custom. "%(alertCondition)s" in %(timeAmount)s minutes.', timeParse.amount), {alertCondition: alertCondition, timeAmount: timeParse.amount});
                                case 'h':
                                    return splunkUtil.sprintf(i18n.ungettext('Custom. "%(alertCondition)s" in %(timeAmount)s hour.', 'Custom. "%(alertCondition)s" in %(timeAmount)s hours.', timeParse.amount), {alertCondition: alertCondition, timeAmount: timeParse.amount});
                                case 'd':
                                    return splunkUtil.sprintf(i18n.ungettext('Custom. "%(alertCondition)s" in %(timeAmount)s day.', 'Custom. "%(alertCondition)s" in %(timeAmount)s days.', timeParse.amount), {alertCondition: alertCondition, timeAmount: timeParse.amount});
                            }
                        } else {
                            return splunkUtil.sprintf(_('Custom. "%s".').t(), alertCondition);
                        }
                        break;
                }
            }
        },
        {
            Entry: BaseModel.extend(
                {
                    initialize: function() {
                        BaseModel.prototype.initialize.apply(this, arguments);
                    }
                },
                {
                    Links: BaseModel,
                    ACL: ACLReadOnlyModel,
                    Content: BaseModel.extend(
                        {
                            initialize: function() {
                                BaseModel.prototype.initialize.apply(this, arguments);
                            },
                            defaults: EntryContentDefaults,
                            validation: {             
                                'ui.type': {
                                    required: true
                                },
                                'ui.realtime.resultscomparatorinput': {
                                    fn: 'validateRealtimeResultsComparatorInput'
                                 },
                                'ui.realtime.resultstime': {
                                    fn: 'validateRealtimeResultsTime'
                                },
                                'ui.realtime.customsearch': {
                                    fn: 'validateRealtimeCustomSearch'
                                },
                                'ui.scheduled.resultsinput': {
                                    fn: 'validateScheduledResultsInput'
                                },
                                'ui.scheduled.customsearch': {
                                    fn: 'validateScheduledCustomSearch'
                                },
                                'alert.suppress.fields': {
                                    fn: 'validateFieldValue'
                                },
                                'ui.supresstime': {
                                    fn: 'validateSuppressTime'
                                },  
                                'alert.track': {
                                    fn: 'validateActions'
                                },
                                'action.script.filename': {
                                    fn: 'validateScriptFilename'
                                },
                                'action.email.to': {
                                    fn: 'validateEmailTo'
                                }
                            },
                            validateRealtimeResultsComparatorInput: function(value, attr, computedState) {
                                if (computedState['ui.type'] === 'realtime' &&
                                    (computedState['ui.realtime.triggercondition'] === 'events' ||
                                        computedState['ui.realtime.triggercondition'] === 'hosts' ||
                                        computedState['ui.realtime.triggercondition'] === 'sources') &&
                                    _.isNaN(mathUtils.strictParseFloat(value))) {
                                    
                                    return _('Trigger threshold must be a number.').t();
                                }
                            },
                            validateRealtimeResultsTime: function(value, attr, computedState) {
                                if (computedState['ui.type'] === 'realtime' &&
                                    (computedState['ui.realtime.triggercondition'] === 'events' ||
                                        computedState['ui.realtime.triggercondition'] === 'hosts' ||
                                        computedState['ui.realtime.triggercondition'] === 'sources' ||
                                        computedState['ui.realtime.triggercondition'] === 'custom') &&
                                    (_.isNaN(parseFloat(value)) || parseFloat(value) <= 0)) {
                                    
                                    return _('Trigger time range must be a number greater than 0.').t();
                                }
                            },
                            validateRealtimeCustomSearch: function(value, attr, computedState) {
                                if (computedState['ui.type'] === 'realtime' &&
                                    computedState['ui.realtime.triggercondition'] === 'custom' &&
                                    (_.isUndefined(value) || $.trim(value).length === 0)) {
                                    
                                    return _('Custom condition is required.').t();
                                }
                            },
                            validateScheduledResultsInput: function(value, attr, computedState) {
                                if (computedState['ui.type'] === 'scheduled' &&
                                    (computedState['ui.scheduled.triggercondition'] === 'events' ||
                                        computedState['ui.scheduled.triggercondition'] === 'hosts' ||
                                        computedState['ui.scheduled.triggercondition'] === 'sources') &&
                                    _.isNaN(mathUtils.strictParseFloat(value))) {
                                    
                                    return _('Trigger threshold must be a number.').t();
                                }
                            },
                            validateScheduledCustomSearch: function(value, attr, computedState) {
                                if (computedState['ui.type'] === 'scheduled' &&
                                    computedState['ui.scheduled.triggercondition'] === 'custom' &&
                                    (_.isUndefined(value) || $.trim(value).length === 0)) {
                                    
                                    return _('Custom condition is required.').t();
                                }
                            },
                            validateFieldValue: function(value, attr, computedState) {
                                if (computedState['alert.suppress'] &&
                                    (!computedState['ui.executeactions'] ||
                                        (computedState['ui.type'] === 'realtime' &&
                                            computedState['ui.realtime.triggercondition'] === 'per_result')) &&
                                    (_.isUndefined(value) || $.trim(value).length === 0)) {
                                    
                                    return _('Per result alert throttling requires at least one throttling field; use * to throttle on all fields.').t();
                                }
                            },
                            validateSuppressTime: function(value, attr, computedState) {
                                if (computedState['alert.suppress'] &&
                                    (!mathUtils.isInteger(value) || value <= 0)) {
                                    
                                    return _('Throttle suppression time range must be a integer greater than 0.').t();
                                }
                            },          
                            validateActions: function(value, attr, computedState) {
                                if (!value) {
                                    var action = _.find(computedState, function(value, attr) {
                                        return splunkUtil.normalizeBoolean(value) === true && /^action.([^\.]*)$/.test(attr);
                                    });
                                    if (!action) {
                                        return _('Enable at least one action.').t();
                                    }
                                }
                            },
                            validateScriptFilename: function(value, attr, computedState) {
                                if (computedState['action.script'] &&
                                    (_.isUndefined(value) || $.trim(value).length === 0)) {
                                    
                                    return _('A filename is required if script action is enabled').t();
                                }
                            },
                            validateEmailTo: function(value, attr, computedState) {
                                 if (computedState['action.email'] &&
                                    (_.isUndefined(value) || $.trim(value).length === 0)) {
                                    
                                    return _('An email address is required if email action is enabled').t();
                                }
                            }
                        }
                    ),
                    Fields: BaseModel
                }
            ),
            Cron: CronModel,
            WorkingTimeRange: TimeRangeModel
        });
        
        return Model;
    }
);

define(
    'collections/search/Alerts',[
        "models/search/Alert",
        "collections/services/saved/Searches"
    ],
    function(AlertModel, SavedSearchCollection) {
        return SavedSearchCollection.extend({
            model: AlertModel,
            initialize: function() {
                SavedSearchCollection.prototype.initialize.apply(this, arguments);
            },
            sync: function(method, model, options) {
                switch (method) {
                    case 'read' :
                        options = options || {};
                        if (!options.forceSearchData) {
                            options.data = options.data || {};
                            var search = '(' + this.constructor.ALERT_SEARCH_STRING + ')';
                            if (options.data.search) {
                                search += ' AND ' + options.data.search;
                            }
                            options.data.search = search;
                        }
                        break;
                }
                return SavedSearchCollection.prototype.sync.apply(this, arguments);
            }
        });
    }
);

/**
 * @author jszeto
 * @date 4/25/13
 *
 * Represents the acceleration specific settings for a DataModel.
 *
 *
 */
define(
    'models/services/datamodel/private/Acceleration',[
        'models/Base'
    ],
    function(BaseModel) {

        return BaseModel.extend({

                defaults: {
                    enabled: false

                }
        });
    }
);
/**
 * A replacement for the <models/SplunkDWhiteList> in <models/services/datamodel/DataModel>.
 *
 * The services/datamodel endpoint does not yet support _new, so we hard-code the required and optional fields here.
 */

define('models/services/datamodel/private/DataModelWhiteList',[
            'jquery',
            'models/SplunkDWhiteList'
        ],
        function(
            $,
            SplunkDWhiteListV2
        ) {

    var CREATE_DATA_MODEL_WHITELIST = {
        entry: [
            {
                fields: {
                    required: [
                        'name'
                    ],
                    optional: [
                        'acceleration',
                        'description'
                    ],
                    wildcard: []
                }
            }
        ]
    };

    var UPDATE_DATA_MODEL_WHITELIST = {
        entry: [
            {
                fields: {
                    required: [],
                    optional: [
                        'acceleration',
                        'description'
                    ],
                    wildcard: []
                }
            }
        ]
    };

    var UPDATE_NO_ACCELERATION_WHITELIST = {
        entry: [
            {
                fields: {
                    required: [],
                    optional: [
                        'description'
                    ],
                    wildcard: []
                }
            }
        ]
    };

    var DataModelWhiteList = SplunkDWhiteListV2.extend({

        sync: function(method, model, options) {
            if(method !== 'read') {
                throw new Error('Method not supported: ' + method);
            }
            var response;
            if(options.url.indexOf(model.url + '/_new') > -1) {
                response = CREATE_DATA_MODEL_WHITELIST;
            }
            else {
                response = DataModelWhiteList.canEditAcceleration ? UPDATE_DATA_MODEL_WHITELIST : UPDATE_NO_ACCELERATION_WHITELIST;
            }
            model.trigger('request', model, response, options);
            options.success(response);

            // Don't pass anything to resolve because we didn't make an AJAX call to proxy
            // We don't fake any arguments either, because there is no standard coming back from the jQuery AJAX call
            return $.Deferred().resolve();
        }

    },
    {
        canEditAcceleration: true
    });

    return DataModelWhiteList;
});

/**
 * A model representing a single data model object field.
 *
 * To be used only as a model inside the "collections/services/datamodel/private/Fields" collection
 *
 * For a description of possible attributes, see http://eswiki.splunk.com/Data_Model_JSON_Specification#Field
 */

define(
    'models/services/datamodel/private/Field',[
        'underscore',
        'models/Base'
    ],
    function(_, BaseModel) {

        var Field =  BaseModel.extend({

            idAttribute: 'fieldName',

            defaults: {
                type: 'string',
                constraints: [],
                fieldName: '',
                required: false,
                multivalue: false,
                hidden: false,
                editable: true
            },

            validation: {
                fieldName: [
                    {
                        required: true,
                        msg: _("Field Name is required.").t()
                    },
                    {
                        pattern: /^((?![{}"\s*']).)*$/g,
                        msg: _("Field Name can not contain whitespace, double quotes, single quotes, curly braces or asterisks.").t()
                    }
                ],
                displayName: [
                    {
                        required: false
                    },
                    {
                        pattern: /^((?!\*).)*$/,
                        msg: _("Display Name can not contain an asterisk.").t()
                    }
                ]
            },

            getBasicDescription: function() {
                return ({
                    displayName: this.get('displayName'),
                    fieldName: this.get('fieldName'),
                    type: this.get('type'),
                    localizedType: this.getLocalizedType(),
                    hidden: this.get('hidden'),
                    required: this.get('required'),
                    owner: this.get('owner'),
                    editable: this.get('editable')
                });
            },

            getLocalizedType: function() {
                var type = this.get("type");
                var localizedType = type;
                switch (type) {
                    case "string":
                        localizedType = _("String").t();
                        break;
                    case "number":
                        localizedType = _("Number").t();
                        break;
                    case "timestamp":
                        localizedType = _("Time").t();
                        break;
                    case "boolean":
                        localizedType = _("Boolean").t();
                        break;
                    case "ipv4":
                        localizedType = _("IPv4").t();
                        break;
                }

                return localizedType;
            }
        },
        {
            createRawField: function() {
                return new Field({multivalue: false,
                                  owner: "BaseEvent",
                                  fieldSearch: "",
                                  fieldName: "_raw",
                                  type: "string",
                                  displayName: "_raw",
                                  hidden: false,
                                  required: false,
                                  editable: true});
            }
        });
        return Field;
    }
);
/**
 * @author sfishel
 *
 * A collection of fields contained in each data model object.
 *
 * To be used only as an internal members of the "models/services/datamodel/private/Object" module
 * and the "models/services/datamodel/private/Calculation" module
 */

define('collections/services/datamodel/private/Fields',['collections/Base', 'models/services/datamodel/private/Field'], function(Base, Field) {

    return Base.extend({ model: Field });

});
/**
 * Util package for working with models.
 */

define('util/model_utils',['underscore'], function(_) {

    var collectionsAreEquivalent = function(coll1, coll2) {
        return _(coll1.toJSON()).isEqual(coll2.toJSON());
    };

    /**
     * @author sfishel
     *
     * A method to reset a collection, first checks that the new data is different from the data already there
     *
     * @param collection {Collection} the collection to reset
     * @param data {Array<Object>} the data to reset the collection
     * @param options {Object} options to be passed to Backbone's reset method
     */

    var safeResetCollection = function(collection, data, options) {
        var comparisonCollection = new collection.constructor();
        comparisonCollection.reset(data, options);
        if(!collectionsAreEquivalent(collection, comparisonCollection)) {
            collection.reset(data, options);
        }
    };

    /**
     * @author sfishel
     *
     * Parse out and handle the JSON representation of a nested collection from a raw sync response.
     *
     * @param model {Model} - the parent model
     * @param response {Object} - the JSON sync response
     * @param keyName {String} - the name of the model attribute that should contain the collection
     * @param collType {Constructor} - the constructor for the nested collection
     */

    var parseNestedCollection = function(model, response, keyName, collType) {
        response = response || {};
        // if the nested collection doesn't exist yet, create a new one
        if(!model.attributes || !model.get(keyName)) {
            // TODO: what if we needed to parse at the collection level here?
            response[keyName] = new collType(response[keyName] || [], { parse: true });
        }
        // otherwise reset the collection if new models were specified in the response
        else if(response[keyName]) {
            var collection = model.get(keyName),
            // have to explicitly call the collection's parse method
                parsedModels = collection.parse.call(collection, response[keyName]),
            // create new collection to compare to the old one to see if anything changed
                comparisonCollection = new collType(parsedModels, { parse: true });

            // if the two collections are different, reset the model's collection to the contents of the new one
            if(!collectionsAreEquivalent(collection, comparisonCollection)) {
                collection.reset(comparisonCollection.toArray());
            }
            // remove the objects from the response so they don't get passed to 'set'
            delete(response[keyName]);
        }
    };

    /**
     * @author sfishel
     *
     * Bind to a nested collection and bubble up some custom events at the model level.
     *
     * @param model {Model} - the parent model
     * @param keyName {String} - the name of the model attribute that contains the collection
     * @param collType {Constructor} - the constructor for the nested collection
     */
    
    var bindNestedCollection = function(model, keyName, collType, options) {
        if(!model.get(keyName)) {
            model.set(keyName, new collType(), options);
        }
        var collection = model.get(keyName);
        // TODO: should we pass some information along when these events are triggered?
        collection.on('add', function(added, collection, options) {
            model.trigger('add:' + keyName, added, collection, options);
            model.trigger('change');
        });
        collection.on('remove', function(removed, collection, options) {
            model.trigger('remove:' + keyName, removed, collection, options);
            model.trigger('change');
        });
        collection.on('reset', function(collection, options) {
            model.trigger('reset:' + keyName, collection, options);
            model.trigger('update:' + keyName);
            model.trigger('change');
        });
        collection.on('change', function(changed, options) {
            model.trigger('change:' + keyName, changed, options);
            model.trigger('update:' + keyName);
            model.trigger('change');
        });
    };
    
    return ({
        safeResetCollection: safeResetCollection,
        parseNestedCollection: parseNestedCollection,
        bindNestedCollection: bindNestedCollection
    });
    
});
/**
 * A model representing a single calculation operation.
 *
 * To be used only as a model inside the "collections/services/datamodel/private/Calculations" collection
 *
 * For a description of available attributes, see http://eswiki.splunk.com/Data_Model_JSON_Specification#Calculation
 */

define('models/services/datamodel/private/Calculation',[
            'jquery',
            'underscore',
            'collections/services/datamodel/private/Fields',
            'models/Base',
            'util/model_utils'
        ],
        function(
            $,
            _,
            Fields,
            BaseModel,
            modelUtils
        ) {

    return BaseModel.extend({

        idAttribute: 'calculationID',
        outputFieldsClass: Fields,

        initialize: function(attrs, options) {
            BaseModel.prototype.initialize.call(this, attrs, options);
            this.initializeAssociated();
        },

        getBasicDescription: function() {
            return ({
                calculationID: this.get('calculationID'),
                calculationType: this.get('calculationType'),
                expandedType: this.getExpandedType(),
                outputFields: this.getFieldList(),
                expression: this.get('expression'),
                owner: this.get('owner'),
                editable: this.get('editable')
            });
        },

        getFieldAt: function(index) {
            return this.outputFields.at(index);
        },

        getFieldByName: function(name) {
            return this.outputFields.get(name);
        },

        removeField: function(cid) {
            var outputFields = this.outputFields,
                toRemove = outputFields.get(cid);

            return outputFields.remove(toRemove);
        },

        removeFieldByName: function(fieldName, options) {
            var outputFields = this.outputFields,
                toRemove = outputFields.get(fieldName);

            outputFields.remove(toRemove, options);
        },

        removeAllFields: function(options) {
            var outputFields = this.outputFields;
            outputFields.reset([], options);
        },

        addField: function(attributes, options) {
            attributes = attributes || {};
            $.extend(attributes, {
                owner: this.get('owner')
            });

            var beforeLength = this.outputFields.length;

            this.outputFields.add(attributes, options);

            return this.outputFields.at(beforeLength);
        },

        withEachField: function(callback, context) {
            context = context || null;
            this.outputFields.each(callback, context);
        },

        getFieldNames: function() {
            return this.outputFields.map(function(outputField) {
                return outputField.get("fieldName");
            }, this);
        },

        // ----- sync behavior ----- //


        initializeAssociated: function() {
            this.associated = this.associated || {};

            if (!this.outputFields) {
                this.outputFields = this.associated.outputFields = new this.outputFieldsClass();
                this.outputFields.on("change associatedChange add remove update reset",
                function(model, options) {
                    this.trigger("associatedChange", model, options);
                }, this);
            }
        },

        clone: function(options) {
            var clone = BaseModel.prototype.clone.apply(this, arguments);
            clone.outputFields.set(this.outputFields.toJSON(options));
            return clone;
        },

        parse: function(response, options) {
            response = $.extend(true, {}, response);
            return this.parseAssociated(response, options);
        },

        parseAssociated: function(response, options) {
            this.initializeAssociated();
            if(response.outputFields) {
                this.outputFields.set(response.outputFields, $.extend({ parse: true }, options));
                delete response.outputFields;
            }
            return response;
        },

        toJSON: function(options) {
            var json = BaseModel.prototype.toJSON.apply(this, arguments);
            json.outputFields = this.outputFields.toJSON(options);
            // TODO [sff] look into these comments from the original toJSON function
            // work-around for SPL-56828, the read endpoint response is different from what the update endpoint expects
            // removing customData from the json spec...fix for SPL-57405
            return json;
        },


        // ----- private methods ----- //


        getFieldList: function() {
            return this.outputFields.map(function(field) {
                return field.getBasicDescription();
            });
        },

        getExpandedType: function() {
            var type = this.get("calculationType");

            var returnType = type;

            switch(type) {
                case "Eval":
                    returnType = _("Eval Expression").t();
                    break;
                case "GeoIP":
                    returnType = _("Geo IP").t();
                    break;
                case "Rex":
                    returnType = _("Regular Expression").t();
                    break;
                case "Lookup":
                    returnType = _("Lookup").t();
                    break;
            }

            return returnType;
        },

        toString: function() {
            return "Calculation " + this.get("calculationType") + "[" + this.get("calculationID") + "]";
        }

    });

});

/**
 * @author jszeto
 * @date 12/7/12
 */
define('models/services/datamodel/private/EvalCalculation',['underscore', 'models/services/datamodel/private/Calculation'], function(_, Calculation) {

    /**
     * Represents an Eval Calculation.
     *
     */
    return Calculation.extend({

        defaults: {
            calculationType: "Eval",
            expression: "",
            editable: true
        },

        validation: {
            expression : {
                required : true,
                msg: _("Eval Expression is a required field.").t()
            },
            calculationType : {
                oneOf : ["Eval"]
            }
        },

        toString: function() {
            if (this.outputFields.length > 0)
                return "EvalCalc [" + this.outputFields.at(0).get("displayName") + "]";
            else
                return "Empty EvalCalc";
        }

    });
});
/**
 * A model representing a single data model object output field for a Lookup or GeoIP Calculation.
 *
 * To be used only as a model inside the "collections/services/datamodel/private/LookupOutputFields" collection
 *
 * For a description of possible attributes, see http://eswiki.splunk.com/Data_Model_JSON_Specification#Field
 */

define(
    'models/services/datamodel/private/LookupOutputField',[
        'underscore',
        'models/services/datamodel/private/Field'
    ],
    function(_, Field) {

        return Field.extend({

            idAttribute: 'fieldName',

            defaults: {
                type: 'string',
                constraints: [],
                fieldName: '',
                lookupOutputFieldName: '',
                required: false,
                multivalue: false,
                hidden: false,
                editable: true
            },

            validation: {
                fieldName: [
                    {
                        required: true,
                        msg: _("Field Name is required.").t()
                    },
                    {
                        pattern: /^((?![{}"\s*']).)*$/g,
                        msg: _("Field Name can not contain whitespace, double quotes, single quotes, curly braces or asterisks.").t()
                    }
                ],
                displayName: [
                    {
                        required: false
                    },
                    {
                        pattern: /^((?!\*).)*$/,
                        msg: _("Display Name can not contain an asterisk.").t()
                    }
                ],
                lookupOutputFieldName: {
                    required: true,
                    msg: _("Field in Lookup is a required field.").t()
                }
            },

            getBasicDescription: function() {
                return ({
                    displayName: this.get('displayName'),
                    lookupOutputFieldName: this.get('lookupOutputFieldName'),
                    fieldName: this.get('fieldName'),
                    type: this.get('type'),
                    localizedType: this.getLocalizedType(),
                    hidden: this.get('hidden'),
                    required: this.get('required'),
                    owner: this.get('owner'),
                    editable: this.get('editable')
                });
            }
        });
    }
);
/**
 * @author jszeto
 *
 * A collection of LookupOutputFields contained in the Lookup or GeoIP Calculation
 *
 * To be used only as an internal members of the "models/services/datamodel/private/LookupCalculation" module
 * and the "models/services/datamodel/private/GeoIPCalculation" module
 */

define('collections/services/datamodel/private/LookupOutputFields',['collections/services/datamodel/private/Fields', 'models/services/datamodel/private/LookupOutputField'], function(Fields, LookupOutputField) {

    return Fields.extend({ model: LookupOutputField });

});
/**
 * @author jszeto
 * @date 12/7/12
 */
define('models/services/datamodel/private/GeoIPCalculation',['backbone',
        'underscore',
        'models/services/datamodel/private/Calculation',
        'collections/services/datamodel/private/LookupOutputFields'
       ],
    function(
        Backbone,
        _,
        Calculation,
        LookupOutputFields) {

    /**
     * Represents an GeoIP Calculation.
     *
     */
    return Calculation.extend({

        defaults: {
            calculationType: "GeoIP",
            inputField: "",
            editable: true
        },

        initialize: function(attrs, options) {
            Calculation.prototype.initialize.call(this, attrs, options);

            this.on("change:inputField", this.inputFieldChanged, this);
        },

        inputFieldChanged: function(model, value, options) {
            if (value !== "") {
                this.withEachField(function(field) {
                    field.set("fieldName", value + "_" + field.get("lookupOutputFieldName"));
                }, this);
            }
        },

        getVisibleOutputFieldsLength: function() {
            var visibleCount = 0;
            this.outputFields.each(function(field) {
                if (!field.get("hidden"))
                    visibleCount++;
            }, this);

            return visibleCount;
        },

        validation: {
            inputField : {
                required : true,
                msg : _("A Geo IP Calculation must contain an input field.").t()
            },
            calculationType : {
                oneOf : ["GeoIP"],
                fn : function(value, attr, computedState) {
                    var outputFields = this.outputFields;
                    var visibleCount = 0;
                    if (outputFields instanceof Backbone.Collection) {
                        var length = outputFields.length;

                        for (var i = 0; i < length; i++) {
                            var field = outputFields.at(i);
                            if (!field.get("hidden"))
                                visibleCount++;
                            if (!_.isUndefined(field.get("displayName")) && field.get("displayName").indexOf('"') != -1)
                                return _('A Geo IP Attribute Display Name cannot contain a quotation mark.').t();
                        }

                        if (visibleCount == 0) {
                            return _("Select at least one Geo IP Attribute.").t();
                        }
                    } else {
                        return _("Internal Error: The Geo IP outputFields are invalid.").t();
                    }
                }
            }
        },


        /**
         * Create the initial outputFields for a GeoIP Calculation
         *
         * @param options
         */
        addGeoIPFields: function(options) {
            this.addGeoIPField("lon", "number", options);
            this.addGeoIPField("lat", "number", options);
            this.addGeoIPField("City", "string", options);
            this.addGeoIPField("Region", "string", options);
            this.addGeoIPField("Country", "string", options);
        },

        addGeoIPField: function(fieldName, type, options) {
            var attributes = {required:true,
                hidden:false,
                type:type,
                lookupOutputFieldName: fieldName,
                fieldName: this.get("inputField") + "_" + fieldName};

            this.addField(attributes, options);
        },

        initializeAssociated: function() {
            this.associated = this.associated || {};
            this.outputFields = this.associated.outputFields = this.outputFields || new LookupOutputFields();
            this.outputFields.on("change associatedChange add remove update reset",
                function(model, options) {
                    this.trigger("associatedChange", model, options);
                }, this);
        }

    });
});
/**
 * @author jszeto
 * @date 1/14/14
 */

/**
 * A model representing a single data model object lookup input field for a Lookup Calculation.
 *
 * To be used only as a model inside the "collections/services/datamodel/private/LookupInputFields" collection
 */

define(
    'models/services/datamodel/private/LookupInput',[
        'underscore',
        'models/Base'
    ],
    function(_, BaseModel) {

        return BaseModel.extend({

            idAttribute: 'lookupField',

            defaults: {
                lookupField: '',
                inputField: ''
            },

            validation: {
                lookupField: {
                    required: true,
                    msg: _("Field in Lookup is a required field.").t()
                },
                inputField: {
                    required: true,
                    msg: _("Input Attribute is required.").t()
                }
            }
        });
    }
);

/*
 * @author jszeto
 * @date 1/14/14
 *
 * A collection of LookupInputs contained in the Lookup Calculation
 *
 * To be used only as an internal members of the "models/services/datamodel/private/LookupInput" module
 */

define('collections/services/datamodel/private/LookupInputs',['collections/Base', 'models/services/datamodel/private/LookupInput'], function(BaseCollection, LookupInput) {

    return BaseCollection.extend({model: LookupInput});

});

/**
 * @author jszeto
 * @date 12/7/12
 */
define('models/services/datamodel/private/LookupCalculation',['jquery',
        'underscore',
        'backbone',
        'models/services/datamodel/private/Calculation',
        'collections/services/datamodel/private/LookupInputs',
        'collections/services/datamodel/private/LookupOutputFields'
       ],
    function(
        $,
        _,
        Backbone,
        Calculation,
        LookupInputs,
        LookupOutputFields
    ) {

    /**
     * Represents a Lookup Calculation.
     *
     */
    return Calculation.extend({

        outputFieldsClass: LookupOutputFields,

        defaults: {
            calculationType: "Lookup",
            lookupName: undefined,
            inputField: "",
            lookupField: "",
            editable: true
        },

        validation: {
            lookupName : {
                required : true,
                msg: _("Select a valid Lookup Table.").t()
            }/*,
            lookupField: {
                required : true,
                msg: _("Input Field in Lookup is a required field").t()
            },
            inputField : {
                required : true,
                msg: _("Select a valid Input Attribute.").t()
            }*/
        },

        initializeAssociated: function() {
            Calculation.prototype.initializeAssociated.apply(this, arguments);

            if (!this.lookupInputs) {
                this.lookupInputs = this.associated.lookupInputs = this.lookupInputs || new LookupInputs();
                this.lookupInputs.on("change associatedChange add remove update reset",
                    function(model, options) {
                        this.trigger("associatedChange", model, options);
                    }, this);
            }
        },

        parseAssociated: function(response, options) {
            Calculation.prototype.parseAssociated.call(this, response, options);
            if(response.lookupInputs) {
                this.lookupInputs.set(response.lookupInputs, $.extend({ parse: true }, options));
                delete response.lookupInputs;
            }
            return response;
        },

        toJSON: function(options) {
            var json = Calculation.prototype.toJSON.apply(this, arguments);
            json.lookupInputs = this.lookupInputs.toJSON(options);
            return json;
        },

        /**
         * Remove an output field by matching its lookupOutputFieldName
         * @param lookupOutputFieldName
         * @return {*}
         */
        removeFieldByLookup: function(lookupOutputFieldName) {
            var field = this.outputFields.findWhere({lookupOutputFieldName: lookupOutputFieldName});
            if (field)
                this.outputFields.remove(field);

            return field;
        },

        /**
         * Returns the output field with the given lookupOutputFieldName
         *
         * @param lookupOutputFieldName
         * @return {*}
         */
        getFieldByLookup: function(lookupOutputFieldName) {
            return this.outputFields.findWhere({lookupOutputFieldName: lookupOutputFieldName});
        },

        /**
         * Run a function on each LookupInput
         *
         * @param callback
         * @param context
         */
        withEachLookupInput: function(callback, context) {
            context = context || null;
            this.lookupInputs.each(callback, context);
        },

        /**
         * Add a new LookupInput to lookupInputs
         * @param attributes
         * @param options
         * @return {*}
         */
        addLookupInput: function(attributes, options) {
            var beforeLength = this.lookupInputs.length;
            this.lookupInputs.add(attributes, options);
            return this.lookupInputs.at(beforeLength);
        },

        /**
         * Remove a lookupInput
         * @param cid
         */
        removeLookupInput: function(cid) {
            var toRemove = this.lookupInputs.get(cid);
            this.lookupInputs.remove(toRemove);
        },

        /**
         * Remove all lookupInputs
         * @param options
         */
        removeAllLookupInputs: function(options) {
            this.lookupInputs.reset([], options);
        },

        /**
         * Return the lookup input associated with a given lookupField
         * @param lookupField
         * @return {*}
         */
        getLookupInput: function(lookupField) {
            return this.lookupInputs.find(function(lookupInput) {
                return lookupInput.get("lookupField") == lookupField;
            }, this);
        }

    });
});
/**
 * @author jszeto
 * @date 3/5/14
 *
 * A model representing a single data model object output field for a Rex Calculation.
 *
 * To be used only as a model inside the "collections/services/datamodel/private/RexOutputFields" collection
 *
 * For a description of possible attributes, see http://eswiki.splunk.com/Data_Model_JSON_Specification#Field
 */

define(
    'models/services/datamodel/private/RexOutputField',[
        'underscore',
        'models/services/datamodel/private/Field'
    ],
    function(_, Field) {

        return Field.extend({

            toJSON: function(options) {
                var json = Field.prototype.toJSON.apply(this, arguments);
                // If options.data.provisional == true, then always return required = false
                if (options && options.data && options.data.provisional) {
                    json.required = false;
                }
                return json;
            }

        });
    }
);
/**
 * @author jszeto
 * @date 3/05/2014
 *
 * A collection of RexOutputFields contained in the Rex Calculation
 *
 * To be used only as an internal members of the "models/services/datamodel/private/RexCalculation" module
 */

define('models/services/datamodel/private/RexOutputFields',['collections/services/datamodel/private/Fields', 'models/services/datamodel/private/RexOutputField'], function(Fields, RexOutputField) {

    return Fields.extend({ model: RexOutputField });

});
/**
 * @author jszeto
 * @date 12/7/12
 */
define('models/services/datamodel/private/RexCalculation',['underscore',
        'backbone',
        'splunk.util',
        'models/services/datamodel/private/Calculation',
        'models/services/datamodel/private/RexOutputFields'],
    function(
        _,
        Backbone,
        splunkUtil,
        Calculation,
        RexOutputFields) {

    /**
     * Represents a Rex Calculation.
     *
     */
    return Calculation.extend({
        outputFieldsClass: RexOutputFields,

        defaults: {
            calculationType: "Rex",
            expression: "",
            inputField: "",
            outputFields: undefined,
            editable: true
        },

        validation: {
            expression : [
                {
                    required : true,
                    msg: _("Regular Expression is a required field.").t()
                }/*,
                {
                    fn : function(value, attr, computedState) {
                        var outputFields = computedState.outputFields;
                        if (outputFields instanceof Backbone.Collection) {
                            if (outputFields.length == 0) {
                                return "A Rex Calculation must contain at least one outputField";
                            }
                        } else {
                            return "Rex Calculation outputFields is invalid";
                        }
                    }
                }*/
            ],
            inputField : {
                required : true,
                msg : _("Select a field to Extract From.").t()
            },
            calculationType : {
                oneOf : ["Rex"]
            }

        },

        getPreviewSearch: function() {
            return splunkUtil.sprintf('rex field=%s "%s" max_match=1',
                                this.get("inputField"), this.get("expression"));
        },

        getPreviewAllSearch: function() {
            return splunkUtil.sprintf('eval _is_match = if(match(%s, "%s"), 1, 0)',
                                this.get("inputField"), this.get("expression"));
        },

        getPreviewMatchSearch: function() {
            return splunkUtil.sprintf('where match(%s, "%s")',
                                this.get("inputField"), this.get("expression"));
        },

        getPreviewNonMatchSearch: function() {
            return splunkUtil.sprintf('where NOT match(%s, "%s")',
                                this.get("inputField"), this.get("expression"));
        }

    });
});
/**
 * A collection of calculations contained in each data model object.
 *
 * To be used only as an internal member of the "models/services/datamodel/private/Object" module
 */

define('collections/services/datamodel/private/Calculations',[
            'jquery',
            'collections/Base',
            'models/services/datamodel/private/Calculation',
            'models/services/datamodel/private/EvalCalculation',
            'models/services/datamodel/private/GeoIPCalculation',
            'models/services/datamodel/private/LookupCalculation',
            'models/services/datamodel/private/RexCalculation'
       ],
       function(
            $,
            Base,
            Calculation,
            EvalCalculation,
            GeoIPCalculation,
            LookupCalculation,
            RexCalculation
           ) {

    // Create a specific Calculation class based on the calculationType
    var ModelFactory = function(attributes, options) {

        switch(attributes.calculationType) {
            case 'Eval':
                return new EvalCalculation(attributes, options);
            case 'GeoIP':
                return new GeoIPCalculation(attributes, options);
            case 'Lookup':
                return new LookupCalculation(attributes, options);
            case 'Rex':
                return new RexCalculation(attributes, options);
            default:
                return new Calculation(attributes, options);
        }
    };

    // make sure the model factory prototype has the correct idAttribute
    $.extend(ModelFactory.prototype, {
        idAttribute: Calculation.prototype.idAttribute
    });

    return Base.extend({

        model: ModelFactory,

        toString: function() {

            var children = "";
            this.each(function(calculation) {
                if (children != "")
                    children += ", ";
                children += calculation.toString();
            }, this);

            return "Calculations [" + children + "]";
        }
    });

});
define('collections/services/datamodel/private/FieldSampleValues',[
            'jquery',
            'collections/Base',
            'models/Base',
            'util/splunkd_utils'
        ],
        function(
            $,
            BaseCollection,
            BaseModel,
            splunkdUtils
        ) {

    var SampleValues = BaseModel.extend({

        idAttribute: 'fieldName',

        defaults: {
            limit: 10
        },

        sync: function(method, model, options) {
            if(method !== 'read') {
                throw new Error('sync method not supported: ' + method);
            }
            var baseUrl = 'search/jobs',
                ajaxData = $.extend(true, {}, options, {
                    data: {
                        exec_mode: 'oneshot',
                        output_mode: 'json_cols',
                        max_time: 30
                    },
                    type: 'POST',
                    dataType: 'json'
                });

            if(model.collection.tsidxNamespace) {
                ajaxData.data.search = '| tstats count from ' + model.collection.tsidxNamespace
                                                 + ' groupby ' + this.id + ' | sort limit=' + this.get('limit') + ' -count';
            }
            else {
                ajaxData.data.search = model.collection.baseSearch + ' | top ' + this.get('limit') + ' "' + this.id + '"';
            }

            return $.ajax(splunkdUtils.prepareSyncOptions(ajaxData, baseUrl));
        },

        parse: function(response) {
            var values = (response && response.columns && response.columns.length > 0 ) ? response.columns[0] : [];
            return { values: values };
        }

    });

    return BaseCollection.extend({

        model: SampleValues,

        initialize: function(models, options) {
            options = options || {};
            this.setBaseSearch(options.baseSearch);
            this.setTsidxNamespace(options.tsidxNamespace);
            BaseCollection.prototype.initialize.apply(this, arguments);
        },

        setBaseSearch: function(baseSearch) {
            this.baseSearch = baseSearch;
        },

        setTsidxNamespace: function(ns) {
            this.tsidxNamespace = ns;
        }

    });

});
/**
 * @author sfishel
 *
 * A util package for working with pivot report element forms.
 *
 * Provides some centralized functions for translating report element property values into corresponding display strings.
 * These functions are shared by the pivot report element views and models to avoid duplicate code.
 */

define('util/pivot/config_form_utils',[
            'underscore',
            'util/time',
            'splunk.util',
            'splunk.i18n'
        ],
        function(
            _,
            timeUtils,
            splunkUtils,
            i18n
        ) {

    var MATCH_FILTER_LABELS = {
        is: _('%(fieldName)s is %(matchValue)s').t(),
        contains: _('%(fieldName)s contains %(matchValue)s').t(),
        isNot: _('%(fieldName)s is not %(matchValue)s').t(),
        doesNotContain: _('%(fieldName)s does not contain %(matchValue)s').t(),
        startsWith: _('%(fieldName)s starts with %(matchValue)s').t(),
        endsWith: _('%(fieldName)s ends with %(matchValue)s').t(),
        isNull: _('%(fieldName)s is null').t(),
        isNotNull: _('%(fieldName)s is not null').t(),
        'in': _('%(fieldName)s is in (%(matchValue)s)').t(),
        regex: _('%(fieldName)s matches %(matchValue)s').t(),
        '=': _('%(fieldName)s = %(matchValue)s').t(),
        '!=': _('%(fieldName)s != %(matchValue)s').t(),
        '<=': _('%(fieldName)s <= %(matchValue)s').t(),
        '<': _('%(fieldName)s < %(matchValue)s').t(),
        '>=': _('%(fieldName)s >= %(matchValue)s').t(),
        '>': _('%(fieldName)s > %(matchValue)s').t(),
        'true': _('%(fieldName)s is true').t(),
        'false': _('%(fieldName)s is false').t()
    };

    var FILTER_RULE_DISPLAY_NAMES = {
        is: _('is').t(),
        contains: _('contains').t(),
        isNot: _('is not').t(),
        doesNotContain: _('does not contain').t(),
        startsWith: _('starts with').t(),
        endsWith: _('ends with').t(),
        isNull: _('is null').t(),
        isNotNull: _('is not null').t(),
        'in': _('is in list').t(),
        regex: _('regex').t(),
        '=': _('=').t(),
        '!=': _('!=').t(),
        '<=': _('<=').t(),
        '<': _('<').t(),
        '>=': _('>=').t(),
        '>': _('>').t(),
        'true': _('is true').t(),
        'false': _('is false').t()
    };

    var LIMIT_FILTER_LABELS_LONG = {
        highest: _('Highest %(limitAmount)s %(fieldName)s by %(limitBy)s').t(),
        lowest: _('Lowest %(limitAmount)s %(fieldName)s by %(limitBy)s').t()
    };

    var LIMIT_FILTER_LABELS_SHORT = {
        highest: _('Highest %(limitAmount)s %(fieldName)s').t(),
        lowest: _('Lowest %(limitAmount)s %(fieldName)s').t()
    };

    var FILTER_LIMIT_TYPE_DISPLAY_NAMES = {
        highest: _('Highest').t(),
        lowest: _('Lowest').t()
    };

    var CELL_VALUE_LABELS = {
        'list': _('Values of %(fieldName)s').t(),
        'values': _('Distinct Values of %(fieldName)s').t(),
        'first': _('First Value of %(fieldName)s').t(),
        'last': _('Last Value of %(fieldName)s').t(),
        'earliest': _('Earliest Value of %(fieldName)s').t(),
        'latest': _('Latest Value of %(fieldName)s').t(),
        'count': _('Count of %(fieldName)s').t(),
        'dc': _('Distinct Count of %(fieldName)s').t(),
        'sum': _('Sum of %(fieldName)s').t(),
        'avg': _('Average of %(fieldName)s').t(),
        'max': _('Max of %(fieldName)s').t(),
        'min': _('Min of %(fieldName)s').t(),
        'stdev': _('Standard Deviation of %(fieldName)s').t(),
        'median': _('Median of %(fieldName)s').t(),
        'duration': _('Duration').t(),
        'listDistinct': _('Distinct Values of %(fieldName)s').t()
    };

    var CELL_VALUE_DISPLAY_NAMES = {
        'list': _('List Values').t(),
        'values': _('List Distinct Values').t(),
        'first': _('First Value').t(),
        'last': _('Last Value').t(),
        'count': _('Count').t(),
        'dc': _('Distinct Count').t(),
        'sum': _('Sum').t(),
        'avg': _('Average').t(),
        'max': _('Max').t(),
        'min': _('Min').t(),
        'stdev': _('Standard Deviation').t(),
        'median': _('Median').t(),
        'duration': _('Duration').t(),
        'earliest': _('Earliest').t(),
        'latest': _('Latest').t(),
        'listDistinct': _('List Distinct Values').t()
    };

    var CELL_VALUE_OUTPUT_TYPES = {
        'list': 'dimension',
        'values': 'dimension',
        'first': 'dimension',
        'last': 'dimension',
        'count': 'metric',
        'dc': 'metric',
        'sum': 'metric',
        'avg': 'metric',
        'max': 'metric',
        'min': 'metric',
        'stdev': 'metric',
        'median': 'metric',
        'duration': 'metric',
        'earliest': 'dimension',
        'latest': 'dimension',
        'listDistinct': 'dimension'
    };

    var SPLIT_MODE_DISPLAY_NAMES = {
        'all': _('All Values').t(),
        'ranges': _('Value Ranges').t()
    };

    var sampleDate = new Date(2011, 0, 31, 23, 1, 1),
        formatSampleDate = function(granularity) {
            return i18n.format_date(sampleDate, timeUtils.RESULTS_TIMESTAMP_FORMATS[granularity]);
        };

    var SPLIT_TIME_PERIOD_DISPLAY_NAMES = {
        'auto': _('Auto').t(),
        'year': splunkUtils.sprintf(_('Years (%(sampleDate)s)').t(), { sampleDate: formatSampleDate('year') }),
        'month': splunkUtils.sprintf(_('Months (%(sampleDate)s)').t(), { sampleDate: formatSampleDate('month') }),
        'day': splunkUtils.sprintf(_('Days (%(sampleDate)s)').t(), { sampleDate: formatSampleDate('day') }),
        'hour': splunkUtils.sprintf(_('Hours (%(sampleDate)s)').t(), { sampleDate: formatSampleDate('hour') }),
        'minute': splunkUtils.sprintf(_('Minutes (%(sampleDate)s)').t(), { sampleDate: formatSampleDate('minute') }),
        'second': splunkUtils.sprintf(_('Seconds (%(sampleDate)s)').t(), { sampleDate: formatSampleDate('second') })
    };

    var SPLIT_TIME_PERIOD_DISPLAY_NAMES_SHORT = {
        'auto': _('Auto').t(),
        'year': _('Years').t(),
        'month': _('Months').t(),
        'day': _('Days').t(),
        'hour': _('Hours').t(),
        'minute': _('Minutes').t(),
        'second': _('Seconds').t()
    };

    /**
     * @param dict
     * @param key
     * @return the corresponding value of the key in the dict, or the key itself if it is not in the dict
     */
    var dictValueOrKey = function(dict, key) {
        return dict.hasOwnProperty(key) ? dict[key] : key;
    };

    var quoteIfContainsSpacesOrCommas = function(str) {
        if (/\s|,/.test(str)) {
            return '"' + str + '"';
        }
        return str;
    };

    var prettyPrintArrayForLabel = function(values) {
        return _(values).map(quoteIfContainsSpacesOrCommas).join(', ');
    };

    return ({

        getMatchFilterLabel: function(fieldName, ruleKey, matchValue) {
            if (_.isArray(matchValue)) {
                matchValue = prettyPrintArrayForLabel(matchValue);
            }
            return splunkUtils.sprintf(
                MATCH_FILTER_LABELS[ruleKey],
                { fieldName: fieldName, matchValue: matchValue }
            );
        },

        filterRuleToDisplay: function(rule) {
            return FILTER_RULE_DISPLAY_NAMES[rule];
        },

        getLimitFilterLabel: function(fieldName, limitType, limitAmount, limitBy) {
            if(limitBy) {
                return splunkUtils.sprintf(
                    LIMIT_FILTER_LABELS_LONG[limitType],
                    { fieldName: fieldName, limitAmount: limitAmount, limitBy: limitBy }
                );
            }
            return splunkUtils.sprintf(
                LIMIT_FILTER_LABELS_SHORT[limitType],
                { fieldName: fieldName, limitAmount: limitAmount }
            );
        },

        filterLimitTypeToDisplay: function(limitType) {
            return FILTER_LIMIT_TYPE_DISPLAY_NAMES[limitType];
        },

        cellValueToDisplay: function(valueType) {
            return CELL_VALUE_DISPLAY_NAMES[valueType];
        },

        getCellValueLabel: function(fieldName, valueKey) {
            return splunkUtils.sprintf(CELL_VALUE_LABELS[valueKey], { fieldName: fieldName });
        },

        cellValueToOutputType: function(valueType, dataType) {
            if(dataType === 'objectCount' || dataType === 'childCount') {
                return 'metric';
            }
            return CELL_VALUE_OUTPUT_TYPES[valueType];
        },

        splitModeToDisplay: function(mode) {
            return dictValueOrKey(SPLIT_MODE_DISPLAY_NAMES, mode);
        },

        splitTimePeriodToDisplay: function(period, showSamples) {
            if(showSamples) {
                return dictValueOrKey(SPLIT_TIME_PERIOD_DISPLAY_NAMES, period);
            }
            return dictValueOrKey(SPLIT_TIME_PERIOD_DISPLAY_NAMES_SHORT, period);
        },

        booleanFieldNameLabel: function(fieldName, isTrue) {
            return isTrue ?
                splunkUtils.sprintf(_('is %(fieldName)s').t(), { fieldName: fieldName }) :
                splunkUtils.sprintf(_('is not %(fieldName)s').t(), { fieldName: fieldName });
        }

    });

});
/**
 * A model representing a single data model object.
 *
 * To be used only as a model inside the "collections/services/datamodel/private/ObjectHierarchy" module.
 *
 * For a description of possible attributes, see http://eswiki.splunk.com/Data_Model_JSON_Specification#Object
 */

define(
    'models/services/datamodel/private/Object',[
        'jquery',
        'underscore',
        'models/Base',
        'models/services/datamodel/private/Field',
        'collections/services/datamodel/private/Fields',
        'collections/services/datamodel/private/Calculations',
        'collections/services/datamodel/private/FieldSampleValues',
        'util/pivot/config_form_utils'
    ],
    function(
        $,
        _,
        BaseModel,
        Field,
        Fields,
        Calculations,
        FieldSampleValues,
        formElementUtils
    ) {

        return BaseModel.extend({

            ROOT_OBJECTS: ['BaseEvent', 'BaseTransaction', 'BaseSearch', 'BaseInterface', 'BaseImplements'],

            idAttribute: 'objectName',

            defaults: {
                constraints: [],
                objectsToGroup: []
            },

            validation: {
                displayName: [
                    {
                        required: true,
                        msg: _("Object Name is a required field.").t()
                    },
                    {
                        pattern: /^((?!\*).)*$/,
                        msg: _("Object Name can not contain an asterisk.").t()
                    }

                ],
                objectName: [
                    {
                        required: true,
                        msg: _("Object ID is a required field.").t()
                    },
                    {
                        pattern: /^[\w\-]+$/,
                        msg: _("Object ID can only contain alphanumeric characters, underscores or hyphens. Whitespace is not allowed.").t()
                    },
                    {
                        pattern: /^[^_].*/,
                        msg: _("Object ID can not start with an underscore character.").t()
                    }
                ],
                objectsToGroup: {
                    fn : function(value, attr, computedState) {
                        var rootParent = computedState.parentName;
                        if (rootParent == "BaseTransaction") {
                            if (value.length == 0) {
                                return _("Root transaction objects require at least one Group Objects value.").t();
                            }
                        }
                    }
                },
                baseSearch: {
                    fn: function(value, attr, computedState) {
                        if (computedState.parentName == "BaseSearch") {
                            if (_(value).isUndefined() || value == "") {
                                return _("Root search objects require a Search String.").t();
                            }
                        }
                    }
                }
            },

            initialize: function(attrs, options) {
                BaseModel.prototype.initialize.apply(this, arguments);
                this.initializeAssociated();
                this.modelIdAndFechOptionsDataMapping = {};
            },

            // TODO: this depends on the object being inside of an ObjectHierarchy, it should really be moved
            // (only used in DataModel.js line 80)
            getBasicAttributes: function() {
                return ({
                    objectName: this.get('objectName'),
                    displayName: this.get('displayName'),
                    rootParent: this.get('rootParent'),
                    lineage: this.get('lineage')
                });
            },

            /**
             * Returns the field object corresponding to the given field name and (optionally) owner,
             * or undefined if no field matches.
             *
             * Searches over primitive fields and fields from calculations
             *
             * @param {String} name - the name of the field to match
             * @param {String) owner (optional) - the owner of the field to match
             */

            getFieldByName: function(name, owner) {
                var fields = this.getFieldList(),
                    calculatedFields = _(this.getCalculationList()).chain().pluck('outputFields').flatten().value(),
                    allFields = _.union(fields, calculatedFields);

                return _(allFields).find(function(field) {
                    return (field.fieldName === name && (!owner || field.owner === owner));
                });
            },

            /**
             * Returns the field object corresponding to the index time field, if one exists,
             * otherwise returns undefined.
             *
             * Enforces that the field must have type 'timestamp' to differentiate from user-created fields.
             * (see SPL-82440)
             *
             * @param {String} name - the name of the field to match
             * @param {String) owner (optional) - the owner of the field to match
             */
            getIndexTimeField: function() {
                var candidate = this.getFieldByName('_time');
                if(candidate && candidate.type === 'timestamp') {
                    return candidate;
                }
                return undefined;
            },

            /**
             * Returns a list representing all fields that are available on the object in a reporting context.
             *
             * Includes primitive fields and fields from calculations.
             * Primary sort is by field data type (objectCount then childCount then all others), secondary sort is
             * lexical by field name.
             *
             * @return {Array<Object>}
             */

            getReportFields: function() {
                var fields = _(this.getFieldList()).filter(function(field) { return !field.hidden; }),
                    calculatedFields = _(this.getCalculationList())
                        .chain()
                        .pluck('outputFields').flatten().filter(function(field) { return field.hidden !== true; })
                        .value(),
                    reportFields = _.union(fields, calculatedFields),
                    sortedReportFields = _(reportFields).sortBy(function(field) {
                        // objectCount fields come before the others, followed by childCount,
                        // then sort is alphabetical by field display name (not case-sensitive)
                        var displayNameLower = field.displayName.toLowerCase();
                        if(field.type === 'objectCount') {
                            return 'a' + displayNameLower;
                        }
                        if(field.type === 'childCount') {
                            return 'b' + displayNameLower;
                        }
                        return 'c' + displayNameLower;
                    }),
                    objectCountField = _(sortedReportFields).find(function(field) {
                        return field.type === 'objectCount';
                    });

                // FIXME: this is a little weird
                if(objectCountField) {
                    objectCountField.displayName = formElementUtils.getCellValueLabel(this.get('displayName'), 'count');
                }
                return sortedReportFields;
            },

            /**
             * In order to be opened in pivot, the object must have some report attributes in addition to its
             * "objectCount" and "childCount" fields
             */

            isPivotable: function() {
                return _(this.getReportFields()).any(function(field) {
                    return (field.type !== 'objectCount' && field.type !== 'childCount');
                });
            },

            /**
             * Returns the reportFields (see getReportFields above) and divides it by data type.
             *
             * Data type categories are "timestamp", "objectCount" (also includes childCount) and "other".
             * Return value is a dictionary of category names mapping to lists of field objects.
             *
             * @return {Object}
             */

            getGroupedReportFields: function() {
                var groups = _(this.getReportFields()).groupBy(function(field) {
                    if(field.type === 'timestamp') {
                        return 'timestamp';
                    }
                    if(field.type in { objectCount: true, childCount: true }) {
                        return 'objectCount';
                    }
                    return 'other';
                });

                groups.objectCount = groups.objectCount || [];
                groups.timestamp = groups.timestamp || [];
                groups.other = groups.other || [];
                return groups;
            },

            /**
             * Returns true if the Object's parentName is not BaseTransaction, BaseEvent or BaseSearch
             *
             * @return {Boolean}
             */
            isChildObject: function() {
                return _(this.ROOT_OBJECTS).indexOf(this.get('parentName')) == -1;
            },

            /**
             * Returns a list of field objects representing the fields inherited from the object's parents.
             *
             * Includes primitive fields and fields from calculations.
             *
             * @return {Array<Object>}
             */

            getInheritedFields: function() {
                var ownName = this.get('lineage'),
                    inheritedFields = _(this.getFieldList())
                        .chain()
                        .filter(function(field) { return (field.owner !== ownName && field.type !== 'childCount'); })
                        .sortBy(function(field) {
                            return field.displayName.toLowerCase();
                        })
                        .value(),
                    inheritedCalculatedFields = _(this.getCalculationList())
                    .chain()
                    .filter(function(calc) { return calc.owner !== ownName;})
                    .map(function(calc) {
                        return _(calc.outputFields).chain()
                                                   .map(function(outputField) {
                                                        return $.extend(outputField, {calculationID: calc.calculationID});})
                                                   .value();})
                    .flatten()
                    .value();

                return _.union(inheritedFields, inheritedCalculatedFields);
            },

            /**
             * Returns a list of field objects representing the fields defined by the object itself.
             *
             * Does not include fields from calculations.
             *
             * @return {Array<Object>}
             */

            getOwnFields: function() {
                var ownName = this.get('lineage');
                return _(this.getFieldList())
                    .chain()
                    .filter(function(field) {
                        return (field.owner === ownName && field.type !== 'childCount' && field.type !== 'objectCount'); })
                    .sortBy(function(field) {
                        return field.displayName.toLowerCase();
                    })
                    .value();
            },

            /**
             * Returns a list of own and inherited field objects of type ipv4
             *
             * Does not include fields from calculations.
             *
             * @return {Array<Object>}
             */
            getIPV4Fields: function() {
                return _(this.getAllowedInputFields()).filter(function(field) { return field.type === "ipv4"; });
            },

            /**
             * Returns a list of own and inherited field objects of type ipv4 that are not currently used
             * for a GeoIP Calculation of this Object or its ancestors
             *
             * Does not include fields from calculations.
             *
             * @return {Array<Object>}
             */
            getAvailableIPV4Fields: function() {
                var geoIPCalculations = this.calculations.filter(
                    function(calculation) { return calculation.get("calculationType") === "GeoIP";});

                return _(this.getAllowedInputFields()).filter(
                    function(field) { return field.type === "ipv4" && !_(geoIPCalculations).find(
                         function(calculation) {return field.fieldName === calculation.get("inputField"); }, this);},
                        this);
            },

            /**
             * Returns a list of calculation objects representing the calculations defined by the object itself.
             *
             * @return {Array<Object>}
             */

            getOwnCalculations: function() {
                return _(this.getCalculationList()).filter(function(calc) {
                    return this.isOwnCalculation(calc);
                }, this);
            },

            isOwnCalculation: function(calculation) {
                var outputFieldType = "";
                var ownName = this.get('lineage');

                if (calculation.calculationType == "Eval" && calculation.outputFields.length > 0) {
                    outputFieldType = calculation.outputFields[0].type;
                }

                // TODO [JCS] Don't show StatsField calculations until we decide how to add/edit them.
                return (calculation.owner === ownName && outputFieldType != "childCount"
                        && outputFieldType != "objectCount" && calculation.calculationType != "StatsField");
            },

            /**
             * Filters the collapsed constraints (see getCollapsedConstraints below) to the ones that are inherited
             * from a parent.
             *
             * @return {Array<Object>}
             */

            getInheritedConstraints: function() {
                return _(this.getCollapsedConstraints()).filter(function(constraint) {
                    return constraint.owner !== this.get('lineage');
                }, this);
            },

            /**
             * Filters the collapsed constraints (see getCollapsedConstraints below) to the one that is owned
             * by the object.
             *
             * @return {Array<Object>}
             */

            getOwnConstraint: function() {
                return _(this.getCollapsedConstraints()).find(function(constraint) {
                    return constraint.owner === this.get('lineage');
                }, this);
            },

            /**
             * Returns a list of field objects containing only those field names that can be referenced
             * in the search language.
             *
             * Includes primitive fields and those that come from calculations.
             * Removes all objectCount and childCount fields.
             *
             * @return {Array<String>}
             */

            getAllSearchFields: function() {
                var ownFieldNames = _(this.getOwnFields())
                        .chain()
                        .filter(function(field) { return !(field.type in { objectCount: true, childCount: true }); })
                        .value(),
                    inheritedFieldNames = _(this.getInheritedFields())
                        .chain()
                        .filter(function(field) { return !(field.type in { objectCount: true, childCount: true }); })
                        .value(),
                    ownCalculatedFieldNames = _(this.getOwnCalculations())
                        .chain()
                        .pluck('outputFields').flatten()
                        .value();

                return _.union(inheritedFieldNames, ownFieldNames, ownCalculatedFieldNames);
            },

            /**
             * Returns the results of getAllSearchFields plus the _raw field
             *
             * @return {Array}
             */
            getAllowedInputFields: function() {
                var rawField = [Field.createRawField().getBasicDescription()];
                var allFields = this.getAllSearchFields();

                return _.union(rawField, allFields);
            },

            /**
             * Return true if the field is owned by this Object
             *
             * @param fieldName
             * @return {Boolean}
             */
            isOwnField: function(fieldName) {
                var field = this.getField(fieldName);
                if (field && field.get("owner") == this.get("lineage"))
                    return true;
                return false;
            },


            /**
             * Returns a search string that will generate a table with only the object's search language fields.
             *
             * TODO: we may be able to remove this now that the back end appends it
             *
             * @return {String}
             */

            getPreviewSearch: function() {
                var allFieldNames = _(this.getAllSearchFields()).pluck('fieldName');
                return (this.get('objectSearch') + ' | fields ' + allFieldNames.join(','));
            },

            getCalculationPreviewSearch: function(calculationFieldNames, includeAllFields, includeTime) {
                var previewSearch = this.get("previewSearch") + " | fields ";

                var fieldsString = "";
                var useComma = false;

                if (includeTime)
                    calculationFieldNames.unshift("_time");

                _(calculationFieldNames).each(function(fieldName) {
                    if (useComma)
                        fieldsString += ",";
                    fieldsString += '"' + fieldName + '"';
                    useComma = true;
                }, this);

                if (includeAllFields) {
                    _(this.getAllSearchFields()).each(function(field) {
                        if (!_(calculationFieldNames).contains(field.fieldName)) {
                            if (useComma)
                                fieldsString += ",";
                            fieldsString += '"' + field.displayName + '"';
                            useComma = true;
                        }
                    }, this);

                    if (useComma)
                        fieldsString += ",";
                    fieldsString += "*";
                }

                return previewSearch + fieldsString;
            },

            /**
             * Add a new Field to the Object
             *
             * @param attributes
             * @param options
             * @return The new Field
             */
            addField: function(attributes, options) {
                attributes = $.extend({ owner: this.get('lineage') }, attributes);
                return this.fields.add(attributes, options);
            },
            /**
             * Removes a field from the object
             *
             * Will not remove the field if it is inherited.
             *
             * @param attributes {Object} - the attributes needed to find the field to remove,
             * will be matched by field name
             */

            removeField: function(attributes) {
                var toRemove = this.fields.get(attributes.fieldName);

                if(!toRemove || toRemove.get('owner') !== this.get('lineage')) {
                    // fail silently if the field doesn't exist or it is inherited
                    // FIXME: should we throw or log an error?
                    return;
                }
                this.fields.remove(toRemove);
            },

            getField: function(fieldName) {
                return this.fields.get(fieldName);
            },

            getCalculation: function(calculationID) {
                return this.calculations.get(calculationID);
            },

            getAnyField: function(fieldName, calculationID) {
                if (calculationID) {
                    var calc = this.getCalculation(calculationID);
                    if (calc)
                        return calc.getFieldByName(fieldName);
                }

                return this.getField(fieldName);
            },

            /**
             * Create a new calculation in the object and return a reference to it.
             *
             * @param attributes {Object} an object literal with the attributes to construct the new calculation
             * @param options {Object} - options to pass to the collection add method ("at" will be ignored)
             * @return {Model} - the newly created calculation model
             */

            createCalculation: function(attributes, options) {
                var calcs = this.calculations,
                    beforeLength = calcs.length;

                attributes = attributes || {};
                $.extend(attributes, {
                    owner: this.get('lineage'),
                    calculationID: Math.random().toString(36).slice(2)
                });

                // not supporting adding a calculation at a specific index, so delete the 'at' option
                options = options || {};
                delete options.at;

                calcs.add(attributes, options);
                // the new calculation is at the end of the collection,
                // so look it up based on the original length and return it
                var newCalc = calcs.at(beforeLength);

                // Prepopulate the outputFields for a GeoIP
                if (attributes.calculationType == "GeoIP")
                    newCalc.addGeoIPFields(options);

                return newCalc;
            },

            /**
             * Removes a calculation from the object
             *
             * @param calculationID - The calculationID attribute of the calculation to remove
             */

            removeCalculation: function(calculationID) {
                var toRemove = this.calculations.get(calculationID);
                this.calculations.remove(toRemove);
            },

            /**
             * Re-orders the objects calculations to match the given list of ids
             *
             * @param order {Array<String>} a list of calculation cid's
             */
            reOrderCalculations: function(order) {

                var ownCalculationIndices = [];

                // Populate ownCalculationIndices array with the indices of our own calculations
                // which might be sparsely located within the calculations array
                this.calculations.each(function(calculation, index) {
                    var calculationBasic = calculation.getBasicDescription();

                    if (this.isOwnCalculation(calculationBasic)) {
                        ownCalculationIndices.push(index);
                    }
                }, this);

                // We only want to reorder our own calculations. So non-own calculations stay at the
                // same index. Own calculations map from the new order array to the sparse indices.
                var newCollection = this.calculations.sortBy(function(calculation, index) {
                    var returnIndex = index;
                    var calculationBasic = calculation.getBasicDescription();

                    if (this.isOwnCalculation(calculationBasic))
                        returnIndex = ownCalculationIndices[_(order).indexOf(calculationBasic.calculationID+'')];

                    return returnIndex;
                }, this);

                this.calculations.reset(newCollection);

            },

            // apply the specified callback to each descendant of the specified parent object
            // TODO: this depends on the object being inside of an ObjectHierarchy, it should really be moved
            withEachDescendant: function(callback, context) {
                if(!this.children) {
                    return;
                }
                context = context || null;

                var recApplyFn = function(child) {
                    callback.call(context, child);
                    _(child.children).each(recApplyFn);
                };

                _(this.children).each(recApplyFn);
            },

            getSampleValuesModel: function(fieldName, owner, fetchOptions) {
                var safeFieldName = this.addLineagePrefix(fieldName, owner),
                    existingModel = this.fieldSampleValues.get(safeFieldName);

                if (existingModel) {
                    if (_.isEqual(this.modelIdAndFechOptionsDataMapping[existingModel.cid], fetchOptions.data)) {
                        return existingModel;
                    }
                    else if (this.modelIdAndFechOptionsDataMapping[existingModel.cid]) {
                        this.fieldSampleValues.remove(existingModel.cid);
                        delete this.modelIdAndFechOptionsDataMapping[existingModel.cid];
                    }
                }
                this.fieldSampleValues.add({ fieldName: safeFieldName });
                var newModel = this.fieldSampleValues.get(safeFieldName);
                newModel.fetch(fetchOptions);
                this.modelIdAndFechOptionsDataMapping[newModel.cid] = fetchOptions.data;

                return newModel;
            },

            addLineagePrefix: function(fieldName, owner) {
                var baseObjectNames = ['BaseEvent', 'BaseTransaction', 'BaseSearch', 'BaseInterface', 'BaseImplements'];
                if(!_(baseObjectNames).contains(owner)) {
                    return owner + '.' + fieldName;
                }
                return fieldName;
            },

            // ----- sync behavior ----- //

            initializeAssociated: function() {
                this.fieldSampleValues = this.fieldSampleValues || new FieldSampleValues();

                this.associated = this.associated || {};
                if (!this.fields) {
                    this.fields = this.associated.fields = new Fields();
                    this.fields.on({
                        "change": function(model, options) {this.triggerAssociatedChange("change", model, options);},
                        "associatedChange": function(model, options) {this.triggerAssociatedChange("associatedChange", model, options);},
                        "add":function(model, options) {this.triggerAssociatedChange("add", model, options);},
                        "remove":function(model, options) {this.triggerAssociatedChange("remove", model, options);},
                        "update":function(model, options) {this.triggerAssociatedChange("update", model, options);},
                        "reset":function(model, options) {this.triggerAssociatedChange("reset", model, options);}
                    }, this);
                }

                if (!this.calculations) {
                    this.calculations = this.associated.calculations = new Calculations();
                    this.calculations.on({
                        "change": function(model, options) {this.triggerAssociatedChange("change", model, options);},
                        "associatedChange": function(model, options) {this.triggerAssociatedChange("associatedChange", model, options);},
                        "add":function(model, options) {this.triggerAssociatedChange("add", model, options);},
                        "remove":function(model, options) {this.triggerAssociatedChange("remove", model, options);},
                        "update":function(model, options) {this.triggerAssociatedChange("update", model, options);},
                        "reset":function(model, options) {this.triggerAssociatedChange("reset", model, options);}
                    }, this);
                }
            },

            triggerAssociatedChange: function(eventName, model, options) {
                //console.log("Object [",this.cid,"] [",this.get("displayName"),"] event [",eventName, "] model [",model.id, "]");
                this.trigger("associatedChange", model, options);
            },

            clone: function(options) {
                var clone = BaseModel.prototype.clone.call(this);
                clone.fields.set(this.fields.toJSON(options));
                clone.calculations.set(this.calculations.toJSON(options));
                return clone;
            },

            parse: function(response, options) {
                response = $.extend(true, {}, response);
                // set the display name to the object name if none is specified
                if(!response.displayName) {
                    response.displayName = response.objectName;
                }
                return this.parseAssociated(response, options);
            },

            parseAssociated: function(response, options) {
                this.initializeAssociated();

                // Clear the fieldSampleValues cache and reapply the baseSearch string
                this.fieldSampleValues.reset();
                this.fieldSampleValues.setBaseSearch(response.objectSearch);
                this.fieldSampleValues.setTsidxNamespace(response.tsidxNamespace);

                if(response.fields) {
                    this.fields.set(response.fields, $.extend({ parse: true }, options));
                    delete response.fields;
                }
                if(response.calculations) {
                    this.calculations.set(response.calculations, $.extend({ parse: true }, options));
                    delete response.calculations;
                }
                return response;
            },

            toJSON: function(options) {
                var json = BaseModel.prototype.toJSON.apply(this, arguments);
                json.fields = this.fields.toJSON(options);
                json.calculations = this.calculations.toJSON(options);
                return json;
            },


            // ----- private methods ----- //


            /**
             * Returns a list of object literals representing a simple description of the object's fields.
             *
             * @return {Array<Object>}
             */

            getFieldList: function() {
                return this.fields.map(function(field) {
                    return field.getBasicDescription();
                });
            },

            /**
             * Returns a list of object literals representing a simple description of the object's calculations.
             *
             * @return {Array<Object>}
             */

            getCalculationList: function() {
                return this.calculations.map(function(calc) {
                    return calc.getBasicDescription();
                });
            },

            /**
             * Returns a list of constraint objects where any constraints with the same owner have been combined.
             *
             * Constraints are combined by joining their "search" attribute on a space character
             *
             * For example if the object's constraints have this structure:
             *
             * [
             *   {
             *     owner: "Object1",
             *     search: "field1=value1"
             *   },
             *   {
             *     owner: "Object2",
             *     search: "field2=value2"
             *   },
             *   {
             *     owner: "Object2",
             *     search: "field3=value3"
             *   }
             * ]
             *
             * The method will return this structure:
             *
             * [
             *   {
             *     owner: "Object1",
             *     search: "field1=value1"
             *   },
             *   {
             *     owner: "Object2",
             *     search: "field2=value2 field3=value3"
             *   }
             * ]
             *
             * @return {Array<Object>}
             */

            getCollapsedConstraints: function() {
                var constraints = this.get('constraints'),
                    groupedList = _(constraints).groupBy('owner'),
                    ownerList = _(constraints).chain().pluck('owner').uniq().value();

                return _(ownerList).map(function(owner) {
                    return {
                        owner: owner,
                        search: _(groupedList[owner]).pluck('search').join(' ')
                    };
                });
            },

            toString: function() {
                return "Object ["+this.cid+"] displayName [" + this.get("displayName") + "] " + this.calculations.toString();
            }

	    });
	}
);

/**
 * A collection representing the object hierarchy of a data model
 *
 * To be used only as an internal member of the "models/services/datamodel/DataModel" module
 */

define('collections/services/datamodel/private/ObjectHierarchy',[
            'underscore',
            'collections/Base',
            'models/services/datamodel/private/Object'
        ],
        function(
            _,
            Base,
            DMObject
        ) {

    return Base.extend({

        /**
         *  A list of reserved root object names representing the abstract base classes for data model objects.
         *  Their order in this list will also dictate the order of root objects in each hierarchy instance,
         *  e.g. all root objects that inherit from BaseEvent will come first.
         */

        ROOT_OBJECT_ORDER: ['BaseEvent', 'BaseTransaction', 'BaseSearch', 'BaseInterface', 'BaseImplements'],

        model: DMObject,

        initialize: function(models, options) {
            Base.prototype.initialize.call(this, models, options);

            // a private instance member containing the hierarchy's root objects
            // used as an entry point for walking the tree
            this._rootObjects = [];

            this.on('reset change:parentName add remove', this.buildHierarchy, this);
        },

        /**
         * Triggered on any reset, add, or remove event.  Re-builds the object hierarchy by reading each object's
         * "parentName" attribute and using it to make sure that parent object has the correct list of children.
         *
         * TODO: should this method throw or trigger an error if the models are not in a valid state?
         */

        buildHierarchy: function() {
            var childrenMap,
                that = this,
                hasNoParent = function(model) {
                    return _(that.ROOT_OBJECT_ORDER).indexOf(model.get('parentName')) > -1;
                };

            // build record of root objects and parent->children relationships
            this._rootObjects = this.filter(hasNoParent);
            childrenMap = this.chain().reject(hasNoParent).groupBy(function(model) {
                return model.get('parentName');
            }).value();

            // clear out any existing child lists
            this.each(function(object) {
                delete(object.children);
            });
            // assign each child list as a member of the model, assembling the tree
            // TODO [JCS] Do we need to do this now that the backend provides a children property?
            _(childrenMap).each(function(childList, parentName) {
                childrenMap[parentName] = _(childList).sortBy(function(child) { return child.get('objectName'); });
                var parentModel = this.find(function(model) { return model.get('objectName') === parentName; });
                parentModel.children = childList;
            }, this);

            // sort the root level objects based on the "root object order" property
            this._rootObjects = _(this._rootObjects).sortBy(function(obj) {
                return _(this.ROOT_OBJECT_ORDER).indexOf(obj.get('parentName'));
            }, this);

            // populate the the rootParent field for each object
            _(this._rootObjects).each(function(root) {
                var rootParentName = root.get('parentName');
                root.set({
                    rootParent: rootParentName
                }, {silent: true});
                root.withEachDescendant(function(child) {
                    child.set({
                        rootParent: rootParentName
                    }, {silent: true});
                }, this);
            }, this);
        },

        /**
         * @param fn - the function to call with each object as its argument, expected to return an object literal
         * @param context - (optional) the scope in which to call the function
         * @return {Array}
         *
         * A tree-structure-flattening version of map
         *
         * Returns a list generated by applying the given callback to each object and then recursively to its children,
         * and also appends a 'depth' field to each item in the returned list, indicating that object's depth in the tree.
         *
         * For example with the following hierarchy structure:
         *
         * Parent
         *   --> ChildOne
         *         --> GrandChildOne
         *         --> GrandChildTwo
         *   --> ChildTwo
         *         --> GrandChildThree
         * Sibling
         *   --> ChildThree
         *
         * Calling "depthFirstMap(function(obj) { return { name: obj.get('objectName') }; });" would return:
         *
         * [
         *   {
         *     name: "Parent",
         *     depth: 0
         *   },
         *   {
         *     name: "ChildOne",
         *     depth: 1
         *   },
         *   {
         *     name: "GrandChildOne",
         *     depth: 2
         *   },
         *   {
         *     name: "GrandChildTwo",
         *     depth: 2
         *   },
         *   {
         *     name: "ChildTwo",
         *     depth: 1
         *   },
         *   {
         *     name: "GrandChildThree",
         *     depth: 2
         *   },
         *   {
         *     name: "Sibling",
         *     depth: 0
         *   },
         *   {
         *     name: "ChildThree",
         *     depth: 1
         *   }
         * ]
         */

        depthFirstMap: function(fn, context) {
            context = context || null;
            var list = [],

                recApplyFn = function(obj, depth) {
                    var mappedObj = fn.call(context, obj);
                    mappedObj.depth = depth;
                    list.push(mappedObj);
                    depth++;
                    _(obj.children).each(function(obj) {
                        recApplyFn(obj, depth);
                    });
                };

            _(this._rootObjects).each(function(obj) {
                recApplyFn(obj, 0);
            });
            return list;
        },
        /**
         * Returns an array of the root objects, sorted by ROOT_OBJECT_ORDER
         *
         * @return {Array}
         */
        getRootObjects: function() {
            return this._rootObjects;
        },

        getAncestorsForObject: function(objectName) {
            var object = this.get(objectName);
            var ancestors = [];
            var parentName = "";

            while (object && !_.contains(this.ROOT_OBJECT_ORDER, parentName)) {
                parentName = object.get("parentName");
                object = this.get(parentName);
                if (object) {
                    ancestors.push(object);
                }
            }

            return ancestors;

        }

    });

});
/**
 * A model representing an individual data model.
 *
 * For a description of the backing endpoint, see: http://eswiki.splunk.com/Data_Model_JSON_Specification
 */

define('models/services/datamodel/DataModel',[
            'jquery',
            'underscore',
            'backbone',
            'models/Base',
            'models/SplunkDBase',
            'models/services/datamodel/private/Acceleration',
            'models/services/datamodel/private/DataModelWhiteList',
            'collections/services/datamodel/private/ObjectHierarchy',
            'util/console',
            'util/splunkd_utils'
        ],
        function(
            $,
            _,
            Backbone,
            BaseModel,
            SplunkDBase,
            Acceleration,
            DataModelWhiteList,
            ObjectHierarchy,
            console,
            splunkDUtils
        ) {

    var CONSTS = {
        BASE_EVENT : "BaseEvent",
        BASE_TRANSACTION : "BaseTransaction",
        BASE_SEARCH : "BaseSearch"
    };

    var DataModel = SplunkDBase.extend({

        initialize: function(attributes, options) {
            var dataModelWhiteList = new DataModelWhiteList();
            options = $.extend({ splunkDWhiteList: dataModelWhiteList }, options);
            return SplunkDBase.prototype.initialize.call(this, attributes, options);
        },

        /**
         *  Returns the data model's object hierarchy as a flattened list of object literals with basic attributes.
         *
         *  For a full description of the structure returned, see the depthFirstMap method in the
         *  "collections/services/datamodel/private/ObjectHierarchy" module
         *
         *  @return {Array}
         */

        getFlattenedHierarchy: function() {
            return (this.entry.content.objects.depthFirstMap(function(obj) {
                return obj.getBasicAttributes();
            }));
        },

        /**
         * Returns a processed version fo the result of getFlattenedHierarchy.
         * Add an "isPivotable" boolean attribute to each object.
         */

        getPivotableHierarchy: function() {
            return _(this.getFlattenedHierarchy()).map(function(obj) {
                obj.isPivotable = this.objectByName(obj.objectName).isPivotable();
                return obj;
            }, this);
        },

        /**
         * Returns the flattened object hierarchy (see getFlattenedHierarchy above) and divides it into sub-hieararchies,
         * one for each of the abstract base object types.
         *
         * The data structure returned is a dictionary of base object names mapping to sub-hierarchies.
         *
         * @return {Object}
         */

        getGroupedFlattenedHierarchy: function() {
            var groupedObjects = _(this.getFlattenedHierarchy()).groupBy(function(obj) {
                return obj.rootParent;
            });

            var returnObject = {};
            returnObject[CONSTS.BASE_EVENT] = groupedObjects[CONSTS.BASE_EVENT] || [];
            returnObject[CONSTS.BASE_TRANSACTION] = groupedObjects[CONSTS.BASE_TRANSACTION] || [];
            returnObject[CONSTS.BASE_SEARCH] = groupedObjects[CONSTS.BASE_SEARCH] || [];

            return returnObject;
        },

        getObjectCount: function() {
            return this.entry.content.objects.length;
        },

        // since the model can be fetched in "concise" mode without the collection of objects,
        // this method provides a way to get the count of objects from the "objectSummary"
        // NOTE: dynamically added/removed objects will not be reflected in this count
        getSummarizedObjectCount: function() {
            // the groups are mutually exclusive, so we can just add up all of the counts
            return _(this.entry.content.objectSummary.toJSON()).reduce(function(runningTotal, groupCount) {
                return runningTotal + groupCount;
            }, 0);
        },

        isEmpty: function() {
            return this.getSummarizedObjectCount() === 0;
        },

        /**
         * Returns true if the data model is privately shared
         * @return {Boolean}
         */
        isPrivate: function() {
            return this.entry.acl.get("sharing") == splunkDUtils.USER;
        },
        /**
         * Returns true if the data model was generated from an sid and has not been saved to the back end.
         * @returns {boolean}
         */
        isTemporary: function() {
            return this.has('sid');
        },
        /**
         * Returns true if the model can be accelerated. Private models can not be accelerated.
         * @return {Boolean}
         */
        canAccelerate: function() {
            var hasEventObject = this.entry.content.objectSummary.get("Event-Based") > 0;
            return hasEventObject && !this.isPrivate();
        },

        /**
         * Returns true if the user can change the model's permissions
         * @return {Boolean}
         */
        canChangePermissions: function() {
            return this.entry.acl.get('can_change_perms');
        },

        /**
         * Returns true if the model can be deleted.
         *
         * @return {Boolean}
         */
        canDelete: function() {
            return this.entry.links.get("remove") ? true : false;
        },

        /**
         * Returns true if the model can be edited.
         * @return {Boolean}
         */
        canWrite: function() {
            return this.entry.acl.get('can_write') ? true : false;
        },

        isAccelerated: function() {
            return this.entry.content.acceleration ? (this.entry.content.acceleration.get("enabled") ? true : false) : false;
        },

        getAncestorsForObject: function(objectName) {
            return this.entry.content.objects.getAncestorsForObject(objectName);
        },

        /**
         * @param objName {String} - the objectName of an object to look up in the hierarchy
         * @return {Model} - a reference to the object, or undefined if it's not there
         */

        objectByName: function(objName) {
            return this.entry.content.objects.get(objName);
        },

        objectByLineage: function(lineage) {
            var objects = lineage.split(".");

            if (objects.length > 0) {
                return this.objectByName(objects[objects.length-1]);
            }

            return undefined;
        },

        /**
         * Adds a new object with the given attributes to the data model and returns a reference to it.
         *
         * @param attributes {Object} - an object literal with the attributes to construct the new object model
         * @param options {Object} - options to pass to the collection add method ("at" will be ignored)
         * @return {Model} - the newly created object model
         */

        addObject: function(attributes, options) {
            // TODO: maybe throw an error if objectName or parentName are not defined
            // TODO [JCS] Allow adding to a transaction, event or search
            if(!attributes.parentName) {
                console.warn('DataModel: addObject called with no parent name specified, using BaseEvent as a default');
                attributes.parentName = CONSTS.BASE_EVENT;
            }
            var objects = this.entry.content.objects,
                beforeLength = objects.length;

            // not supporting adding objects at a particular index, so delete the 'at' option
            options = options || {};
            delete options.at;
            objects.add(attributes, options);
            // the new object is at the end of the collection, so look it up based on the original length and return it
            return objects.at(beforeLength);
        },

        /**
         * Removes an object and its children from the data model.
         *
         * A no-op if the model is currently in the data model.
         *
         * @param object {Model} - the object model instance to be removed
         */

        removeObjectAndChildren: function(object) {
            object.withEachDescendant(function(child) {
                this.entry.content.objects.remove(child, { silent: true });
            }, this);
            this.entry.content.objects.remove(object);
        },

        // ------ sync behavior ---- //

        url: 'datamodel/model',
        generateFromSidUrl: 'datamodel/generate',

        sync: function(method, model, options) {
            // If an sid is included in the params for a fetch, populate the data model using the generate-from-sid endpoint.
            if(method === 'read' && options && options.data && options.data.sid) {
                options = $.extend(true, { output_mode: 'json' }, options);
                options = splunkDUtils.prepareSyncOptions(options, model.generateFromSidUrl);
                var optionsData = options.data;
                // The fields and field_coverage options are mutually exclusive, let fields trump field_coverage.
                if(optionsData.fields) {
                    delete optionsData.field_coverage;
                }
                return Backbone.Model.prototype.sync.call(this, method, model, options);
            }
            return SplunkDBase.prototype.sync.apply(this, arguments);
        },

        initializeAssociated: function() {
            SplunkDBase.prototype.initializeAssociated.call(this);
            var content = this.entry.content;

            if (!content.objects) {
                content.objects = content.associated.objects = new ObjectHierarchy();
                content.objects.on("change associatedChange add remove update reset",
                                function(model, options) {this.trigger("associatedChange", model, options);}, this);
            }

            content.objectSummary = content.associated.objectSummary = content.objectSummary || new BaseModel();
            content.acceleration = content.associated.acceleration = content.acceleration || new Acceleration();
        },

        clone: function() {
            // TODO [sff] this is horrible...
            // have to set a temporary flag or if the model is accelerated it will not clone itself correctly
            this.entry.content.isCloning = true;
            var clone = new this.constructor();
            clone.setFromSplunkD(this.toSplunkD());
            // TODO [sff] do we have to call this?
            clone.entry.content.objects.buildHierarchy();
            this.entry.content.isCloning = false;
            return clone;
        },

        parse: function(response, options) {
            response = $.extend(true, {}, response);
            this.initializeAssociated();
            response = this.parseSplunkDPayload(response);
            // If the data model was generated from an sid, add that sid to the root attributes.
            if(options && options.data && options.data.sid) {
                response.sid = options.data.sid;
            }
            return SplunkDBase.prototype.parse.call(this, response);
        },
        parseFile: function(response) {
            response = $.extend(true, {}, response);
            this.initializeAssociated();
            response = this.parseSplunkDPayload(response);
            var response_entry = response.entry[0];
            this.entry.content.set(response_entry.content);
            delete response_entry.content;
            delete response.entry;
            return response;    
        },
        setFromSplunkD: function(payload, options) {
            payload = $.extend(true, {}, payload);
            //console.log("DataModel.setFromSplunkD before parse",this.toString());
            payload = this.parseSplunkDPayload(payload, options);
            //console.log("DataModel.setFromSplunkD after parse",this.toString());
            return SplunkDBase.prototype.setFromSplunkD.call(this, payload, options);
        },

        parseSplunkDPayload: function(payload, options) {
            var entry = payload.entry;
            var acceleration;

            if(entry && entry.length > 0 && entry[0].content) {
                //console.log("DM.parseSplunkDPayload",this.cid,"objects[0].calculations");

                // Save the acceleration info and apply later since content gets clobbered
                if (entry[0].content.acceleration)
                    acceleration = JSON.parse(entry[0].content.acceleration); // String representation of the acceleration JSON
                // what we want to treat as content from now on is actually stringified into the "description" attribute
                var content;

                if (_(entry[0].content).has("description")) {
                    content = entry[0].content = JSON.parse(entry[0].content.description);
                } else {
                    content = entry[0].content;
                }

                // set the display name equal to the model name if no display name is given
                if(!content.displayName) {
                    content.displayName = content.modelName;
                }

                if(_(content.objects).isArray()) {
                    this.entry.content.objects.set(content.objects, $.extend({ parse: true }, options));
                    delete content.objects;
                }
                if (_(content.objectSummary).isObject()) {
                    this.entry.content.objectSummary.set(content.objectSummary, $.extend({ parse: true }, options));
                    delete content.objectSummary;
                }
                if (_(acceleration).isObject()) {
                    this.entry.content.acceleration.set(acceleration, $.extend({ parse: true }, options));
                }
            }
            return payload;
        },

        toString: function() {
            var children = "";
            this.entry.content.objects.each(function(object) {
                if (children != "")
                    children += ", ";
                children += object.toString();
            }, this);

            return "DataModel [" + this.cid + "] objects cid [" + this.entry.content.objects.cid + "] Objects: " + children;
        }

    }, CONSTS);

    // break the shared reference to Entry
    DataModel.Entry = SplunkDBase.Entry.extend({});
    // now we can safely extend Entry.Content
    DataModel.Entry.Content = SplunkDBase.Entry.Content.extend({

        toJSON: function(options) {
            var json = SplunkDBase.Entry.Content.prototype.toJSON.apply(this, arguments);
            var returnValue = {};

            if(this.objects.length > 0) {
                json.objects = this.objects.toJSON(options);
            }

            if (this.objectSummary) {
                json.objectSummary = this.objectSummary.toJSON(options);
            }

            if (this.acceleration) {
                returnValue.acceleration = JSON.stringify(this.acceleration.toJSON(options));
            }

            //console.log("=========== DataModelV2.toJSON =============");
            //console.log(JSON.stringify(json));
            if (json.name) {
                json.modelName = json.name;
                returnValue.name = json.name;
                delete json.name;
            }

            var accelerationEnabled = this.acceleration ? this.acceleration.get("enabled") : false;
            if (this.isCloning || _.isUndefined(accelerationEnabled) || !accelerationEnabled || this.isCreating)
                returnValue.description = JSON.stringify(json);

            return returnValue;
        }

    });

    return DataModel;

});

/**
 * A collection of data models
 */

define('collections/services/datamodel/DataModels',[
            'jquery',
            'underscore',
            'collections/SplunkDsBase',
            'models/services/datamodel/DataModel'
        ],
        function(
            $,
            _,
            SplunkDsBase,
            DataModel
        ) {

    return SplunkDsBase.extend({

        model: DataModel,
        url: 'datamodel/model'

    });

});
define('views/shared/splunkbar/find/Master',[
    'jquery',
    'underscore',
    'module',
    'models/Base',
    'views/shared/splunkbar/find/results/Master',
    'views/shared/splunkbar/find/FindProgress',
    'views/shared/tablecaption/Input',
    'collections/shared/Dashboards',
    'collections/search/Reports',
    'collections/search/Alerts',
    'collections/services/datamodel/DataModels',
    'views/Base',
    'util/splunkd_utils'
],
function(
    $,
    _,
    module,
    BaseModel,
    FindBarResults,
    FindProgress,
    InputView,
    DashboardsCollection,
    ReportsCollection,
    AlertsCollection,
    DataModelsCollection,
    BaseView,
    splunkdUtils
) {
    return BaseView.extend({
        moduleId: module.id,
        tagName: 'li',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            //models
            this.stateModel = new BaseModel();
            this.rawSearch = new BaseModel();
            //collections
            this.collection.dashboards = new DashboardsCollection();
            this.collection.reports = new ReportsCollection();
            this.collection.alerts = new AlertsCollection();
            this.collection.datamodels = new DataModelsCollection();
            //deferreds
            this.deferreds = {};
            this.deferreds.dashboardDeferred = $.Deferred();
            this.deferreds.reportDeferred = $.Deferred();
            this.deferreds.alertDeferred = $.Deferred();
            this.deferreds.datamodelDeferred = $.Deferred();
            
            this.children.findProgress = new FindProgress({
                model: {
                    application: this.model.application,
                    state: this.stateModel
                },
                mode: 'menu',
                onHiddenRemove: true
            });

            this.stateModel.on('change:search',  
                _.debounce(function() {
                    var rawSearch = this.rawSearch.get('rawSearch');
                    if (!rawSearch || rawSearch === '') {
                        if(this.children.findbarResults) {
                            this.children.findbarResults.hide();   
                        }
                        this.collection.dashboards = new DashboardsCollection();
                        this.collection.reports = new ReportsCollection();
                        this.collection.alerts = new AlertsCollection();
                        this.collection.datamodels = new DataModelsCollection();
                       return;
                    }
                    var $target =  $('.findbar-container'),
                        $focus = $('.findbar-container .search-query');
                    
                    // Show find progress while waiting for results to return.
                    if(this.children.findbarResults) {
                        this.children.findbarResults.hide();   
                    }
                    $($target).append(this.children.findProgress.render().el);
                    this.children.findProgress.show($target, {$onOpenFocus: $focus});

                    this.deferreds.dashboardDeferred = $.Deferred();
                    this.deferreds.reportDeferred = $.Deferred();
                    this.deferreds.alertDeferred = $.Deferred();
                    this.deferreds.datamodelDeferred = $.Deferred();
                    this.fetchDashboardCollection();
                    this.fetchReportCollection();
                    this.fetchAlertCollection();
                    this.fetchDataModelCollection();
                    
                    this.collection.dashboards.on('sync', function() {
                            this.deferreds.dashboardDeferred.resolve();
                    }.bind(this));
                    
                    this.collection.reports.on('sync', function() {
                        this.deferreds.reportDeferred.resolve();
                    }.bind(this));
            
                    this.collection.alerts.on('sync', function() {
                        this.deferreds.alertDeferred.resolve();
                    }.bind(this));
            
                    this.collection.datamodels.on('sync', function() {
                        this.deferreds.datamodelDeferred.resolve();
                    }.bind(this));
                    
                    $.when(
                        this.deferreds.dashboardDeferred,
                        this.deferreds.reportDeferred,
                        this.deferreds.alertDeferred,
                        this.deferreds.datamodelDeferred
                    ).then(function() {
                        this.showFindBarResults($target);
                    }.bind(this));
                }.bind(this), 250),
                this
            );
        },
        events: {
            'click .findbar-container': function(e){
                var rawSearch = this.rawSearch.get('rawSearch');
                if (rawSearch && rawSearch !== '') {
                    var $target = $(e.currentTarget);
                    this.showFindBarResults($target);
                }
            }
        },
        showFindBarResults: function($target) {
            var $focus = $('.findbar-container .search-query');
            this.children.findProgress.hide();
            if (this.children.findbarResults && this.children.findbarResults.shown) {
                this.children.findbarResults.render();
                return;
            }
            this.children.findbarResults = new FindBarResults({
                collection: {
                    dashboards: this.collection.dashboards,
                    reports: this.collection.reports,
                    alerts: this.collection.alerts,
                    datamodels: this.collection.datamodels,
                    apps: this.collection.apps
                },
                model: {
                    application: this.model.application,
                    state: this.stateModel,
                    rawSearch: this.rawSearch
                },
                mode: 'menu',
                onHiddenRemove: true
            });
            $($target).append(this.children.findbarResults.render().el);
            this.children.findbarResults.show($target, {$onOpenFocus: $focus});
        },
        fetchDashboardCollection: function() { 
            var dashboards = this.collection.dashboards,
                search = '';
            if (this.rawSearch.get('rawSearch')) {
                search = splunkdUtils.createSearchFilterString(this.rawSearch.get('rawSearch'), ['label','eai:data']);
                
            }
            if (search) {
                search += ' AND ';
            }
            search += DashboardsCollection.availableWithUserWildCardSearchString(this.model.application.get('owner')); 

            dashboards.safeFetch({ 
                data : { 
                    app: '-', 
                    owner: '-', 
                    search: search, 
                    count: 3,
                    offset: 0
                }, 
                success: function(response) {
                }.bind(this) 
            }); 
        },
        fetchReportCollection: function() {
            var reports = this.collection.reports,
                search = this.stateModel.get('search') || '';
            if (search) {
                search += ' AND ';
            }
            search += ReportsCollection.availableWithUserWildCardSearchString(this.model.application.get('owner')) + ' AND is_visible=1';

            reports.safeFetch({
                data : {
                    app: '-',
                    owner: '-',
                    search: search,
                    count: 3
                },
                excludeAlerts: true,
                success: function() {
                }.bind(this)
            });
        },
        fetchAlertCollection: function() {
            if (!this.model.serverInfo.isFreeLicense()) {
                var alerts = this.collection.alerts,
                    search = this.stateModel.get('search') || '';
                if (search) {
                    search += ' AND ';
                }
                search += ReportsCollection.availableWithUserWildCardSearchString(this.model.application.get('owner')) + ' AND is_visible=1';

                alerts.safeFetch({
                    data:{
                        app: '-',
                        owner: '-',
                        search: search,
                        count: 3
                    },
                    success: function() {
                    }.bind(this)
                });
            } else {
                this.deferreds.alertDeferred.resolve();
            }
        },
        fetchDataModelCollection: function() { 
            if (!this.model.serverInfo.isLite()) {
                var datamodels = this.collection.datamodels, 
                    search = this.rawSearch.get('rawSearch') || ''; 
                if (search) {
                    search += ' AND ';
                }
                search += '(eai:acl.owner="*")';

                datamodels.safeFetch({
                    data : {
                        app: '-',
                        owner: '-',
                        sort_mode: ['auto', 'auto'],
                        search: search,
                        count: 3,
                        offset: 0,
                        concise: true
                    }, 
                    success: function(response) {
                    }.bind(this) 
                }); 
            } else {
                this.deferreds.datamodelDeferred.resolve();
            }
        },
        render: function() {
            var html = this.compiledTemplate();
            this.$el.append(html);
            this.children.findbar = new InputView({
                model: {
                    state: this.stateModel,
                    rawSearch: this.rawSearch
                },
                findBar: true
            });
            this.$('.findbar-container').append(this.children.findbar.render().el);
        },
        template: '\
        <div class="findbar-container"></div>\
        '
    });
});


define('contrib/text!views/shared/splunkbar/messages/NoConnectionOverlay.html',[],function () { return '<div class="modal-backdrop fade in"></div>\n<div class="modal disconnection-warning-modal">\n\t<h3><%= _("Disconnected from Splunk server").t() %></h3>\n\t<p><%= _("Your network connection may have been lost or Splunk server may be down.").t() %></p>\n</div>\n';});

define('views/shared/splunkbar/messages/NoConnectionOverlay',[
    'underscore',
    'module',
    'views/Base',
    'views/shared/WaitSpinner',
    'contrib/text!views/shared/splunkbar/messages/NoConnectionOverlay.html',
    'splunk.util'
],
    function(
        _,
        module,
        BaseView,
        WaitSpinnerView,
        Template,
        splunkUtil
        ){
        
        var image = new Image();
        image.src = splunkUtil.make_url("/static/img/skins/default/loading_medium_green.png");
        var image2x = new Image();
        image2x.src = splunkUtil.make_url("/static/img/skins/default/loading_medium_green_2x.png");
        
        
        return BaseView.extend({
            moduleId: module.id,
            template: Template,
            className: 'splunk-components',
            initialize: function() {
                BaseView.prototype.initialize.apply(this, arguments);
                
                var spinnerOptions = {
                    color: 'green',
                    size: 'medium',
                    frameWidth: 19
                };
                
                this.children.spinner = new WaitSpinnerView(spinnerOptions);
                this.visible = false;
                this.$el.hide();
            },
            show: function() {
                if (this.visible) {
                    return;
                }
                
                this.visible = true;
                this.$el.show();
                this.children.spinner.start();
            },
            hide: function() {
                if (!this.visible) {
                    return;
                }
                
                this.visible = false;
                this.$el.hide();
                this.children.spinner.stop();
            },
            render: function() {
                this.$el.html(this.compiledTemplate);
                this.$(".modal").append(this.children.spinner.render().el);
                return this;
            }
        });
    });


define('contrib/text!views/shared/splunkbar/ProductMenu.html',[],function () { return '<a href="#" class="dropdown-toggle">\n    <i class="icon icon-greater"></i>\n    <span><%- productMenuLabel %></span>\n    <b class="caret"></b>\n</a>\n<div class="dropdown-menu" id="global-product-menu">\n    <div class="arrow"></div>\n    <ul>\n        <li><a class="instances external" href="<%=productMenuUriPrefix%>apex/RMEC_InstancePage" target="productlink"><%- _("Instances").t() %></a></li>\n        <% if(isAdmin) {%>\n            <li><a class="invite external" href="<%=productMenuUriPrefix%>apex/RMEC_InstancePage" target="productlink"><%- _("Upgrade").t() %></a></li>\n            <li><a class="invite external" href="<%=productMenuUriPrefix%>apex/RMEC_InvitePage" target="productlink"><%- _("Invite Users").t() %></a></li>\n        <% }%>\n    </ul>\n</div>\n';});

define('views/shared/splunkbar/ProductMenu',[
    'underscore',
    'module',
    'views/Base',
    'views/shared/delegates/Popdown',
    'contrib/text!views/shared/splunkbar/ProductMenu.html'
],
function(
    _,
    module,
    BaseView,
    Popdown,
    template
){
    return BaseView.extend({
        moduleId: module.id,
        template: template,
        tagName: 'li',
        className: 'dropdown product',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            this.debouncedRender();
        },
        render: function() {
            var productMenuLabel = this.model.webConf.entry.content.get('productMenuLabel') || "My Splunk",
                productMenuUriPrefix = this.model.webConf.entry.content.get('productMenuUriPrefix') || '',
                isAdmin = this.model.user.isAdmin() || this.model.user.isCloudAdmin(),
                html = this.compiledTemplate({
                    productMenuLabel: _(productMenuLabel).t(),
                    productMenuUriPrefix: productMenuUriPrefix,
                    isAdmin: isAdmin
                });
            this.$el.html(html);

            var popup = this.$el.find('#global-product-menu');
            this.popdown = new Popdown({el:popup.parent(), mode: 'dialog'});

            return this;
        }
    });
});

define(
    'models/services/configs/Web',[
        'models/SplunkDBase'
    ],
    function(SplunkDBaseModel) {
        return SplunkDBaseModel.extend({
            url: "configs/conf-web",
            urlRoot: "configs/conf-web",
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
            }
        });
    }
);
define(
    'models/services/authentication/CurrentContext',[
        'models/SplunkDBase'
    ],
    function(SplunkDBaseModel) {
        return SplunkDBaseModel.extend({
            url: "authentication/current-context",
            initialize: function() {
                SplunkDBaseModel.prototype.initialize.apply(this, arguments);
            }
        });
    }
);
define(
    'collections/services/authentication/CurrentContexts',[
        "models/services/authentication/CurrentContext",
        "collections/SplunkDsBase"
    ],
    function(CurrentContextModel, SplunkDsBaseCollection) {
        return SplunkDsBaseCollection.extend({
            model: CurrentContextModel,
            url: "authentication/current-context",
            initialize: function() {
                SplunkDsBaseCollection.prototype.initialize.apply(this, arguments);
            }
        });
    }
);
define('models/shared/splunkbar/SystemMenuSection',[
    'models/Base'
],
function(
    BaseModel
){
    return BaseModel.extend({
        initialize: function(){
            BaseModel.prototype.initialize.apply(this, arguments);
            
            //TODO lame...
            if( !this.get('items') ){
                this.set({items: []});
            }
        }
    });
});
define('collections/shared/splunkbar/SystemMenuSections',[
    'models/shared/splunkbar/SystemMenuSection',
    'collections/Base'
],
function(
    SystemMenuSectionModel,
    BaseCollection
){
    return BaseCollection.extend({
        model: SystemMenuSectionModel,
        initialize: function() {
            BaseCollection.prototype.initialize.apply(this, arguments);
        },
        comparator: function(a, b){
            var x = a.get('order'),
                y = b.get('order');
            if(x === y){
                return 0;
            }
            return x > y ? 1 : -1;
        }
    });
});

define('contrib/text!views/shared/splunkbar/Master.html',[],function () { return '<div class="no_connection-overlay"></div>\n<a href="<%-homeLink%>" class="brand" title="splunk &gt; <%- _(\'listen to your data\').t() %>">splunk<strong>&gt;</strong></a>\n<ul class="navbar-global-nav nav">\n    <li class="dropdown apps">\n        <a href="#" class="dropdown-toggle"><%- _("Apps").t() %><b class="caret"></b></a>\n    </li>\n</ul>\n\n<ul class="navbar-global-nav nav pull-right">\n    <li class="dropdown user"></li>\n    <li class="dropdown messages"><a href="#" class="dropdown-toggle"><%- _("Messages").t() %><b class="caret"></b></a></li>\n    <li class="dropdown system<%- options.section==\'system\' ? \' active \' : \'\'%>">\n        <a href="#" class="dropdown-toggle"><%- _("System").t() %><b class="caret"></b></a>\n    </li>\n    <li class="dropdown activity"><a href="#"><%- _("Activity").t() %></a></li>\n    <li class="dropdown help"><a href="#" class="dropdown-toggle"><%- _("Help").t() %><b class="caret"></b></a></li>\n    <li class="dropdown findbar"></li>\n</ul><!-- /.user-nav -->\n';});


define('contrib/text!views/shared/splunkbar/MasterCloud.html',[],function () { return '<div class="no_connection-overlay"></div>\n<a href="<%-homeLink%>" class="brand" title="splunk &gt; <%- _(\'listen to your data\').t() %>">splunk<strong>&gt;</strong></a>\n<ul class="navbar-global-nav nav">\n    <li class="dropdown apps">\n        <a href="#" class="dropdown-toggle"><%- _("Apps").t() %><b class="caret"></b></a>\n    </li>\n    <li class="dropdown messages"><a href="#" class="dropdown-toggle"><%- _("Messages Cloud").t() %><b class="caret"></b></a></li>\n    <li class="dropdown system<%- options.section==\'system\' ? \' active \' : \'\'%>">\n        <a href="#" class="dropdown-toggle"><%- _("System").t() %><b class="caret"></b></a>\n    </li>\n    <li class="dropdown activity"><a href="#"><%- _("Activity").t() %></a></li>\n    <li class="dropdown findbar"></li>\n</ul>\n\n<ul class="navbar-global-nav nav pull-right">\n    <li class="dropdown user"></li>\n    <li class="dropdown product"></li>\n    <li class="dropdown help"><a href="#" class="dropdown-toggle"><%- _("Resources").t() %><b class="caret"></b></a></li>\n</ul><!-- /.user-nav -->';});

define(
    'util/csrf_protection',[
        'jquery',
        'splunk.util'
    ],
    function($, splunkUtils) {
        var HEADER_NAME = 'X-Splunk-Form-Key';
        var FORM_KEY = splunkUtils.getFormKey();

        // If the form key is not present, return without 
        // setting up the prefilter. Return instead of throwing
        // because there are some scenarios (Independent Mode)
        // where this is the expected behavior.
        if (!FORM_KEY) {
            return;
        }

        if ($) {
            $.ajaxPrefilter(function(options, originalOptions, jqXHR) {
                if (options['type'] && options['type'].toUpperCase() == 'GET') return;
                jqXHR.setRequestHeader(HEADER_NAME, FORM_KEY);
            });

            $(document).ready(function() {
                $(document).bind('ajaxError', function(event, xhr, opts, err) {
                    // because we'll get a 401 when logout is clicked, prevent 
                    // /en-US/account/login?return_to=/en-US/account/logout from happening
                    var pathname = window.location.pathname;
                    if (xhr.status === 401 && pathname.indexOf('/account/logout') === -1) {
                        document.location = splunkUtils.make_url('account/login?return_to=' + encodeURIComponent(pathname + document.location.search));
                        return;
                    }
                });
            });
        } else {
            throw "Splunk's jQuery.ajax extension requires jQuery.";   
        }
    }
);

/* Insert a jQuery ajax prefilter that sets options.cache=false for all GET requests
 * This is a preventative measure to avoid an intermittent bug in Chrome 28 (see SPL-71743)
 */ 

define(
    'util/ajax_no_cache',[
        'jquery'
    ],
    function($) {
        if ($) {
            $.ajaxPrefilter(function(options, originalOptions, jqXHR) {
                if (options.type && options.type.toUpperCase() == 'GET' && options.cache === undefined) {
                    options.cache = false;
                }
            });

        } else {
            throw "ajax_no_cache requires jQuery.";   
        }
    }
);

// splunk bar
define('views/shared/splunkbar/Master',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'splunk.util',
    'helpers/Session',
    'views/Base',
    'views/shared/delegates/Popdown',
    'views/shared/splunkbar/AppMenu',
    'views/shared/splunkbar/SystemMenu',
    'views/shared/splunkbar/UserMenu',
    'views/shared/splunkbar/messages/Master',
    'views/shared/splunkbar/ActivityMenu',
    'views/shared/splunkbar/HelpMenu',
    'views/shared/splunkbar/find/Master',
    'views/shared/splunkbar/messages/NoConnectionOverlay',
    'views/shared/splunkbar/ProductMenu',
    'models/services/data/UserPref',
    'models/services/AppLocal',
    'models/shared/User',
    'models/services/server/ServerInfo',
    'models/services/configs/Web',
    'models/shared/Application',
    'collections/services/authentication/CurrentContexts',
    'collections/services/AppLocals',
    'collections/services/Messages',
    'collections/services/data/ui/Managers',
    'collections/shared/splunkbar/SystemMenuSections',
    'contrib/text!views/shared/splunkbar/Master.html',
    'contrib/text!views/shared/splunkbar/MasterCloud.html',
    'uri/route',
    'util/splunkd_utils',
    'util/csrf_protection',
    'util/ajax_no_cache'
],
function(
    $,
     _,
     Backbone,
     module,
     splunkUtil,
     Session,
     BaseView,
     Popdown,
     AppMenuView,
     SystemMenu,
     UserMenu,
     MessagesView,
     ActivityMenu,
     HelpMenu,
     FindBar,
     NoConnectionOverlay,
     ProductMenu,
     UserPrefModel,
     AppLocalModel,
     UserModel,
     ServerInfoModel,
     WebConfModel,
     ApplicationModel,
     CurrentContextsCollection,
     AppsCollection,
     MessagesCollection,
     ManagersCollection,
     SystemMenuSectionsCollection,
     coreTemplate,
     cloudTemplate,
     route,
     splunkDUtils
){
    var View = BaseView.extend({
        moduleId: module.id,
        className: 'navbar-splunkbar',
        defaults: {
            showAppsList: true
        },
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            this.options = _.extend({},this.defaults, this.options);
            this.MAX_RETRIES_BEFORE_FAIL = 3;
            this.MESSAGES_POLLING_DELAY_STANDARD = 60000;
            this.MESSAGES_POLLING_DELAY_HI_FREQ = 1000;
            this.isFreeDfd = $.Deferred();
            this.userDfd = $.Deferred();
            this.appsDfd =  $.Deferred();
            this.serverInfoDfd = $.Deferred();
            this.webConfDfd = $.Deferred();
            this.cntRetries = 0;
            if (this.model && this.model.user && this.model.user.entry.content.has('realname')){
                this.userDfd.resolve();
            } else {
                this.model.user.on('sync', function() {
                    this.userDfd.resolve();
                }, this);
            }
            if (this.collection && this.collection.apps && this.collection.apps.length){
                this.appsDfd.resolve();
            } else {
                this.collection.apps.on('sync', function() {
                    this.appsDfd.resolve();
                }, this);
            }
            if (this.model && this.model.serverInfo) {
                if (this.model.serverInfo.hasAttr('isFree')) {
                    if (this.model.serverInfo.isFreeLicense()) {
                        this.isFreeDfd.resolve();
                    } else {
                        this.isFreeDfd.reject();
                    }
                } else {
                    this.model.serverInfo.on('change reset', function () {
                        if (this.model.serverInfo.isFreeLicense()) {
                            this.isFreeDfd.resolve();
                        } else {
                            this.isFreeDfd.reject();
                        }
                    }.bind(this));
                }
                if (this.model.serverInfo.hasAttr('product_type')){
                    this.serverInfoDfd.resolve();
                } else {
                    this.model.serverInfo.on('sync', function () {
                        this.serverInfoDfd.resolve();
                    }, this);
                }
            }
            this.collection.sections.on('reset', this.sectionsMunger, this);
            Session.on('restart timeout', function() {
                this.collection.messages.stopPolling();
            }, this);
            Session.on('start', function() {
                this.collection.messages.startPolling();
            }, this);

            if (this.model && this.model.webConf){
                if (this.model.webConf.entry && this.model.webConf.entry.content &&
                    this.model.webConf.entry.content.has('showProductMenu')){
                    this.webConfDfd.resolve();
                } else {
                    this.model.webConf.on('sync', function() {
                        this.webConfDfd.resolve();
                    }, this);
                }
            }
        },
        remove: function() {
            BaseView.prototype.remove.apply(this, arguments);
            Session.off('restart timeout start', null, this);
            return this;
        },
        render: function() {
            $.when(this.serverInfoDfd).then(function() {
                var template = this.model.serverInfo.isCloud() ? cloudTemplate : coreTemplate,
                    homeLink = route.home(
                    this.model.application.get('root'),
                    this.model.application.get('locale'));
                    this.compiledTemplate = this.compileTemplate(template);

                var html = this.compiledTemplate({
                    makeUrl: splunkUtil.make_url,
                    options: this.options,
                    homeLink: homeLink
                });
                this.$el.html(html);

                var activeMenu = this.getActiveMenu();

                $.when(this.userDfd, this.appsDfd).then(function() {
                    if (this.model.user.canUseApps() && this.options.showAppsList){
                        this.children.apps = new AppMenuView({
                            collection: this.collection,
                            model: this.model,
                            activeMenu: activeMenu
                        });
                        this.$('.apps.dropdown').replaceWith(this.children.apps.el);
                    } else {
                        this.$el.find('.apps').remove();
                    }
                    this.children.systemMenu = new SystemMenu({
                        collection: {
                            sections: this.collection.sections,
                            managers: this.collection.managers,
                            apps: this.collection.apps
                        },
                        model: {
                            application: this.model.application,
                            user: this.model.user
                        }
                    });
                    this.$('.system.dropdown').replaceWith(this.children.systemMenu.el);

                    this.children.findbar = new FindBar({
                        model: {
                            user: this.model.user,
                            application: this.model.application,
                            serverInfo: this.model.serverInfo
                        },
                        collection: {
                            apps: this.collection.apps
                        }
                    });
                    //TODO [uks]: Do we need to call render()
                    this.$('.findbar').replaceWith(this.children.findbar.render().el);

                    this.webConfDfd.done(function(){
                        this.isFreeDfd.fail(function() {

                            this.children.userMenu = new UserMenu({
                                collection: {
                                    currentContext: this.model.currentContext //this represents the current logged in user
                                },
                                model: {
                                    user: this.model.user,
                                    application: this.model.application,
                                    webConf: this.model.webConf,
                                    config: this.model.config,
                                    serverInfo: this.model.serverInfo
                                }
                            });
                            this.$('.user.dropdown').replaceWith(this.children.userMenu.el);
                        }.bind(this));
                    }.bind(this));
                }.bind(this));

                this.children.messages = new MessagesView({
                    collection: {
                        messages: this.collection.messages,
                        legacyMessages: this.collection.legacyMessages
                    },

                    model: {
                        serverInfo: this.model.serverInfo
                    }
                });

                this.children.noConnectionOverlay = new NoConnectionOverlay();
                $('body').append(this.children.noConnectionOverlay.render().el);

                this.collection.messages.on('serverValidated', function(success, context, messages) {
                    if (success && this.cntRetries > 0) {
                        this.restartMessagePolling(this.MESSAGES_POLLING_DELAY_STANDARD);
                        this.children.noConnectionOverlay.hide();
                        this.cntRetries = 0;
                        return;
                    }
                    var netErrorMsg = _.find(messages, function(msg) {
                        return msg.type == splunkDUtils.NETWORK_ERROR || 'network_error';
                    });
                    if (netErrorMsg) {
                        if (this.cntRetries == 0) {
                            this.restartMessagePolling(this.MESSAGES_POLLING_DELAY_HI_FREQ);
                        }
                        if (this.cntRetries >= this.MAX_RETRIES_BEFORE_FAIL) {
                            this.children.noConnectionOverlay.show();
                        }
                        this.cntRetries += 1;
                    }
                }, this);
                this.$('.messages.dropdown').replaceWith(this.children.messages.render().el);
                this.restartMessagePolling(this.MESSAGES_POLLING_DELAY_STANDARD);

                $.when(this.userDfd, this.appsDfd).then(function() {
                    this.children.activityMenu = new ActivityMenu({
                        model: {
                            user: this.model.user,
                            application: this.model.application
                        }
                    });
                    this.$('.activity').replaceWith(this.children.activityMenu.el);

                    this.children.helpMenu = new HelpMenu({
                        model: this.model,
                        collection: {
                            apps: this.collection.apps
                        }
                    });
                    this.$('.help').replaceWith(this.children.helpMenu.el);

                    // highlight the active menu
                    if (activeMenu){
                        this.$(activeMenu.selector).addClass("active");
                    }
                }.bind(this));

                //product menu
                $.when(this.webConfDfd, this.userDfd).done(function(){
                    var isCloud = this.model.serverInfo.isCloud(),
                        showProductMenu = splunkUtil.normalizeBoolean(this.model.webConf.entry.content.get('showProductMenu'));

                    if (isCloud && showProductMenu){
                        this.children.productMenu = new ProductMenu({
                            model: this.model,
                            collection: this.collection
                        });
                        this.$('.product').replaceWith(this.children.productMenu.el);
                    }

                }.bind(this));

                return this;
            }.bind(this));
        },
        restartMessagePolling: function(interval) {
            this.collection.messages.stopPolling();
            this.collection.messages.startPolling({delay: interval, uiInactivity: true, stopOnError: false, data: {count: 1000}});
        },
        getActiveMenu: function() {
            // the active menu is based on the current page
            // get path
            var path = Backbone.history.location.pathname;
            var pathComponents = path.split("/"),
                pathComponentsLen = pathComponents.length;
            var appAndPageComponents = [pathComponents[pathComponentsLen-2], pathComponents[pathComponentsLen-1]];
            var appAndPage = appAndPageComponents.join("/");
            var locale = this.model.application.get('locale');
            var app = this.model.application.get('app');

            var activityPages = ["search/status_index",
                                 "search/search_status", "search/search_detail_activity", "search/search_activity_by_user",
                                 "search/splunkweb_status", "search/internal_messages",
                                 "search/scheduler_status", "search/scheduler_user_app", "search/scheduler_savedsearch", "search/scheduler_status_errors", "search/pdf_activity"];
            var changePasswordPage = "authentication/changepassword";
            var jobManagerPage = app + '/job_management';
            var triggeredAlertsPage = locale + '/alerts';
            var homePage = "launcher/home";
            var managerPage = locale + "/manager";

            var activeMenuSelector = null;
            var activeMenuName = '';
            if (activityPages.indexOf(appAndPage) > -1 ||
                path.indexOf(jobManagerPage) > -1 ||
                path.indexOf(triggeredAlertsPage) > -1) {
                activeMenuSelector = '.activity';
                activeMenuName = "activity";
            } else if (path.indexOf(changePasswordPage) > -1) {
                activeMenuSelector = '.user';
                activeMenuName = "user";
            } else if (path.indexOf(managerPage) > -1) {
                activeMenuSelector = 'menu-system';
                activeMenuName = "manager";
            } else if (path.indexOf(homePage) > -1) {
                activeMenuSelector = '.brand';
                activeMenuName = "home";
            } else {
                activeMenuSelector = '.menu-apps';
                activeMenuName = "app";
            }

            return {
                selector: activeMenuSelector,
                name: activeMenuName
            };
        },
        sectionsMunger: function() {
            this.collection.sections.add({
                id: 'knowledge_configurations',
                label: _('Knowledge').t(),
                icon: 'bookmark',
                order: 1
            });
            this.collection.sections.add({
                id: 'auth_configurations',
                label: _('Users and authentication').t(),
                icon: 'user',
                order: 6
            });
            this.collection.sections.add({
                id: 'deployment_configurations',
                label: _('Distributed environment').t(),
                icon: 'distributed-environment',
                order: 5
            });
            this.collection.sections.add({
                id: 'system_configurations',
                label: _('System').t(),
                icon: 'settings',
                order: 2
            });
            this.collection.sections.add({
                id: 'data_configurations',
                label: _('Data').t(),
                icon: 'data',
                order: 4
            });
            
            this.collection.managers.each(function(manager){
                var menuUrl = manager.entry.content.get('menu.url') || '',
                    sectionName = manager.entry.content.get('menu.name'),
                    disabledByLicense = splunkUtil.normalizeBoolean(manager.entry.content.get('disabled_by_license') || false),
                    order = manager.entry.content.get('menu.order') || 1000,
                    pageStart = route.encodeRoot(this.model.application.get('root'), this.model.application.get('locale')),
                    url = pageStart + splunkUtil.sprintf(menuUrl, {namespace: this.model.application.get('app') || 'NOTHING'});

                if(!disabledByLicense && sectionName){
                    var section = this.collection.sections.get(sectionName);
                    if(section){
                        var sectionItems = section.get('items');
                        if(sectionItems){
                            sectionItems.push(manager);
                        }
                    }
                }

                manager.set({
                    url: url,
                    order: order
                });
            }.bind(this));
 
            this.collection.sections.trigger('ready');
        }
    },
    {
        create: function(options){
            options = options || {};
            options.collection = options.collection || {};
            options.model = options.model || {};

            //the APPLICATION model is REQUIRED argument from the consumer. If its not passed, make up an empty one, to keep things rendering, and assure continuance
            //TODO should log this
            var applicationDfd = $.Deferred();
            if(!options.model.application){
                options.model.application = new ApplicationModel();
            }
            // handle both when the application model is already filled and when it has yet to complete fetching
            if (options.model.application.get('app')) {
                applicationDfd.resolve();
            } else {
                options.model.application.on('change', applicationDfd.resolve);
            }

            if(!options.model.appLocal) {
                options.model.appLocal = new AppLocalModel();
                applicationDfd.done(function() {
                    if (options.model.application.get("app") !== 'system') {
                        options.model.appLocal.fetch({
                            url: splunkDUtils.fullpath(options.model.appLocal.url + "/" + encodeURIComponent(options.model.application.get("app"))),
                            data: {
                                app: options.model.application.get("app"),
                                owner: options.model.application.get("owner")
                            }
                        });
                    }
                });
            }

            var currentUserIdDfd = $.Deferred();
            currentUserIdDfd.resolve(options.model.application.get('owner'));

            var appsDfd = $.Deferred();

            var appsCollection;
            if(!options.collection.apps){
                appsCollection = options.collection.apps = new AppsCollection();
                $.when(currentUserIdDfd).done(function(){
                    appsCollection.fetch({
                        data: {
                            sort_key: 'name',
                            sort_dir: 'asc',
                            app: '-' ,
                            owner: options.model.application.get('owner'),
                            search: 'visible=true AND disabled=0 AND name!=launcher',
                            count: -1
                        }
                    });
                    appsCollection.on('reset sort', appsDfd.resolve);
                });
            } else {
                appsDfd.resolve();
            }

            if (!options.model.userPref){
                options.model.userPref = new UserPrefModel();
                options.model.userPref.fetch({data: {app:'user-prefs', owner: options.model.application.get('owner'), count:-1}});
                appsCollection = options.collection.apps;
                options.model.userPref.on('change', function(){
                    appsDfd.done(function(){
                        appsCollection.sortWithString(options.model.userPref.entry.content.get('appOrder'));
                        appsCollection.trigger('ready');
                    });
                });
            }

            var serverInfoDfd = $.Deferred();
            if (!options.model.serverInfo) {
                options.model.serverInfo = new ServerInfoModel();
                options.model.serverInfo.fetch({
                    success: function() {
                        serverInfoDfd.resolve();
                    }
                });
            } else {
                serverInfoDfd.resolve();
            }
            
            
            if(!options.model.user){
                options.model.user = new UserModel({}, {serverInfoModel: options.model.serverInfo});
                $.when(currentUserIdDfd, serverInfoDfd).done(function(currentUserId){
                    options.model.user.set('id', encodeURIComponent(currentUserId));
                    options.model.user.fetch();
                });
            }

            if (!options.collection.messages) {
                options.collection.messages = new MessagesCollection();
                //SPL-48272 - fetch messages by time created in descending order
                options.collection.messages.fetchData.set({
                    "sort_key" : "timeCreated_epochSecs",
                    "sort_dir" : "desc"
                });
            }
            
            var managersDfd = $.Deferred();
            if (!options.collection.managers){
                options.collection.managers = new ManagersCollection();
                $.when(currentUserIdDfd).done(function(currentUsername){
                    options.collection.managers.fetch({
                        data: {
                            app: '-',
                            owner: currentUsername,
                            count: 0,
                            digest: 1
                        },
                        success: function() {
                            managersDfd.resolve();
                        }
                    });
                });
            } else {
                managersDfd.resolve();
            }

            options.collection.sections = new SystemMenuSectionsCollection();
            options.model.webConf = new WebConfModel({id: 'settings'});
            options.model.webConf.fetch();
            
            var view = new View(options);

            $.when(managersDfd).done(function() {
                view.sectionsMunger();
            });
            
            return view;
        }
    });
    return View;
});


define('contrib/text!views/shared/appbar/NavItem.html',[],function () { return '<% var hasSubmenu = item.submenu && item.submenu.length && item.submenu.length > 0; %>\n<a href="<%-item.uri%>" title="<%- _(item.label).t() %>" class="<%=hasSubmenu ? \'dropdown-toggle\' : \'\'%>" <%=hasSubmenu ? \'data-toggle="popdown"\' : \'\'%>>\n    <%- _(item.label).t() %>\n    <%if(hasSubmenu){%>\n       <b class="caret"></b>\n    <%}%>\n</a>\n<%if(hasSubmenu){%>\n    <div class="dropdown-menu">\n    \t<div class="arrow"></div>\n    \t<div class="slideNavPlaceHolder"></div>\n    </div>\n<%}%>\n';});


define('contrib/text!views/shared/AppNav-SlideNavTemplate.html',[],function () { return '<%if(!submenu){return "";}%>\n<ul class="slidenavList scroll-group">\n    <% _.each(submenu, function(i, index) { %>\n    <li data-index="<%=index%>" class="<%=i.divider ? \'divider\':\'\'%>">\n        <% if(!i.divider){ %>\n            <% if(i.submenu && i.submenu.length>0){ %>\n                <a href="#">\n                    <%- _.unescape(_(i.label).t()) %>\n                </a>\n                <i class="icon-triangle-right-small"></i>\n            <%}else if (i.hasOwnProperty(\'reportUri\')) { %>\n                <a href="<%=i.reportUri%>" class="primary-link">\n                    <%- _.unescape(_(i.label).t()) %>\n                </a>\n                <a href="<%=i.uri%>" class="secondary-link">\n                    <i class="icon-<%= i.hasOwnProperty(\'dispatchView\') && i.dispatchView === \'pivot\' ? \'pivot\' : \'search\' %>"></i>\n                </a>\n            <%} else { %>\n                <a href="<%=i.uri%>">\n                    <%- _.unescape(_(i.label).t()) %>\n                </a>\n            <%}%>\n        <%}%>\n    </li>\n    <% }); %>\n</ul>\n';});

/*!
 * jQuery UI Position 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );

define("jquery.ui.position", ["jquery.ui.widget"], function(){});

define('splunk.widget.slidenav',['jquery', 'jquery.ui.widget', 'jquery.ui.position'], function($){
    return $.widget( "splunk.slidenav", {
        options: {
            levelTemplate: '',
            navData: {},
            childPropertyName: 'children',
            backText: 'Back'
        },
        _create: function(){
            var self = this;
            this.isAnimating = false;
            this.$el = $(this.element);
            this.$wrap = $('<div class="auto"></div>');
            this.$el.append(this.$wrap);
            this._chain = [this.addLevel(this.options.navData)];
            this.$backButton = $(self.templateBack());
            this.$el.prepend(this.$backButton);
            this.$backButton.on('click', function(event){
                self.back();
                event.preventDefault();
            });
            this.$el.on('click', 'LI', function(event){
                var li = $(event.target).closest('LI');
                self.select(li, event);
            });
        },
        addLevel: function(navData){
            var newLevel = $(this.options.levelTemplate(navData));
            this.$wrap.append(newLevel);
            if(this._chain){
                newLevel.position({
                    of: this._chain[this._chain.length-1],
                    my: 'left top',
                    at: 'right top',
                    collision: 'none',
                    offset: "0 0"
                });
            }
            newLevel.data('slidenav', navData);
            return newLevel;
        },
        select: function(selected, event){
            if(this.isAnimating){
                return false;
            }
            var ul = selected.closest('ul'),
                navData = ul.data('slidenav'),
                selectedIndex = selected.data("index");
            selected.find('a').addClass('slideNavActiveParent');
            selected = navData[this.options.childPropertyName][selectedIndex];
            if(selected[this.options.childPropertyName] && selected[this.options.childPropertyName].length > 0){
                if(event){
                    event.preventDefault();
                }
                this.next(selected);
            }else{
                this._trigger('select', event, selected);
            }
        },
        next: function(selected){
            var current = this._chain[this._chain.length-1] || null;
            selected.domReference = selected.domReference || this.addLevel(selected);
            this._chain.push(this.slide(selected.domReference.show(), function(){
                current.find('a').prop('tabindex', '-1');
                selected.domReference.find('a').first().focus();
            }));
            this.$backButton.show();
        },
        back: function(){
            if(this._chain.length <= 1 || this.isAnimating){
                return false;
            }
            if(this._chain.length === 2){
                this.$backButton.hide();
            }
            var $hide = this._chain.pop(),
                to = this._chain[this._chain.length-1];
            to.find('.slideNavActiveParent').removeClass('slideNavActiveParent').focus();
            this.slide(to, function(){
                $hide.scrollTop(0).hide();
                to.find('a').prop('tabindex', '0');
            });
        },
        slide: function(to, callback){
            var self = this;
            this.$wrap.outerHeight(to.outerHeight());
            this.isAnimating = true;
            this.$wrap.animate({
                left: -to.position().left
            }, {
                duration: 200,
                complete: function(){
                    self.isAnimating = false;
                    if(callback){
                        callback.apply(self, arguments);
                    }
                }
            });
            return to;
        },
        templateBack: function(){
            return this.options.templateBack || '<div class="backbutton" style="display: none;"><a href="#" class="slidenavback "><i class="icon-chevron-left"></i>'+this.options.backText+'</a></div>';
        }
    });
});

define('views/shared/appbar/NavItem',[
    'jquery',
    'underscore',
    'module',
    'views/Base',
    'views/shared/delegates/Popdown',
    'contrib/text!views/shared/appbar/NavItem.html',
    'contrib/text!views/shared/AppNav-SlideNavTemplate.html',
    'views/shared/delegates/StopScrollPropagation',
    'splunk.widget.slidenav'//no import
],
function(
    $,
    _,
    module,
    BaseView,
    Popdown,
    templateNavItem,
    templateSlideNav,
    StopScrollPropagation
){
    var templateSlideNavCompiled = _.template(templateSlideNav);
    var View = BaseView.extend({
            moduleId: module.id,
            className: 'nav-item',
            tagName: 'li',
            initialize: function() {
                BaseView.prototype.initialize.apply(this, arguments);
            },
            render: function() {
                var html,
                    viewName = this.options.navItemObj.viewName,
                    isLite = this.model.serverInfo.isLite();
                    
                if (this.options.navItemObj.divider) {
                    html = _.template(this.dividerTemplate, {});
                } else {
                    html = _.template(templateNavItem, {
                        item: this.options.navItemObj,
                        isActive: this.options.isActive
                    });
                }

                // Nav Restrictors for Lite
                if ((viewName === "pivot") && !this.model.user.canPivot()) {
                    return;
                } 
                
                this.$el.append(html);
                this.$el.addClass('nav-item-'+this.options.navItemObj.viewName);
                if(this.options.navItemObj.submenu && this.options.navItemObj.submenu.length > 0){
                    this.$el.addClass('dropdown');
                    this.slideNav = this.$el.find('.slideNavPlaceHolder').slidenav({
                        navData: this.options.navItemObj,
                        levelTemplate: templateSlideNavCompiled,
                        childPropertyName: 'submenu',
                        backText: _('Back').t()
                    });

                    this.popdown = new Popdown({
                        el: this.$el,
                        dialog: this.slidenav,
                        mode: 'dialog'
                    });

                    this.children.stopScrollPropagation = new StopScrollPropagation({el:this.slideNav.find('.slidenavList')});
                }

                return this;
            },
            dividerTemplate: '<span class="divider" style="display: block;float: left;height: 10px;margin: 0 15px;opacity: 0.2;"></span>'
        }
    );
    return View;
});

define('views/shared/appbar/AppNav',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/Base',
    'views/shared/appbar/NavItem'
],
function(
    $,
    _,
    Backbone,
    module,
    BaseView,
    NavItem
){
    return BaseView.extend({
        moduleId: module.id,
        tagName: 'ul',
        className: 'nav nav-pills',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            this.listenTo(this.model.appNav, 'change:nav', this.debouncedRender);
            this.listenTo(this.model.application, 'change:page', this.setActiveItem);
        },
        render: function() {
            var self = this;
            var navData = this.model.appNav.get('nav');
            if(!navData){return this;}

            this.$el.html('');
            $.each(navData, function(index, navItemObj){
                var navItemView = new NavItem({
                    navItemObj: navItemObj,
                    model: {
                        serverInfo: self.model.serverInfo,
                        user: self.model.user    
                    }                    
                });
                self.$el.append(navItemView.render().$el);
            });

            this.setActiveItem.call(this);

            return this;
        },
        setActiveItem: function(){
            var self = this;
            if(this.model.application.get('page')){
                var activePage = this.model.application.get('page');
                var activeItem = self.$el.find('.nav-item-'+activePage);
                activeItem.addClass('active');
            }
        }
    });
});


define('contrib/text!views/shared/appbar/AppLabel.html',[],function () { return '<a class="app-link" href="<%=appLink%>">\n    <div class="app-logo"></div>\n\n    <div class="app-name">\n        <span class="app-label">\n            <%-_(appLabel).t()%>\n        </span>\n    </div>\n</a>\n';});

define('views/shared/appbar/AppLabel',[
    'underscore',
    'module',
    'views/Base',
    'contrib/text!views/shared/appbar/AppLabel.html'
],
function(
    _,
    module,
    BaseView,
    templateAppLabel
){
    return BaseView.extend({
        moduleId: module.id,
        className: 'app-bar-label-wrapper',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            this.model.appNav.on('change', this.render, this);
        },
        showLogo: function(){
            this.$el.find('.app-logo').show();
            this.$el.find('.app-name').hide();
        },
        showName: function(){
            this.$el.find('.app-name').show();
            this.$el.find('.app-logo').hide();
        },
        render: function(){
            var label = this.model.appNav.get('label') || '';

            var html = _.template(templateAppLabel, {
                appLink: this.model.appNav.get('link'),
                appLabel: label,
                appLogo: this.model.appNav.get('logo')
            });
            this.$el.html(html);

            this.setAppLabelDisplay();

            return this;
        },
        setAppLabelDisplay: function(){
            if (this.model.appNav.get('logo')) {
                var img = new Image();
                img.onload = function(){
                    if(parseInt(img.width, 10) < 2){
                        this.showName();
                    }else{
                        this.$el.find('.app-logo').empty().append(img);
                        this.showLogo();
                    }
                }.bind(this);

                img.onerror = function(){
                    this.showName();
                }.bind(this);

                img.src = this.model.appNav.get('logo');
            }
        }
    });
});

define(
    'views/shared/tour/ProductTours',[
        'jquery',
        'underscore',
        'module',
        'views/shared/Modal',
        'models/services/data/ui/Tour',
        'collections/services/data/ui/Tours',
        'uri/route',
        'splunk.util'
    ],
    function(
        $, 
        _, 
        module, 
        Modal,
        TourModel,
        Tours,
        route,
        splunk_utils
    ){
        return Modal.extend({
            moduleId: module.id,
            initialize: function() {
                Modal.prototype.initialize.apply(this, arguments);

                this.toursDfd = $.Deferred();
                this.collection = this.collection || {};
                this.isLite = this.model.serverInfo.isLite();

                this.collection.tours = new Tours();
                this.collection.tours.fetch({
                    data: {
                        app: this.model.application.get('app'),
                        owner: this.model.application.get('owner'),
                        count: -1
                    },
                    success: function(collection, response) {
                        this.setTours();
                        this.toursDfd.resolve();
                    }.bind(this)
                });
            },

            setTours: function() {
                var productType = this.model.serverInfo.getProductType(),
                    instanceType = this.model.serverInfo.getInstanceType(),
                    tourIdentifier = productType + ((instanceType) ? ':' + instanceType : ''),
                    searchTourName = 'search-tour:' + tourIdentifier,
                    adddataTourName = 'adddata-tour:' + tourIdentifier,
                    dashboardsTourName = 'dashboards-tour:' + tourIdentifier;

                this.searchTour = this.collection.tours.getTourModel(searchTourName);
                this.adddataTour = this.collection.tours.getTourModel(adddataTourName);
                this.dashboardsTour = this.collection.tours.getTourModel(dashboardsTourName);

                if (this.searchTour) {
                    this.searchLink = route.page(
                        this.model.application.get('root'),
                        this.model.application.get('locale'),
                        'search',
                        this.searchTour.getTourPage(),
                        { data: {tour: searchTourName} }
                    );
                }

                if (this.adddataTour) {
                    this.adddataLink = route.manager(
                        this.model.application.get('root'),
                        this.model.application.get('locale'),
                        'search',
                        this.adddataTour.getTourPage(),
                        {data: {tour: adddataTourName}}
                    );
                }

                if (this.dashboardsTour) {
                    this.dashboardsLink = route.page(
                        this.model.application.get('root'),
                        this.model.application.get('locale'),
                        'search',
                        this.dashboardsTour.getTourPage(),
                        {data: {tour: dashboardsTourName}}
                    );
                }
            },

            events: $.extend({}, Modal.prototype.events, {
                'click .search-tour': function(e) {
                    window.location = this.searchLink;
                },

                'click .adddata-tour': function(e) {
                    window.location = this.adddataLink;
                },

                'click .dashboards-tour': function(e) {
                    window.location = this.dashboardsLink;
                },

                'click .light-product-tour': function(e) {
                    this.hide();
                    this.trigger('product-tour');
                }
            }),

            render: function() {
                $.when(this.toursDfd).then(function() {
                    this.$el.html(this.compiledTemplate({
                        canAddData: this.options.canAddData || false,
                        isLite: this.isLite,
                        searchTour: this.searchTour,
                        adddataTour: this.adddataTour,
                        dashboardsTour: this.dashboardsTour
                    }));
                }.bind(this));
                return this;
            },

            template: '\
                <div class="modal-header"><h3 class="modal-title"><%= _("Select a Tour").t() %></h3> ' + Modal.BUTTON_CLOSE + '</div>\
                <ul class="tours-links">\
                    <% if (isLite) { %>\
                    <li class="light-product-tour"><i class="icon-greater"></i><br /> <%= _("Splunk Light Tour").t() %> <div class="mask"></div></li>\
                    <% } %>\
                    <% if (canAddData && adddataTour) { %>\
                    <li class="adddata-tour"><i class="icon-data-input"></i><br /> <%= _("Add Data Tour").t() %> <div class="mask"></div></li>\
                    <% } %>\
                    <% if (searchTour) { %>\
                    <li class="search-tour"><i class="icon-search"></i><br /> <%= _("Search Tour").t() %> <div class="mask"></div></li>\
                    <% } %>\
                    <% if (dashboardsTour) { %>\
                    <li class="dashboards-tour"><i class="icon-dashboard"></i><br /> <%= _("Dashboards Tour").t() %> <div class="mask"></div></li>\
                    <% } %>\
                </ul>\
            '
        });
    }
);

define('contrib/text!views/shared/tour/ImageTour.html',[],function () { return '<div id="<%- imageTourId %>" class="carousel">\n    <div class="carousel-inner">\n        <% for (var i=0 ; i < images.length; i++) { %>\n            <div class="item <%- (i === 0) ? " active " : " " %>">\n                <img src="<%- imgUrlLocalized %>/<%- images[i] %>" />\n                <div class="tour-gutter">\n                    <div class="gutter-text">\n                        <%= captions[i] %>\n                    </div>\n                </div>\n                <% if (liteTour && i === images.length - 1) { %>\n                    <div class="last-slide">\n                        <a id="documentation" class="help-link" href="<%- docLink %>" target="_blank"></a>\n                        <a id="splunk-answers" class="help-link" href="http://answers.splunk.com" target="_blank"></a>\n                    </div>\n                <% } %>\n            </div>\n            <% } %>\n    </div>\n    <div class="carousel-assets">\n        <ol class="carousel-indicators">\n            <% for (var i=0 ; i < images.length; i++) { %>\n                <li data-target="#<%- imageTourId %>" data-slide-to="<%- i %>" <%- (i===0 ) ? \'class=active\' : \'\' %>></li>\n                <% } %>\n        </ol>\n        <a class="carousel-control left disabled" href="#<%- imageTourId %>" data-slide="prev">\n            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="25px" height="48px" viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\n                <g>\n                    <polygon points="476.81,-0.002 499.794,22.355 136.249,395.998 499.794,769.641 476.81,791.998 91.501,395.998  " />\n                </g>\n            </svg>\n        </a>\n        <a class="carousel-control right" href="#<%- imageTourId %>" data-slide="next">\n            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="25px" height="48px" viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\n                <g>\n                    <polygon points="114.484,792 91.5,769.643 455.045,396 91.5,22.357 114.484,0 499.793,396  " />\n                </g>\n            </svg>\n        </a>\n        <a class="btn btn-primary try-it-now"><%= _(\'Try it now\').t() %></a>\n        <p class="tour-links">\n            <a class="skip-tour" href="#"><%= _(\'Skip tour\').t() %></a>\n            <a class="next-tour" href="#"><%= _(\'Continue to\').t() %> <%- nextTourLabel %></a>\n        </p>\n    </div>\n</div>';});

/* ==========================================================
 * bootstrap-carousel.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#carousel
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* CAROUSEL CLASS DEFINITION
  * ========================= */

  var Carousel = function (element, options) {
    this.$element = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options = options
    this.options.pause == 'hover' && this.$element
      .on('mouseenter', $.proxy(this.pause, this))
      .on('mouseleave', $.proxy(this.cycle, this))
  }

  Carousel.prototype = {

    cycle: function (e) {
      if (!e) this.paused = false
      if (this.interval) clearInterval(this.interval);
      this.options.interval
        && !this.paused
        && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
      return this
    }

  , getActiveIndex: function () {
      this.$active = this.$element.find('.item.active')
      this.$items = this.$active.parent().children()
      return this.$items.index(this.$active)
    }

  , to: function (pos) {
      var activeIndex = this.getActiveIndex()
        , that = this

      if (pos > (this.$items.length - 1) || pos < 0) return

      if (this.sliding) {
        return this.$element.one('slid', function () {
          that.to(pos)
        })
      }

      if (activeIndex == pos) {
        return this.pause().cycle()
      }

      return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
    }

  , pause: function (e) {
      if (!e) this.paused = true
      if (this.$element.find('.next, .prev').length && $.support.transition.end) {
        this.$element.trigger($.support.transition.end)
        this.cycle(true)
      }
      clearInterval(this.interval)
      this.interval = null
      return this
    }

  , next: function () {
      if (this.sliding) return
      return this.slide('next')
    }

  , prev: function () {
      if (this.sliding) return
      return this.slide('prev')
    }

  , slide: function (type, next) {
      var $active = this.$element.find('.item.active')
        , $next = next || $active[type]()
        , isCycling = this.interval
        , direction = type == 'next' ? 'left' : 'right'
        , fallback  = type == 'next' ? 'first' : 'last'
        , that = this
        , e

      this.sliding = true

      isCycling && this.pause()

      $next = $next.length ? $next : this.$element.find('.item')[fallback]()

      e = $.Event('slide', {
        relatedTarget: $next[0]
      , direction: direction
      })

      if ($next.hasClass('active')) return

      if (this.$indicators.length) {
        this.$indicators.find('.active').removeClass('active')
        this.$element.one('slid', function () {
          var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()])
          $nextIndicator && $nextIndicator.addClass('active')
        })
      }

      if ($.support.transition && this.$element.hasClass('slide')) {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $next.addClass(type)
        $next[0].offsetWidth // force reflow
        $active.addClass(direction)
        $next.addClass(direction)
        this.$element.one($.support.transition.end, function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () { that.$element.trigger('slid') }, 0)
        })
      } else {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $active.removeClass('active')
        $next.addClass('active')
        this.sliding = false
        this.$element.trigger('slid')
      }

      isCycling && this.cycle()

      return this
    }

  }


 /* CAROUSEL PLUGIN DEFINITION
  * ========================== */

  var old = $.fn.carousel

  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('carousel')
        , options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option)
        , action = typeof option == 'string' ? option : options.slide
      if (!data) $this.data('carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  $.fn.carousel.defaults = {
    interval: 5000
  , pause: 'hover'
  }

  $.fn.carousel.Constructor = Carousel


 /* CAROUSEL NO CONFLICT
  * ==================== */

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }

 /* CAROUSEL DATA-API
  * ================= */

  $(document).on('click.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var $this = $(this), href
      , $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
      , options = $.extend({}, $target.data(), $this.data())
      , slideIndex

    $target.carousel(options)

    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('carousel').pause().to(slideIndex).cycle()
    }

    e.preventDefault()
  })

}(window.jQuery);
define("bootstrap.carousel", ["jquery"], function(){});

define(
    'views/shared/tour/ImageTour',[
        'jquery',
        'underscore',
        'backbone',
        'module',
        'views/shared/Modal',
        'models/services/data/ui/Tour',
        'contrib/text!views/shared/tour/ImageTour.html',
        'splunk.util',
        'uri/route',
        'bootstrap.carousel'
    ],
    function(
        $,
        _,
        backbone,
        module,
        Modal,
        TourModel,
        TourTemplate,
        splunk_util,
        route,
        undefined
    ){
        return Modal.extend({
            moduleId: module.id,
            className: Modal.prototype.className + ' tour-modal image-tour-container',
            template: TourTemplate,
            initialize: function() {
                Modal.prototype.initialize.apply(this, arguments);

                this.imgCheck = $.Deferred();
                this.nextTourCheck = $.Deferred();
                this.root = this.model.application.get('root');
                this.locale = this.model.application.get('locale');
                this.liteTour = this.model.tour.entry.get('name') === 'light-product-tour';

                this.assetsUrl = splunk_util.make_url('/static/img/tour/assets');
                this.tourId = this.cid;
                this.images = this.model.tour.getImages();
                this.captions = this.model.tour.getImageCaptions();
                this.nextTour = this.model.tour.getNextTour();
                this.imageContext = this.model.tour.getImageContext();

                this.localPathString = '';

                if (this.imageContext && this.imageContext != 'system') {
                    this.localPathString = '/app/' + this.imageContext;
                }

                this.imageRoot = splunk_util.make_url('static' + this.localPathString + '/img/');

                this.imgUrl = this.imageRoot + ((this.model.tour) ? this.model.tour.getImgPath() : this.options.imgPath);
                this.imgUrlLocalized = this.imgUrl + '/' + this.locale;
                this.testImg = this.imgUrlLocalized + '/' + this.images[0];

                // Check for localized version of image tour.
                $('<img src="' + this.testImg + '" />')
                .load(function() {
                    this.imgCheck.resolve();
                }.bind(this))
                .error(function() {
                    this.imgUrlLocalized = this.imgUrl;
                    this.imgCheck.resolve();
                }.bind(this));

                if (this.nextTour) {
                    this.setNextTour();
                } else {
                    this.nextTourCheck.resolve();
                }

                if (!this.model.tour.viewed()) {
                    this.setViewed();
                }
            },

            events: $.extend({}, Modal.prototype.events, {
                'click .close-tour': 'hide',

                'click .skip-tour': 'hide',

                'click .try-it-now': 'hide',

                'click .item.active img': function(e) {
                    this.$('.carousel-control.right').click();
                },

                'keyup': function(e) {
                    if (e.keyCode == 39) {
                        this.$('.carousel-control.right').click();
                    } else if (e.keyCode == 37) {
                        this.$('.carousel-control.left').click();
                    }
                },

                'mouseout .carousel': function(e) {
                    this.$('.carousel').carousel('pause');
                },

                'click .start-tour': function(e) {
                    $('.welcome-slide').hide();
                },

                'click .carousel-control.disabled': function(e) {
                    e.preventDefault();
                    return false;
                },

                'click .next-tour': function(e) {
                    e.preventDefault();
                    window.location = this.nextTourURL;
                }
            }),

            setNextTour: function() {
                var app = this.model.application.get('app'),
                    owner = this.model.application.get('owner'),
                    nextTour = this.nextTour,
                    tourDfd = $.Deferred(),
                    page, data, url, label;

                this.model.nextTour = new TourModel();
                this.model.nextTour.bootstrap(tourDfd, app, owner, nextTour);

                $.when(tourDfd).then(function() {
                    page = this.model.nextTour.getTourPage();
                    data = splunk_util.queryStringToProp(this.model.nextTour.getTourURLData() || '');
                    label = _(this.model.nextTour.getLabel()).t() || _('next tour').t();

                    data.tour = nextTour;
                    url = route.page(
                        this.model.application.get('root'),
                        this.model.application.get('locale'),
                        this.model.application.get('app'),
                        page,
                        { data: data }
                    );

                    this.nextTourLabel = label;
                    this.nextTourURL = url;
                    this.nextTourCheck.resolve();
                }.bind(this));
            },

            setViewed: function() {
                this.model.tour.entry.content.set('viewed', true);
            },

            render: function() {
                var docLink = route.docHelp(this.root, this.locale, 'splunkcore.homepage.docs');

                $.when(this.imgCheck, this.nextTourCheck).then(function() {
                    this.$el.html(this.compiledTemplate({
                        _: _,
                        images: this.images,
                        imgUrl: this.imgUrl,
                        imgUrlLocalized: this.imgUrlLocalized,
                        assetsUrl: this.assetsUrl,
                        captions: this.captions,
                        liteTour: this.liteTour,
                        docLink: docLink,
                        imageTourId: this.tourId,
                        nextTourLabel: this.nextTourLabel
                    }));

                    this.$('.carousel').carousel({
                        interval: false,
                        pause: true
                    }).on('slid', '', function() {
                        this.$('.carousel-control').removeClass('disabled');
                        this.$('.skip-tour').show();
                        this.$('.next-tour').hide();
                        this.$('.try-it-now').hide();
                        if (this.$('.item:first').hasClass('active')) {
                            this.$('.left.carousel-control').toggleClass('disabled');
                        } else if (this.$('.item:last').hasClass('active')) {
                            this.$('.right.carousel-control').addClass('disabled');
                            this.$('.try-it-now').show();
                            this.$('.skip-tour').hide();
                            if (this.nextTour) {
                                this.$('.next-tour').show();
                            }
                        }
                    }.bind(this));

                    $('.modal-backdrop').addClass('tour-backdrop');
                }.bind(this));

                return this;
            }
        });
    }
);

define(
'views/shared/litebar/HelpMenu',[
    'views/shared/splunkbar/HelpMenu',
    'views/shared/tour/ProductTours',
    'views/shared/tour/ImageTour',
    'models/services/data/ui/Tour',
    'uri/route',
    'splunk.util'
],
function(
    HelpMenu,
    ProductToursModal,
    ImageTour,
    TourModel,
    route,
    splunk_utils
){
    return HelpMenu.extend({
        initialize: function(){
            HelpMenu.prototype.initialize.apply(this, arguments);
            this.hasTours = (this.collection && this.collection.tours) ? this.collection.tours.checkTours(this.model.user.serverInfo) : false;
        },

        events: $.extend({}, HelpMenu.prototype.events, {
            'click .splunk-tours': 'renderToursModal'
        }),

        renderToursModal: function() {
            this.closePopdown();
            this.children.toursModal = new ProductToursModal({
                canAddData: this.model.user.canAddData(),
                model: {
                    application: this.model.application,
                    serverInfo: this.model.user.serverInfo
                },
                onHiddenRemove: true
            });

            $('body').append('<div class="splunk-components tours-modal"></div>');
            $('.tours-modal').append(this.children.toursModal.render().el);
            this.children.toursModal.show();

            this.children.toursModal.on('product-tour', this.renderProductTour, this);
        },

        renderProductTour: function() {
            this.closePopdown();
            var app = this.model.application.get('app'),
                owner = this.model.application.get('owner'),
                tourDfd = $.Deferred();

            this.model.tour = new TourModel();
            this.model.tour.bootstrap(tourDfd, app, owner, 'light-product-tour');

            $.when(tourDfd).then(function() {
                this.children.imageTour = new ImageTour({
                    model: {
                        application: this.model.application,
                        tour: this.model.tour
                    },
                    backdrop: 'static',
                    onHiddenRemove: true,
                    liteTour: true
                });

                // The 'splunk-components' wrapper is necessary
                // for modal to render correctly in manager.
                $('body').append('<div class="splunk-components image-tour"></div>');
                $('.image-tour').append(this.children.imageTour.render().el);
                this.children.imageTour.show();
            }.bind(this));
        }
    });
});


define('contrib/text!views/shared/litebar/Master.html',[],function () { return '<i class="pull-left icon icon-menu">\n    <span class="message-notification"></span>\n</i>\n<span class="brand pull-left" title="splunk &gt; <%- _(\'listen to your data\').t() %>"><a href="<%- homeLink %>">splunk<strong>&gt;</strong> <span class="sub-brand">&#xF003;</span></a></span>\n\n<div class="nav pull-left"></div>\n\n<ul class="navbar-global-nav pull-right">\n    <li class="dropdown user"></li>\n    <li class="dropdown product"></li>\n    <li class="dropdown help"><a href="#" class="dropdown-toggle"><%- _("Resources").t() %><b class="caret"></b></a></li>\n</ul>';});

/**
 * @author Leo
 *
 * Produces a JSON object containing necessary data to construct an app's navigation menu.
 *
 */
define('helpers/AppNav',[
    'jquery',
    'underscore',
    'backbone',
    'splunk.util',
    'util/xml'
],
function (
    $,
    _,
    Backbone,
    splunk_util,
    XML
){
    var app,
        views,
        rootEndpoint,
        searches,
        nav,
        seenViews = [],
        seenSearches = [];

    /**
     * Filters the collection to models belonging to the current app, optionally with name matching a string and
     * optionally among those that haven't been processed yet.
     *
     * @param collection Input collection
     * @param match {String} optional String to match
     * @param seen {Array} optional list of already processed objects that should be skipped
     * @return {Array} filtered array of models
     */
    function getMatchingItems(collection, match, seen) {
        return collection.filter(function(it) {
            var itApp =  it.entry.acl.get('app'),
                itName = it.entry.get('name'),
                isGlobal = it.entry.acl.get('sharing') === 'global';
            if (!isGlobal && itApp !== app) {
                return false;
            }
            if (match) {
                return (itName.toLowerCase().indexOf(match.toLowerCase())>-1 && !(seen && seen.indexOf(app+'/'+itName)>-1));
            } else {
                return !(seen && seen.indexOf(app+'/'+itName)>-1);
            }
        });
    }

    /**
     * Searches views collection for a view name to get its label
     *
     * @param name {String} view name
     * @return {Object} containing view label
     */
    function getViewProps(viewName) {
        var obj, view, i, v;
        views = views || [];
        for (i=0; i<views.length; i++) {
            v = views.at(i);
            if (v.entry.get('name').toLowerCase() === viewName.toLowerCase()) {
                // allow either a view local to the current app
                if (v.entry.acl.get('app') == app) {
                    view = v;
                    break; // local views have priority over global ones

                // or a globally shared view from another app
                } else if (v.entry.acl.get('sharing') == 'global') {
                    view = v;
                }
            }
        }

        if (view) {
            if (!view.entry.content.get('isVisible')) {
                return false;
            }
            obj = {
                label: view.entry.content.get('label') || viewName,
                uri: splunk_util.make_url('app', app, viewName),
                viewName: viewName,
                app: app
            };
        } else {
            return false;
        }
        return obj;
    }

    /**
     * Searches saved searches collection for a search name to get its properties
     * @param name {String} search name
     * @return {Object} containing search properties
     */
    function getSavedProps(name) {
        var obj,
            saved = searches.find(function(s) {
                return (s.entry.get('name').toLowerCase() === name.toLowerCase());
            });
        if (saved) {
            obj = {
                uri: splunk_util.make_full_url('app/'+encodeURIComponent(app)+'/@go', {'s': saved.id}),
                sharing: saved.get('sharing'),
                label: name,
                reportUri: splunk_util.make_full_url('app/'+encodeURIComponent(app)+'/report', {'s': saved.id})
            };
            if (saved.entry.content.get('request.ui_dispatch_view')) {
                obj.dispatchView = saved.entry.content.get('request.ui_dispatch_view');
            }
        } else {
            return false;
        }
        return obj;
    }

    function sanatizeHref(href){
        if(typeof href !== 'string'){
            return false;
        }
        var decodedhref = $("<div></div>").html(href).text();
        decodedhref = window.decodeURI(decodedhref);
        decodedhref = decodedhref.replace(/(\r\n|\n|\r|\s)/gm,'').toLowerCase();
        if(decodedhref.indexOf(':') > -1 &&
            decodedhref.indexOf('javascript:') > -1 ||
            decodedhref.indexOf('vbscript:') > -1 ||
            decodedhref.indexOf('data:') > -1 ||
            decodedhref.indexOf('livescript:') > -1){
            href = false;
        }
        return href;
    }

    /**
     * Recursively go through nav xml, building a json object
     *
     * @param nav {xml}
     * @return {Object} JSON object
     */
    function parseNavXml(nav) {
        var output = [],
            c;
        for (c=0; c<nav.length; c++) {
            var node = nav[c],
                $node = $(node),
                nodeName = splunk_util.lowerTrimStr(node.nodeName),
                obj;

            if (nodeName === 'collection') {
                obj = {
                    label: $node.attr('label'),
                    uri: '#'
                };
                // recursion warning!
                var children = parseNavXml($node.children());
                if (!children.submenu.length ||
                    !_.find(children.submenu, function(obj) { return !obj.divider; })) {
                    // skip empty collections and ones containing only dividers
                    continue;
                }
                _.extend(obj, children);
            /*
            Views
             */
            } else if (nodeName === 'view') {
                var viewName = $node.attr('name'),
                    isDefault = splunk_util.normalizeBoolean($node.attr('default')||"false"),
                    source = splunk_util.lowerTrimStr($node.attr('source')),
                    match = $node.attr('match');

                if (viewName) {
                    obj = getViewProps(viewName);
                    if (!obj) {
                        continue;
                    }
                    if (isDefault) {
                        obj.isDefault = isDefault;
                    }
                    // mark as seen
                    seenViews.push(app+'/'+viewName);

                } else if (source) {
                    var matchedViews = [],
                        i;
                    if (source == 'all') {
                        matchedViews = getMatchingItems(views, match);
                    } else if (source == 'unclassified') {
                        matchedViews = getMatchingItems(views, match, seenViews);
                    }
                    for (i=0; i<matchedViews.length; i++) {
                        viewName = matchedViews[i].entry.get('name');
                        obj = getViewProps(viewName);
                        if (!obj) {
                            continue;
                        }
                        if (!matchedViews[i].entry.content.get('isDashboard')) {
                            continue;
                        }
                        // mark as seen
                        seenViews.push(app+'/'+viewName);
                        output.push(obj);
                    }
                    obj = false;
                }

            /*
             Saved searches
             */
            } else if (nodeName === 'saved') {
                var savedName = $node.attr('name');
                source = splunk_util.lowerTrimStr($node.attr('source'));
                match = $node.attr('match');

                if (savedName) {
                    obj = getSavedProps(savedName);
                    if (!obj) {
                        continue;
                    }
                    seenSearches.push(app+'/'+savedName);
                } else if (source) {
                    var matchedSearches = [];
                    if (source == 'all') {
                        matchedSearches = getMatchingItems(searches, match);
                    } else if (source == 'unclassified') {
                        matchedSearches = getMatchingItems(searches, match, seenSearches);
                    }
                    for (i=0; i<matchedSearches.length; i++) {
                        savedName = matchedSearches[i].entry.get('name');
                        obj = getSavedProps(savedName);
                        if (!obj) {
                            continue;
                        }
                        // mark as seen
                        seenSearches.push(app+'/'+savedName);
                        output.push(obj);
                    }
                    obj = false;
                }
            } else if (nodeName === 'a') {
                var href = sanatizeHref($node.attr('href'));
                if(href===false){
                    obj=false;
                }else{
                    if (href.indexOf('/') === 0 && href[1] !== '/'){
                        href = splunk_util.make_url(href);
                    }
                    obj = {
                        label: $node.text(),
                        uri: href,
                        viewName: $node.attr('name') || ''
                    };
                }
            } else if (nodeName === 'divider') {
                obj = {
                    label: '',
                    divider: true
                };
            } else {
                obj = {
                    label: 'unknown node in nav'
                };
            }

            if (obj) {
                output.push(obj);
            }

        }
        return {submenu: output};
    }

    function parseNavModel(nav, viewsCollection, savedSearchCollection, rootPath){
        var xmlNavString = nav.entry.content.get('eai:data');
        var navXmlObj;
        try {
            navXmlObj = XML.parse(xmlNavString);
        } catch (e) {
            // Fall back to legacy behavior where slightly invalid XML was corrected
            // SPL-84474
            navXmlObj = XML.parse(xmlNavString.replace(/\&/g, "&amp;"));
        }
        var root = navXmlObj.find('nav');
        var searchView = root.attr('search_view');
        var appColor = root.attr('color');

        seenViews = seenSearches = [];
        app = nav.entry.content.get('eai:appName');
        views = viewsCollection;
        rootEndpoint = rootPath || '';
        searches = new Backbone.Collection(savedSearchCollection.filter(function(model) {
            var appMatch = model.entry.acl.get('app') == app,
                isGlobal = model.entry.acl.get('sharing') == 'global';
            return appMatch || isGlobal;
        }));
        return {
            nav: parseNavXml(root.children()).submenu,
            searchView: searchView,
            color: appColor
        };
    }

    /**
     * Entry point, kicking off the parsing.
     *
     * @param navsCollection {Collection} output of /data/ui/nav endpoint
     * @param viewsCollection {Collection} output of /data/ui/views endpoint
     * @param savedSearchCollection {Collection} output of /saved/searches endpoint
     *
     * @return {Array} of JSON objects or null if appname is undefined or nav coll is empty
     */
    function parseNavCollection(navsCollection, viewsCollection, savedSearchCollection, rootPath) {
        var result = [];
        rootEndpoint = rootPath || '';
        seenViews = seenSearches = [];
        if (!navsCollection || navsCollection.length == 0) {
            return null;
        }
        navsCollection.each(function(nav){
            result.push(
                parseNavModel(nav,viewsCollection, savedSearchCollection)
            );
        });
        return result;
    }

    return {
        parseNavModel: parseNavModel,
        parseNavCollection: parseNavCollection
    };
});

define('contrib/text!views/shared/litebar/SystemSection.html',[],function () { return '<div class="collapsible-heading">\n  <a class="collapsible-toggle" href="#">\n    <i class="icon-collapsible-toggle icon-chevron-right"></i>\n    <%- groupTitle %>\n  </a>\n</div>\n<div class="collapsible-body" style="display: none">\n    <% var addedItems = []; %>\n    <% _.each(this.model.get(\'items\'), function(item, i){ %>\n        <% if(_.indexOf(addedItems, item.entry.content.get(\'menu.label\')) === -1) { %>    \n            <a href="<%-item.get(\'url\')%>" id="<%- item.entry.get("name") %>"><%- _(item.entry.content.get(\'menu.label\')).t() || _(item.entry.get(\'name\')).t() || \'\' %></a>\n            <% addedItems.push(item.entry.content.get(\'menu.label\')); %>\n        <% } %>\n    <% }); %>\n</div>\n';});

define('views/shared/litebar/SystemSection',[
    'jquery',
    'underscore',
    'module',
    'views/Base',
    'contrib/text!views/shared/litebar/SystemSection.html'
],
function(
    $,
    _,
    module,
    BaseView,
    systemMenuSectionTemplate
){
    return BaseView.extend({
        moduleId: module.id,
        template: systemMenuSectionTemplate,
        className: 'collapsible-group',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            var itemsArray = this.model.get('items');
            itemsArray.sort(function(a,b){
                return parseInt(a.get('order'), 10) - parseInt(b.get('order'), 10);
            });
        },
        render: function() {
            var html = this.compiledTemplate({
                model: this.model,
                groupTitle: this.model.get('label')
            });
            this.$el.html(html);
            this.$el.attr('id', this.model.get('label').toLowerCase().replace(/ /g,''));
            return this;
        }
    });
});

define('contrib/text!views/shared/litebar/Activity.html',[],function () { return '<div class="collapsible-heading">\n  <a class="collapsible-toggle" href="#">\n    <i class="icon-collapsible-toggle icon-chevron-right"></i>\n    <%- _("Activity").t() %>\n  </a>\n</div>\n<div class="collapsible-body" style="display: none">\n    <a href="<%= jobLink %>"><%- _("Jobs").t() %></a>\n    <% if (typeof alertsLink !== "undefined" && alertsLink !== null) { %>\n    \t<a href="<%= alertsLink %>"><%- _("Triggered Alerts").t() %></a>\n    <% } %>\n    <% if (typeof statusLink !== "undefined" && statusLink !== null) { %>\n        <a href="<%= statusLink %>"><%- _("System Activity").t() %></a>\n    <% } %>\n</div>\n';});

define(
'views/shared/litebar/Activity',[
    'module',
    'views/shared/splunkbar/ActivityMenu',
    'contrib/text!views/shared/litebar/Activity.html'
],
function(
    module,
    ActivityMenu,
    activityMenuTemplate
){
    return ActivityMenu.extend({
        moduleId: module.id,
        template: activityMenuTemplate,
        tagName: 'div',
        className: 'collapsible-group activity',
        id: 'activity'
    });
});


define('contrib/text!views/shared/splunkbar/messages/MasterLite.html',[],function () { return '<div id="global-messages-menu">\n    <div class="messages-header">\n        <span class="messages-header-text"><a title="messages rollover" href="#"><%= _(\'Messages\').t() %></a><span>\n        <span class="message-notification"><%- collection.length %></span>\n        <a href="#" class="delete-all-messages"><%= _(\'Clear all\').t() %></a>\n    </div>\n    <ul class="message-list">\n    </ul>\n    <div class="no-messages">\n        <%- _("You have no messages.").t() %>\n    </div>\n</div>\n';});

define(
'views/shared/splunkbar/messages/LiteMessages',[
    'jquery',
    'underscore',
    'views/shared/splunkbar/messages/Master',
    'views/shared/splunkbar/messages/Message',
    'views/shared/splunkbar/messages/LegacyMessage',
    'contrib/text!views/shared/splunkbar/messages/MasterLite.html',
    'util/general_utils'
],
function(
    $,
    _,
    Messages,
    MessageView,
    LegacyMessageView,
    LiteTemplate,
    general_utils
){
    return Messages.extend({
        template: LiteTemplate,
        tagName: 'div',
        className: 'lite-messages',
        renderMessages: function(forceUpdate) {
                if(forceUpdate !== true &&
                    this.isLocalMouseSelection &&
                    general_utils.getMouseSelection() && general_utils.getMouseSelection().length>0) {
                    return;
                }
                this.isLocalMouseSelection = false;
                var numMessages = this.collection.length;
                if(this.legacyMessages){
                    numMessages = numMessages + this.legacyMessages.length;
                }

                $('.message-notification').text(numMessages);

                //remove existing message children
                _.each(this.children, function(view, key){
                    if (key.substr(0, 7) == 'message') {
                        this.children[key].remove();
                        delete this.children[key];
                    }
                }, this);

                //iterate through collection
                var messageView;

                this.collection.each(function(model, key){
                    //create view
                    var serverInfoModel = (this.model && this.model.serverInfo) ? this.model.serverInfo : {};
                    messageView = new MessageView({model: model, serverInfo: serverInfoModel});
                    this.children['message' + model.get("id")] = messageView;
                    this.$('#global-messages-menu .message-list').append(messageView.render().$el);
                    //bind destruction of model to delete view
                }, this);

                var numLegacyMessages = 0;
                if(this.legacyMessages){
                    numLegacyMessages = this.legacyMessages.length;
                    this.legacyMessages.each(function(model){
                        messageView = new LegacyMessageView({model: model});
                        this.children['messageLegacy' + model.get("id")] = messageView;
                        this.$('#global-messages-menu .message-list').append(messageView.render().$el);
                    }, this);
                }
                if (this.collection.length > 0 || numLegacyMessages > 0) {
                    this.$('.popdown-dialog-footer, .message-list, .message_count_wrapper').show();
                    $('.message-notification').show();
                    this.$(".no-messages").hide();
                } else {
                    this.$('.popdown-dialog-footer, .message-list, .message_count_wrapper').hide();
                    $('.message-notification').hide();
                    this.$(".no-messages").show();
                }

            }
    });
});

define(
    'models/services/data/ui/Pref',[
        'jquery',
        'models/SplunkDBase',
        'util/splunkd_utils'
    ],
    function(
        $,
        BaseModel,
        splunkd_utils
    ) {
        var Pref = BaseModel.extend({
            url: 'data/ui/prefs',
            initialize: function() {
                BaseModel.prototype.initialize.apply(this, arguments);
            },
            bootstrap: function(uiPrefsDeferred, page, app, owner) {
                var uiPrefsUrl = splunkd_utils.fullpath(
                        this.url + "/" + encodeURIComponent(page),
                        {
                            app: app,
                            owner: owner
                        }
                     ),
                     proxyUIPrefModel = new Pref();

                proxyUIPrefModel.fetch({
                    url: uiPrefsUrl,
                    success: function(model, response) {
                         if ((owner||'').toLowerCase() !== proxyUIPrefModel.entry.acl.get('owner')) {
                             //we got a shared UIPref entity so we need to make a new local entity
                             this.fetch({
                                 success: function(model, response) {
                                     var data = $.extend(true, {name: page}, proxyUIPrefModel.entry.content.toJSON());
                                     this.entry.content.set(data);
                                     uiPrefsDeferred.resolve();
                                 }.bind(this),
                                 error: function(model, response) {
                                     uiPrefsDeferred.resolve();
                                 }.bind(this)
                             });
                         } else {
                             this.setFromSplunkD(proxyUIPrefModel.toSplunkD());
                             uiPrefsDeferred.resolve();
                         }
                     }.bind(this),
                     error: function(model, response) {
                         this.fetch({
                             success: function(model, response) {
                                 this.entry.content.set({
                                     name: page
                                 });
                                 uiPrefsDeferred.resolve();
                             }.bind(this),
                             error: function(model, response) {
                                 uiPrefsDeferred.resolve();
                             }.bind(this)
                         });
                     }.bind(this)
                });
            }
        });
        
        return Pref;
    }
);

define('contrib/text!views/shared/litebar/SideNav.html',[],function () { return '<div class="sidenav-body">\n    <div class="messages"></div>\n    <div class="sidenav-menus"></div>\n</div>';});

/**
 *   views/shared/delegates/Accordion
 *
 *   Desc:
 *     This class applies accordion behaviors.
 *     Default markup is based on Twitter Bootstrap's Collapse
 *     http://twitter.github.com/bootstrap/
 *
 *     @param {Object} (Optional) options An optional object literal having one or more settings.
 *
 *    Usage:
 *       var p = new Popdown({options})
 *
 *    Options:
 *        el (required): The event delegate.
 *        group: jQuery selector for the toggle and body wrapper ".accordion-group".
 *        toggle: jQuery selector for the accordion group's toggle. Defaults to ".accordion-toggle".
 *        body: jQuery selector for the accordion group's body. Defaults to ".accordion-body".
 *        default: jQuery selector or object for the default group. Defaults to ".accordion-group:first-child".
 *        collapsible: Will allow for each to open/close on each's own w/o others toggling
 *
 *    Methods:
 *        show: show a panel. Parameters are the group, which can be a selector or jQuery object, and a boolean to enable or disable animation.
 */


define('views/shared/delegates/Accordion',[
    'jquery',
    'underscore',
    'views/shared/delegates/Base'
],function(
    $,
    _,
    DelegateBase
){
    return DelegateBase.extend({
        initialize: function(){
            var defaults = {
                group: ".accordion-group",
                toggle: ".accordion-toggle",
                body: ".accordion-body",
                defaultGroup: ".accordion-group:first-child",
                icon: ".icon-accordion-toggle",
                inactiveIconClass: "icon-triangle-right-small",
                activeIconClass: "icon-triangle-down-small",
                activeClass: "active",
                collapsible: false,
                speed: 300
            };

            _.defaults(this.options, defaults);
            
            this.events = {};
            this.events["click " + this.options.toggle] = "toggle";

            //setup
            this.$(this.options.body).hide();
            this.$(this.options.icon).addClass(this.options.inactiveIconClass);
            
            //show the default group all
            this.show(this.$(this.options.defaultGroup), false);
        },
        toggle: function (e) {
            e.preventDefault();      
            var $group = $(e.currentTarget).closest(this.options.group);
            
            if (this.options.collapsible) {
                this.singleToggle($group);
                return;
            }

            //if the group is already active, do nothing.
            if ($group.hasClass(this.options.activeClass)) {
                return;
            }
            
            this.trigger('toggle'); 
            this.show($group, true);
            this.trigger('toggled');
        },
        show: function (group, animate) {
            var that = this,
                $newGroup = $(group),
                $activeGroup = this.$(this.options.group + '.' + this.options.activeClass),
                showComplete = function () {
                  that.trigger('shown');
                },
                hideComplete = function () {
                  that.trigger('hidden');
                };

            //ignore if the item is already active.
            this.trigger('show');
            this.trigger('hide');
            
            //Swap the active classes.
            $activeGroup.removeClass(this.options.activeClass);
            $newGroup.addClass(this.options.activeClass);

            //Swap the icon classes
            $activeGroup.find(this.options.icon).addClass(this.options.inactiveIconClass).removeClass(this.options.activeIconClass);
            $newGroup.find(this.options.icon).addClass(this.options.activeIconClass).removeClass(this.options.inactiveIconClass);
            
            //Show hide the body
            if (animate){
                $activeGroup.find(this.options.body).slideUp({duration:this.options.speed, queue: false, complete:hideComplete});
                $newGroup.find(this.options.body).slideDown({duration:this.options.speed, queue: false, complete:showComplete});
            } else {
                $activeGroup.find(this.options.body).hide({duration:0, queue: false, complete:hideComplete});
                $newGroup.find(this.options.body).show({duration:0, queue: false, complete:showComplete});
            }
        },
        singleToggle: function(group) {
            if (group.hasClass(this.options.activeClass)) {
                group.find(this.options.icon).addClass(this.options.inactiveIconClass).removeClass(this.options.activeIconClass);
                group.find(this.options.body).slideUp({duration:this.options.speed, queue: false});
            } else {
                group.find(this.options.icon).addClass(this.options.activeIconClass).removeClass(this.options.inactiveIconClass);
                group.find(this.options.body).slideDown({duration:this.options.speed, queue: false});
            }
            group.toggleClass(this.options.activeClass);
            this.trigger('toggled');
        },
        initialToggleOn: function(group) {
            group.find(this.options.icon).addClass(this.options.activeIconClass).removeClass(this.options.inactiveIconClass);
            group.find(this.options.body).show();
            group.addClass(this.options.activeClass);
        }
    });
});
Splunk.namespace("Splunk.Messenger");

/**
 * A controller like class who carries a message.
 *
 * Example:
 * var broker = new Splunk.Messenger.Bus();
 *
 * //Send a message.
 * broker.send("info", "Info message a", "foobar_b", null, null);
 * broker.send("info", "Info message b", "foobar_a", null, null);
 *
 * //Get all messages.
 * broker.receive(null, null, function(message){
 *     alert("Got some arbitrary message object.");
 * });
 *
 * //Get all messages filtered by level 'info'.
 * broker.receive({"level":"info"}, null, function(message){
 *     alert("Got a a message object with a level of info.");
 * });
 *
 * //Get all messages filtered by level 'info' and ordered by date.
 * broker.receive({"level":"info"}, ['date'], function(msg){
 *     alert("Got a message object with a level of info sorted by date (latest first).");
 * });
 */
Splunk.Messenger.Bus = $.klass({
    DATE_FORMAT: "%Y-%m-%dT%H:%M:%S",
    MAX_SUBJECTS_BUFFER: 100,
    MAX_OBSERVERS_BUFFER: 200,
    /**
     * Initializes Messenger Bus.
     */
    initialize: function(){
        this.count = 1;
        this.id = 0;
        this.logger = Splunk.Logger.getLogger("Splunk.Messenger.Bus");
        this.observers = [];
        this.subjects = [];
        $(window).bind("unload", this.gc.bind(this));
    },
    /**
     * Create a new observer object.
     *
     * @param {Object||null} filter An object literal key/value filter: {(key) {String} One of x properties for an Object: (value) {String || RegExp} An arbitrary string value to match or regular expression object, all matching.
     * @param {Array||null} sort An Array of key values to sort by.
     * @param {Boolean} negate If you wish to negate the entire filter, matching only items that do not match the filter.
     * @param {Boolean} cancel Stop the propogation of notification to other observers.
     * @return An new observer object.
     * @type Object
     */
    createObserver: function(filter, sort, callback, negate, cancel){
        filter.control = filter.hasOwnProperty('control') ? filter.control : true;
        return {
            'filter':filter,
            'sort':sort,
            'callback':callback,
            'negate':negate,
            'cancel':cancel
        };
    },
    /**
     * Create a new subject object.
     *
     * @param {String} level The severity level.
     * @param {String} content The message content.
     * @param {*} className The class identifier for the message of any type.
     * @param {String} date The UTC ISO Date.
     * @param {String} id An id value (Does not have to be unique).
     * @return An new subject object.
     * @type Object
     */
    createSubject: function(level, content, className, date, id, control){
        return {
            'level':level,
            'control':control,
            'content':content,
            'className':className,
            'date':date,
            'id': id
        };
    },
    /**
     * Filter an Array of Objects given an arbitrary set of key/value pairs.
     *
     * @param {Array} arrayOfObjects An array of object literal values.
     * @param {Object} kv An object literal key/value filter: {(key) {String} One of x properties for an Object: (value) {String || RegExp} An arbitrary string value to match or regular expression object, all matching.
     * @return Matching (included) and non-matching (excluded) subject(s).
     * @type Object
     */
    filter: function(arrayOfObjects, kv){
        var included = [];
        var excluded = [];
        for(i=0; i<arrayOfObjects.length; i++){
            var object = arrayOfObjects[i];
            var match = true;
            for(var k in kv){
                if(kv.hasOwnProperty(k) && object.hasOwnProperty(k) && object[k] !== undefined &&
                    ((k=='control' && (kv[kv]||!object[k])
                    || ((kv[k] instanceof RegExp)?object[k].search(kv[k])!=-1:kv[k]==object[k])))){
                    continue;
                }else{
                    match = false;
                    break;
                }
            }
            if(match){
                included.push(object);
            }else{
                excluded.push(object);
            }
        }
        return {"included":included, "excluded":excluded};
    },
    /**
     * Garbage collection routine.
     */
    gc: function(){
        this.observers = [];
    },
    /**
     * Create an empty subject object.
     *
     * @return An empy subject.
     * @type Object
     */
    getEmptySubject: function(){
        return this.createSubject("", "", "", "", "", false);
    },
    /**
     * Get a unique id with zero padding.
     */
    getUniqueId: function(){
        this.id++;
        var paddingLength = [this.MAX_OBSERVERS_BUFFER].join("").length + 1;
        var zeropad = [this.id, ""].join("");
        while(zeropad.length<paddingLength){
            zeropad = ["0", zeropad].join("");
        }
        return zeropad;
    },
    /**
     * Get matching subject item(s) based on optional filter and sort criteria.
     *
     * @param {Boolean} del Delete the entire message queue after retrieval.
     * @param {Object||null} filter An object literal key/value filter: {(key) {String} One of x properties for an Object: (value) {String || RegExp} An arbitrary string value to match or regular expression object, all matching.
     * @param {Array||null} sort An Array of key values to sort by.
     * @param {Boolean} (Optional) negate If you wish to negate the entire filter, matching only items that do not match the filter.
     * @return Matched subject(s).
     * @type Array
     */
    getSubjects: function(del, filter, sort, negate){
        negate = arguments[3] || false;
        //this.logger.info("Filter negation enabled", arguments);
        var filtered = (filter && this.hasSubjectProperty(filter))?this.filter(this.subjects, filter):{"included":this.subjects.concat([]), "excluded":[]};
        var included = (negate)?filtered.excluded:filtered.included;
        var excluded = (negate)?filtered.included:filtered.excluded;
        if(del){
            this.subjects = excluded;
        }
        return (sort && sort.length>0)?this.sort(included, sort):included;
    },
    /**
     * Get the length of matching subjects.
     *
     * @param {Object||null} filter An object literal key/value filter: {(key) {String} One of x properties for an Object: (value) {String || RegExp} An arbitrary string value to match or regular expression object, all matching.
     * @param {Boolean} (Optional) negate If you wish to negate the entire filter, matching only items that do not match the filter.
     * @return The length of matching queue entities.
     * @type Number
     */
    getSubjectLength: function(filter){
        var negate = arguments[1] || false;
        return this.getSubjects(false, filter, null, negate).length;
    },
    /**
     * Check if an object has a subject property.
     *
     * @param {Object} object An object to check properties against.
     * @return If the object has a queue entity property.
     * @type Boolean
     */
    hasSubjectProperty: function(object){
        for(var property in object){
            if(this.isValidSubjectProperty(property)){
                return true;
            }
        }
        return false;
    },
    /**
     * Check if a subject has all required properties.
     *
     * @param {Object} object An object to check properties against.
     * @return If the object is a valid queue entity.
     * @type Boolean
     */
    isValidSubject: function(object){
        var subject = this.getEmptySubject();
        for(var property in subject){
            if(subject.hasOwnProperty(property) && !object.hasOwnProperty(property)){
                return false;
            }
        }
        return true;
    },
    /**
     * Check if subject property is valid.
     *
     * @param {String} property A property to validate.
     * @return If the property is a queue entity property.
     * @type Boolean
     */
    isValidSubjectProperty: function(property){
        var subject = this.getEmptySubject();
        return (subject.hasOwnProperty(property))?true:false;
    },
    /**
     * Send notification to all observers.
     *
     * @param {Array} observers An array of observers.
     */
    notify: function(observers){
        //this.logger.info("notify subject(s)");
        observers = observers.concat([]).sort(this.observerNotifySortby.bind(this));
        var observer;
        for(var j=0; j<observers.length; j++){
            observer = observers[j];
            var subjects = this.getSubjects(observer.cancel, observer.filter, observer.sort, observer.negate);
            for(var k=0; k<subjects.length; k++){
                var subject = subjects[k];
                this.logger.info(subject);
                try{
                    observer.callback(subject);
                }catch(e){
                    //setTimeout(function(e){throw e;}, 0);//Keep on trucking...
                }
            }
        }
        for(var l=0; l<observers.length; l++){
            observer = observers[l];
            this.getSubjects(true, observer.filter, null, observer.negate);//remove all matched observers.
        }
    },
    /**
     * Sort pattern for observer notification.
     *
     * @param {Object} a
     * @param {Object} b
     * @return Defaults to 0, no sort required.
     * @type Number
     * @return
     * < 0: Sort "a" to be a lower index than "b"
     * = 0: "a" and "b" should be considered equal, and no sorting performed.
     * > 0: Sort "b" to be a lower index than "a".
     */
    observerNotifySortby: function(a, b){
        return 0;
    },
    /**
     * Create an observer of subjects(s).
     *
     * @param {Object||null} filter An object literal key/value filter: {(key) {String} One of x properties for an Object: (value) {String || RegExp} An arbitrary string value to match or regular expression object, all matching.
     * @param {Array||null} sort An Array of key values to sort by.
     * @param {Function} callback A callback handler to call with the matching message.
     * @param {Boolean} negate If you wish to negate the entire filter, matching only items that do not match the filter.
     * @param {Boolean} cancel Stop the propogation of notification to other observers.
     */
    receive: function(filter, sort, callback, negate, cancel){
        var observer = this.createObserver(filter, sort, callback, negate, cancel);
        if(this.observers.length>=this.MAX_OBSERVERS_BUFFER){
            this.logger.warn("observers length exceeds MAX_OBSERVERS_BUFFER constraint of", this.MAX_OBSERVERS_BUFFER, "dropping earliest item.");
            this.observers.shift();
        }
        this.observers.push(observer);
        this.notify([observer]);
    },
    /**
     * Send a subject.
     *
     * @param {String} level The severity level.
     * @param {String} content The message string text.
     * @param {*} className The class identifier for the message of any type.
     * @param {String || null} id An id value (Does not have to be unique), if null generates a unique value.
     * @param {String || null} date An optional UTC ISO Date, if null defaults value of now is added.
     */
    send: function(level, content, className, id, date, control){
        //this.logger.info("send message");
        date = date || (new Date()).strftime(this.DATE_FORMAT);
        id = id || this.getUniqueId();
        control = control ? true : false;
        var subject = this.createSubject(level, content, className, date, id, control);
        if(this.subjects.length>=this.MAX_SUBJECTS_BUFFER){
            this.logger.warn("subjects length exceeds MAX_SUBJECTS_BUFFER constraint of", this.MAX_SUBJECTS_BUFFER, "dropping earliest item.");
            this.subjects.shift();
        }
        this.logger.info(sprintf('MSG [%s, %s] %s', level, className, content));
        this.subjects.push(subject);
        this.notify(this.observers);
    },
    /**
     * Sort an Array of Objects given an arbitrary set of key/value pairs in (default is alpha ordering).
     *
     * @param {Array} arrayOfObjects An array of object literal values.
     * @param {Array} key An Array of key values to sort by.
     * @return A sorted array of objects.
     * @type Object
     */
    sort: function(arrayOfObjects, keys){
        var sortedArray = arrayOfObjects.concat([]);
        for(var i=0; i<keys.length; i++){
            var k = keys[i];
            sortedArray.sort(function(a, b){
                if(!a.hasOwnProperty(k) || !b.hasOwnProperty(k)){
                    this.logger.warn("Cannot sort with invalid key", k);
                    return 0;
                }else{
                    return ([a[k], b[k]].sort()[0]!==a[k])?1:-1;
                }
            });
        }
        return sortedArray;
    }
});
/**
 * Augment Bus for application specific implementation. Based on className hierarchy and splunkd server messaging.
 * Overrides send and receive methods.
 *
 * Example:
 * var broker = Splunk.Messenger.System.getInstance();
 *
 * //Send a message.
 * broker.send("info", "splunk", "This is a message");
 * broker.send("info", "splunk.search.job", "This is a message");
 * broker.send("info", "splunk.search", "This is a message");
 *
 * //Get all messages.
 * broker.receive("splunk.search.job", function(message){
 *     alert("Got one message matching className splunk.search.job.");
 * });
 *
 * broker.receive("splunk", function(message){
 *     alert("Got any message matching className splunk or splunk.search");
 * });
 *
 * //Get all non-matching messages.
 * broker.receive("*", function(msg){
 *     alert("Got a message that is neither splunk, splunk.search or splunk.search.job");
 * });
 */
Splunk.Messenger.System = $.klass(Splunk.Messenger.Bus, {
    RECEIVE_WILD_CARD: "*",
    RECEIVE_LEVELS: ["persistent", "info", "warn", "error", "fatal"],
    RECEIVE_LEVEL: "fatal",
    REQUEST_TIMEOUT: 5000,
    SERVER_ENABLED: true,
    SERVER_POLL_INTERVAL: 60000,
    SERVER_RESOURCE: Splunk.util.make_url("/api/messages/index"),
    SERVER_CLASSIFIER: "splunk.services",
    SERVER_SESSION_EXPIRED_MESSAGE: _("Your session has expired."),
    SERVER_DOWN_MESSAGE: _("Your network connection may have been lost or Splunk web may be down."),
    SERVER_BACK_UP_MESSAGE: _("Your network connection was either restored or Splunk web was restarted."),    
    
    // number of consecutive request failures to throw warning to user
    // about potential connection issues
    OFFLINE_WARNING_THRESHOLD: 2,

    /**
     * Intializes Messenger System.
     *
     * @param {Object} super
     */
    initialize: function($super){
        $super();
        this.logger = Splunk.Logger.getLogger("Splunk.Messenger.System");
        this.intervalId = null;
        this.isRequestQueued = false;
        this.isServerDown = false;
        this.errorCount = 0;
        this.abortRequests = false;
        this.previousEtag = "";
        if(this.SERVER_ENABLED && typeof DISABLE_MESSENGER === 'undefined') {
            setTimeout(this.getServerMessages.bind(this), 0);//chrome throttle for status code of 0
            this.startPoller();
        }
        $(document).bind("SessionTimeout", this.onSessionTimeout.bind(this));
        $(document).bind("SessionStart", this.onSessionStart.bind(this));
    },
    /**
     * Serialize a className into a hierarchy matching RegExp object.
     *
     * @param {String} className
     * @type RegExp
     * @return RegExp serialized className.
     */
    classNameSerialize: function(className){
        var regex;
        if(!className)
            className = this.RECEIVE_WILD_CARD;
        if(className===this.RECEIVE_WILD_CARD){
            regex = /./;
        }else{
            var classNameParts = className.split(".");
            if(classNameParts.length===0){
                classNameParts = [className];
            }
            var pattern = "^" + classNameParts.join("\.");
            try{
                regex = new RegExp(pattern);
            }catch(e){
                this.logger.error("Could not create RegExp object for className", className);
                return null;
            }
        }
        return regex;
    },
    /**
     * Retrieve messages from the app server.
     */
    getServerMessages: function(){
        if(!this.isRequestQueued && !this.abortRequests){
            this.isRequestQueued = true;
            $.ajax({
                type: "GET",
                url: this.SERVER_RESOURCE,
                dataType: "text",
                beforeSend: function(XMLHttpRequest){
                    //don't set If-None-Match header to empty string value (see SPL-70971)
                    if (this.previousEtag) {
                        try {
                            XMLHttpRequest.setRequestHeader("If-None-Match", this.previousEtag);
                        } catch(e) {
                            // IE6 does not have setRequestHeader()
                        }
                    }
                }.bind(this),
                timeout: this.REQUEST_TIMEOUT,
                error: this.onServerMessagesError.bind(this),
                complete: this.onServerMessagesComplete.bind(this)
            });
            //this.logger.info("Getting messages from server.");
        }
    },
    /**
     * Override sort pattern for observer notification. Follows class hiearchy pattern: aaa.bbb.ccc, aaa.bbb, aaa, *.
     *
     * @param {Object} a
     * @param {Object} b
     * @return Defaults to 0, no sort required.
     * @type Number
     * @return
     * < 0: Sort "a" to be a lower index than "b"
     * = 0: "a" and "b" should be considered equal, and no sorting performed.
     * > 0: Sort "b" to be a lower index than "a".
     */
    observerNotifySortby: function(a, b){
        var classNameA = (a.filter.className instanceof RegExp)?a.filter.className.toString():a.filter.className;
        var classNameB = (b.filter.className instanceof RegExp)?b.filter.className.toString():b.filter.className;
        var classNameWildCard = this.classNameSerialize(this.RECEIVE_WILD_CARD).toString();
        if(classNameA===classNameWildCard){    
            return 1;
        }else if(classNameB===classNameWildCard){
            return -1;
        }else{
            return ([classNameA, classNameB].sort()[0]!==classNameA)?1:-1;
        }
    },
    /**
     * Handle error repsonse from jQuery $.ajax
     */
    onServerMessagesError: function(){
        //this.logger.error("onServerMessagesError fired");
    },
    /**
     * Handle a splunk appserver jsonresponse envelope.
     *
     * @param {Object} data The XMLHttpRequest object.
     * @param {String} textStatus A string describing the type of success of the request.
     */
    onServerMessagesComplete: function(data, textStatus){
        this.isRequestQueued = false;
        this.previousEtag = data.getResponseHeader("Etag");
        switch(data.status){
            case 0:
         	case 12029: //IE9(prob 8 as well) has it's own HTTP error status of 12029.. WTF?! 
                this.errorCount++;
         		this.previousEtag = new Date();
                if (this.errorCount >= this.OFFLINE_WARNING_THRESHOLD) {
                    this.isServerDown = true;
                    this.send("error", this.SERVER_CLASSIFIER, this.SERVER_DOWN_MESSAGE);
                    this.logger.warn("Server message timeout, offline");           	
                }
            	break;
            case 304:
                this.errorCount = 0;
                break;
            case 412:
                this.abortRequests = true;
                this.send("error", this.SERVER_CLASSIFIER, this.SERVER_SESSION_EXPIRED_MESSAGE);
                this.logger.warn("Server message session expired, abort further requests.");
                break;
            case 200:
                this.errorCount = 0;
                if(this.isServerDown){
                    this.logger.info("Server message back online.");
                    this.isServerDown = false;
                    this.previousEtag = new Date();
                    
                    // all messages from this persistent store should be marked as 'persistent'
                    this.send("persistent", this.SERVER_CLASSIFIER, this.SERVER_BACK_UP_MESSAGE);
                    break;
                }
                this.processResponse(data);
                break;
            default:
                break;
        }
    },
    /**
     * Handle Splunk.Session start event, ensure abortRequests is false to enable poller http requests.
     * 
     * @param {Object} event A jQuery event object.
     * @param {Date} date The fire time of the event.
     */    
    onSessionStart: function(event, date){
        this.logger.info("Starting message poller...");
        this.abortRequests = false;
    },    
    /**
     * Handle Splunk.Session timeout event, ensure abortRequests is true to cancel poller http requests.
     * 
     * @param {Object} event A jQuery event object.
     * @param {Date} date The fire time of the event.
     */
    onSessionTimeout: function(event, date){
        this.logger.info("Stopping message poller...");
        this.abortRequests = true;
    },
    /**
     * Process response data from messages endpoint.
     * 
     * @param {Object} data The XMLHttpRequest object.
     */
    processResponse: function(data){
        try{
            this.logger.info("Server message process response");
            data = JSON.parse(data.responseText);
        }catch(e){
            this.logger.warn("Could not parse server messages with error");
            return;
        }
        for(var i=0; i<data.messages.length; i++){
            var dataObj = data.messages[i];
            if(dataObj.hasOwnProperty("type") && dataObj.hasOwnProperty("message")){
                try{
                    this.send(dataObj.type.toLowerCase(), this.SERVER_CLASSIFIER, dataObj.message, dataObj.id);
                }catch(e){
                    this.logger.error("Could not send message through bus", e);
                }
            }else{
                this.logger.error("Missing jsonresponse property from app server.");
            }
        }        
    },
    /**
     * Override receive method based on className and id.
     *
     * @param {String} className The class identifier for the message following ("foo.bar" convention, "*" for all non-matched classNames)
     * @param {Function} callback A callback handler to call with the matching message.
     * @param {String} (Optional) id An id value (Does not have to be unique).
     */
    receive: function($super, className, callback, id, control){

        if(!className)
            className = this.RECEIVE_WILD_CARD;
        var classNameRegExp = this.classNameSerialize(className);
        if(!classNameRegExp){
            return;
        }
        for(var i=0; i<this.RECEIVE_LEVELS.length; i++){
            var filter = {};
            filter.className = classNameRegExp;
            if(id){
                filter.id = id;
            }
            if(control)
                filter.control = true;
            filter.level = this.RECEIVE_LEVELS[i];
            var uniqueReceiver = true;
            for(var j=0; j<this.observers.length; j++){
                var observerFilter = this.observers[j].filter;
                if((observerFilter.level && observerFilter.level===filter.level) && (observerFilter.className && observerFilter.className.toString()===filter.className.toString())){
                    uniqueReceiver = false;
                    this.logger.warn("Can't add another receiver with level", filter.level, "for already observed className", className);
                    break;
                }
            }
            if(uniqueReceiver){
                $super(filter, null, callback, false, true);
            }
            if(this.RECEIVE_LEVELS[i]===this.RECEIVE_LEVEL){
                break;
            }
        }
    },
    /**
     * Reset polling the server at a set interval for messages.
     */
    resetPoller: function(){
        if(this.intervalId){
            clearInterval(this.intervalId);
        }
        this.startPoller();
    },
    /**
     * Override send method.
     *
     * @param {String} level The severity level.
     * @param {String} className className The class identifier for the message following ("foo.bar" convention)
     * @param {String} content The message string text.
     * @param {String} (Optional) id An id value (Does not have to be unique).
     */
    send: function($super, level, className, content, id, control){
        id = id || null;
        if(jQuery.inArray(level, this.RECEIVE_LEVELS)!=-1){
            if(this.SERVER_ENABLED){
                this.resetPoller();
            }
            $super(level, content, className, id, null, control);
        }else{
            this.logger.warn("Message not sent, invalid message level -", level, "- needs to be one of", this.RECEIVE_LEVELS.join(","));
        }
    },
    /**
     * Start polling the server at a set interval for messages.
     */
    startPoller: function(){
        this.intervalId = setInterval(this.getServerMessages.bind(this), this.SERVER_POLL_INTERVAL);
    },
    /**
     * Inject a control event to instruct listeners to clear their display
     */
    clear: function() {
        this.send('info', 'control', 'CLEAR', null, true);
    }
});
Splunk.Messenger.System.instance = null;
/**
 * Singleton reference to Messenger System object.
 *
 * @return A reference to a shared Messenger System object.
 * @type Object
 */
Splunk.Messenger.System.getInstance = function(){
    if(!Splunk.Messenger.System.instance){
        Splunk.Messenger.System.instance = new Splunk.Messenger.System();
    }
    return Splunk.Messenger.System.instance;
};

define("splunk.messenger", ["splunk","splunk.util","splunk.logger","splunk.i18n","lowpro"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Splunk.Messenger;
    };
}(this)));

// splunk bar
define('views/shared/litebar/SideNav',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/Base',
    'views/shared/litebar/SystemSection',
    'views/shared/litebar/Activity',
    'views/shared/litebar/RestartDialog',
    'views/shared/splunkbar/messages/LiteMessages',
    'views/shared/splunkbar/messages/NoConnectionOverlay',
    'models/services/data/UserPref',
    'models/services/AppLocal',
    'models/services/authentication/User',
    'models/services/data/ui/Pref',
    'models/shared/Application',
    'collections/services/data/ui/Managers',
    'collections/shared/splunkbar/SystemMenuSections',
    'collections/services/Messages',
    'contrib/text!views/shared/litebar/SideNav.html',
    'views/shared/delegates/Accordion',
    'uri/route',
    'splunk.util',
    'splunk.messenger',
    'splunk.logger',
    'util/splunkd_utils'
],
function(
    $,
    _,
    Backbone,
    module,
    BaseView,
    SystemSection,
    ActivityMenu,
    RestartDialog,
    MessagesView,
    NoConnectionOverlay,
    UserPrefModel,
    AppLocalModel,
    UserModel,
    uiPref,
    ApplicationModel,
    ManagersCollection,
    SystemMenuSectionsCollection,
    MessagesCollection,
    sideTemplate,
    Accordion,
    route,
    splunkUtil,
    splunkMessenger,
    splunkLogger,
    splunkDUtils
){
    var View = BaseView.extend({
        moduleId: module.id,
        template: sideTemplate,
        className: 'sidenav',
        initialize: function() {
            BaseView.prototype.initialize.apply(this, arguments);
            
            this.children.accordion = new Accordion({
                el: this.el,
                group: ".collapsible-group",
                toggle: ".collapsible-toggle",
                body: ".collapsible-body",
                icon: ".icon-collapsible-toggle",
                inactiveIconClass: "icon-chevron-right",
                activeIconClass: "icon-chevron-down",
                collapsible: true
            });

            this.children.activityMenu = new ActivityMenu({
                model: {
                    user: this.model.user,
                    application: this.model.application
                }
            });

            this.collection.sections.on('ready', function() {
                this.debouncedRender();
            }, this);

            this.model.userPref.entry.content.on('ready', function() {
                this.debouncedRender();
            }, this);

            this.children.accordion.on('toggled', function() {
                this.setPrefs();
            }, this);

            //listen for restart events
            $(document).on('restart_failed', function() {
                this.hideRestartModal();
            }.bind(this));

            this.canRestart = this.model.user.canRestart();
        },

        events: {
            'click #control' : function(e) {    
                e.preventDefault();
                if (this.canRestart) {
                    if (confirm(_("Are you sure you want to restart Splunk?").t())) {
                        this.showRestartModal();
                        splunkUtil.restart_server();
                    }
                }
            },
            'click .splunk-tour' : function(e) {    
                e.preventDefault();
                this.showOnboardingTour();
            }
        },

        showRestartModal: function() {
                this.children.restartDialog = new RestartDialog({backdrop: 'static'});
                // Necessary for modal to render correctly in manager.
                $('body').append('<div class="splunk-components restartModal"></div>');
                $('.restartModal').append(this.children.restartDialog.render().el);
                this.children.restartDialog.show();
        },

        hideRestartModal: function() {
            if (this.children.restartDialog) {
                this.children.restartDialog.hide();
            }
        },

        _setInitials: function() {
            var name = this.model.user.entry.content.get("realname") || this.model.user.entry.get("name") || "",
                names = name.split(/\s/),
                first = (names.length > 0) ? names[0].charAt(0) : "",
                last = (names.length > 1) ? names[names.length - 1].charAt(0) : "";
            
            this.$('.user-name').html(first + last);
        },

        setPrefs: function(e) {
            var activeNavs = '|',
                elements = this.$('.collapsible-group');
            for (var i = 0; i < elements.length; i++) {
                if ($(elements[i]).hasClass('active')) {
                    activeNavs = activeNavs.concat($(elements[i]).attr('id')).concat('|');
                }
            }
            this.model.userPref.entry.content.set({
                'display.prefs.activeSideNav': activeNavs
            });
            this.model.userPref.save({});
        },

        liteMessages: function() {
            this.children.messages = new MessagesView({
                collection: {
                    messages: this.collection.messages,
                    legacyMessages: this.collection.legacyMessages
                },
                model: {
                    serverInfo: this.model.serverInfo
                }
            });

            this.MAX_RETRIES_BEFORE_FAIL = 3;
            this.MESSAGES_POLLING_DELAY_STANDARD = 60000;
            this.MESSAGES_POLLING_DELAY_HI_FREQ = 1000;

            this.children.noConnectionOverlay = new NoConnectionOverlay();
            $('body').append(this.children.noConnectionOverlay.render().el);

            this.collection.messages.on('serverValidated', function(success, context, messages) {
                if (success && this.cntRetries > 0) {
                    this.restartMessagePolling(this.MESSAGES_POLLING_DELAY_STANDARD);
                    this.children.noConnectionOverlay.hide();
                    this.cntRetries = 0;
                    return;
                }
                var netErrorMsg = _.find(messages, function(msg) {
                    return msg.type == splunkDUtils.NETWORK_ERROR || 'network_error';
                });
                if (netErrorMsg) {
                    if (this.cntRetries == 0) {
                        this.restartMessagePolling(this.MESSAGES_POLLING_DELAY_HI_FREQ);
                    }
                    if (this.cntRetries >= this.MAX_RETRIES_BEFORE_FAIL) {
                        this.children.noConnectionOverlay.show();
                    }
                    this.cntRetries += 1;
                }
            }, this);
            this.$('.messages').replaceWith(this.children.messages.render().el);
            this.restartMessagePolling(this.MESSAGES_POLLING_DELAY_STANDARD);
        },

        restartMessagePolling: function(interval) {
            this.collection.messages.stopPolling();
            this.collection.messages.startPolling({delay: interval, uiInactivity: true, stopOnError: false, data: {count: 1000}});
        },

        render: function() {
            this.$el.html(this.template);
            this.liteMessages();
            this.collection.sections.each(function(section){
                if (section.get('items') && section.get('items').length === 0) {
                    return;
                }
                var sectionView = new SystemSection({
                    model: section
                });
                
                this.$('.sidenav-menus').append(sectionView.render().el);
            }.bind(this));

            this.$('.sidenav-menus').prepend(this.children.activityMenu.render().el);

            var activeSideNavs = this.model.userPref.entry.content.get('display.prefs.activeSideNav') || [];
            _.each(this.$('.collapsible-group'), function(node) {
                if (activeSideNavs.indexOf(node.id) > -1) {
                    this.children.accordion.initialToggleOn($(node));
                }
            }.bind(this));

            if (!this.canRestart) {
                this.$('#control').remove();
            }

            if (!this.model.user.canEditReceiving()) {
                this.$('#forwardreceive').remove();
            }

            if (!this.model.user.canViewLicense()) {
                this.$('#licensing_stacks').remove();
            }

            if (!this.model.user.canEditUsers()) {
                this.$('#authentication_users').remove();
            }

            if (!this.model.user.canEditServer()) {
                this.$('#systemsettings').remove();
            }

            return this;
        }
    },
    {
        create: function(options){
            options = options || {};
            options.collection = options.collection || {};
            options.model = options.model || {};

            //the APPLICATION model is REQUIRED argument from the consumer. If its not passed, make up an empty one, to keep things rendering, and assure continuance
            //TODO should log this
            var applicationDfd = $.Deferred();
            if (!options.model.application){
                options.model.application = new ApplicationModel();
            }
            // handle both when the application model is already filled and when it has yet to complete fetching
            if (options.model.application.get('app')) {
                applicationDfd.resolve();
            } else {
                options.model.application.on('change', applicationDfd.resolve);
            }

            var currentUserIdDfd = $.Deferred();
            currentUserIdDfd.resolve(options.model.application.get('owner'));

            if (!options.model.user) {
                options.model.user = new UserModel();
                $.when(currentUserIdDfd).done(function(currentUserId) {
                    options.model.user.set('id', encodeURIComponent(currentUserId));
                    options.model.user.fetch();
                });
            }

            var managersDfd = $.Deferred();
            if (!options.collection.managers) {
                options.collection.managers = new ManagersCollection();
                $.when(currentUserIdDfd).done(function(currentUsername) {
                    options.collection.managers.fetch({
                        data: {
                            app: '-',
                            owner: currentUsername,
                            count: 0,
                            digest: 1
                        },
                        success: function() {
                            managersDfd.resolve();
                        }
                    });
                });
            } else {
                managersDfd.resolve();
            }

            var sections = options.collection.sections = new SystemMenuSectionsCollection();

            sections.add({
                id: 'knowledge_configurations',
                label: _('Knowledge').t(),
                icon: 'bookmark',
                order: 2
            });

            if (options.model.user.isAdmin() || options.model.user.isCloudAdmin()) {
                sections.add({
                    id: 'data_configurations',
                    label: _('Data').t(),
                    icon: 'data',
                    order: 1
                });
                sections.add({
                    id: 'system_configurations',
                    label: _('System').t(),
                    icon: 'settings',
                    order: 3
                });
            }

            $.when(managersDfd).done(function() {
                options.collection.managers.each(function(manager) {
                    var menuUrl = manager.entry.content.get('menu.url') || '',
                        sectionName = manager.entry.content.get('menu.name'),
                        disabledByLicense = splunkUtil.normalizeBoolean(manager.entry.content.get('disabled_by_license') || false),
                        order = manager.entry.content.get('menu.order') || 1000,
                        pageStart = route.encodeRoot(options.model.application.get('root'), options.model.application.get('locale')),
                        app = options.model.application.get('app');
                        if (!app) {
                            app = 'NOTHING';
                        }
                        else {
                            app = app === splunkDUtils.SYSTEM ? 'search' : app;
                        }
                        var url = pageStart + splunkUtil.sprintf(menuUrl, {namespace: app});

                    if (!disabledByLicense && sectionName) {
                        var section = sections.get(sectionName);
                        if (section) {
                            var sectionItems = section.get('items');
                            if (sectionItems) {
                                sectionItems.push(manager);
                            }
                        }
                    }
                    manager.set({
                        url: url,
                        order: order
                    });
                });
                sections.trigger('ready');
            });

            return new View(options);
        }
    });
    return View;
});

/**
 * Util package for working with colors.
 */
define('util/color_utils',['underscore'], function(_) {

    var hslColorFromRgbColor = function(rgbColor) {
        /**
         * convert from [r,g,b] to [h,s,l]
         *  r,g,b: [0,255]
         *  h: [0,360)
         *  s: [0,100]
         *  l: [0,100]
         *  Uses algorithm as specified on Wikipedia http://en.wikipedia.org/wiki/HSL_and_HSV
         */

        var r = rgbColor[0];
        var g = rgbColor[1];
        var b = rgbColor[2];
        var computedH = 0;
        var computedS = 0;
        var computedL = 0;

        if (r === null || g === null || b === null ||
            isNaN(r) || isNaN(g)|| isNaN(b) ) {
            return null;
        }

        if (r < 0 || g < 0 || b < 0 ||
            r > 255 || g > 255 || b > 255) {
            return null;
        }

        r = r / 255;
        g = g / 255;
        b = b / 255;
        var minRGB = Math.min(r, Math.min(g, b));
        var maxRGB = Math.max(r, Math.max(g, b));
        var chroma = maxRGB - minRGB;

        var h_prime = 0;
        if (chroma == 0) {
            h_prime = 0;
        }
        else if (maxRGB == r) {
            h_prime = ((g - b) / chroma) % 6;
        } else if (maxRGB == g) {
            h_prime = ((b - r) / chroma) + 2;
        } else if (maxRGB == b) {
            h_prime = ((r - g) / chroma) + 4;
        }

        var h = h_prime * 60;
        while (h < 0)
        {
            h += 360;
        }
        while (h > 360)
        {
            h -= 360;
        }

        var l = 0.5 * (maxRGB + minRGB);

        var s = 0;
        if (chroma == 0) {
            s = 0;
        } else {
            s = chroma / (1 - Math.abs(2 * l - 1));
        }

        if (s < 0) { s = 0; }
        if (s > 1) { s = 1; }
        if (l < 0) { l = 0; }
        if (l > 1) { l = 1; }

        return [h, s * 100, l * 100];
    };

    var rgbColorFromHslColor = function(hslColor) {
        /**
         * convert from [h,s,l] to [r,g,b]
         *  r,g,b: [0,255]
         *  h: [0,360)
         *  s: [0,100]
         *  l: [0,100]
         *  Uses algorithm as specified on Wikipedia http://en.wikipedia.org/wiki/HSL_and_HSV
         */
        if (hslColor.length != 3) {
            return null;
        }

        var h = hslColor[0],
            s = hslColor[1],
            l = hslColor[2];

        s = s / 100;
        l = l / 100;

        while (h < 0)
        {
            h += 360;
        }
        while (h > 360)
        {
            h -= 360;
        }

        if (h < 0 || h > 360 ||
            s < 0 || s > 1 ||
            l < 0 || l > 1)
        {
            return null;
        }

        // chroma
        var c = (1 - Math.abs(2 * l - 1)) * s;

        // determine color components (sans lightness)
        var h1 = h / 60;
        var x = c * (1 - Math.abs((h1 % 2) - 1));
        var r1 = 0,
            g1 = 0,
            b1 = 0;

        if (h1 < 1) {
            r1 = c;
            g1 = x;
        } else if (h1 < 2) {
            r1 = x;
            g1 = c;
        } else if (h1 < 3) {
            g1 = c;
            b1 = x;
        } else if (h1 < 4) {
            g1 = x;
            b1 = c;
        } else if (h1 < 5) {
            r1 = x;
            b1 = c;
        } else {
            r1 = c;
            b1 = x;
        }

        // add lightness component to get r,g,b
        var m = l - 0.5 * c;
        var r = r1 + m,
            g = g1 + m,
            b = b1 + m;

        // return in [0,255] range
        r *= 255;
        g *= 255;
        b *= 255;

        return [r, g, b];
    };

    var rgbColorFromRgbString = function(rgbColorString) {
        /**
         * given "rgb(r,g,b)" converts to [r,g,b]
         */

        var rgbValueStrings = rgbColorString.match(/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
        if (rgbValueStrings === null) {
            return null;
        }

        var rgbColor = [parseInt(rgbValueStrings[1], 10),
                        parseInt(rgbValueStrings[2], 10),
                        parseInt(rgbValueStrings[3], 10)];

        return rgbColor;
    };

    var rgbStringFromRgbColor = function(rgbColor) {
        /**
         * given [r,g,b] returns "rgb(r,g,b)"
         *  r, g, b are all rounded to nearest integers
         */
        if (rgbColor.length != 3) {
            return null;
        }

        var roundedRgbColor = _.map(rgbColor, Math.round);
        var rgbString = "rgb(" + roundedRgbColor[0] + ", " + roundedRgbColor[1] + ", " + roundedRgbColor[2] + ")";
        return rgbString;
    };

    var hslStringFromHslColor = function(hslColor) {
        /**
         * given [h,s,l] returns "hsl(h,s%,l%)"
         *  h, s, l are all rounded to nearest integers
         */
        if (hslColor.length != 3) {
            return null;
        }
        var roundedHslColor = _.map(hslColor, Math.round);
        var hslString = "hsl(" + roundedHslColor[0] + ", " + roundedHslColor[1] + "%, " + roundedHslColor[2] + "%)";
        return hslString;
    };

    var hslColorFromHslString = function(hslColorString) {
        /**
         * given "hsl(h,s%,l%)" returns [h,s,l]
         */
        var hslValueStrings = hslColorString.match(/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)$/);
        if (hslValueStrings === null) {
            return null;
        }

        var hslColor = [parseInt(hslValueStrings[1], 10),
                        parseInt(hslValueStrings[2], 10),
                        parseInt(hslValueStrings[3], 10)];

        return hslColor;
    };

    var rgbColorFromHexString = function(hexColorString) {
        /**
         * given "#RRGGBB" returns [r,g,b]
         */
        var normHexColorString = normalizeHexString(hexColorString);
        var hexValueStrings = normHexColorString.match(/^#?([\dA-Fa-f]{2})([\dA-Fa-f]{2})([\dA-Fa-f]{2})$/);
        if (hexValueStrings === null) {
            return null;
        }

        var rgbColor = [parseInt(hexValueStrings[1], 16),
                        parseInt(hexValueStrings[2], 16),
                        parseInt(hexValueStrings[3], 16)];

        return rgbColor;
    };

    var hexStringFromRgbColor = function(rgbColor) {
        /**
         * given [r,g,b] returns "#RRGGBB"
         *  r,g,b rounded to nearest integers
         */
        if (rgbColor.length != 3) {
            return null;
        }

        var roundedRgbColor = _.map(rgbColor, Math.round);
        var hexComponents = _.map(roundedRgbColor, function(num) {
            var hex = num.toString(16);
            if (hex.length < 2) {
                hex = "0" + hex;
            }
            return hex.toUpperCase();
        });
        var hexString = "#" + hexComponents[0] + hexComponents[1] + hexComponents[2];
        return hexString;
    };

    var normalizeHexString = function(hexString) {
        /**
         * given "rrggbb", "RRGGBB", "#rrggbb", "#RRGGBB" returns "#RRGGBB"
         */
        var normString = '#' + hexString.replace('#','');
        normString = normString.toUpperCase();
        // check for #RGB, to convert to #RRGGBB
        var hexValueStrings = normString.match(/^#?([\dA-F])([\dA-F])([\dA-F])$/);
        if (hexValueStrings !== null) {
            normString = '#' + hexValueStrings[1] + hexValueStrings[1] +
                               hexValueStrings[2] + hexValueStrings[2] +
                               hexValueStrings[3] + hexValueStrings[3];
        }
        return normString;
    };

    var modifyLuminosityOfHslColor = function(hslColor, luminosityMultiplier){
        /**
         * adjusts the luminosity of the specified hsl color by multiplying by luminosityMultiplier
         *  l is clamped to within [0,100]
         */
        var modHslColor = hslColor.slice(0);

        modHslColor[2] *= luminosityMultiplier;
        if (modHslColor[2] > 100) {
            modHslColor[2] = 100;
        } else if (modHslColor[2] < 0) {
            modHslColor[2] = 100;
        }

        return modHslColor;
    };

    var modifyLuminosityOfRgbColor = function(rgbColor, luminosityMultiplier){
        /**
         * adjusts the luminosity of the specified rgb color by luminosityMultiplier
         *   1 - convert to hsl
         *   2 - l *= luminosityMultiplier AND clamp(0,100)
         *   3 - convert back to rgb
         */
        var hslColor = hslColorFromRgbColor(rgbColor);
        var modHslColor = modifyLuminosityOfHslColor(hslColor, luminosityMultiplier);
        var modRgbColor = rgbColorFromHslColor(modHslColor);
        return modRgbColor;
    };

    var modifyLuminosityOfHexString = function(hexString, luminosityMultiplier){
        /**
         * adjusts the luminosity of the specified rgb color by luminosityMultiplier
         *   1 - convert to rgb, then to hsl
         *   2 - l *= luminosityMultiplier AND clamp(0,100)
         *   3 - convert back to rgb, then to hex
         */
        var rgbColor = rgbColorFromHexString(hexString);
        var modRgbColor = modifyLuminosityOfRgbColor(rgbColor, luminosityMultiplier);
        var modHexString = hexStringFromRgbColor(modRgbColor);
        return modHexString;
    };

    var generateGradientStylesWithMidColor = function(startColor, midColor, colorStop, endColor){
        /**
         * returns array of gradient style directives that cover set of browsers
         * builds gradient from three colors, places the midColor at colorStop percent
         *  startColor, midColor, endColor are css interpretable colors
         *  colorStop is "stop%", e.g. "50%", "80%"
         */
        var gradients =
            [
                ' -webkit-gradient(linear, 0 0, 0 100%, from(@startColor), color-stop(@colorStop, @midColor), to(@endColor)) ',
                ' -webkit-linear-gradient(@startColor, @midColor @colorStop, @endColor) ',
                ' -moz-linear-gradient(top, @startColor, @midColor @colorStop, @endColor) ',
                ' -o-linear-gradient(@startColor, @midColor @colorStop, @endColor) ',
                ' linear-gradient(@startColor, @midColor @colorStop, @endColor) ',
                // note: this uses filter instead of bg-image
                " progid:DXImageTransform.Microsoft.gradient(startColorstr='@startColor', endColorstr='@endColor', GradientType=0) "  // IE9 and down, gets no color-stop at all for proper fallback
            ];
        for (var i=0;i<gradients.length;i++){
            gradients[i] = gradients[i].replace(/@startColor/g, startColor);
            gradients[i] = gradients[i].replace(/@midColor/g, midColor);
            gradients[i] = gradients[i].replace(/@colorStop/g, colorStop);
            gradients[i] = gradients[i].replace(/@endColor/g, endColor);
        }
        return gradients;
    };

    var generateGradientStyles = function(startColor, endColor){
        /**
         * returns array of gradient style directives that cover set of browsers
         * builds gradient from two colors
         *  startColor, endColor are css interpretable colors
         */
        var gradients =
            [
                ' -moz-linear-gradient(top, @startColor, @endColor) ', // FF 3.6+
                ' -webkit-gradient(linear, 0 0, 0 100%, from(@startColor), to(@endColor))', // Safari 4+, Chrome 2+
                ' -webkit-linear-gradient(top, @startColor, @endColor) ', // Safari 5.1+, Chrome 10+
                ' -o-linear-gradient(top, @startColor, @endColor) ', // Opera 11.10
                ' linear-gradient(to bottom, @startColor, @endColor) ', // Standard, IE10
                // note: this uses filter instead of bg-image
                " progid:DXImageTransform.Microsoft.gradient(startColorstr='@startColor', endColorstr='@endColor', GradientType=0)  " // IE9 and down
            ];
        for (var i=0;i<gradients.length;i++){
            gradients[i] = gradients[i].replace(/@startColor/g, startColor);
            gradients[i] = gradients[i].replace(/@endColor/g, endColor);
        }
        return gradients;
    };

    // Prefixes hex value with provided symbols (e.g. '0x' or '#')
    var replaceSymbols = function(string, symbols) {
        if (!string) {
            return '';
        }
        var strippedString = this.stripSymbols(string);
        return symbols + strippedString;
    };

    // Removes '0x' and '#' prefixes to return just the color hex value itself
    var stripSymbols = function(string) {
        if (!string) {
            return '';
        }
        if (string.substring(0,2) === '0x') {
            return string.substring(2);
        }
        if (string.substring(0,1) === '#') {
            return string.substring(1);
        }
        return string;
    };

    var interpolateColors = function(color1, color2, p) {
        var r1 = (color1 >> 16) & 0xFF,
            g1 = (color1 >> 8) & 0xFF,
            b1 = color1 & 0xFF,

            r2 = (color2 >> 16) & 0xFF,
            g2 = (color2 >> 8) & 0xFF,
            b2 = color2 & 0xFF,

            rInterp = r1 + Math.round((r2 - r1) * p),
            gInterp = g1 + Math.round((g2 - g1) * p),
            bInterp = b1 + Math.round((b2 - b1) * p);

        return ((rInterp << 16) | (gInterp << 8) | bInterp);
    };

    return {
        hslColorFromRgbColor: hslColorFromRgbColor,
        rgbColorFromHslColor: rgbColorFromHslColor,
        hslColorFromHslString: hslColorFromHslString,
        rgbColorFromRgbString: rgbColorFromRgbString,
        hslStringFromHslColor: hslStringFromHslColor,
        rgbStringFromRgbColor: rgbStringFromRgbColor,
        rgbColorFromHexString: rgbColorFromHexString,
        hexStringFromRgbColor: hexStringFromRgbColor,
        normalizeHexString: normalizeHexString,
        modifyLuminosityOfHslColor: modifyLuminosityOfHslColor,
        modifyLuminosityOfRgbColor: modifyLuminosityOfRgbColor,
        modifyLuminosityOfHexString: modifyLuminosityOfHexString,
        generateGradientStylesWithMidColor: generateGradientStylesWithMidColor,
        generateGradientStyles: generateGradientStyles,
        replaceSymbols: replaceSymbols,
        stripSymbols: stripSymbols,
        interpolateColors: interpolateColors
    };
});

define('views/shared/litebar/Master',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/Base',
    'views/shared/appbar/AppNav',
    'views/shared/appbar/AppLabel',
    'views/shared/splunkbar/UserMenu',
    'views/shared/litebar/HelpMenu',
    'views/shared/splunkbar/ProductMenu',
    'models/services/data/ui/Nav',
    'models/services/AppLocal',
    'collections/services/AppLocals',
    'collections/services/data/ui/Views',
    'collections/services/saved/Searches',
    'contrib/text!views/shared/litebar/Master.html',
    'helpers/AppNav',
    'helpers/Session',
    'collections/services/authentication/CurrentContexts',
    'collections/services/Messages',
    'views/shared/litebar/SideNav',
    'models/services/data/UserPref',
    'models/services/configs/Web',
    'util/splunkd_utils',
    'splunk.util',
    'uri/route',
    'util/color_utils',
    'util/console',
    'util/csrf_protection',
    'util/ajax_no_cache'
],
function(
    $,
    _,
    Backbone,
    module,
    BaseView,
    AppNavView,
    AppLabelView,
    UserMenu,
    HelpMenu,
    ProductMenu,
    NavModel,
    AppModel,
    AppsCollection,
    ViewsCollection,
    SavedSearchesCollection,
    templateMaster,
    appNavParser,
    Session,
    CurrentContexts,
    MessagesCollection,
    SideNav,
    UserPref,
    WebConfModel,
    splunkDUtils,
    splunkUtil,
    route,
    color_utils,
    console
) {
    var View = BaseView.extend({
        moduleId: module.id,
        className: 'lite-bar',
        template: templateMaster,
        initialize: function(options) {
            BaseView.prototype.initialize.apply(this, arguments);
            this.webConfDfd = $.Deferred();

            this.children.sideNav = new SideNav.create({
                model: {
                    user: this.model.user,
                    serverInfo: this.model.serverInfo,
                    appNav: this.model.appNav,
                    application: this.model.application,
                    userPref: this.options.model.userPref,
                    appLocal: this.model.appLocal
                },
                collection: this.collection
            });

            this.children.appNav = new AppNavView({
                model: {
                    user: this.model.user,
                    serverInfo: this.model.serverInfo,
                    appNav: this.model.appNav,
                    application: this.model.application
                },
                collection: this.collection
            });

            this.children.helpMenu = new HelpMenu({
                model: this.model,
                collection: this.collection
            });

            this.children.userMenu = new UserMenu({
                collection: {
                    currentContext: this.model.currentContext //this represents the current logged in user
                },
                model: {
                    user: this.model.user,
                    application: this.model.application,
                    webConf: this.model.webConf,
                    config: this.model.config,
                    serverInfo: this.model.serverInfo
                }
            });

            this.children.appLabel = new AppLabelView({
                model: this.model,
                collection: this.collection
            });

            if(options.autoRender !== false) {
                this.debouncedRender();
            }
            this.collection.sections.on('ready', function() {
                this.$el.before(this.children.sideNav.el);
            }, this);

            this.model.webConf.on('ready', function() {
                this.webConfDfd.resolve();
            }, this);

            options.collection.messages = new MessagesCollection();
            options.collection.messages.fetchData.set({
                "sort_key" : "timeCreated_epochSecs",
                "sort_dir" : "desc"
            });

            Session.on('restart timeout', function() {
                this.collection.messages.stopPolling();
            }, this);
            Session.on('start', function() {
                this.collection.messages.startPolling();
            }, this);
        },

        events: {
            'click .icon-menu': function(e) {
                this.moveNav();
                $('.sidenav-screen').fadeIn(500);
            },
            'click .sidenav-screen': function(e) {
                this.moveNav();
                $('.sidenav-screen').fadeOut(500);
            },
            'click .icon-menu.active': function(e) {
                $('.sidenav-screen').fadeOut(500);
            }
        },

        moveNav: function() {
            $('.sidenav').toggleClass('open');
            $('body').toggleClass('open');
            $('.lite-bar .icon-menu').toggleClass('active');
        },

        render: function() {
            var app = this.model.application,
                html = this.compiledTemplate({
                    homeLink: route.page('', app.get('locale'), 'search')
                });

            this.$el.html(html);
            this.$('.nav').html(this.children.appNav.render().el);
            this.$('.help').replaceWith(this.children.helpMenu.render().el);
            this.$('.user').replaceWith(this.children.userMenu.render().el);
            this.$el.before(this.children.sideNav.el);
            this.$el.prepend('<div class="sidenav-screen"></div>');

            $.when(this.webConfDfd).done(function() {
                var isCloud = this.model.serverInfo.isCloud(),
                    showProductMenu = splunkUtil.normalizeBoolean(this.model.webConf.entry.content.get('showProductMenu'));

                if (isCloud && showProductMenu) {
                    this.children.productMenu = new ProductMenu({
                        model: this.model,
                        collection: this.collection
                    });
                    this.$('.product').replaceWith(this.children.productMenu.el);
                } else {
                    this.$('.product').remove();
                }
            }.bind(this));

            return this;
        }
    },
    {
        createWithAppNavUrl: function(options) {
            var self = this;
            var app = 'search';
            var owner = options.model.application.get('owner');
            var applicationDfd = new $.Deferred();

            if (app && owner) {
                applicationDfd.resolve(app, owner);
            } else {
                options.model.application.once('change', function() {
                    var app = 'search';
                    var owner = options.model.application.get('owner');
                    if (app && owner) {
                        applicationDfd.resolve(app, owner);
                    }
                });
            }

            applicationDfd.done(function() {
                var url = route.appNavUrl(options.model.application.get('root'), options.model.application.get('locale'), 'search');
                $.ajax({
                    url: url,
                    dataType:'json'
                }).done(function(data) {
                        self._applyAppNavData(data, options.model.appNav, options, false);
                    }).fail(function() {
                        self.createWithBackbone(options);
                    });
            });
        },
        createWithAppNavModel: function(options) {
            var appNav = options.model.appNav;
            this._applyAppNavData(appNav.entry.content.toJSON(), appNav, options, false);
        },
        createWithBackbone: function(options) {
            var self = this;
            var applicationDfd = $.Deferred();
            var appNavDfd = $.Deferred();
            var viewsDfd = $.Deferred();
            var savedSearchesDfd = $.Deferred();
            function updateNavData() {
                var data = appNavParser.parseNavModel(
                    options.model.splunkDappNav,
                    options.collection.views,
                    options.collection.savedSearches,
                    options.model.application.get('root')
                );
                var appLabel;
                if (data.appLabel) {
                    appLabel = data.appLabel;
                } else if (options.model.app && options.model.app.entry && options.model.app.entry.content && options.model.app.entry.content.get('label')) {
                    appLabel = options.model.app.entry.content.get('label') || '';
                }
                self._applyAppNavData({
                    nav: data.nav,
                    color: data.color,
                    label: appLabel,
                    defaultView: data.defaultView,
                    searchView: data.searchView
                }, options.model.appNav, options, false);
            }

            var app = 'search';
            var owner = options.model.application.get('owner');
            if (app && owner) {
                applicationDfd.resolve(app, owner);
            } else {
                options.model.application.once('change', function() {
                    var app = options.model.application.get('app');
                    var owner = options.model.application.get('owner');
                    if (app && owner) {
                        applicationDfd.resolve(app, owner);
                    }
                });
            }

            if (!options.model.app) {
                options.model.app = new AppModel();
                applicationDfd.done(function(app, owner) {
                    options.model.app.set({id: 'apps/local/' + app});
                    options.model.app.fetch({data: {app: app, owner: owner}});
                });
            }

            if (!options.collection.views) {
                options.collection.views = new ViewsCollection();
                applicationDfd.done(function(app, owner) {
                    options.collection.views.fetch({data: {app: app, owner: owner, count: -1, digest: 1}});
                });
            }

            if (!options.collection.savedSearches) {
                options.collection.savedSearches = new SavedSearchesCollection();
                applicationDfd.done(function(app, owner) {
                    options.collection.savedSearches.fetch({data: {app: app, owner: '-', search: 'is_visible=1 AND disabled=0', count: -1}}); //TODO: _with_new=1?
                });
            }

            if (!options.model.splunkDappNav) {
                options.model.splunkDappNav = new NavModel();
                applicationDfd.done(function(app, owner) {
                    options.model.splunkDappNav.fetch({data: {app: app, owner: owner}});
                });
            }

            options.collection.views.once('reset', viewsDfd.resolve);
            options.collection.savedSearches.once('reset', savedSearchesDfd.resolve);
            options.model.splunkDappNav.once('sync', appNavDfd.resolve);

            $.when(viewsDfd, savedSearchesDfd, appNavDfd).then(updateNavData);
        },
        _applyAppNavData: function(data, appNav, options, fromCache) {
            var app = options.model.application;
            var appLink = route.page(app.get('root'), app.get('locale') || '', 'search');
            var appLogo = route.appLogo(app.get('root'), app.get('locale') || '', app.get('owner'), 'search');

            if (console.DEBUG_ENABLED) {
                if (this._lastApply) {
                    console.debug('Applying app nav data %o after %o ms', data, new Date().getTime() - this._lastApply);
                } else {
                    this._lastApply = new Date().getTime();
                    console.debug('Applying app nav data: %o', data);
                }
            }
            appNav.set({
                nav: data.nav,
                color: data.color,
                label: data.label,
                logo: appLogo,
                link: appLink,
                defaultView: data.defaultView,
                searchView: data.searchView
            });

            if (!fromCache) {
                this._cacheValue(data, options);
            }
        },
        _supportsSessionStorage: function() {
            return 'sessionStorage' in window && window.sessionStorage;
        },
        _cachePrefix: 'splunk-appnav',
        _cacheKey: function(app) {
            return [this._cachePrefix, app.get('app'), app.get('owner'), app.get('locale')].join(':');
        },
        _cacheValue: function(data, options) {
            if (this._supportsSessionStorage()) {
                data = _(data).pick('nav', 'color', 'label', 'defaultView', 'searchView');
                console.debug('Caching app nav data: %o', data);
                try {
                    window.sessionStorage.setItem(this._cacheKey(options.model.application), JSON.stringify(data));
                } catch (e) {
                    console.warn('Update to store app nav data in sessionStorage: ', e);
                }
            }
        },
        _createFromCache: function(options) {
            if (this._supportsSessionStorage()) {
                try {
                    var cacheKey = this._cacheKey(options.model.application);
                    var cachedData = JSON.parse(window.sessionStorage.getItem(cacheKey));
                    if (cachedData) {
                        console.debug('Applying cached app nav data: %o', cachedData);
                        var appNav = new Backbone.Model();
                        this._applyAppNavData(cachedData, appNav, options, true);
                        options.model.appNav = appNav;
                        _.delay(_.bind(this._loadDefault, this, options), 1000);
                        return;
                    }
                } catch (e) {
                    console.warn('Unable load cached app nav data: ', e);
                }
            }
            this._createDefault(options);
        },
        _loadDefault: function(options) {
            if (options.appServerUrl) {
                this.createWithAppNavUrl(options);
            } else {
                this.createWithBackbone(options);
            }
        },
        _createDefault: function(options) {
            if (options.model.appNav) {
                this.createWithAppNavModel(options);
            } else {
                options.model.appNav = new Backbone.Model();
                this._loadDefault(options);
            }
        },
        create: function(options) {
            options = options || {};
            options.collection = options.collection || {};
            options.model = options.model || {};
            if (options.useSessionStorageCache === true) {
                this._createFromCache(options);
            } else {
                this._createDefault(options);
            }

            if (!options.model.userPref) {
                options.model.userPref = new UserPref();
                var userPrefDfd = options.model.userPref.fetch({data: {app:'user-prefs', owner: options.model.application.get('owner'), count:-1}});
                $.when(userPrefDfd).then(function() {
                    options.model.userPref.entry.content.trigger('ready');
                });
            }

            var applicationDfd = $.Deferred();
            if(!options.model.appLocal) {
                options.model.appLocal = new AppModel();
                applicationDfd.done(function() {
                    if (options.model.application.get("app") !== 'system') {
                        options.model.appLocal.fetch({
                            url: splunkDUtils.fullpath(options.model.appLocal.url + "/" + encodeURIComponent('search')),
                            data: {
                                app: 'search',
                                owner: options.model.application.get("owner")
                            }
                        });
                    }
                });
            }

            if (!options.collection.apps) {
                options.collection.apps = new AppsCollection();
                options.collection.apps.fetch({
                    data: {
                        sort_key: 'name',
                        sort_dir: 'desc',
                        app: '-' ,
                        owner: options.model.application.get('owner'),
                        search: 'visible=true AND disabled=0 AND name!=launcher',
                        count:-1
                    }
                });
            }

            options.model.webConf = new WebConfModel({id: 'settings'});
            options.model.webConf.fetch({
                success: function() {
                    options.model.webConf.trigger('ready');
                }
            });
            
            return new View(options);
        }
    });
    return View;
});


define('contrib/text!views/shared/appbar/Master.html',[],function () { return '<h2 class="app-name pull-right"></h2>\n<div class="nav"></div>\n';});

define('views/shared/appbar/Master',[
    'jquery',
    'underscore',
    'backbone',
    'module',
    'views/Base',
    'views/shared/appbar/AppNav',
    'views/shared/appbar/AppLabel',
    'models/shared/Application',
    'models/services/data/ui/Nav',
    'models/services/AppLocal',
    'collections/services/data/ui/Views',
    'collections/services/saved/Searches',
    'contrib/text!views/shared/appbar/Master.html',
    'helpers/AppNav',
    'uri/route',
    'util/color_utils',
        'util/console',
        'util/xml'
],
function(
    $,
    _,
    Backbone,
    module,
    BaseView,
    AppNavView,
    AppLabelView,
    ApplicationModel,
    NavModel,
    AppModel,
    ViewsCollection,
    SavedSearchesCollection,
    templateMaster,
    appNavParser,
    route,
    color_utils,
    console,
    XML
) {
    var View = BaseView.extend({
        moduleId: module.id,
        className: 'app-bar',
        initialize: function(options) {
            BaseView.prototype.initialize.apply(this, arguments);

            this.children.appNav = new AppNavView({
                model: {
                    user: this.model.user,
                    serverInfo: this.model.serverInfo,
                    appNav: this.model.appNav,
                    application: this.model.application
                },
                collection: this.collection
            });

            this.children.appLabel = new AppLabelView({
                model: this.model,
                collection: this.collection
            });

            this.setBannerColor();
            this.model.appNav.on('change:color', this.setBannerColor, this);

            if(options.autoRender !== false) {
                this.debouncedRender();
            }
        },
        render: function() {
            var html = _.template(templateMaster);
            this.$el.html(html);
            this.$el.find('.nav').html(this.children.appNav.render().el);
            this.$el.find('.app-name').html(this.children.appLabel.render().el);

            return this;
        },
        setBannerColor: function(){
            if(!this.model.appNav){return false;}

            var navColor = color_utils.normalizeHexString(this.model.appNav.get('color')||'');
            var isHexColor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(navColor);
            if (!isHexColor ){
                return false;
            }
            this.$el.css('background-color', navColor);
        }
    },
    {
        END_GRADIENT_LUMINOSITY: 0.90,
        createWithAppNavUrl: function(options){
            var self = this;
            var app = options.model.application.get('app');
            var owner = options.model.application.get('owner');
            var applicationDfd = new $.Deferred();

            if (app && owner) {
                applicationDfd.resolve(app, owner);
            } else {
                options.model.application.once('change', function() {
                    var app = options.model.application.get('app');
                    var owner = options.model.application.get('owner');
                    if (app && owner) {
                        applicationDfd.resolve(app, owner);
                    }
                });
            }

            applicationDfd.done(function(){
                var url = route.appNavUrl(options.model.application.get('root'), options.model.application.get('locale'), options.model.application.get('app'));
                $.ajax({
                    url: url,
                    dataType:'json'
                }).done(function(data){
                        self._applyAppNavData(data, options.model.appNav, options, false);
                    }).fail(function() {
                        self.createWithBackbone(options);
                    });
            });
        },
        createWithAppNavModel: function(options) {
            var appNav = options.model.appNav;
            this._applyAppNavData(appNav.entry.content.toJSON(), appNav, options, false);
        },
        createWithBackbone: function(options){
            var self = this;
            var applicationDfd = $.Deferred();
            var appNavDfd = $.Deferred();
            var viewsDfd = $.Deferred();
            var savedSearchesDfd = $.Deferred();
            var appDfd = $.Deferred();
            function updateNavData() {
                var data = appNavParser.parseNavModel(
                    options.model.splunkDappNav,
                    options.collection.views,
                    options.collection.savedSearches,
                    options.model.application.get('root')
                );
                var appLabel;
                if (data.appLabel) {
                    appLabel = data.appLabel;
                } else if (options.model.app && options.model.app.entry && options.model.app.entry.content && options.model.app.entry.content.get('label')) {
                    appLabel = options.model.app.entry.content.get('label') || '';
                }
                self._applyAppNavData({
                    nav: data.nav,
                    color: data.color,
                    label: appLabel,
                    defaultView: data.defaultView,
                    searchView: data.searchView
                }, options.model.appNav, options, false);
            }

            var app = options.model.application.get('app');
            var owner = options.model.application.get('owner');
            if (app && owner) {
                applicationDfd.resolve(app, owner);
            } else {
                options.model.application.once('change', function() {
                    var app = options.model.application.get('app');
                    var owner = options.model.application.get('owner');
                    if (app && owner) {
                        applicationDfd.resolve(app, owner);
                    }
                });
            }

            if (!options.model.app) {
                options.model.app = new AppModel();
                applicationDfd.done(function(app, owner) {
                    options.model.app.set({id: 'apps/local/' + app});
                    options.model.app.fetch({data: {app: app, owner: owner}});
                });
            }

            if (!options.collection.views) {
                options.collection.views = new ViewsCollection();
                applicationDfd.done(function(app, owner) {
                    options.collection.views.fetch({data: {app: app, owner: owner, count: -1, digest: 1}});
                });
            }

            if (!options.collection.savedSearches) {
                options.collection.savedSearches = new SavedSearchesCollection();
                applicationDfd.done(function(app, owner) {
                    appNavDfd.then(function() {
                        var xml = this.entry.content.get('eai:data');
                        // Only fetch the savedsearhes collection if we're referencing saved searches in the nav
                        if (XML.parse(xml).find('saved[match],saved[source]').length > 0) {
                            options.collection.savedSearches.fetch({
                                data: {
                                    app: app,
                                    owner: '-',
                                    search: 'is_visible=1 AND disabled=0',
                                    count: 500 // Limited to 500 saved searches to match appserver behavior
                                }
                            });
                        } else {
                            savedSearchesDfd.resolve();
                        }
                    });
                });
            }

            if (!options.model.splunkDappNav) {
                options.model.splunkDappNav = new NavModel();
                applicationDfd.done(function(app, owner) {
                    options.model.splunkDappNav.fetch({data: {app: app, owner: owner}});
                });
            }

            options.collection.views.once('reset', viewsDfd.resolve);
            options.collection.savedSearches.once('reset', savedSearchesDfd.resolve);
            options.model.splunkDappNav.once('sync', appNavDfd.resolve);
            options.model.app.once('sync', appDfd.resolve);

            $.when(viewsDfd, savedSearchesDfd, appNavDfd).then(updateNavData);
        },
        _applyAppNavData: function(data, appNav, options, fromCache) {
            var app = options.model.application;
            var appLink = route.page(app.get('root'), app.get('locale') || '', app.get('app'));
            var appIcon = route.appIcon(app.get('root'), app.get('locale') || '', app.get('owner'), app.get('app'));
            var appLogo = route.appLogo(app.get('root'), app.get('locale') || '', app.get('owner'), app.get('app'));

            if (console.DEBUG_ENABLED) {
                if (this._lastApply) {
                    console.debug('Applying app nav data %o after %o ms', data, new Date().getTime() - this._lastApply);
                } else {
                    this._lastApply = new Date().getTime();
                    console.debug('Applying app nav data: %o', data);
                }
            }
            appNav.set({
                nav: data.nav,
                color: data.color,
                label: data.label,
                icon: appIcon,
                logo: appLogo,
                link: appLink,
                defaultView: data.defaultView,
                searchView: data.searchView
            });

            if (!fromCache) {
                this._cacheValue(data, options);
            }
        },
        _supportsSessionStorage: function() {
            return 'sessionStorage' in window && window.sessionStorage;
        },
        _cachePrefix: 'splunk-appnav',
        _cacheKey: function(app) {
            return [this._cachePrefix, app.get('app'), app.get('owner'), app.get('locale')].join(':');
        },
        _cacheValue: function(data, options) {
            if (this._supportsSessionStorage()) {
                data = _(data).pick('nav', 'color', 'label', 'defaultView', 'searchView');
                console.debug('Caching app nav data: %o', data);
                try {
                    window.sessionStorage.setItem(this._cacheKey(options.model.application), JSON.stringify(data));
                } catch (e) {
                    console.warn('Update to store app nav data in sessionStorage: ', e);
                }
            }
        },
        _createFromCache: function(options) {
            if (this._supportsSessionStorage()) {
                try {
                    var cacheKey = this._cacheKey(options.model.application);
                    var cachedData = JSON.parse(window.sessionStorage.getItem(cacheKey));
                    if (cachedData) {
                        console.debug('Applying cached app nav data: %o', cachedData);
                        var appNav = new Backbone.Model();
                        this._applyAppNavData(cachedData, appNav, options, true);
                        options.model.appNav = appNav;
                        _.delay(_.bind(this._loadDefault, this, options), 1000);
                        return;
                    }
                } catch (e) {
                    console.warn('Unable load cached app nav data: ', e);
                }
            }
            this._createDefault(options);
        },
        _loadDefault: function(options){
            if (options.appServerUrl) {
                this.createWithAppNavUrl(options);
            } else {
                this.createWithBackbone(options);
            }
        },
        _createDefault: function(options) {
            if (options.model.appNav) {
                this.createWithAppNavModel(options);
            } else {
                options.model.appNav = new Backbone.Model();
                this._loadDefault(options);
            }
        },
        create: function(options) {
            options = options || {};
            options.collection = options.collection || {};
            options.model = options.model || {};
            if (options.useSessionStorageCache === true) {
                this._createFromCache(options);
            } else {
                this._createDefault(options);
            }
            return new View(options);
        }
    });
    return View;
});


define('contrib/text!views/shared/footer/Master.html',[],function () { return '<ul class="nav nav-footer">\n    <li><a href="#" id="about"><%= _(\'About\').t() %></a></li>\n    <li><a href="http://www.splunk.com/r/support" target="_blank"><%= _(\'Support\').t() %></a></li>\n    <li><a href="http://www.splunk.com/r/bugs" target="_blank"><%= _(\'File a Bug\').t() %></a></li>\n    <li><a href="<%- makeDocLink(currentPageDocLocation) %>" target="_blank"><%- _("Documentation").t() %></a></li>\n    <li><a href="http://www.splunk.com/r/privacy" target="_blank"><%= _(\'Privacy Policy\').t() %></a></li>\n</ul>\n<p class="copyright">&copy; 2005-<%=new Date().getFullYear()%> <%= _(\'Splunk Inc. All rights reserved.\').t() %></p>\n';});

define('views/shared/footer/Master',[
    'jquery',
    'module',
    'views/Base',
    'views/shared/AboutDialog',
    'models/services/server/ServerInfo',
    'models/shared/Application',
    'models/services/AppLocal',
    'collections/services/AppLocals',
    'contrib/text!views/shared/footer/Master.html',
    'uri/route',
    'util/splunkd_utils'
],
    function(
        $,
        module,
        BaseView,
        AboutDialogView,
        ServerInfoModel,
        ApplicationModel,
        AppLocalModel,
        AppsCollection,
        footerTemplate,
        route,
        splunkDUtils
        ){
        var View = BaseView.extend({
                moduleId: module.id,
                className: 'splunkified',
                template: footerTemplate,
                initialize: function() {
                    BaseView.prototype.initialize.apply(this, arguments);

                    // can only render once we have application and appLocal ready
                    var applicationModelDeferred = $.Deferred();
                    var appLocalModelDeferred = $.Deferred();

                    if (this.options.model.application.get('app')) {
                        applicationModelDeferred.resolve();
                    } else {
                        this.options.model.application.on('change reset', applicationModelDeferred.resolve);
                    }     

                    if (this.options.model.appLocal.entry.content.get('version')) {
                        appLocalModelDeferred.resolve();
                    } else {
                        this.options.model.appLocal.on('change reset', appLocalModelDeferred.resolve);
                    }
                    
                    $.when(applicationModelDeferred, appLocalModelDeferred).done(this.render.bind(this));
                },
                events: {
                    'click a[id=about]': function(e) {
                        this.children.aboutDialog = new AboutDialogView({
                            collection: this.options.collection.apps,
                            model: {
                                applicationModel: this.options.model.application,
                                appLocal: this.options.model.appLocal,
                                serverInfo: this.options.model.serverInfo
                            },
                            onHiddenRemove: true
                        });
                        //for compatibility with the module system, this needs to be wrapped in an extra div.
                        this.modalWrapper = $('<div class="splunk-components">').appendTo("body").append(this.children.aboutDialog.render().el);
                        this.children.aboutDialog.once('hidden', function() {
                            this.modalWrapper.remove();
                            // SPL-76438: set focus when the modal is closed.
                            $(e.currentTarget).focus();
                        }, this);
                        
                        this.children.aboutDialog.show();
                        e.preventDefault();
                    }
                },
                makeDocLink: function(location) {
                    return route.docHelpInAppContext(
                        this.model.application.get("root"),
                        this.model.application.get("locale"),
                        location,
                        this.model.application.get("app"),
                        this.model.appLocal.entry.content.get('version'),
                        this.model.appLocal.appAllowsDisable(),
                        this.model.appLocal.entry.content.get('docs_section_override')
                    );
                },
                render: function() {
                    // location is in form: app.<app_name>.<page_name>
                    var currentPageDocLocation = [
                            'app',
                            this.model.application.get('app'),
                            this.model.application.get('page')
                        ].join(".");
                    var html = this.compiledTemplate({
                        makeDocLink: this.makeDocLink.bind(this),
                        currentPageDocLocation: currentPageDocLocation
                    });
                    this.$el.html(html);
                    return this;
                }
            },
            {
                create: function(options){
                    options = options || {};
                    options.model = options.model || {};
                    options.collection = options.collection || {};
                    if (!options.model.serverInfo) {
                        options.model.serverInfo = new ServerInfoModel();
                        options.model.serverInfo.fetch();
                    }
                    var applicationDfd = $.Deferred();
                    if(!options.model.application){
                        options.model.application = new ApplicationModel();
                    }
                    
                    if (options.model.application.get('app')) {
                        applicationDfd.resolve();
                    } else {
                        options.model.application.on('change', applicationDfd.resolve);
                    }

                    if(!options.model.appLocal) {
                        options.model.appLocal = new AppLocalModel();
                        applicationDfd.done(function() {
                            if (options.model.application.get("app") !== 'system') {
                                options.model.appLocal.fetch({
                                    url: splunkDUtils.fullpath(options.model.appLocal.url + "/" + encodeURIComponent(options.model.application.get("app"))),
                                    data: {
                                        app: options.model.application.get("app"),
                                        owner: options.model.application.get("owner")
                                    }
                                });
                            }
                        });
                    }

                    if (!options.collection.apps) {
                        options.collection.apps = new AppsCollection();
                        options.collection.apps.fetch({
                            data: {
                                sort_key: 'name',
                                sort_dir: 'desc',
                                app: '-' ,
                                owner: options.model.application.get('owner'),
                                search: 'visible=true AND disabled=0 AND name!=launcher',
                                count:-1
                            }
                        });
                    }

                    return new View(options);
                }
            });
        return View;
    });


define('contrib/text!views/shared/tour/TourBar.html',[],function () { return '<div class="tourbar"\n    <% if (fixedHeight) { %>\n        style="position: absolute; min-height: <%= fixedHeight %>px; max-height: <%= fixedHeight %>px; width: 100%; z-index: 15;"\n    <% } %>\n>\n    <div class="previous-container">\n        <% if (previousLink) { %>\n            <a class="previous btn" href="<%= previousLink %>"><i class="icon-chevron-left"></i></a>\n        <% } %>\n    </div>\n    <div class="close-container">\n        <a href="<%- exitLink %>" class="btn close-btn"><%= _("Exit").t() %></a>\n        \n    </div>\n    <div class="next-container">\n        <% if (nextLink) { %>\n            <a class="next btn" href="<%= nextLink %>"><i class="icon-chevron-right"></i></a>\n        <% } %>\n    </div>\n    <div class="info-container"\n        <% if (fixedHeight) { %>\n            style="min-height: <%= fixedHeight - 20 %>px;"\n        <% } %>\n    >\n        <span class="info">\n            <%= info %>\n        </span>\n    </div>\n</div>\n';});

define(
    'views/shared/tour/TourBar',[
        'jquery',
        'underscore',
        'module',
        'backbone',
        'splunk.util',
        'views/Base',
        'contrib/text!views/shared/tour/TourBar.html'
    ],
    function(
        $,
        _,
        module,
        Backbone,
        splunk_util,
        BaseView,
        template
    ) {
    
        return BaseView.extend({
            template: template,
            moduleId: module.id,
            initialize: function(options) {
                BaseView.prototype.initialize.call(this, options);
                this.fixedHeight = this.options.fixedHeight || 0;
            },

            events: {
                "click .next"       : "handleNext",
                "click .previous"   : "handlePrevious"
            },

            setFixedHeight: function(height) {
                this.fixedHeight = height;
            },

            removeHighlight: function() {
                // if an element is currently highlighted, remove that highlight
                if (this._currentHighlightedSelector) {
                    var currentElement = $(this._currentHighlightedSelector);
                    currentElement.removeClass('tour-highlight');
                    this._currentHighlightedSelector = undefined;
                }
                this._highlightSelector = undefined;
            },

            highlightElement: function(selector) {
                if (selector) {
                    this._highlightSelector = selector;
                }
    
                if (this._highlightSelector) {
                    var element = $(this._highlightSelector);
                    if (!element.hasClass('tour-highlight')) {
                        if (element) {
                            element.addClass('tour-highlight');
                            this._currentHighlightedSelector = this._highlightSelector;
                        } 

                        setTimeout(function() {
                            this.highlightElement(); 
                        }.bind(this), 250);
                    }
                }
            },

            handleNext: function(e) {
                // TODO - add functionality to not reload page
            },

            handlePrevious: function(e) {
                // TODO - add functionality to not reload page
            },

            render: function() {
                this.removeHighlight();

                var selector = this.model.tour.entry.content.get("highlightSelector");
                if (selector) {
                    this.highlightElement(selector);
                }

                var info = this.model.tour.getInfo(),
                    nextLink = this.model.tour.getNextLink(),
                    previousLink = this.model.tour.getPreviousLink(),
                    exitLink = this.model.tour.getExitLink(),
                    html = this.compiledTemplate({
                        previousLink: previousLink,
                        nextLink: nextLink,
                        exitLink: exitLink,
                        info: _(info).t(),
                        fixedHeight: this.fixedHeight
                    });

                this.$el.html(html);

                return this;
            }
        });
    }
);


/**
 * Intro.js v1.0.0
 * https://github.com/usablica/intro.js
 * MIT licensed
 *
 * Copyright (C) 2013 usabli.ca - A weekend project by Afshin Mehrabani (@afshinmeh)
 */

(function (root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports);
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('intro',['exports'], factory);
  } else {
    // Browser globals
    factory(root);
  }
} (this, function (exports) {
  //Default config/variables
  var VERSION = '1.0.0';

  /**
   * IntroJs main class
   *
   * @class IntroJs
   */
  function IntroJs(obj) {
    this._targetElement = obj;

    this._options = {
      /* Next button label in tooltip box */
      nextLabel: 'Next &rarr;',
      /* Previous button label in tooltip box */
      prevLabel: '&larr; Back',
      /* Skip button label in tooltip box */
      skipLabel: 'Skip',
      /* Done button label in tooltip box */
      doneLabel: 'Done',
      /* If tour has another linked tour */
      nextTourLabel: '',
      /* Default tooltip box position */
      tooltipPosition: 'bottom',
      /* Next CSS class for tooltip boxes */
      tooltipClass: '',
      /* CSS class that is added to the helperLayer */
      highlightClass: '',
      /* Close introduction when pressing Escape button? */
      exitOnEsc: true,
      /* Close introduction when clicking on overlay layer? */
      exitOnOverlayClick: true,
      /* Show step numbers in introduction? */
      showStepNumbers: true,
      /* Let user use keyboard to navigate the tour? */
      keyboardNavigation: true,
      /* Show tour control buttons? */
      showButtons: true,
      /* Show tour bullets? */
      showBullets: true,
      /* Show tour progress? */
      showProgress: false,
      /* Scroll to highlighted element? */
      scrollToElement: true,
      /* Set the overlay opacity */
      overlayOpacity: 0.8,
      /* Precedence of positions, when auto is enabled */
      positionPrecedence: ["bottom", "top", "right", "left"],
      /* Disable an interaction with element? */
      disableInteraction: false
    };
  }

  /**
   * Initiate a new introduction/guide from an element in the page
   *
   * @api private
   * @method _introForElement
   * @param {Object} targetElm
   * @returns {Boolean} Success or not?
   */
  function _introForElement(targetElm) {
    var introItems = [],
        self = this;

    if (this._options.steps) {
      //use steps passed programmatically
      var allIntroSteps = [];

      for (var i = 0, stepsLength = this._options.steps.length; i < stepsLength; i++) {
        var currentItem = _cloneObject(this._options.steps[i]);
        //set the step
        currentItem.step = introItems.length + 1;
        //use querySelector function only when developer used CSS selector
        if (typeof(currentItem.element) === 'string') {
          //grab the element with given selector from the page
          currentItem.element = document.querySelector(currentItem.element);
        }

        //intro without element
        if (typeof(currentItem.element) === 'undefined' || currentItem.element == null) {
          var floatingElementQuery = document.querySelector(".introjsFloatingElement");
          if (floatingElementQuery == null) {
            floatingElementQuery = document.createElement('div');
            floatingElementQuery.className = 'introjsFloatingElement';

            document.body.appendChild(floatingElementQuery);
          }

          currentItem.element  = floatingElementQuery;
          currentItem.position = 'floating';
        }

        if (currentItem.element != null) {
          introItems.push(currentItem);
        }
      }

    } else {
      //use steps from data-* annotations
      var allIntroSteps = targetElm.querySelectorAll('*[data-intro]');
      //if there's no element to intro
      if (allIntroSteps.length < 1) {
        return false;
      }

      //first add intro items with data-step
      for (var i = 0, elmsLength = allIntroSteps.length; i < elmsLength; i++) {
        var currentElement = allIntroSteps[i];
        var step = parseInt(currentElement.getAttribute('data-step'), 10);

        if (step > 0) {
          introItems[step - 1] = {
            element: currentElement,
            intro: currentElement.getAttribute('data-intro'),
            step: parseInt(currentElement.getAttribute('data-step'), 10),
            tooltipClass: currentElement.getAttribute('data-tooltipClass'),
            highlightClass: currentElement.getAttribute('data-highlightClass'),
            position: currentElement.getAttribute('data-position') || this._options.tooltipPosition
          };
        }
      }

      //next add intro items without data-step
      //todo: we need a cleanup here, two loops are redundant
      var nextStep = 0;
      for (var i = 0, elmsLength = allIntroSteps.length; i < elmsLength; i++) {
        var currentElement = allIntroSteps[i];

        if (currentElement.getAttribute('data-step') == null) {

          while (true) {
            if (typeof introItems[nextStep] == 'undefined') {
              break;
            } else {
              nextStep++;
            }
          }

          introItems[nextStep] = {
            element: currentElement,
            intro: currentElement.getAttribute('data-intro'),
            step: nextStep + 1,
            tooltipClass: currentElement.getAttribute('data-tooltipClass'),
            highlightClass: currentElement.getAttribute('data-highlightClass'),
            position: currentElement.getAttribute('data-position') || this._options.tooltipPosition
          };
        }
      }
    }

    //removing undefined/null elements
    var tempIntroItems = [];
    for (var z = 0; z < introItems.length; z++) {
      introItems[z] && tempIntroItems.push(introItems[z]);  // copy non-empty values to the end of the array
    }

    introItems = tempIntroItems;

    //Ok, sort all items with given steps
    introItems.sort(function (a, b) {
      return a.step - b.step;
    });

    //set it to the introJs object
    self._introItems = introItems;

    //add overlay layer to the page
    if(_addOverlayLayer.call(self, targetElm)) {
      //then, start the show
      _nextStep.call(self);

      var skipButton     = targetElm.querySelector('.introjs-skipbutton'),
          nextStepButton = targetElm.querySelector('.introjs-nextbutton');

      self._onKeyDown = function(e) {
        if (e.keyCode === 27 && self._options.exitOnEsc == true) {
          //escape key pressed, exit the intro
          _exitIntro.call(self, targetElm);
          //check if any callback is defined
          if (self._introExitCallback != undefined) {
            self._introExitCallback.call(self);
          }
        } else if(e.keyCode === 37) {
          //left arrow
          _previousStep.call(self);
        } else if (e.keyCode === 39) {
          //right arrow
          _nextStep.call(self);
        } else if (e.keyCode === 13) {
          //srcElement === ie
          var target = e.target || e.srcElement;
          if (target && target.className.indexOf('introjs-prevbutton') > 0) {
            //user hit enter while focusing on previous button
            _previousStep.call(self);
          } else if (target && target.className.indexOf('introjs-skipbutton') > 0) {
            //user hit enter while focusing on skip button
            _exitIntro.call(self, targetElm);
          } else {
            //default behavior for responding to enter
            _nextStep.call(self);
          }

          //prevent default behaviour on hitting Enter, to prevent steps being skipped in some browsers
          if(e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }
      };

      self._onResize = function(e) {
        _setHelperLayerPosition.call(self, document.querySelector('.introjs-helperLayer'));
        _setHelperLayerPosition.call(self, document.querySelector('.introjs-tooltipReferenceLayer'));
      };

      if (window.addEventListener) {
        if (this._options.keyboardNavigation) {
          window.addEventListener('keydown', self._onKeyDown, true);
        }
        //for window resize
        window.addEventListener('resize', self._onResize, true);
      } else if (document.attachEvent) { //IE
        if (this._options.keyboardNavigation) {
          document.attachEvent('onkeydown', self._onKeyDown);
        }
        //for window resize
        document.attachEvent('onresize', self._onResize);
      }
    }
    return false;
  }

 /*
   * makes a copy of the object
   * @api private
   * @method _cloneObject
  */
  function _cloneObject(object) {
      if (object == null || typeof (object) != 'object' || typeof (object.nodeType) != 'undefined') {
          return object;
      }
      var temp = {};
      for (var key in object) {
          temp[key] = _cloneObject(object[key]);
      }
      return temp;
  }
  /**
   * Go to specific step of introduction
   *
   * @api private
   * @method _goToStep
   */
  function _goToStep(step) {
    //because steps starts with zero
    this._currentStep = step - 2;
    if (typeof (this._introItems) !== 'undefined') {
      _nextStep.call(this);
    }
  }

  /**
   * Go to next step on intro
   *
   * @api private
   * @method _nextStep
   */
  function _nextStep() {
    this._direction = 'forward';

    if (typeof (this._currentStep) === 'undefined') {
      this._currentStep = 0;
    } else {
      ++this._currentStep;
    }

    if ((this._introItems.length) <= this._currentStep) {
      //end of the intro
      //check if any callback is defined
      if (this._options.nextTourURL) {
        window.location = this._options.nextTourURL;
      }
      if (typeof (this._introCompleteCallback) === 'function') {
        this._introCompleteCallback.call(this);
      }
      // _exitIntro.call(this, this._targetElement);
      --this._currentStep;
      return;
    }

    var nextStep = this._introItems[this._currentStep];
    if (typeof (this._introBeforeChangeCallback) !== 'undefined') {
      this._introBeforeChangeCallback.call(this, nextStep.element);
    }

    _showElement.call(this, nextStep);
  }

  /**
   * Go to previous step on intro
   *
   * @api private
   * @method _nextStep
   */
  function _previousStep() {
    this._direction = 'backward';

    if (this._currentStep === 0) {
      return false;
    }

    var nextStep = this._introItems[--this._currentStep];
    if (typeof (this._introBeforeChangeCallback) !== 'undefined') {
      this._introBeforeChangeCallback.call(this, nextStep.element);
    }

    _showElement.call(this, nextStep);
  }

  /**
   * Exit from intro
   *
   * @api private
   * @method _exitIntro
   * @param {Object} targetElement
   */
  function _exitIntro(targetElement) {
    //remove overlay layer from the page
    var overlayLayer = targetElement.querySelector('.introjs-overlay');

    //return if intro already completed or skipped
    if (overlayLayer == null) {
      return;
    }

    //for fade-out animation
    overlayLayer.style.opacity = 0;
    setTimeout(function () {
      if (overlayLayer.parentNode) {
        overlayLayer.parentNode.removeChild(overlayLayer);
      }
    }, 10);

    //remove all helper layers
    var helperLayer = targetElement.querySelector('.introjs-helperLayer');
    if (helperLayer) {
      helperLayer.parentNode.removeChild(helperLayer);
    }

    var referenceLayer = targetElement.querySelector('.introjs-tooltipReferenceLayer');
    if (referenceLayer) {
      referenceLayer.parentNode.removeChild(referenceLayer);
	}
    //remove disableInteractionLayer
    var disableInteractionLayer = targetElement.querySelector('.introjs-disableInteraction');
    if (disableInteractionLayer) {
      disableInteractionLayer.parentNode.removeChild(disableInteractionLayer);
    }

    //remove intro floating element
    var floatingElement = document.querySelector('.introjsFloatingElement');
    if (floatingElement) {
      floatingElement.parentNode.removeChild(floatingElement);
    }

    //remove `introjs-showElement` class from the element
    var showElement = document.querySelector('.introjs-showElement');
    if (showElement) {
      showElement.className = showElement.className.replace(/introjs-[a-zA-Z]+/g, '').replace(/^\s+|\s+$/g, ''); // This is a manual trim.
    }

    //remove `introjs-fixParent` class from the elements
    var fixParents = document.querySelectorAll('.introjs-fixParent');
    if (fixParents && fixParents.length > 0) {
      for (var i = fixParents.length - 1; i >= 0; i--) {
        fixParents[i].className = fixParents[i].className.replace(/introjs-fixParent/g, '').replace(/^\s+|\s+$/g, '');
      };
    }

    //clean listeners
    if (window.removeEventListener) {
      window.removeEventListener('keydown', this._onKeyDown, true);
    } else if (document.detachEvent) { //IE
      document.detachEvent('onkeydown', this._onKeyDown);
    }

    //set the step to zero
    this._currentStep = undefined;
  }

  /**
   * Render tooltip box in the page
   *
   * @api private
   * @method _placeTooltip
   * @param {Object} targetElement
   * @param {Object} tooltipLayer
   * @param {Object} arrowLayer
   */
  function _placeTooltip(targetElement, tooltipLayer, arrowLayer, helperNumberLayer) {
    var tooltipCssClass = '',
        currentStepObj,
        tooltipOffset,
        targetElementOffset;

    //reset the old style
    tooltipLayer.style.top        = null;
    tooltipLayer.style.right      = null;
    tooltipLayer.style.bottom     = null;
    tooltipLayer.style.left       = null;
    tooltipLayer.style.marginLeft = null;
    tooltipLayer.style.marginTop  = null;

    arrowLayer.style.display = 'inherit';

    if (typeof(helperNumberLayer) != 'undefined' && helperNumberLayer != null) {
      helperNumberLayer.style.top  = null;
      helperNumberLayer.style.left = null;
    }

    //prevent error when `this._currentStep` is undefined
    if (!this._introItems[this._currentStep]) return;

    //if we have a custom css class for each step
    currentStepObj = this._introItems[this._currentStep];
    if (typeof (currentStepObj.tooltipClass) === 'string') {
      tooltipCssClass = currentStepObj.tooltipClass;
    } else {
      tooltipCssClass = this._options.tooltipClass;
    }

    tooltipLayer.className = ('introjs-tooltip ' + tooltipCssClass).replace(/^\s+|\s+$/g, '');

    //custom css class for tooltip boxes
    var tooltipCssClass = this._options.tooltipClass;

    currentTooltipPosition = this._introItems[this._currentStep].position;
    if ((currentTooltipPosition == "auto" || this._options.tooltipPosition == "auto")) {
      if (currentTooltipPosition != "floating") { // Floating is always valid, no point in calculating
        currentTooltipPosition = _determineAutoPosition.call(this, targetElement, tooltipLayer, currentTooltipPosition)
      }
    }
    var targetOffset = _getOffset(targetElement)
    var tooltipHeight = _getOffset(tooltipLayer).height
    var windowSize = _getWinSize()
    switch (currentTooltipPosition) {
      case 'top':
        tooltipLayer.style.left = '15px';
        tooltipLayer.style.top = '-' + (tooltipHeight + 10) + 'px';
        arrowLayer.className = 'introjs-arrow bottom';
        break;
      case 'right':
        tooltipLayer.style.left = (_getOffset(targetElement).width + 20) + 'px';
        if (targetOffset.top + tooltipHeight > windowSize.height) {
          // In this case, right would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          arrowLayer.className = "introjs-arrow left-bottom";
          tooltipLayer.style.top = "-" + (tooltipHeight - targetOffset.height - 20) + "px"
        }
        arrowLayer.className = 'introjs-arrow left';
        break;
      case 'left':
        if (this._options.showStepNumbers == true) {
          tooltipLayer.style.top = '15px';
        }

        if (targetOffset.top + tooltipHeight > windowSize.height) {
          // In this case, left would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          tooltipLayer.style.top = "-" + (tooltipHeight - targetOffset.height - 20) + "px"
          arrowLayer.className = 'introjs-arrow right-bottom';
        } else {
          arrowLayer.className = 'introjs-arrow right';
        }
        tooltipLayer.style.right = (targetOffset.width + 20) + 'px';


        break;
      case 'floating':
        arrowLayer.style.display = 'none';

        //we have to adjust the top and left of layer manually for intro items without element
        tooltipOffset = _getOffset(tooltipLayer);

        tooltipLayer.style.left   = '50%';
        tooltipLayer.style.top    = '50%';
        tooltipLayer.style.marginLeft = '-' + (tooltipOffset.width / 2)  + 'px';
        tooltipLayer.style.marginTop  = '-' + (tooltipOffset.height / 2) + 'px';

        if (typeof(helperNumberLayer) != 'undefined' && helperNumberLayer != null) {
          helperNumberLayer.style.left = '-' + ((tooltipOffset.width / 2) + 18) + 'px';
          helperNumberLayer.style.top  = '-' + ((tooltipOffset.height / 2) + 18) + 'px';
        }

        break;
      case 'bottom-right-aligned':
        arrowLayer.className      = 'introjs-arrow top-right';
        tooltipLayer.style.right  = '0px';
        tooltipLayer.style.bottom = '-' + (_getOffset(tooltipLayer).height + 10) + 'px';
        break;
      case 'bottom-middle-aligned':
        targetElementOffset = _getOffset(targetElement);
        tooltipOffset       = _getOffset(tooltipLayer);

        arrowLayer.className      = 'introjs-arrow top-middle';
        tooltipLayer.style.left   = (targetElementOffset.width / 2 - tooltipOffset.width / 2) + 'px';
        tooltipLayer.style.bottom = '-' + (tooltipOffset.height + 10) + 'px';
        break;
      case 'bottom-left-aligned':
      // Bottom-left-aligned is the same as the default bottom
      case 'bottom':
      // Bottom going to follow the default behavior
      default:
        tooltipLayer.style.bottom = '-' + (_getOffset(tooltipLayer).height + 10) + 'px';
        tooltipLayer.style.left = (_getOffset(targetElement).width / 2 - _getOffset(tooltipLayer).width / 2) + 'px';

        arrowLayer.className = 'introjs-arrow top';
        break;
    }
  }

  /**
   * Determines the position of the tooltip based on the position precedence and availability
   * of screen space.
   *
   * @param {Object} targetElement
   * @param {Object} tooltipLayer
   * @param {Object} desiredTooltipPosition
   *
   */
  function _determineAutoPosition(targetElement, tooltipLayer, desiredTooltipPosition) {

    // Take a clone of position precedence. These will be the available
    var possiblePositions = this._options.positionPrecedence.slice()

    var windowSize = _getWinSize()
    var tooltipHeight = _getOffset(tooltipLayer).height + 10
    var tooltipWidth = _getOffset(tooltipLayer).width + 20
    var targetOffset = _getOffset(targetElement)

    // If we check all the possible areas, and there are no valid places for the tooltip, the element
    // must take up most of the screen real estate. Show the tooltip floating in the middle of the screen.
    var calculatedPosition = "floating"

    // Check if the width of the tooltip + the starting point would spill off the right side of the screen
    // If no, neither bottom or top are valid
    if (targetOffset.left + tooltipWidth > windowSize.width) { 
      _removeEntry(possiblePositions, "bottom")
      _removeEntry(possiblePositions, "top");
    } else {
      // Check for space below
      if ((targetOffset.height + targetOffset.top + tooltipHeight) > windowSize.height) {
        _removeEntry(possiblePositions, "bottom")
      }

      // Check for space above
      if (targetOffset.top - tooltipHeight < 0) {
        _removeEntry(possiblePositions, "top");
      }
    }

    // Check for space to the right
    if (targetOffset.width + targetOffset.left + tooltipWidth > windowSize.width) {
      _removeEntry(possiblePositions, "right");
    }

    // Check for space to the left
    if (targetOffset.left - tooltipWidth < 0) {
      _removeEntry(possiblePositions, "left");
    }

    // At this point, our array only has positions that are valid. Pick the first one, as it remains in order
    if (possiblePositions.length > 0) {
      calculatedPosition = possiblePositions[0];
    }

    // If the requested position is in the list, replace our calculated choice with that
    if (desiredTooltipPosition && desiredTooltipPosition != "auto") {
      if (possiblePositions.indexOf(desiredTooltipPosition) > -1) {
        calculatedPosition = desiredTooltipPosition
      }
    }

    return calculatedPosition
  }

  /**
   * Remove an entry from a string array if it's there, does nothing if it isn't there.
   *
   * @param {Array} stringArray
   * @param {String} stringToRemove
   */
  function _removeEntry(stringArray, stringToRemove) {
    if (stringArray.indexOf(stringToRemove) > -1) {
      stringArray.splice(stringArray.indexOf(stringToRemove), 1);
    }
  }

  /**
   * Update the position of the helper layer on the screen
   *
   * @api private
   * @method _setHelperLayerPosition
   * @param {Object} helperLayer
   */
  function _setHelperLayerPosition(helperLayer) {
    if (helperLayer) {
      //prevent error when `this._currentStep` in undefined
      if (!this._introItems[this._currentStep]) return;

      var currentElement  = this._introItems[this._currentStep],
          elementPosition = _getOffset(currentElement.element),
          widthHeightPadding = 10;

      if (currentElement.position == 'floating') {
        widthHeightPadding = 0;
      }

      //set new position to helper layer
      helperLayer.setAttribute('style', 'width: ' + (elementPosition.width  + widthHeightPadding)  + 'px; ' +
                                        'height:' + (elementPosition.height + widthHeightPadding)  + 'px; ' +
                                        'top:'    + (elementPosition.top    - 5)   + 'px;' +
                                        'left: '  + (elementPosition.left   - 5)   + 'px;');

    }
  }

  /**
   * Add disableinteraction layer and adjust the size and position of the layer
   *
   * @api private
   * @method _disableInteraction
   */
  function _disableInteraction () {
    var disableInteractionLayer = document.querySelector('.introjs-disableInteraction');
    if (disableInteractionLayer === null) {
      disableInteractionLayer = document.createElement('div');
      disableInteractionLayer.className = 'introjs-disableInteraction';
      this._targetElement.appendChild(disableInteractionLayer);
    }

    _setHelperLayerPosition.call(this, disableInteractionLayer);
  }

  /**
   * Show an element on the page
   *
   * @api private
   * @method _showElement
   * @param {Object} targetElement
   */
  function _showElement(targetElement) {
    if (typeof (this._introChangeCallback) !== 'undefined') {
      this._introChangeCallback.call(this, targetElement.element);
    }

    var self = this,
        oldHelperLayer = document.querySelector('.introjs-helperLayer'),
        oldReferenceLayer = document.querySelector('.introjs-tooltipReferenceLayer'),
        highlightClass = 'introjs-helperLayer',
        elementPosition = _getOffset(targetElement.element);

    //check for a current step highlight class
    if (typeof (targetElement.highlightClass) === 'string') {
      highlightClass += (' ' + targetElement.highlightClass);
    }
    //check for options highlight class
    if (typeof (this._options.highlightClass) === 'string') {
      highlightClass += (' ' + this._options.highlightClass);
    }

    if (oldHelperLayer != null) {
      var oldHelperNumberLayer = oldReferenceLayer.querySelector('.introjs-helperNumberLayer'),
          oldtooltipLayer      = oldReferenceLayer.querySelector('.introjs-tooltiptext'),
          oldArrowLayer        = oldReferenceLayer.querySelector('.introjs-arrow'),
          oldtooltipContainer  = oldReferenceLayer.querySelector('.introjs-tooltip'),
          skipTooltipButton    = oldReferenceLayer.querySelector('.introjs-skipbutton'),
          nextTourButton       = oldReferenceLayer.querySelector('.introjs-nexttourbutton'),
          prevTooltipButton    = oldReferenceLayer.querySelector('.introjs-prevbutton'),
          nextTooltipButton    = oldReferenceLayer.querySelector('.introjs-nextbutton');

      //update or reset the helper highlight class
      oldHelperLayer.className = highlightClass;
      //hide the tooltip
      oldtooltipContainer.style.opacity = 0;
      oldtooltipContainer.style.display = "none";

      if (oldHelperNumberLayer != null) {
        var lastIntroItem = this._introItems[(targetElement.step - 2 >= 0 ? targetElement.step - 2 : 0)];

        if (lastIntroItem != null && (this._direction == 'forward' && lastIntroItem.position == 'floating') || (this._direction == 'backward' && targetElement.position == 'floating')) {
          oldHelperNumberLayer.style.opacity = 0;
        }
      }

      //set new position to helper layer
      _setHelperLayerPosition.call(self, oldHelperLayer);
      _setHelperLayerPosition.call(self, oldReferenceLayer);

      //remove `introjs-fixParent` class from the elements
      var fixParents = document.querySelectorAll('.introjs-fixParent');
      if (fixParents && fixParents.length > 0) {
        for (var i = fixParents.length - 1; i >= 0; i--) {
          fixParents[i].className = fixParents[i].className.replace(/introjs-fixParent/g, '').replace(/^\s+|\s+$/g, '');
        };
      }

      //remove old classes
      var oldShowElement = document.querySelector('.introjs-showElement');
      if (oldShowElement){
        oldShowElement.className = oldShowElement.className.replace(/introjs-[a-zA-Z]+/g, '').replace(/^\s+|\s+$/g, '');
      }
      
      //we should wait until the CSS3 transition is competed (it's 0.3 sec) to prevent incorrect `height` and `width` calculation
      if (self._lastShowElementTimer) {
        clearTimeout(self._lastShowElementTimer);
      }
      self._lastShowElementTimer = setTimeout(function() {
        //set current step to the label
        if (oldHelperNumberLayer != null) {
          oldHelperNumberLayer.innerHTML = targetElement.step;
        }
        //set current tooltip text
        oldtooltipLayer.innerHTML = targetElement.intro;
        //set the tooltip position
        oldtooltipContainer.style.display = "block";
        _placeTooltip.call(self, targetElement.element, oldtooltipContainer, oldArrowLayer, oldHelperNumberLayer);

        //change active bullet
        oldReferenceLayer.querySelector('.introjs-bullets li > a.active').className = '';
        oldReferenceLayer.querySelector('.introjs-bullets li > a[data-stepnumber="' + targetElement.step + '"]').className = 'active';

        oldReferenceLayer.querySelector('.introjs-progress .introjs-progressbar').setAttribute('style', 'width:' + _getProgress.call(self) + '%;');

        //show the tooltip
        oldtooltipContainer.style.opacity = 1;
        if (oldHelperNumberLayer) oldHelperNumberLayer.style.opacity = 1;

        //reset button focus
        if (nextTooltipButton.tabIndex === -1) {
          //tabindex of -1 means we are at the end of the tour - focus on skip / done
          skipTooltipButton.focus();
        } else {
          //still in the tour, focus on next
          nextTooltipButton.focus();
        }
      }, 10);

    } else {
      var helperLayer       = document.createElement('div'),
          referenceLayer    = document.createElement('div'),
          arrowLayer        = document.createElement('div'),
          tooltipLayer      = document.createElement('div'),
          tooltipTextLayer  = document.createElement('div'),
          bulletsLayer      = document.createElement('div'),
          progressLayer     = document.createElement('div'),
          buttonsLayer      = document.createElement('div');
          linksLayer        = document.createElement('div');

      helperLayer.className = highlightClass;
      referenceLayer.className = 'introjs-tooltipReferenceLayer';

      referenceLayer.onmousedown = function(e) {
        e.stopPropagation();
      }

      //set new position to helper layer
      _setHelperLayerPosition.call(self, helperLayer);
      _setHelperLayerPosition.call(self, referenceLayer);

      //add helper layer to target element
      this._targetElement.appendChild(helperLayer);
      this._targetElement.appendChild(referenceLayer);

      arrowLayer.className = 'introjs-arrow';

      tooltipTextLayer.className = 'introjs-tooltiptext';
      tooltipTextLayer.innerHTML = targetElement.intro;

      bulletsLayer.className = 'introjs-bullets';

      if (this._options.showBullets === false) {
        bulletsLayer.style.display = 'none';
      }


      var ulContainer = document.createElement('ul');

      for (var i = 0, stepsLength = this._introItems.length; i < stepsLength; i++) {
        var innerLi    = document.createElement('li');
        var anchorLink = document.createElement('a');

        anchorLink.onmousedown = function(e) {
          e.stopPropagation();
          self.goToStep(this.getAttribute('data-stepnumber'));
        };

        if (i === (targetElement.step-1)) anchorLink.className = 'active';

        anchorLink.href = 'javascript:void(0);';
        anchorLink.innerHTML = "&nbsp;";
        anchorLink.setAttribute('data-stepnumber', this._introItems[i].step);

        innerLi.appendChild(anchorLink);
        ulContainer.appendChild(innerLi);
      }

      bulletsLayer.appendChild(ulContainer);

      progressLayer.className = 'introjs-progress';

      if (this._options.showProgress === false) {
        progressLayer.style.display = 'none';
      }
      var progressBar = document.createElement('div');
      progressBar.className = 'introjs-progressbar';
      progressBar.setAttribute('style', 'width:' + _getProgress.call(this) + '%;');

      progressLayer.appendChild(progressBar);

      buttonsLayer.className = 'introjs-tooltipbuttons';
      if (this._options.showButtons === false) {
        buttonsLayer.style.display = 'none';
      }

      linksLayer.className = 'introjs-tooltiplinks';
      if (this._options.showButtons === false) {
        linksLayer.style.display = 'none';
      }

      tooltipLayer.className = 'introjs-tooltip';
      tooltipLayer.appendChild(tooltipTextLayer);
      tooltipLayer.appendChild(bulletsLayer);
      tooltipLayer.appendChild(progressLayer);

      //add helper layer number
      if (this._options.showStepNumbers == true) {
        var helperNumberLayer = document.createElement('span');
        helperNumberLayer.className = 'introjs-helperNumberLayer';
        helperNumberLayer.innerHTML = targetElement.step;
        referenceLayer.appendChild(helperNumberLayer);
      }

      tooltipLayer.onmousedown = function(e) {
        e.stopPropagation();
      }

      tooltipLayer.appendChild(arrowLayer);
      referenceLayer.appendChild(tooltipLayer);

      //next button
      var nextTooltipButton = document.createElement('a');

      nextTooltipButton.onmousedown = function(e) {
        e.stopPropagation();
        _nextStep.call(self);
      };

      nextTooltipButton.href = 'javascript:void(0);';
      nextTooltipButton.innerHTML = this._options.nextLabel;

      //previous button
      var prevTooltipButton = document.createElement('a');

      prevTooltipButton.onmousedown = function(e) {
        e.stopPropagation();
        if (self._currentStep != 0) {
          _previousStep.call(self);
        }
      };

      prevTooltipButton.href = 'javascript:void(0);';
      prevTooltipButton.innerHTML = this._options.prevLabel;

      //skip button
      var skipTooltipButton = document.createElement('a');
      skipTooltipButton.className = 'introjs-button introjs-skipbutton';
      skipTooltipButton.href = 'javascript:void(0);';
      skipTooltipButton.innerHTML = this._options.skipLabel;

      skipTooltipButton.onmousedown = function(e) {
        e.stopPropagation();
        if (self._introItems.length - 1 == self._currentStep && typeof (self._introCompleteCallback) === 'function') {
          self._introCompleteCallback.call(self);
        }

        if (self._introItems.length - 1 != self._currentStep && typeof (self._introExitCallback) === 'function') {
          self._introExitCallback.call(self);
        }

        _exitIntro.call(self, self._targetElement);
      };

      linksLayer.appendChild(skipTooltipButton);

      // Next Tour link
      var nextTourButton = document.createElement('a');
      nextTourButton.className = 'introjs-button introjs-nexttourbutton';
      nextTourButton.href = 'javascript:void(0);';
      nextTourButton.innerHTML = '';

      nextTourButton.onmousedown = function(e) {
        e.stopPropagation();
        if (this._options.nextTourURL) {
          window.location = this._options.nextTourURL;
        }

        _exitIntro.call(self, self._targetElement);
      }.bind(this);

      linksLayer.appendChild(nextTourButton);

      //in order to prevent displaying next/previous button always
      if (this._introItems.length > 1) {
        buttonsLayer.appendChild(prevTooltipButton);
        buttonsLayer.appendChild(nextTooltipButton);
      }

      buttonsLayer.appendChild(linksLayer);
      tooltipLayer.appendChild(buttonsLayer);

      //set proper position
      _placeTooltip.call(self, targetElement.element, tooltipLayer, arrowLayer, helperNumberLayer);
    }

    //disable interaction
    if (this._options.disableInteraction === true) {
      _disableInteraction.call(self);
    }

    prevTooltipButton.removeAttribute('tabIndex');
    nextTooltipButton.removeAttribute('tabIndex');
    skipTooltipButton.classList.remove('done');

    if (this._currentStep == 0 && this._introItems.length > 1) {
      prevTooltipButton.className = 'introjs-button introjs-prevbutton introjs-disabled';
      prevTooltipButton.tabIndex = '-1';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton';
      skipTooltipButton.innerHTML = this._options.skipLabel;
      nextTourButton.innerHTML = '';
    } else if (this._introItems.length - 1 == this._currentStep || this._introItems.length == 1) {
      prevTooltipButton.className = 'introjs-button introjs-prevbutton';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton introjs-disabled';
      nextTooltipButton.tabIndex = '-1';

      if (this._options.nextTourLabel) {
        //nextTourButton.innerHTML = 'Continue to ' + this._options.nextTourLabel;
        nextTooltipButton.classList.remove('introjs-disabled');
      } else {
        skipTooltipButton.classList.add('done');
        skipTooltipButton.innerHTML = this._options.doneLabel;
      } 
      
      
    } else {
      prevTooltipButton.className = 'introjs-button introjs-prevbutton';
      nextTooltipButton.className = 'introjs-button introjs-nextbutton';
      skipTooltipButton.innerHTML = this._options.skipLabel;
      nextTourButton.innerHTML = '';
    }

    //Set focus on "next" button, so that hitting Enter always moves you onto the next step
    nextTooltipButton.focus();

    //add target element position style
    targetElement.element.className += ' introjs-showElement';

    var currentElementPosition = _getPropValue(targetElement.element, 'position');
    if (currentElementPosition !== 'absolute' &&
        currentElementPosition !== 'relative') {
      //change to new intro item
      targetElement.element.className += ' introjs-relativePosition';
    }

    var parentElm = targetElement.element.parentNode;
    while (parentElm != null) {
      if (parentElm.tagName.toLowerCase() === 'body') break;

      //fix The Stacking Contenxt problem.
      //More detail: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
      var zIndex = _getPropValue(parentElm, 'z-index');
      var opacity = parseFloat(_getPropValue(parentElm, 'opacity'));
      var transform = _getPropValue(parentElm, 'transform') || _getPropValue(parentElm, '-webkit-transform') || _getPropValue(parentElm, '-moz-transform') || _getPropValue(parentElm, '-ms-transform') || _getPropValue(parentElm, '-o-transform');
      if (/[0-9]+/.test(zIndex) || opacity < 1 || transform !== 'none') {
        parentElm.className += ' introjs-fixParent';
      }

      parentElm = parentElm.parentNode;
    }

    if (!_elementInViewport(targetElement.element) && this._options.scrollToElement === true) {
      var rect = targetElement.element.getBoundingClientRect(),
        winHeight = _getWinSize().height,
        top = rect.bottom - (rect.bottom - rect.top),
        bottom = rect.bottom - winHeight;

      //Scroll up
      if (top < 0 || targetElement.element.clientHeight > winHeight) {
        window.scrollBy(0, top - 30); // 30px padding from edge to look nice

      //Scroll down
      } else {
        window.scrollBy(0, bottom + 100); // 70px + 30px padding from edge to look nice
      }
    }

    if (typeof (this._introAfterChangeCallback) !== 'undefined') {
      this._introAfterChangeCallback.call(this, targetElement.element);
    }
  }

  /**
   * Get an element CSS property on the page
   * Thanks to JavaScript Kit: http://www.javascriptkit.com/dhtmltutors/dhtmlcascade4.shtml
   *
   * @api private
   * @method _getPropValue
   * @param {Object} element
   * @param {String} propName
   * @returns Element's property value
   */
  function _getPropValue (element, propName) {
    var propValue = '';
    if (element.currentStyle) { //IE
      propValue = element.currentStyle[propName];
    } else if (document.defaultView && document.defaultView.getComputedStyle) { //Others
      propValue = document.defaultView.getComputedStyle(element, null).getPropertyValue(propName);
    }

    //Prevent exception in IE
    if (propValue && propValue.toLowerCase) {
      return propValue.toLowerCase();
    } else {
      return propValue;
    }
  }

  /**
   * Provides a cross-browser way to get the screen dimensions
   * via: http://stackoverflow.com/questions/5864467/internet-explorer-innerheight
   *
   * @api private
   * @method _getWinSize
   * @returns {Object} width and height attributes
   */
  function _getWinSize() {
    if (window.innerWidth != undefined) {
      return { width: window.innerWidth, height: window.innerHeight };
    } else {
      var D = document.documentElement;
      return { width: D.clientWidth, height: D.clientHeight };
    }
  }

  /**
   * Add overlay layer to the page
   * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport
   *
   * @api private
   * @method _elementInViewport
   * @param {Object} el
   */
  function _elementInViewport(el) {
    var rect = el.getBoundingClientRect();

    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      (rect.bottom+80) <= window.innerHeight && // add 80 to get the text right
      rect.right <= window.innerWidth
    );
  }

  /**
   * Add overlay layer to the page
   *
   * @api private
   * @method _addOverlayLayer
   * @param {Object} targetElm
   */
  function _addOverlayLayer(targetElm) {
    var overlayLayer = document.createElement('div'),
        styleText = '',
        self = this;

    //set css class name
    overlayLayer.className = 'introjs-overlay';

    //check if the target element is body, we should calculate the size of overlay layer in a better way
    if (targetElm.tagName.toLowerCase() === 'body') {
      styleText += 'top: 0;bottom: 0; left: 0;right: 0;position: fixed;';
      overlayLayer.setAttribute('style', styleText);
    } else {
      //set overlay layer position
      var elementPosition = _getOffset(targetElm);
      if (elementPosition) {
        styleText += 'width: ' + elementPosition.width + 'px; height:' + elementPosition.height + 'px; top:' + elementPosition.top + 'px;left: ' + elementPosition.left + 'px;';
        overlayLayer.setAttribute('style', styleText);
      }
    }

    targetElm.appendChild(overlayLayer);

    overlayLayer.onmousedown = function(e) {
      e.stopPropagation();

      if (self._options.exitOnOverlayClick == true) {
        _exitIntro.call(self, targetElm);

        //check if any callback is defined
        if (self._introExitCallback != undefined) {
          self._introExitCallback.call(self);
        }
      }
    };

    setTimeout(function() {
      styleText += 'opacity: ' + self._options.overlayOpacity.toString() + ';';
      overlayLayer.setAttribute('style', styleText);
    }, 10);

    return true;
  }

  /**
   * Get an element position on the page
   * Thanks to `meouw`: http://stackoverflow.com/a/442474/375966
   *
   * @api private
   * @method _getOffset
   * @param {Object} element
   * @returns Element's position info
   */
  function _getOffset(element) {
    var elementPosition = {};

    //set width
    elementPosition.width = element.offsetWidth;

    //set height
    elementPosition.height = element.offsetHeight;

    //calculate element top and left
    var _x = 0;
    var _y = 0;
    while (element && !isNaN(element.offsetLeft) && !isNaN(element.offsetTop)) {
      _x += element.offsetLeft;
      _y += element.offsetTop;
      element = element.offsetParent;
    }
    //set top
    elementPosition.top = _y;
    //set left
    elementPosition.left = _x;

    return elementPosition;
  }

  /**
   * Gets the current progress percentage
   *
   * @api private
   * @method _getProgress
   * @returns current progress percentage
   */
  function _getProgress() {
    // Steps are 0 indexed
    var currentStep = parseInt((this._currentStep + 1), 10);
    return ((currentStep / this._introItems.length) * 100);
  }

  /**
   * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
   * via: http://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically
   *
   * @param obj1
   * @param obj2
   * @returns obj3 a new object based on obj1 and obj2
   */
  function _mergeOptions(obj1,obj2) {
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }

  var introJs = function (targetElm) {
    if (typeof (targetElm) === 'object') {
      //Ok, create a new instance
      return new IntroJs(targetElm);

    } else if (typeof (targetElm) === 'string') {
      //select the target element with query selector
      var targetElement = document.querySelector(targetElm);

      if (targetElement) {
        return new IntroJs(targetElement);
      } else {
        throw new Error('There is no element with given selector.');
      }
    } else {
      return new IntroJs(document.body);
    }
  };

  /**
   * Current IntroJs version
   *
   * @property version
   * @type String
   */
  introJs.version = VERSION;

  //Prototype
  introJs.fn = IntroJs.prototype = {
    clone: function () {
      return new IntroJs(this);
    },
    setOption: function(option, value) {
      this._options[option] = value;
      return this;
    },
    setOptions: function(options) {
      this._options = _mergeOptions(this._options, options);
      return this;
    },
    start: function () {
      _introForElement.call(this, this._targetElement);
      return this;
    },
    goToStep: function(step) {
      _goToStep.call(this, step);
      return this;
    },
    nextStep: function() {
      _nextStep.call(this);
      return this;
    },
    previousStep: function() {
      _previousStep.call(this);
      return this;
    },
    exit: function() {
      _exitIntro.call(this, this._targetElement);
      return this;
    },
    refresh: function() {
      _setHelperLayerPosition.call(this, document.querySelector('.introjs-helperLayer'));
      _setHelperLayerPosition.call(this, document.querySelector('.introjs-tooltipReferenceLayer'));
      return this;
    },
    onbeforechange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introBeforeChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onbeforechange was not a function');
      }
      return this;
    },
    onchange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onchange was not a function.');
      }
      return this;
    },
    onafterchange: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introAfterChangeCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onafterchange was not a function');
      }
      return this;
    },
    oncomplete: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introCompleteCallback = providedCallback;
      } else {
        throw new Error('Provided callback for oncomplete was not a function.');
      }
      return this;
    },
    onexit: function(providedCallback) {
      if (typeof (providedCallback) === 'function') {
        this._introExitCallback = providedCallback;
      } else {
        throw new Error('Provided callback for onexit was not a function.');
      }
      return this;
    }
  };

  exports.introJs = introJs;
  return introJs;
}));

define(
    'views/shared/tour/InteractiveTour',[
        'jquery',
        'underscore',
        'backbone',
        'module',
        'views/Base',
        'splunk.util',
        'uri/route',
        'intro'
    ],
    function(
        $,
        _,
        backbone,
        module,
        BaseView,
        splunk_util,
        route,
        Intro
    ){
        return BaseView.extend({
            moduleId: module.id,
            initialize: function() {
                BaseView.prototype.initialize.apply(this, arguments);

                if (!this.model.tour) {
                    return;
                }

                this.tourOptions = {};
                this.interactiveTour = new Intro();
                this.steps = this.model.tour.getSteps();

                this.tourOptions = {
                    steps: this.steps,
                    nextLabel: '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="22px" height="40px" viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\
                        <g>\
                            <polygon points="114.484,792 91.5,769.643 455.045,396 91.5,22.357 114.484,0 499.793,396  " />\
                        </g>\
                    </svg>',
                    prevLabel: '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="22px" height="40px" viewBox="0 0 612 792" enable-background="new 0 0 612 792" xml:space="preserve">\
                        <g>\
                            <polygon points="476.81,-0.002 499.794,22.355 136.249,395.998 499.794,769.641 476.81,791.998 91.501,395.998  " />\
                        </g>\
                    </svg>',
                    skipLabel: _('Skip tour').t(),
                    doneLabel: _('Try it now').t(),
                    showStepNumbers: false,
                    exitOnOverlayClick: false,
                    scrollToElement: false
                };
                
                this.nextTour = this.model.tour.getNextTour();

                if (this.nextTour && this.collection.tours) {
                    this.setNextTour();
                }

                this.interactiveTour.setOptions(this.tourOptions);

                if (!this.model.tour.viewed()) {
                    this.setViewed();
                }
            },

            setNextTour: function() {
                this.model.nextTour = this.collection.tours.getTourModel(this.nextTour);
                var page, data, url, label;

                if (this.model.nextTour) {
                    page = this.model.nextTour.getTourPage();
                    data = splunk_util.queryStringToProp(this.model.nextTour.getTourURLData() || '');
                    data.tour = this.nextTour;
                    url = route.page(
                        this.model.application.get('root'),
                        this.model.application.get('locale'),
                        this.model.application.get('app'),
                        page,
                        { data: data }
                    );
                    label = this.model.nextTour.getLabel();

                    this.tourOptions.nextTourLabel = label;
                    this.tourOptions.nextTourURL = url;
                }
            },

            renderTour: function() {
                this.interactiveTour.start();
                
                this.interactiveTour.onbeforechange(function() {
                    this.nextStepSetup();
                }.bind(this));

                this.interactiveTour.onafterchange(function() {
                    this.interactiveTour.refresh();
                }.bind(this));
            },

            setViewed: function() {
                this.model.tour.entry.content.set('viewed', true);
            },

            nextStepSetup: function() {
                this.killPoptarts();

                var curStep = this.interactiveTour._currentStep,
                    step = this.interactiveTour._introItems[curStep],
                    stepElement = this.steps[curStep].element,
                    stepPos = this.steps[curStep].position || 'auto',
                    nextElement;

                this.checkforCallBack(curStep);

                nextElement = (typeof(stepElement) === 'string') ? $(stepElement)[0] : stepElement;

                if (nextElement) {
                    step.element = nextElement;
                    step.position = stepPos;
                }
            },

            killPoptarts: function() {
                // necessary to remove generated poptarts
                $('body').trigger('mousedown');

                if ($('.modalize-table-overlay')[0]) {
                    $('.modalize-table-overlay').click();
                }
            },

            checkforCallBack: function(curStep) {
                if (!$.isEmptyObject(this.steps[curStep].callback)) {
                    var triggerElement = this.steps[curStep].callback.eventEl,
                        type = this.steps[curStep].callback.eventType;
                    $(triggerElement).trigger(type);
                }
            },

            render: function() {
                this.renderTour();
                return this;
            }
        });
    }
);

define(
    'views/shared/tour/FirstTimeTourModal',[
        'jquery',
        'underscore',
        'backbone',
        'module',
        'views/shared/tour/ImageTour',
        'views/shared/tour/InteractiveTour',
        'views/shared/Modal',
        'uri/route',
        'splunk.util'
    ],
    function(
        $,
        _,
        backbone,
        module,
        ImageTour,
        InteractiveTour,
        Modal,
        route,
        splunk_utils
    ){
        return Modal.extend({
            moduleId: module.id,
            initialize: function() {
                Modal.prototype.initialize.apply(this, arguments);

                if (!this.model.tour) {
                    return;
                }

                var name = this.model.user.entry.content.get('realname'),
                    username = this.model.user.entry.get('name'),
                    fullname = name || username || '';

                fullname = _.escape(fullname);
                this.welcomeText = splunk_utils.sprintf(_('Welcome, %s').t(), fullname);
                this.introText = this.options.introText || _('It looks like this is your first time on this page. Would you like to take a quick tour?').t();
                this.tourName = this.options.tourName;
                this.on('hidden', function() {
                    this.setViewed();
                });
            },

            events: $.extend({}, Modal.prototype.events, {
                'click .modal-btn-continue': 'runTour'
            }),

            setViewed: function() {
                this.model.tour.entry.content.set('viewed', true);
            },

            runTour: function() {
                this.hide();
                var isImgTour = this.model.tour.isImgTour();

                if (isImgTour) {
                    this.children.tour = new ImageTour({
                        model: {
                            tour: this.model.tour,
                            application: this.model.application
                        },
                        onHiddenRemove: true,
                        backdrop: 'static'
                    });
                    $('body').append('<div class="splunk-components image-tour"></div>');
                    $('.image-tour').append(this.children.tour.render().el);
                    this.children.tour.show();
                } else {
                    var qs = this.model.tour.getTourURLData(),
                        qsData, tourLink;

                    if (qs) {
                        qsData = splunk_utils.queryStringToProp(qs);

                        qsData.tour =  this.tourName;
                        tourLink = route.page(
                            this.model.application.get('root'),
                            this.model.application.get('locale'),
                            'search',
                            this.model.tour.getTourPage(),
                            { data: qsData }
                        );
                        window.location = tourLink;
                    } else {
                        this.children.tour = new InteractiveTour({
                            model: {
                                tour: this.model.tour,
                                application: this.model.application
                            },
                            collection: {
                                tours: this.collection.tours
                            },
                            introModal: false
                        });
                        this.children.tour.render();
                    }
                }
            },

            render: function() {
                this.$el.html(Modal.TEMPLATE);
                this.$(Modal.HEADER_TITLE_SELECTOR).html(_(this.welcomeText).t());
                this.$(Modal.BUTTON_CLOSE_SELECTOR).remove();
                this.$(Modal.BODY_SELECTOR).append(Modal.FORM_HORIZONTAL);
                this.$(Modal.BODY_SELECTOR).append(_(this.introText).t());
                this.$(Modal.FOOTER_SELECTOR).append('<a href="#" class="btn modal-btn-skip pull-left" data-dismiss="modal">' + _('Skip').t() + '</a>');
                this.$(Modal.FOOTER_SELECTOR).append('<a href="#" class="btn modal-btn-continue pull-right btn-primary">' + _('Continue to tour').t() + '</a>');
            }
        });
    }
);
define(
    'views/shared/Page',[
        'module',
        'views/Base',
        'views/shared/splunkbar/Master',
        'views/shared/litebar/Master',
        'views/shared/appbar/Master',
        'views/shared/footer/Master',
        'views/shared/tour/TourBar',
        'views/shared/tour/ImageTour',
        'views/shared/tour/InteractiveTour',
        'views/shared/tour/FirstTimeTourModal'
    ],
    function(
        module,
        BaseView,
        SplunkBarView,
        SplunkBarSideView,
        AppBarView,
        FooterView,
        TourBar,
        ImageTour,
        InteractiveTour,
        FirstTimeTourModal
    ) {
        return BaseView.extend({
            moduleId: module.id,
            initialize: function() {
                BaseView.prototype.initialize.apply(this, arguments);
                this.useSideNav = this.model.user.canUseSidenav();

                if (this.useSideNav) {
                    this.children.sideNav = SplunkBarSideView.create({
                        model: {
                            application: this.model.application,
                            appNav: this.model.appNav,
                            appLocal: this.model.appLocal,
                            user: this.model.user,
                            serverInfo: this.model.serverInfo,
                            config: this.model.config
                        },
                        collection: this.collection 
                    });
                } else {
                    if (this.options.splunkBar) {
                        this.children.splunkBar = SplunkBarView.create({
                            model: {
                                application: this.model.application,
                                appNav: this.model.appNav,
                                appLocal: this.model.appLocal,
                                user: this.model.user,
                                serverInfo: this.model.serverInfo,
                                config: this.model.config
                            },
                            collection: this.collection, 
                            showAppsList: this.options.hasOwnProperty("showAppsList") ? this.options.showAppsList : true  
                        });
                    }
                    if (this.model.appNav) {
                        this.children.appBar = AppBarView.create({
                            section: this.options.section || '',
                            model: {
                                application: this.model.application,
                                appNav: this.model.appNav,
                                user: this.model.user,
                                serverInfo: this.model.serverInfo
                            },
                            collection: this.collection
                        });
                    }
                }
                
                if (this.options.footer) {
                    this.children.footer = FooterView.create({
                        model: this.model,
                        collection: this.collection
                    });
                }

                if (this.model.tour) {
                    this.isImgTour = this.model.tour.isImgTour();
                    this.isInteractive = this.model.tour.isInteractive();
                    this.firstTimeCheck = this.model.tour.firstTimeCheck();
                    this.tourDisabled = this.model.tour.isDisabled();

                    if (this.firstTimeCheck) {
                        var firstTime = !this.model.tour.viewed();
                        if (firstTime) {
                            this.children.tour = new FirstTimeTourModal({
                                model: {
                                    tour: this.model.tour,
                                    application: this.model.application,
                                    user: this.model.user
                                },
                                collection: {
                                    tours: this.collection.tours
                                },
                                tourName: this.model.tour.entry.get('name'),
                                introText: this.model.tour.getIntroText(),
                                backdrop: 'static'
                            });
                        } else {
                            this.model.tour = null;
                        }
                    } else if (this.isInteractive) {
                        this.children.tour = new InteractiveTour({
                            model: {
                                tour: this.model.tour,
                                application: this.model.application
                            },
                            collection: this.collection
                        });
                    } else if (this.isImgTour) {
                        this.children.tour = new ImageTour({
                            model: {
                                tour: this.model.tour,
                                application: this.model.application
                            },
                            onHiddenRemove: true,
                            backdrop: 'static'
                        });
                    } else {
                        this.children.tour = new TourBar({
                            model: {
                                tour: this.model.tour
                            }
                        });
                    }
                }
            },
            render: function() {
                this.renderLoadingMessage();
                this.renderHeader();
                this.renderTour();
                this.renderFooter();
                return this;
            },
            renderHeader: function() {
                if (this.useSideNav) {
                    this.$('header').append(this.children.sideNav.el);
                } else {        
                    if (this.options.splunkBar) {
                        this.$('header').append(this.children.splunkBar.render().el);
                    }
                    if (this.model.appNav) {
                        this.$('header').append(this.children.appBar.el);
                    }
                }
            },
            renderTour: function() {
                if (this.model.tour && !this.tourDisabled) {
                    $.when(this.options.deferreds.tour, this.options.deferreds.pageViewRendered).then(function() {
                        if (this.firstTimeCheck) {
                            this.children.tour.render().el;
                            this.children.tour.show();
                        } else if (this.isInteractive) {
                            this.children.tour.render();
                        } else if (this.isImgTour) {
                            // The 'splunk-components' wrapper is necessary  
                            // for modal to render correctly in manager.
                            $('body').append('<div class="splunk-components image-tour"></div>');
                            $('.image-tour').append(this.children.tour.render().el);
                            this.children.tour.show();
                        } else {        
                            this.$('header').append(this.children.tour.render().el);
                        }
                    }.bind(this));
                }
            },
            renderFooter: function() {
                if (this.options.footer) {
                    this.$('footer').append(this.children.footer.render().el);
                }
            },
            renderLoadingMessage: function() {
                var html = this.compiledTemplate({loadingMessage: this.options.loadingMessage || ''});
                this.$el.html(html);
            },
            template: '\
                <a class="navSkip" href="#navSkip" tabIndex="1">Screen reader users, click here to skip the navigation bar</a>\
                <header role="banner"></header>\
                <a id="navSkip"></a> \
                <div class="main-section-body" role="main">\
                    <% if (loadingMessage) { %>\
                        <div class="loading-message"><%- loadingMessage %></div>\
                    <% } %>\
                </div>\
                <footer role="contentinfo"></footer>\
            '
        });
    }
);

define('util/ajax_logging',[
            'jquery',
            'underscore',
            'splunk.logger',
            'splunk.util'
        ],
        function(
            $,
            _,
            SplunkLogger,
            splunkUtils
        ) {

    var LOG_MODE = splunkUtils.getConfigValue("JS_LOGGER_MODE", "None"),
        LOG_LEVEL = splunkUtils.getConfigValue("JS_LOGGER_LEVEL", "INFO");

    // only need to attach an ajaxPrefilter handler if the logger type and log level indicate it is needed
    if(LOG_MODE !== 'None' && LOG_LEVEL === 'DEBUG') {
        var logger = SplunkLogger.getLogger('ajax_logging.js');

        // black-list of AJAX URLs that should not be logged
        var URL_BLACKLIST = [
            SplunkLogger.mode.Server.END_POINT,
            'services/messages'
        ];

        $.ajaxPrefilter(function(options, originalOptions, jqXHR) {
            var passesBlacklist = _(URL_BLACKLIST).every(function(blacklistUrl) {
                return options.url.indexOf(blacklistUrl) === -1;
            });
            if(passesBlacklist) {
                logger.debug('sending AJAX request to ', options.url);
                logger.trace();
            }
        });
    }

});
Splunk.namespace("Splunk.Error");
Splunk.Error.PROPAGATE = true; //if error should propagate or not
Splunk.Error.loggerMode = Splunk.Logger.mode.Server; //the desired Splunk.Logger.mode
/**
 * The Handler singleton provides a standard interface for handling all thrown exceptions.
 * Dependency on splunk.js, logger.js
 */
/*jshint -W057:false */
Splunk.Error.Handler = new function(){
/*jshint -W057:true */
    var self = this,
        logger = Splunk.Logger.getLogger("Splunk.Error", Splunk.Error.loggerMode);
    /**
     * Interface for handling window.onerror events, first log it to standard logger, second re-throw the original exception if PROPAGATE set to true.
     *
     * @param {String} msg The error message
     * @param {String} url The error source url
     * @param {String} line The error line reference
     */
    self.onerror = function(message, fileName, lineNumber){
        var output = format(message, fileName, lineNumber);
        logger.error(output);
        return !Splunk.Error.PROPAGATE; //return true to stop error propagation, false to allow propagation
    };
    /**
     * Interface for throwing an error, first log it to standard logger, second re-throw the original exception if PROPAGATE set to true.
     *
     * @param {Error} error The error object caught
     */
    self.raise = function(error){
        var output = format(error.message, error.fileName, error.lineNumber);
        logger.error(output);
        if(Splunk.Error.PROPAGATE){
            throw error;
        }
    };
    /**
     * Format a logger message.
     * 
     * @param {String} message Human-readable description of the error.
     * @param {String} fileName The name of the file containing the code that caused the exception.
     * @param {Number} lineNumber The line number of the code that caused the exception.
     */
    var format = function(message, fileName, lineNumber){
        return "lineNumber=" + lineNumber + ", message=" + message + ", fileName=" + fileName;
    };
    /**
     * In Firefox if an error is thrown in an event handler attached using addEventListener
     * it will not make it to the window.onerror handler, see: https://bugzilla.mozilla.org/show_bug.cgi?id=312448
     * Override jQuery.fn.bind with a handler in a try/catch block.
     *
     * Note: This is currently broken, event exceptions in ff will not be caught.
     */
    var jQueryHandler = function(){
        var bindCopy = jQuery.fn.bind;
        jQuery.fn.bind = function(type, data, fn){
            if(!fn && data && typeof(data)=='function'){
                fn = data;
                data = null;
            }
            if(fn){
                var fnCopy = fn;
                var handler = function(){
                    try{
                        fnCopy.apply(this, arguments);
                    }catch(e){
                        self.raise(e);
                    }
                };
                fn = handler;
            }
            return bindCopy.call(this, type, data, fn);
        };
    };
    /**
     * Constructor for Handler interface
     */   
    self.Error = function(){
        window.onerror = self.onerror; //use onerror instead of $(window).error( ... ) for proper stack trace, Webkit does not support window.onerror, see: https://bugs.webkit.org/show_bug.cgi?id=8519
        //jQueryHandler();
    }();
};
define("splunk.error", ["jquery","splunk","splunk.logger"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Splunk.Error;
    };
}(this)));

define('routers/Base',[
        'underscore',
        'backbone',
        'models/shared/Application',
        'models/services/AppLocal',
        'models/config',
        'models/services/server/ServerInfo',
        'models/services/data/ui/Nav',
        'models/services/data/UserPref',
        'models/shared/User',
        'models/shared/ClassicURL',
        'models/services/data/ui/Tour',
        'collections/services/data/ui/Tours',
        'collections/services/AppLocals',
        'collections/services/data/ui/Managers',
        'views/shared/Page',
        'util/csrf_protection',
        'util/ajax_no_cache',
        'util/ajax_logging',
        'util/splunkd_utils',
        'splunk.util',
        'util/console',
        'splunk.error',
        'uri/route'
    ],
    function(
        _,
        Backbone,
        ApplicationModel,
        AppLocalModel,
        configModel,
        ServerInfoModel,
        AppNavModel,
        UserPrefModel,
        UserModel,
        ClassicURL,
        TourModel,
        ToursCollection,
        AppLocalsCollection,
        ManagersCollection,
        PageView,
        undefined,
        ajaxNoCache,
        ajaxLogging,
        splunkd_utils,
        splunkUtils,
        console,
        splunkError,
        route
    ) {
    return Backbone.Router.extend({
        routes: {
            ':locale/app/:app/:page': 'page',
            ':locale/app/:app/:page/': 'page',
            ':locale/app/:app/:page/*splat': 'page',
            ':locale/manager/:app/:page': 'page',
            ':locale/manager/:app/:page/': 'page',
            ':locale/manager/:app/:page/*splat': 'page',
            '*root/:locale/app/:app/:page': 'pageRooted',
            '*root/:locale/app/:app/:page/': 'pageRooted',
            '*root/:locale/app/:app/:page/*splat': 'pageRooted',
            '*root/:locale/manager/:app/:page': 'pageRooted',
            '*root/:locale/manager/:app/:page/': 'pageRooted',
            '*root/:locale/manager/:app/:page/*splat': 'pageRooted',
            '*splat': 'notFound'
        },
        initialize: function(options) {
            options = $.extend({model:{}, collection:{}, deferreds: {}}, options);
            //add __splunk__ to global namespace
            if (window.location.href.indexOf('debug=1')!=-1) {
                (function(exports) {
                    this.__splunk__ = exports;
                })(this);
            }
            //configuration
            this.enableAppBar = true;
            this.enablePageView = true;
            this.enableFooter = true;
            this.showAppsList = true;
            this.fetchUser = true;
            this.fetchAppLocals = false;
            this.fetchAppLocal = true;
            this.fetchUserPref = false;
            this.fetchServerInfo = true;
            this.fetchManagers = true;
 
            this.loadingMessage = '';

            //models
            this.model = {};
            this.model.config = options.model.config || configModel;
            this.model.application = options.model.application || new ApplicationModel({owner: this.model.config.get('USERNAME')});
            this.model.appNav = options.model.appNav || new AppNavModel();
            this.model.appLocal = options.model.appLocal || new AppLocalModel();
            this.model.userPref = options.model.userPref || new UserPrefModel();
            this.model.serverInfo = options.model.serverInfo || new ServerInfoModel();
            this.model.user = options.model.user || new UserModel({}, {serverInfoModel: this.model.serverInfo});
            this.model.tour = options.model.tour || new TourModel();

            //collections
            this.collection = {};
            this.collection.appLocals = options.collection.appLocals || new AppLocalsCollection();
            this.collection.appLocalsUnfiltered = options.collection.appLocalsUnfiltered || new AppLocalsCollection();
            this.collection.managers = options.collection.managers || new ManagersCollection();
            this.collection.tours = new ToursCollection();

            //views
            this.views = {};
            
            //deferreds
            this.deferreds = options.deferreds || {};
            this.deferreds.user = options.deferreds.user || $.Deferred();
            this.deferreds.appNav = options.deferreds.appNav || $.Deferred();
            this.deferreds.appLocal = options.deferreds.appLocal || $.Deferred();
            this.deferreds.appLocals = options.deferreds.appLocals || $.Deferred();
            this.deferreds.appLocalsUnfiltered = options.deferreds.appLocalsUnfiltered || $.Deferred();
            this.deferreds.userPref = options.deferreds.userPref || $.Deferred();
            this.deferreds.serverInfo = options.deferreds.serverInfo || $.Deferred();
            this.deferreds.pageViewRendered = options.deferreds.pageViewRendered || $.Deferred();
            this.deferreds.tour = options.deferreds.tour || $.Deferred();
            this.deferreds.managers = options.deferreds.managers || $.Deferred();
            this.deferreds.application = options.deferreds.application || $.Deferred();

            //history
            if(options.history){
                this.history = options.history;
            }else{
                this.history = {};
                _.each(this.routes, function(value) {
                    this.on('route:' + value, function() {
                        this.history[window.location.pathname] = true;
                    }, this);
                }, this);
            }

        },
        page: function(locale, app, page) {
            this.shouldRender = !this.history[window.location.pathname];
            this.model.application.set({
                locale: locale,
                app: app,
                page: page.split('?')[0]
            });
            this.deferreds.application.resolve();
            
            this.bootstrapAppNav();
            this.bootstrapAppLocal();
            this.bootstrapServerInfo();
            this.bootstrapTour();
            this.bootstrapUserPref();
            this.bootstrapManagers();
 
            if (this.enablePageView && !this.pageView) {
                this.$whenPageViewDependencies().then(function(){
                    this.pageView = new PageView({
                        splunkBar: true,
                        showAppsList: this.showAppsList,
                        footer: this.enableFooter,
                        section: this.model.application.get('page'),
                        loadingMessage: this.loadingMessage,
                        model: {
                            application: this.model.application,
                            appNav: this.model.appNav,
                            appLocal: this.model.appLocal,
                            user: this.model.user,
                            serverInfo: this.model.serverInfo,
                            config: this.model.config,
                            tour: this.model.tour,
                            userPref: this.model.userPref
                        },
                        collection: {
                            apps: this.collection.appLocals,
                            tours: this.collection.tours,
                            managers: this.collection.managers
                        },
                        deferreds: {
                            tour: this.deferreds.tour,
                            pageViewRendered: this.deferreds.pageViewRendered
                        }
                    });
                    this.pageView.render();
                    this.deferreds.pageViewRendered.resolve();
                }.bind(this));
            }
        },
        pageRooted: function(root, locale, app, page) {
            this.model.application.set({
                root: root
            }, {silent: true});
            this.page(locale, app, page);
        },
        notFound: function() {
            console.log('Page not found.');
        },
        $whenPageViewDependencies: function() {
            this.bootstrapUser();
            this.bootstrapAppLocals();
            return $.when(this.deferreds.user, this.deferreds.appLocals, this.deferreds.appLocal, 
                this.deferreds.appNav, this.deferreds.serverInfo, this.deferreds.tour, this.deferreds.managers);
        },
        bootstrapAppNav: function() {
            var appNavPartialData;
            if (this.deferreds.appNav.state() !== 'resolved') {
                if (this.enableAppBar) {
                    appNavPartialData = __splunkd_partials__['/appnav'];
                    if (appNavPartialData) {
                        this.model.appNav.setFromSplunkD(appNavPartialData);
                        this.deferreds.appNav.resolve();                        
                    } else {
                        this.model.appNav.fetch({
                            data: {
                                app: this.model.application.get("app"),
                                owner: this.model.application.get("owner")
                            },
                            success: function(model, response) {
                                this.deferreds.appNav.resolve();
                            }.bind(this),
                            error: function(model, response) {
                                this.deferreds.appNav.resolve();
                            }.bind(this)
                        });                        
                    }
                } else {
                    this.model.appNav = undefined;
                    this.deferreds.appNav.resolve();
                }
            }            
        },
        bootstrapAppLocals: function() {
            if (this.deferreds.appLocals.state() !== 'resolved') {
                if (this.fetchAppLocals) {
                    this.collection.appLocals.fetch({ //fetch all apps in one shot filtering out launcher on success
                        data: {
                            sort_key: 'name',
                            sort_dir: 'asc',
                            app: '-' ,
                            owner: this.model.application.get('owner'),
                            search: 'visible=true AND disabled=0',
                            count: -1
                        },
                        success: function(collection, response) {
                            this.collection.appLocalsUnfiltered.set(collection.models);
                            collection.remove(collection.get('/servicesNS/nobody/system/apps/local/launcher'));//remove launcher
                            this.deferreds.appLocals.resolve();
                            this.deferreds.appLocalsUnfiltered.resolve();
                        }.bind(this),
                        error: function(collection, response) {
                            this.deferreds.appLocals.resolve();
                            this.deferreds.appLocalsUnfiltered.resolve();
                        }.bind(this)
                    });
                } else {
                    this.collection.appLocals = undefined;
                    this.collection.appLocalsUnfiltered = undefined;
                    this.deferreds.appLocals.resolve();
                    this.deferreds.appLocalsUnfiltered.resolve();
                }
            }
        },
        bootstrapTour: function() {
            if (this.model.tour && this.model.tour.id) {
                return;
            }

            var app = this.model.application.get('app'),
                owner = this.model.application.get('owner'),
                page = this.model.application.get('page'),
                queryProps = splunkUtils.queryStringToProp(window.location.search),
                tourPage;
            
            if (app == 'search') {
                tourPage = page;
            }

            this.tourName = undefined;

            if (queryProps.tour) {
                this.tourName = queryProps.tour;
                this.model.classicurl = new ClassicURL();
                this.model.classicurl.fetch({
                    success: function(model, response) {
                        this.deferreds.appLocal.resolve();
                        this.model.classicurl.unset('tour');
                        this.model.classicurl.save({}, {replaceState: true});
                    }.bind(this),
                    error: function(model, response) {
                        this.deferreds.appLocal.resolve();
                    }.bind(this)
                });
            } else if (tourPage) {
                this.tourName = tourPage + '-tour';
                this.firstTimeCheck = true;
            }

            if (this.deferreds.tour.state() !== 'resolved') {
                this.collection.tours.fetch({
                    data: {
                        app: app,
                        owner: owner,
                        count: -1
                    },
                    success: function(collection, response) {
                        this.setTourModel(this.tourName);
                    }.bind(this),
                    error: function(collection, response) {
                        this.deferreds.tour.resolve();
                    }.bind(this)
                });
            } else {
                this.model.tour = null;
                this.deferreds.tour.resolve();
            }
        },
        setTourModel: function(tourName) {
            if (!tourName) {
                this.model.tour = null;
                this.deferreds.tour.resolve();
                return false;
            }

            var app = this.model.application.get('app'),
                owner = this.model.application.get('owner'),
                productType = this.model.serverInfo.getProductType(),
                instanceType = this.model.serverInfo.getInstanceType(),
                isLite = this.model.serverInfo.isLite(),
                name, tourCheck;

            if (this.firstTimeCheck) {
                if (isLite) {
                    // make check if Splunk Light global tour has been viewed
                    var lightTour = this.collection.tours.getTourModel('light-product-tour');
                    if (lightTour && !lightTour.viewed()) {
                        tourCheck = lightTour;
                    }
                }

                if (!tourCheck) {
                    var envTourName = tourName + ':' + productType + ((instanceType) ? ':' + instanceType : '');
                    tourCheck = this.collection.tours.getTourModel(envTourName);
                }
            } else {
                tourCheck = this.collection.tours.getTourModel(tourName);
            }

            if (tourCheck) {
                name = tourCheck.entry.get('name') || '';
                this.model.tour.bootstrap(this.deferreds.tour, app, owner, name);
                if (this.model.tour) {
                    if (this.firstTimeCheck) {
                        this.model.tour.entry.content.set('firstTimeCheck', true);
                    }

                    this.model.tour.entry.content.on('change', function() {
                        this.updateTour();
                    }, this);
                }
            } else {
                this.model.tour = null;
                this.deferreds.tour.resolve();
            }
        },
        updateTour: function() {
            var data = {};
            if (this.model.tour.isNew()) {
                data = {
                    app: this.model.application.get('app'),
                    owner: this.model.application.get('owner')
                };
            }
            this.model.tour.save({}, {
                data: data
            });
        },
        bootstrapAppLocal: function() {
            var app, appLocalPartialData;
            if (this.deferreds.appLocal.state() !== 'resolved') {
                app = this.model.application.get('app');

                if (this.fetchAppLocal && (app !== 'system')) {
                    appLocalPartialData = __splunkd_partials__['/servicesNS/nobody/system/apps/local/' + encodeURIComponent(app)];
                    if (appLocalPartialData) {
                        this.model.appLocal.setFromSplunkD(appLocalPartialData);
                        this.deferreds.appLocal.resolve();
                    } else {
                        this.model.appLocal.fetch({
                            url: splunkd_utils.fullpath(this.model.appLocal.url + "/" + encodeURIComponent(app)),
                            data: {
                                app: app,
                                owner: this.model.application.get("owner")
                            },
                            success: function(model, response) {
                                this.deferreds.appLocal.resolve();
                            }.bind(this),
                            error: function(model, response) {
                                this.deferreds.appLocal.resolve();
                            }.bind(this)
                        });
                    }                    
                } else {
                    this.model.appLocal = undefined;
                    this.deferreds.appLocal.resolve();
                }
            }            
        },
        bootstrapServerInfo: function() {
            var serverInfoPartialData;
            if (this.deferreds.serverInfo.state() !== 'resolved') {
                if (this.fetchUser || this.fetchServerInfo) {
                    serverInfoPartialData = __splunkd_partials__['/services/server/info'];
                    if (serverInfoPartialData) {
                        this.model.serverInfo.setFromSplunkD(serverInfoPartialData);
                        this.deferreds.serverInfo.resolve();
                    } else {
                        this.model.serverInfo.fetch({
                            success: function(model, response) {
                                this.deferreds.serverInfo.resolve();
                            }.bind(this),
                            error: function(model, response) {
                                this.deferreds.serverInfo.resolve();
                            }.bind(this)                        
                        });
                    }
                } else {
                    this.model.serverInfo = undefined;
                    this.deferreds.serverInfo.resolve();
                }
            }  
        },
        bootstrapUserPref: function() {
            if (this.deferreds.userPref.state() !== 'resolved') {
                if (this.fetchUserPref) {
                    this.model.userPref.fetch({
                        success: function(model, response) {
                            this.deferreds.userPref.resolve();
                        }.bind(this),
                        error: function(model, response) {
                            this.deferreds.userPref.resolve();
                        }.bind(this)

                     });
                } else {
                    this.model.userPref = undefined;
                    this.deferreds.userPref.resolve();
                }
            }
        },
        bootstrapUser: function() {
            if (this.deferreds.user.state() !== 'resolved') {
                if (this.fetchUser) {
                    this.model.user.fetch({
                        url: splunkd_utils.fullpath(this.model.user.url + "/" + encodeURIComponent(this.model.application.get("owner"))),
                        data: {
                            app: this.model.application.get("app"),
                            owner: this.model.application.get("owner")
                        },
                        success: function(model, response) {
                            $.when(this.deferreds.serverInfo).then(function() {
                                this.deferreds.user.resolve();
                            }.bind(this));
                        }.bind(this),
                        error: function(model, response) {
                            $.when(this.deferreds.serverInfo).then(function() {
                                this.deferreds.user.resolve();
                            }.bind(this));
                        }.bind(this)
                    });
                } else {
                    this.model.user = undefined;
                    this.deferreds.user.resolve();
                }
            }
        },
        bootstrapManagers: function() {
            if (this.deferreds.managers.state() !== 'resolved') {
                if (this.fetchManagers) {
                    this.collection.managers.fetch({
                        data: {
                            app: "-",
                            owner: this.model.application.get("owner"),
                            count: 0,
                            digest: 1
                        },
                        success: function(collection, response, options) {
                            this.deferreds.managers.resolve();
                        }.bind(this),
                        error: function(collection, response, options) {
                            this.deferreds.managers.resolve();
                        }.bind(this)
                    });
                } else {
                    this.collection.managers = undefined;
                    this.deferreds.managers.resolve();
                }
            }
        },
        // convenience method for subclasses to update the page <title>
        // as browser compatibility issues arise, they can be encapsulated here
        setPageTitle: function(title) {
            this.deferreds.serverInfo.done(function(){
                var version = this.model.serverInfo.getVersion() || _('N/A').t();
                var isLite = this.model.serverInfo.isLite();
                document.title = splunkUtils.sprintf(_('%s | Splunk %s %s').t(), title, isLite ? 'Light' : '', version);
            }.bind(this));
        }
    });
});


define("app/pages/common", function(){});
