<form stylesheet="ui_simple.css,hover.css,hide_timeindicator.css,panel_decoration.css,table_data_bar.css" script="ui_simple.js,active_button.js,autodiscover.js,table_data_bar.js" isVisible="true">
    <label>NMON Summary Light Analysis</label>
    <fieldset autoRun="false" submitButton="false">

        <input type="time" token="timerange" searchWhenChanged="true">
            <label>Time Range:</label>
            <default>
                <earliestTime>-24h</earliestTime>
                <latestTime>now</latestTime>
            </default>
            <change>
                <unset token="form.refresh"></unset>
            </change>
        </input>

        <input type="dropdown" token="osfilter" searchWhenChanged="true">
            <label>Filter OS Type:</label>
            <default>*</default>
            <choice value="*">Any OS</choice>
            <choice value="AIX">AIX</choice>
            <choice value="Linux">Linux</choice>
            <choice value="Solaris">Solaris</choice>
        </input>

        <input id="frameID" type="dropdown" token="frameID" searchWhenChanged="true">
            <label>Frame IDs:</label>
            <!-- Populating Data Model Search -->
            <search id="frameIDSearch">
                <query>| tstats count AS Count from datamodel=NMON_Data_CPU where (nodename = CPU) (CPU.OStype=$osfilter$) groupby "CPU.frameID" prestats=true
| stats dedup_splitvals=t count AS Count by "CPU.frameID"
| sort limit=0 "CPU.frameID"
| fields - _span | fillnull Count | fields "CPU.frameID"</query>
                <earliest>$timerange.earliest$</earliest>
                <latest>$timerange.latest$</latest>
            </search>
            <choice value="*">Any</choice>
            <default>*</default>
            <fieldForLabel>CPU.frameID</fieldForLabel>
            <fieldForValue>CPU.frameID</fieldForValue>
        </input>

        <input type="text" token="host-prefilter" searchWhenChanged="true">
            <label>Optional: Filter hosts populating</label>
            <default>*</default>
        </input>

        <input id="host" type="dropdown" token="host" searchWhenChanged="true">
            <label>Host:</label>
            <!-- Populating Data Model Search -->
            <search id="baseSearch">
                <query>| tstats count AS Count from datamodel=NMON_Data_CPU where (nodename = CPU) (CPU.frameID="$frameID$") (host="$host-prefilter$") (CPU.OStype="$osfilter$") groupby host prestats=true
| stats dedup_splitvals=t count AS Count by host
| sort limit=0 host
| fields - _span
| fillnull Count
| fields host, Count</query>
                <earliest>$timerange.earliest$</earliest>
                <latest>$timerange.latest$</latest>
            </search>
            <fieldForLabel>host</fieldForLabel>
            <fieldForValue>host</fieldForValue>
        </input>

        <input type="dropdown" token="span" searchWhenChanged="true">
            <label>Span:</label>
            <default>`nmon_span`</default>
            <choice value="`nmon_span`">auto</choice>
            <choice value="span=1m">1 minute</choice>
            <choice value="span=2m">2 minutes</choice>
            <choice value="span=3m">3 minutes</choice>
            <choice value="span=4m">4 minutes</choice>
            <choice value="span=5m">5 minutes</choice>
            <choice value="span=10m">10 minutes</choice>
            <choice value="span=15m">15 minutes</choice>
            <choice value="span=30m">30 minutes</choice>
            <choice value="span=1h">1 hour</choice>
            <choice value="span=2h">2 hours</choice>
            <choice value="span=12h">12 hours</choice>
            <choice value="span=4h">4 hours</choice>
            <choice value="span=1d">1 day</choice>
            <choice value="span=2d">2 days</choice>
            <choice value="span=1w">7 days</choice>
            <choice value="span=1mon">1 month</choice>
        </input>

        <input type="dropdown" token="refresh" searchWhenChanged="true">
            <label>Auto-refresh:</label>
            <fieldForLabel>label</fieldForLabel>
            <fieldForValue>value</fieldForValue>
            <selectFirstChoice>true</selectFirstChoice>
            <search>
                <query>| `def_auto_refresh`</query>
                <earliest>$timerange.earliest$</earliest>
                <latest>$timerange.latest$</latest>
            </search>
        </input>

    </fieldset>

    <!--
    Dynamic configuration
    The following searches are being used to define various tokens using event handlers
    -->

    <!-- OStype -->

    <search id="OSType_detection">
        <query>eventtype=nmon:performance host=$host$ | head 1 | stats count by OStype | fields OStype</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <progress>
            <condition match="'result.OStype'==&quot;Linux&quot;">
                <set token="is_Linux">true</set>
                <unset token="is_AIX"></unset>
                <unset token="is_Solaris"></unset>
            </condition>
            <condition match="'result.OStype'==&quot;AIX&quot;">
                <set token="is_AIX">true</set>
                <unset token="is_Linux"></unset>
                <unset token="is_Solaris"></unset>
            </condition>
            <condition match="'result.OStype'==&quot;Solaris&quot;">
                <set token="is_Solaris">true</set>
                <unset token="is_AIX"></unset>
                <unset token="is_Linux"></unset>
            </condition>
        </progress>
    </search>

    <!-- CPU data source (CPU_ALL versus LPAR) -->

    <search>
        <query>eventtype=nmon:performance type=LPAR host=$host$ | head 100 | stats count | where count&gt;0</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <progress>
            <condition match="$job.resultCount$ == 0">
                <set token="is_not_LPAR">true</set>
                <unset token="is_LPAR"></unset>
                <set token="CPU_datasource">CPU_ALL usage</set>
                <set token="CPU_datasource_minilabel">CPU % usage</set>
            </condition>
            <condition>
                <set token="is_LPAR">true</set>
                <unset token="is_not_LPAR"></unset>
                <set token="CPU_datasource">LPAR usage</set>
                <set token="CPU_datasource_minilabel">partition vCPUs usage</set>
            </condition>
        </progress>
    </search>

    <!-- TOP data availability -->

    <search>
        <query>eventtype=nmon:performance type=TOP host=$host$ | head 100 | stats count | where count&gt;0</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <progress>
            <condition match="$job.resultCount$ == 0">
                <set token="show_null_top">true</set>
            </condition>
            <condition>
                <unset token="show_null_top"/>
                <set token="start_top_searches">true</set>
            </condition>
        </progress>
    </search>

    <!-- UPTIME data availability -->

    <search>
        <query>eventtype=nmon:performance type=UPTIME host=$host$ load_average_1min="*" | head 100 | stats count | where count&gt;0</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <progress>
            <condition match="$job.resultCount$ == 0">
                    <unset token="start_uptime_searches"></unset>
                    <set token="show_null_uptime">true</set>
            </condition>
            <condition>
                    <set token="start_uptime_searches">true</set>
                    <unset token="show_null_uptime"></unset>
            </condition>
        </progress>
    </search>

    <!-- DG data availability -->

    <search>
        <query>eventtype=nmon:performance type=DGXFER host=$host$ value&gt;0 | head 100 | stats count | where count&gt;0</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <progress>
            <condition match="$job.resultCount$ == 0">
                    <set token="start_disk_stats_search">_time,*</set>
                    <unset token="start_dg_stats_search"></unset>
            </condition>
            <condition>
                    <set token="start_dg_stats_search">_time,*</set>
                    <unset token="start_disk_stats_search"></unset>
            </condition>
        </progress>
    </search>

    <!-- DF_STORAGE data availability -->

    <search>
        <query>eventtype=nmon:performance type=DF_STORAGE host=$host$ | head 100 | stats count | where count&gt;0</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <progress>
            <condition match="$job.resultCount$ == 0">
                    <set token="start_jfs_storage_search">true</set>
                    <unset token="start_df_storage_search"></unset>
            </condition>
            <condition>
                    <set token="start_df_storage_search">true</set>
                    <unset token="start_jfs_storage_search"></unset>
            </condition>
        </progress>
    </search>


    <!-- Configuration Search uses nmon_inventory -->

    <search id="configSearch" depends="$show_configuration$">
        <query>| inputlookup nmon_inventory
| rename hostname as host
| search host=$host$
| sort limit=0 host | eval OS_summary=upper(OStype)+" / "+OSversion
| fields host, OS_summary, cpu_cores, Processor</query>
        <earliest>0</earliest>
        <!-- Progress event has access to job properties only -->
        <progress>
            <condition match="'job.resultCount' == 0">
                <set token="show_null_config">True</set>
            </condition>
            <condition>
                <unset token="show_null_config"/>
            </condition>
        </progress>
    </search>

    <search id="MEMSearch" depends="$show_configuration$">
        <query>| tstats latest("MEM.allOS_Real_total_MB") AS mem_total_MB latest("MEM.allOS_Virtual_total_MB") AS swap_total_MB from datamodel=NMON_Data_MEM where (nodename = MEM) (host=$host$)
groupby host prestats=true
| stats dedup_splitvals=t latest("MEM.allOS_Real_total_MB") AS mem_total_MB latest("MEM.allOS_Virtual_total_MB") AS swap_total_MB by host
| foreach *total* [ eval &lt;&lt;FIELD&gt;&gt; = round('&lt;&lt;FIELD&gt;&gt;', 0) ]</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>

    <search id="CPUSearch_summary">
        <query>| tstats max("CPU.lpar_vp_usage_PCT") AS vp_usage avg("CPU.cpu_PCT") AS pct_usage from datamodel=NMON_Data_CPU where (nodename = CPU) (host=$host$) (CPU.type="CPU_ALL" OR CPU.type="LPAR") groupby _time, host prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max("CPU.lpar_vp_usage_PCT") AS vp_usage avg("CPU.cpu_PCT") AS pct_usage by _time, host
| eventstats count(eval(vp_usage>0)) as count_lpar
| eval usage=if(count_lpar>0, vp_usage, pct_usage)
| stats max(usage) AS max_usage avg(usage) AS avg_usage median(usage) AS median_usage | eval max_usage=round(max_usage, 2), avg_usage=round(avg_usage, 2), median_usage=round(median_usage, 2)</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>

    <search id="TOPSearch">
        <query>| tstats
max("TOP_ALLOS.pct_CPU") AS pct_CPU from datamodel=NMON_Data_TOP.TOP_ALLOS where (nodename = TOP_ALLOS) (host=$host$)
groupby _time, host, "TOP_ALLOS.logical_cpus", "TOP_ALLOS.virtual_cpus", "TOP_ALLOS.Command", "TOP_ALLOS.PID" prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t
max("TOP_ALLOS.pct_CPU") AS pct_CPU by _time, host, "TOP_ALLOS.logical_cpus", "TOP_ALLOS.virtual_cpus", "TOP_ALLOS.Command", "TOP_ALLOS.PID"
| rename "TOP_ALLOS.logical_cpus" AS logical_cpus, "TOP_ALLOS.virtual_cpus" AS virtual_cpus "TOP_ALLOS.Command" AS Command "TOP_ALLOS.PID" AS PID
| fields host, logical_cpus, virtual_cpus, Command, PID, pct_CPU
| eval limit=(logical_cpus*100)
| where (pct_CPU&lt;=limit)
| eval smt_threads=(logical_cpus/virtual_cpus)
| eval pct_CPU=case(isnum(smt_threads) AND smt_threads>="2", pct_CPU*1.2, isnum(smt_threads) AND smt_threads>="4", pct_CPU*1.4, isnum(smt_threads), pct_CPU)
| stats sum(pct_CPU) As pct_CPU,last(logical_cpus) As logical_cpus by _time,Command
| eval usage_per_core=(pct_CPU/100)
| stats sum(usage_per_core) As usage_per_core by _time,Command
| stats avg(usage_per_core) as avg_usage_per_core, max(usage_per_core) as max_usage_per_core by Command
| eval avg_usage_per_core=round(avg_usage_per_core,3)
| eval max_usage_per_core=round(max_usage_per_core,3)
| sort - avg_usage_per_core</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>

    <!-- Help the user -->

    <row rejects="$host$">
        <panel>
            <html>
                <div class="red_help_user">
                    <p>- - - - - - - - - - ACTION REQUIRED: please select your server name(s) in the host selector above - - - - - - - - - -</p>
                </div>
            </html>
        </panel>
    </row>

    <!-- Information panel -->

    <row rejects="$host$">
        <panel>
            <html>

                <div class="imgheader2">
                    <img src="../../static/app/nmon/icons/grey_theme/info.png" alt="Info"/>

                    <h4>The Nmon Summary interface has been designed for focused time ranges, very large time ranges may require time to be fully processed</h4>
                    <h4>For long time analysis, please consider using metric dedicated interfaces available from App home pages</h4>

                </div>

            </html>
        </panel>
    </row>

    <row>
        <panel>
            <viz type="nmon.radial_meter">
                <search base="CPUSearch_summary">
                    <query>gauge max_usage</query>
                </search>
                <option name="nmon.radial_meter.backgroundColor">#FFF</option>
                <option name="nmon.radial_meter.dialColor">#d0d5d9</option>
                <option name="nmon.radial_meter.valueColor">#555</option>
                <option name="nmon.radial_meter.minValue">0</option>
                <option name="nmon.radial_meter.maxValue">100</option>
                <option name="nmon.radial_meter.useRangemap">true</option>
                <option name="nmon.radial_meter.thresholdStyle">percentage</option>
                <option name="nmon.radial_meter.minRangeColor">#3fc77a</option>
                <option name="nmon.radial_meter.midRangeColor">#fbcd2f</option>
                <option name="nmon.radial_meter.midRangeThreshold">55</option>
                <option name="nmon.radial_meter.maxRangeColor">#b44441</option>
                <option name="nmon.radial_meter.maxRangeThreshold">85</option>
                <option name="nmon.radial_meter.caption">Max %CPU</option>
                <option name="height">180</option>
                <option name="refresh.display">preview</option>
            </viz>
        </panel>
        <panel>
            <viz type="nmon.radial_meter">
                <search base="CPUSearch_summary">
                    <query>gauge avg_usage</query>
                </search>
                <option name="nmon.radial_meter.backgroundColor">#FFF</option>
                <option name="nmon.radial_meter.dialColor">#d0d5d9</option>
                <option name="nmon.radial_meter.valueColor">#555</option>
                <option name="nmon.radial_meter.minValue">0</option>
                <option name="nmon.radial_meter.maxValue">100</option>
                <option name="nmon.radial_meter.useRangemap">true</option>
                <option name="nmon.radial_meter.thresholdStyle">percentage</option>
                <option name="nmon.radial_meter.minRangeColor">#3fc77a</option>
                <option name="nmon.radial_meter.midRangeColor">#fbcd2f</option>
                <option name="nmon.radial_meter.midRangeThreshold">55</option>
                <option name="nmon.radial_meter.maxRangeColor">#b44441</option>
                <option name="nmon.radial_meter.maxRangeThreshold">85</option>
                <option name="nmon.radial_meter.caption">Avg %CPU</option>
                <option name="height">180</option>
                <option name="refresh.display">preview</option>
            </viz>
        </panel>
        <panel>
            <viz type="nmon.radial_meter">
                <search base="CPUSearch_summary">
                    <query>gauge median_usage</query>
                </search>
                <option name="nmon.radial_meter.backgroundColor">#FFF</option>
                <option name="nmon.radial_meter.dialColor">#d0d5d9</option>
                <option name="nmon.radial_meter.valueColor">#555</option>
                <option name="nmon.radial_meter.minValue">0</option>
                <option name="nmon.radial_meter.maxValue">100</option>
                <option name="nmon.radial_meter.useRangemap">true</option>
                <option name="nmon.radial_meter.thresholdStyle">percentage</option>
                <option name="nmon.radial_meter.minRangeColor">#3fc77a</option>
                <option name="nmon.radial_meter.midRangeColor">#fbcd2f</option>
                <option name="nmon.radial_meter.midRangeThreshold">55</option>
                <option name="nmon.radial_meter.maxRangeColor">#b44441</option>
                <option name="nmon.radial_meter.maxRangeThreshold">85</option>
                <option name="nmon.radial_meter.caption">Median %CPU</option>
                <option name="height">180</option>
                <option name="refresh.display">preview</option>
            </viz>
        </panel>
    </row>

    <!-- ######################################### Active Buttons #########################################  -->

    <row>
        <panel>
            <html>
                <div class="custom-sub-nav" style="text-align: center;">
                    <button class="button2_lowpadding glow" data-token-name="show_configuration" data-alt-label="HIDE CONFIGURATION SUMMARY" data-token-value="fields *">SHOW CONFIGURATION SUMMARY</button>
                </div>
            </html>
        </panel>
        <panel>
            <html>
                <div class="custom-sub-nav" style="text-align: center;">
                    <button class="button2_lowpadding glow" data-token-name="show_uptime_load_average" data-alt-label="HIDE UPTIME LOAD AVERAGE" data-token-value="fields *">SHOW UPTIME LOAD AVERAGE</button>
                </div>
            </html>
        </panel>
    </row>

    <row depends="$show_configuration$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>Start host configuration</h1>
                </div>
            </html>
        </panel>
    </row>

    <row depends="$show_configuration$">

        <panel rejects="$show_null_config$">
            <title>Operating System</title>
            <single>
                <search base="configSearch">
                    <query>fields OS_summary</query>
                </search>
                <option name="drilldown">none</option>
                <option name="underLabel">Operating System Level</option>
            </single>
        </panel>

        <panel rejects="$show_null_config$">
            <title>Processor Configuration</title>
            <single>
                <search base="configSearch">
                    <query>fields cpu_cores</query>
                </search>
                <option name="drilldown">none</option>
                <option name="underLabel">Virtual Proc / Logical Cores</option>
            </single>
            <single>
                <search base="configSearch">
                    <query>fields Processor</query>
                </search>
                <option name="drilldown">none</option>
                <option name="underLabel">Processor Type</option>
            </single>
        </panel>

        <panel depends="$show_null_config$">
            <html>
                <p style="color:blue;margin-left:30px;font-size:14px;margin-top:50px">SYSTEM SUMMARY OVERVIEW Search returned no results, The nmon inventory data may not be available yet for this host, manually run the Nmon Inventory Generation report or wait for the auto update. (occurs every hour by default)</p>
            </html>
        </panel>

        <panel>
            <title>Memory Configuration</title>

            <single>
                <search base="MEMSearch">
                    <query>fields mem_total_MB</query>
                </search>
                <option name="drilldown">none</option>
                <option name="underLabel">Total Memory</option>
                <option name="unit">MB</option>
            </single>

            <single>
                <search base="MEMSearch">
                    <query>fields swap_total_MB</query>
                </search>
                <option name="drilldown">none</option>
                <option name="underLabel">Total Paging Space</option>
                <option name="unit">MB</option>
            </single>

        </panel>
    </row>

    <row depends="$show_configuration$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>End host configuration</h1>
                </div>
            </html>
        </panel>
    </row>

    <!-- nmon external UPTIME -->

    <search id="baseSearch_loadaverage" depends="$start_uptime_searches$">
        <query>| tstats max(CPU.UPTIME.load_average_1min) AS load_average_1min max(CPU.UPTIME.load_average_5min) AS load_average_5min max(CPU.UPTIME.load_average_15min) AS load_average_15min from datamodel=NMON_Data_CPU where (nodename = CPU.UPTIME) (host=$host$) groupby _time host prestats=true span=1m
| stats dedup_splitvals=t max(CPU.UPTIME.load_average_1min) AS load_average_1min max(CPU.UPTIME.load_average_5min) AS load_average_5min max(CPU.UPTIME.load_average_15min) AS load_average_15min by _time, host
| timechart $span$ avg(load_average_1min) as load_average_1min, avg(load_average_5min) as load_average_5min, avg(load_average_15min) as load_average_15min</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <sampleRatio>1</sampleRatio>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>

    <row depends="$show_uptime_load_average$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>Start uptime load average</h1>
                </div>
            </html>
        </panel>
    </row>

    <row depends="$show_uptime_load_average$ $show_null_uptime$">
        <panel>
            <html>
                <div class="red_help_user">
                    <p>- - - - - - - - - - UPTIME DATA UNAVAILABLE: The uptime data (nmon external collection) is not available, collecting these data require the TA-nmon 1.3.x minimum - - - - - - - - - -</p>
                </div>
            </html>
        </panel>
    </row>

    <row depends="$show_uptime_load_average$">
        <panel>
            <title>SYSTEM LOAD AVERAGE (nmon external: UPTIME)</title>
            <single>
                <search base="baseSearch_loadaverage">
                    <query>fields _time, load_average_1min | where isnotnull(load_average_1min)</query>
                </search>
                <option name="colorBy">trend</option>
                <option name="drilldown">all</option>
                <option name="numberPrecision">0.00</option>
                <option name="trendColorInterpretation">inverse</option>
                <option name="underLabel">load average 1min</option>
                <option name="useColors">1</option>
            </single>
            <single>
                <search base="baseSearch_loadaverage">
                    <query>fields _time, load_average_5min | where isnotnull(load_average_5min)</query>
                </search>
                <option name="colorBy">trend</option>
                <option name="drilldown">all</option>
                <option name="numberPrecision">0.00</option>
                <option name="trendColorInterpretation">inverse</option>
                <option name="underLabel">load average 5min</option>
                <option name="useColors">1</option>
            </single>
            <single>
                <search base="baseSearch_loadaverage">
                    <query>fields _time, load_average_15min | where isnotnull(load_average_15min)</query>
                </search>
                <option name="colorBy">trend</option>
                <option name="drilldown">all</option>
                <option name="numberPrecision">0.00</option>
                <option name="trendColorInterpretation">inverse</option>
                <option name="underLabel">load average 15min</option>
                <option name="useColors">1</option>
            </single>
            <single>
                <search depends="$start_uptime_searches$">
                    <query>| tstats latest(CPU.UPTIME.uptime) AS uptime from datamodel=NMON_Data_CPU where (nodename = CPU.UPTIME) (host=$host$) groupby host prestats=true
| stats dedup_splitvals=t latest(CPU.UPTIME.uptime) AS uptime
| eval uptime=if(uptime&lt;86400, round((uptime/3600), 2) . " hours", round((uptime/86400), 2) . " days" )
| fields uptime</query>
                    <earliest>-15m</earliest>
                    <latest>now</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="drilldown">all</option>
                <option name="underLabel">current server uptime</option>
            </single>
            <chart>
                <search base="baseSearch_loadaverage">
                    <query>fields _time,load_average_1min,load_average_5min,load_average_15min</query>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">collapsed</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">right</option>
                <option name="height">350</option>
            </chart>
            <table>
                <search base="baseSearch_loadaverage" depends="$start_uptime_searches$">
                    <query>stats latest(load_average_1min) as current_load_average_1min, avg(load_average_1min) as avg_load_average_1min, max(load_average_1min) as max_load_average_1min,
latest(load_average_5min) as current_load_average_5min, avg(load_average_5min) as avg_load_average_5min, max(load_average_5min) as max_load_average_5min,
latest(load_average_15min) as current_load_average_15min, avg(load_average_15min) as avg_load_average_15min, max(load_average_15min) as max_load_average_15min
| foreach * [ eval &lt;&lt;FIELD&gt;&gt; = round('&lt;&lt;FIELD&gt;&gt;', 2) ]
| eval "load average 1 min" =  "Current: " . current_load_average_1min . " Average: " . avg_load_average_1min . " Max: " . max_load_average_1min
| eval "load average 5 min" = "Current: " . current_load_average_5min . " Average: " . avg_load_average_5min . " Max: " . max_load_average_5min
| eval "load average 15 min" = "Current: " . current_load_average_15min . " Average: " . avg_load_average_15min . " Max: " . max_load_average_15min
| fields "load average *min" | transpose | eval order=case(column="load average 1 min", 1, column="load average 5 min", 2, column="load average 15 min", 3) | sort order | rename column as "By", "row 1" as "Load average" | fields By, "Load average"</query>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
            </table>
        </panel>

    </row>

    <row depends="$show_uptime_load_average$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>End uptime load average</h1>
                </div>
            </html>
        </panel>
    </row>

    <row>
        <panel id="cpu">
            <title>CPU Usage Statistics - $CPU_datasource_minilabel$</title>

            <chart>
                <search id="cputimechart">
                    <query>| tstats
max("CPU.lpar_vp_usage") AS vp_usage max("CPU.cpu_PCT") AS pct_usage
from datamodel=NMON_Data_CPU where (nodename = CPU) (host=$host$) (CPU.type="CPU_ALL" OR CPU.type="LPAR") groupby _time, host prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t
max("CPU.lpar_vp_usage") AS vp_usage max("CPU.cpu_PCT") AS pct_usage by _time, host
| eventstats count(eval(vp_usage>0)) as count_lpar
| eval usage=if(count_lpar>0, vp_usage, pct_usage)
| timechart $span$ max(usage) AS "Max CPU usage" avg(usage) AS "Avg CPU usage"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">350</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">$CPU_datasource_minilabel$</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="refresh.display">none</option>
            </chart>

        </panel>

        <panel id="disk">
            <title>I/O Operations per second</title>

            <chart depends="$start_dg_stats_search$">
                <search depends="$start_dg_stats_search$">
                    <query>| tstats max(dg.disk_total_iops) as disk_total_iops max(dg.disk_read_KB_per_sec) as disk_read_KB_per_sec max(dg.disk_write_KB_per_sec) as disk_write_KB_per_sec max(dg.disk_block_size_KB) as disk_block_size_KB from datamodel=NMON_Data_disks_dg where (nodename = dg) (host=$host$) groupby _time, host, dg.device prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max(dg.disk_total_iops) as disk_total_iops max(dg.disk_read_KB_per_sec) as disk_read_KB_per_sec max(dg.disk_write_KB_per_sec) as disk_write_KB_per_sec max(dg.disk_block_size_KB) as disk_block_size_KB by _time, host, dg.device
| rename "dg.device" AS device
| fields host, device, disk_*
| eval disk_read_iops=(disk_read_KB_per_sec/disk_block_size_KB), disk_write_iops=(disk_write_KB_per_sec/disk_block_size_KB)
| stats sum(disk_*) as "disk_*" by _time,host
| timechart $span$ max(disk_total_iops) As "max Total I/O", avg(disk_total_iops) As "avg Total I/O"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">350</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">I/O per second</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="refresh.display">none</option>
            </chart>

            <chart depends="$start_disk_stats_search$">
                <search id="IOPStimechart" depends="$start_disk_stats_search$">
                    <query>| tstats max("DISKXFER.value") AS iops from datamodel=NMON_Data_DISKXFER where (nodename = DISKXFER) (host=$host$)
groupby _time, host, "DISKXFER.device" prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max("DISKXFER.value") AS iops by _time, host, "DISKXFER.device"
| dedup _time, host, "DISKXFER.device", iops
| stats sum(iops) AS iops by _time, host
| timechart $span$ max(iops) As "max Total I/O", avg(iops) As "avg Total I/O"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">350</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">I/O per second</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <!-- ######################################### Active Buttons #########################################  -->

    <row>
        <panel>
            <html>
                <div class="custom-sub-nav" style="text-align: center;">
                    <button class="button2_lowpadding glow" data-token-name="show_cpu" data-alt-label="HIDE EXTENDED CPU STATS" data-token-value="true">SHOW EXTENDED CPU STATS</button>
                </div>
            </html>
        </panel>
        <panel>
            <html>
                <div class="custom-sub-nav" style="text-align: center;">
                    <button class="button2_lowpadding glow" data-token-name="show_disks" data-alt-label="HIDE EXTENDED DISKS STATS" data-token-value="true">SHOW EXTENDED DISKS STATS</button>
                </div>
            </html>
        </panel>
    </row>

    <!-- ######################################### CPU #########################################  -->

    <row depends="$show_cpu$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>Start extended CPU stats</h1>
                </div>
            </html>
        </panel>
    </row>

    <row depends="$show_cpu$" rejects="$is_LPAR$">
        <panel>
            <chart>
                <title>% CPU stats over time per category</title>
                <search depends="$show_cpu$">
                    <query>| tstats `CPU_ALL(max)` from datamodel=NMON_Data_CPU where (nodename = CPU.CPU_ALL) (host=$host$)
groupby _time, host prestats=true span=1m
| stats dedup_splitvals=t `CPU_ALL(max)` by _time, host
| timechart $span$
avg("CPU.Idle_PCT") AS "Idle %",
avg("CPU.Sys_PCT") AS "Sys %",
avg("CPU.User_PCT") AS "User %",
avg("CPU.Wait_PCT") AS "Wait %"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">%</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.maximumNumber">100</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <row depends="$show_cpu$" rejects="$is_LPAR$">
        <panel>
            <chart>
                <title>% CPU stats over time per core</title>
                <search depends="$show_cpu$">
                    <query>| tstats `CPU_ALL(max)` from datamodel=NMON_Data_CPU where (nodename = CPU.CPUnn) (host=$host$)
groupby _time, host, "CPU.CPUnn.logical_core" prestats=true span=1m
| stats dedup_splitvals=t `CPU_ALL(max)` by _time, host, "CPU.CPUnn.logical_core"
| timechart `nmon_span` useother=f limit=0 avg("CPU.cpu_PCT") AS cpu_PCT by "CPU.CPUnn.logical_core" | fields _time,_time, *</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">%</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.maximumNumber">100</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <!-- This is for AIX LPARs -->

    <row depends="$show_cpu$ $is_LPAR$ $is_AIX$">
        <panel>
            <chart>
                <title>AIX LPAR statistics</title>
                <search depends="$show_cpu$ $is_LPAR$ $is_AIX$">
                    <query>| tstats `LPAR(max)` from datamodel=NMON_Data_CPU where (nodename = CPU.LPAR) (host=$host$) groupby _time,"CPU.frameID",host prestats=true span=1m
| stats dedup_splitvals=t `LPAR(max)` by _time,"CPU.frameID",host
| rename CPU.lpar_vp_usage AS usage
| timechart $span$ max(usage) As usage max(CPU.entitled) As entitled, max(CPU.virtualCPUs) As virtualCPUs</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">Virtual CPUs</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <row depends="$show_cpu$ $is_LPAR$ $is_AIX$">
        <panel>
            <chart>
                <title>AIX LPAR statistics per category</title>
                <search depends="$show_cpu$ $is_LPAR$ $is_AIX$">
                    <query>| tstats max(CPU.VP_Idle_PCT) AS VP_Idle_PCT, max(CPU.VP_Sys_PCT) AS VP_Sys_PCT, max(CPU.VP_User_PCT) AS VP_User_PCT, max(CPU.VP_Wait_PCT) AS VP_Wait_PCT from datamodel=NMON_Data_CPU where (nodename = CPU.LPAR) (host=$host$) groupby _time,"CPU.frameID",host prestats=true span=1m
| stats dedup_splitvals=t max(CPU.VP_Idle_PCT) AS VP_Idle_PCT, max(CPU.VP_Sys_PCT) AS VP_Sys_PCT, max(CPU.VP_User_PCT) AS VP_User_PCT, max(CPU.VP_Wait_PCT) AS VP_Wait_PCT by _time,"CPU.frameID",host
| rename CPU.lpar_vp_usage AS usage
| timechart $span$ avg(VP_Idle_PCT) AS VP_Idle_PCT, avg(VP_Sys_PCT) AS VP_Sys_PCT, avg(VP_User_PCT) AS VP_User_PCT, avg(VP_Wait_PCT) AS VP_Wait_PCT</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked100</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <row depends="$show_cpu$ $is_LPAR$ $is_AIX$">
        <panel>
            <chart rejects="$show_null_AIX_pooldata$">
                <title>AIX LPAR Pools statistics</title>
                <search depends="$show_cpu$ $is_LPAR$ $is_AIX$">
                    <query>| tstats max("CPU.poolCPUs") AS "CPU.poolCPUs" max("CPU.LPAR.Pool_usage") AS usage values("CPU.LPAR.Pool_id") AS "CPU.LPAR.Pool_id" from datamodel=NMON_Data_CPU where (nodename = CPU.LPAR) (host=$host$) (CPU.PoolIdle!=0) groupby _time, "CPU.frameID", host prestats=true span=1m
| stats dedup_splitvals=t max("CPU.poolCPUs") AS "CPU.poolCPUs" max("CPU.LPAR.Pool_usage") AS usage values("CPU.LPAR.Pool_id") AS "CPU.LPAR.Pool_id" by _time, "CPU.frameID", host
| rename CPU.LPAR.Pool_usage AS usage
| timechart $span$ max(usage) As usage max(CPU.poolCPUs) AS poolCPUs</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                    <progress>
                        <condition match="$job.resultCount$ == 0">
                            <set token="show_null_AIX_pooldata">true</set>
                        </condition>
                        <condition>
                            <unset token="show_null_AIX_pooldata"/>
                        </condition>
                    </progress>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">Virtual CPUs</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
            <html depends="$show_null_AIX_pooldata$">
                <p style="color:blue;margin-left:30px;font-size:14px"><b>AIX LPAR Pools statistics:</b> Search returned no results, this partition might not be allowed to retrieve the pool statistics it belongs to.</p>
            </html>
        </panel>
    </row>

    <!-- This is for PowerLinux LPARs -->

    <row depends="$show_cpu$ $is_LPAR$ $is_Linux$">
        <panel>
            <chart>
                <title>PowerLinux LPAR statistics</title>
                <search depends="$show_cpu$ $is_LPAR$ $is_Linux$">
                    <query>| tstats max("CPU.lpar_vp_usage") AS usage max("CPU.LPAR_Linux.partition_active_processors") AS partition_active_processors max("CPU.LPAR_Linux.partition_entitled_capacity") AS partition_entitled_capacity from datamodel=NMON_Data_CPU where (nodename = CPU.LPAR_Linux) (host=$host$) groupby _time, host, "CPU.frameID" prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max("CPU.lpar_vp_usage") AS usage max("CPU.LPAR_Linux.partition_active_processors") AS partition_active_processors max("CPU.LPAR_Linux.partition_entitled_capacity") AS partition_entitled_capacity by _time, host, "CPU.frameID"
| timechart $span$ max(usage) AS PhysicalCPU max(partition_entitled_capacity) As partition_entitled_capacity, max(partition_active_processors) As partition_active_processors</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">Virtual CPUs</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <row depends="$show_cpu$ $is_LPAR$ $is_Linux$">
        <panel>
            <chart>
                <title>PowerLinux LPAR Pools statistics</title>
                <search depends="$show_cpu$ $is_LPAR$ $is_Linux$">
                    <query>| tstats max("CPU.lpar_pool_capacity") AS "CPU.lpar_pool_capacity" max("CPU.lpar_pool_vp_usage") AS usage from datamodel=NMON_Data_CPU where (nodename = CPU.LPAR_Linux.LPAR_Linux_Pool) (host=$host$) groupby _time, "CPU.frameID", host prestats=true span=1m
| stats dedup_splitvals=t max("CPU.lpar_pool_capacity") AS "CPU.lpar_pool_capacity" max("CPU.lpar_pool_vp_usage") AS usage by _time, "CPU.frameID", host
| rename CPU.lpar_pool_vp_usage AS usage
| timechart $span$ max(usage) As usage max(CPU.lpar_pool_capacity) AS poolCPUs</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">Virtual CPUs</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <!-- This is for Solaris -->

    <row depends="$show_cpu$ $is_Solaris$">
        <panel>
            <chart>
                <title>Solaris WML statistics per zone</title>
                <search depends="$show_cpu$ $is_Solaris$">
                    <query>| tstats max("WLM.value") AS value from datamodel=NMON_Data_WLM where (nodename = WLM.WLMZONECPU) (host=$host$) groupby _time, host, "WLM.device" prestats=true span=1m
| stats dedup_splitvals=t max("WLM.value") AS value by _time, host, "WLM.device"
| rename "WLM.*" AS * | eval key=host+":"+device | timechart $span$ limit=0 useother=f max(value) As value by key</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">% CPU</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <row depends="$show_cpu$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>End extended CPU stats</h1>
                </div>
            </html>
        </panel>
    </row>

    <!-- ######################################### DISKS #########################################  -->

    <!--  disks extended stats (DG*) -->

    <row depends="$show_disks$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>Start extended Disks stats</h1>
                </div>
            </html>
        </panel>
    </row>

    <row depends="$show_disks$ $start_dg_stats_search$">
        <panel>
            <chart>
                <title>Avg I/O per sec over time - click on the chart to get by device view</title>
                <search depends="$show_disks$ $start_dg_stats_search$">
                    <query>| tstats max(dg.disk_total_iops) as disk_total_iops max(dg.disk_read_KB_per_sec) as disk_read_KB_per_sec max(dg.disk_write_KB_per_sec) as disk_write_KB_per_sec max(dg.disk_block_size_KB) as disk_block_size_KB from datamodel=NMON_Data_disks_dg where (nodename = dg) (host=$host$) groupby _time, host, dg.device prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max(dg.disk_total_iops) as disk_total_iops max(dg.disk_read_KB_per_sec) as disk_read_KB_per_sec max(dg.disk_write_KB_per_sec) as disk_write_KB_per_sec max(dg.disk_block_size_KB) as disk_block_size_KB by _time, host, dg.device
| rename "dg.device" AS device
| fields host, device, disk_*
| eval disk_read_iops=(disk_read_KB_per_sec/disk_block_size_KB), disk_write_iops=(disk_write_KB_per_sec/disk_block_size_KB)
| stats sum(disk_*) as "disk_*" by _time,host
| timechart $span$ avg(disk_total_iops) as disk_total_iops | trendline sma5(disk_total_iops) AS trend</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">I/O per sec</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
                <drilldown target="search">
                    <link>search?earliest=$timerange.earliest$&amp;latest=$timerange.latest$&amp;q=eventtype=nmon:performance type=DGXFER host=$host$
| timechart $span$ limit=0 useother=f avg(disk_total_iops) as disk_total_iops by device&amp;display.general.type=visualizations&amp;display.page.search.tab=visualizations&amp;display.visualizations.charting.chart=line</link>
                </drilldown>
            </chart>
        </panel>
        <panel>
            <chart>
                <title>Avg read/write I/O per sec over time - click on the chart to get by device view</title>
                <search depends="$start_dg_stats_search$">
                    <query>| tstats max(dg.disk_total_iops) as disk_total_iops max(dg.disk_read_KB_per_sec) as disk_read_KB_per_sec max(dg.disk_write_KB_per_sec) as disk_write_KB_per_sec max(dg.disk_block_size_KB) as disk_block_size_KB from datamodel=NMON_Data_disks_dg where (nodename = dg) (host=$host$) groupby _time, host, dg.device prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max(dg.disk_total_iops) as disk_total_iops max(dg.disk_read_KB_per_sec) as disk_read_KB_per_sec max(dg.disk_write_KB_per_sec) as disk_write_KB_per_sec max(dg.disk_block_size_KB) as disk_block_size_KB by _time, host, dg.device
| rename "dg.device" AS device
| fields host, device, disk_*
| eval disk_read_iops=(disk_read_KB_per_sec/disk_block_size_KB), disk_write_iops=(disk_write_KB_per_sec/disk_block_size_KB)
| stats sum(disk_*) as "disk_*" by _time,host
| timechart $span$ avg(disk_read_iops) as disk_read_iops avg(disk_write_iops) as disk_write_iops</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">I/O per sec</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
                <drilldown target="search">
                    <link>search?earliest=$timerange.earliest$&amp;latest=$timerange.latest$&amp;q=eventtype=nmon:performance type=DGSIZE OR type=DGREAD OR type=DGWRITE host=$host$
| stats max(disk_*) as "disk_*" by _time,host,device
| eval disk_read_iops=(disk_read_KB_per_sec/disk_block_size_KB), disk_write_iops=(disk_write_KB_per_sec/disk_block_size_KB)
| timechart $span$ limit=0 useother=f avg(disk_read_iops) as disk_read_iops, avg(disk_write_iops) as disk_write_iops by device&amp;display.general.type=visualizations&amp;display.page.search.tab=visualizations&amp;display.visualizations.charting.chart=line</link>
                </drilldown>
            </chart>
        </panel>
    </row>

    <row depends="$show_disks$ $start_dg_stats_search$">
        <panel>
            <chart>
                <title>Avg % busy time - click on the chart to get by device view</title>
                <search depends="$show_disks$ $start_dg_stats_search$">
                    <query>| tstats max(dg.disk_busy_time_pct) as disk_busy_time_pct from datamodel=NMON_Data_disks_dg where (nodename = dg) (dg.disk_busy_time_pct&gt;=0) (host=$host$) groupby _time, host, dg.device prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max(dg.disk_busy_time_pct) as disk_busy_time_pct by _time, host, dg.device
| rename "dg.device" AS device
| fields host, device, disk_*
| stats avg(disk_*) as "disk_*" by _time,host
| timechart $span$ avg(disk_busy_time_pct) as disk_busy_time_pct | trendline sma5(disk_busy_time_pct) AS trend</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">% of time busy</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
                <drilldown target="search">
                    <link>search?earliest=$timerange.earliest$&amp;latest=$timerange.latest$&amp;q=eventtype=nmon:performance type=DGBUSY host=$host$
| timechart $span$ limit=0 useother=f avg(disk_busy_time_pct) as disk_busy_time_pct by device&amp;display.general.type=visualizations&amp;display.page.search.tab=visualizations&amp;display.visualizations.charting.chart=line</link>
                </drilldown>
            </chart>
        </panel>
        <panel>
            <chart>
                <title>Avg data transfer size over time - click on the chart to get by device view</title>
                <search depends="$start_dg_stats_search$">
                    <query>| tstats max(dg.disk_block_size_KB) as disk_block_size_KB from datamodel=NMON_Data_disks_dg where (nodename = dg) (host=$host$) groupby _time, host, dg.device prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max(dg.disk_block_size_KB) as disk_block_size_KB by _time, host, dg.device
| rename "dg.device" AS device
| fields host, device, disk_*
| stats avg(disk_*) as "disk_*" by _time,host
| timechart $span$ avg(disk_block_size_KB) as disk_block_size_KB | trendline sma5(disk_block_size_KB) AS trend</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">KBytes per transfer</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
                <drilldown target="search">
                    <link>search?earliest=$timerange.earliest$&amp;latest=$timerange.latest$&amp;q=eventtype=nmon:performance type=DGSIZE host=$host$
| timechart $span$ limit=0 useother=f avg(disk_block_size_KB) as disk_block_size_KB by device&amp;display.general.type=visualizations&amp;display.page.search.tab=visualizations&amp;display.visualizations.charting.chart=line</link>
                </drilldown>
            </chart>
        </panel>
    </row>

    <row depends="$show_disks$ $start_dg_stats_search$">
        <panel>
            <chart>
                <title>Avg read/write data rate (KBytes/sec) - click on the chart to get by device view</title>
                <search depends="$show_disks$ $start_dg_stats_search$">
                    <query>| tstats max(dg.disk_read_KB_per_sec) as disk_read_KB_per_sec max(dg.disk_write_KB_per_sec) as disk_write_KB_per_sec from datamodel=NMON_Data_disks_dg where (nodename = dg) (host=$host$) groupby _time, host, dg.device prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max(dg.disk_read_KB_per_sec) as disk_read_KB_per_sec max(dg.disk_write_KB_per_sec) as disk_write_KB_per_sec by _time, host, dg.device
| rename "dg.device" AS device
| fields host, device, disk_*
| stats avg(disk_*) as "disk_*" by _time,host
| timechart $span$ avg(disk_read_KB_per_sec) as disk_read_KB_per_sec avg(disk_write_KB_per_sec) as disk_write_KB_per_sec</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">KBytes/sec</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
                <drilldown target="search">
                    <link>search?earliest=$timerange.earliest$&amp;latest=$timerange.latest$&amp;q=eventtype=nmon:performance type=DGREAD OR type=DGWRITE host=$host$
| timechart $span$ limit=0 useother=f max(disk_read_KB_per_sec) as disk_read_KB_per_sec max(disk_write_KB_per_sec) as disk_write_KB_per_sec by device&amp;display.general.type=visualizations&amp;display.page.search.tab=visualizations&amp;display.visualizations.charting.chart=line</link>
                </drilldown>
            </chart>
        </panel>
        <panel>
            <chart>
                <title>Avg read/write service time (ms) - click on the chart to get by device view</title>
                <search depends="$start_dg_stats_search$">
                    <query>| tstats max(dg.disk_read_service_time_ms) as disk_read_service_time_ms max(dg.disk_write_service_time_ms) as disk_write_service_time_ms from datamodel=NMON_Data_disks_dg where (nodename = dg) (host=$host$) groupby _time, host, dg.device prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t max(dg.disk_read_service_time_ms) as disk_read_service_time_ms max(dg.disk_write_service_time_ms) as disk_write_service_time_ms by _time, host, dg.device
| rename "dg.device" AS device
| fields host, device, disk_*
| stats avg(disk_*) as "disk_*" by _time,host
| timechart $span$ avg(disk_read_service_time_ms) as disk_read_service_time_ms avg(disk_write_service_time_ms) as disk_write_service_time_ms</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">Milliseconds (ms)</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
                <drilldown target="search">
                    <link>search?earliest=$timerange.earliest$&amp;latest=$timerange.latest$&amp;q=eventtype=nmon:performance type=DGREADSERV OR type=DGWRITESERV host=$host$
| timechart $span$ limit=0 useother=f max(disk_read_service_time_ms) as disk_read_service_time_ms max(disk_write_service_time_ms) as disk_write_service_time_ms by device&amp;display.general.type=visualizations&amp;display.page.search.tab=visualizations&amp;display.visualizations.charting.chart=line</link>
                </drilldown>
            </chart>
        </panel>
    </row>

    <!--  disks standard stats (DISK*) -->

    <row depends="$show_disks$ $start_disk_stats_search$">
        <panel>
            <chart>
                <title>Avg I/O per sec over time</title>
                <search depends="$show_disks$ $start_disk_stats_search$">
                    <query>| tstats max("DISKXFER.value") AS DISKXFER.value from datamodel=NMON_Data_DISKXFER where (nodename = DISKXFER) (host="$host$") groupby _time, host, "DISKXFER.device" prestats=true span=1m
| stats dedup_splitvals=t max("DISKXFER.value") AS DISKXFER.value by _time, host, "DISKXFER.device"
| rename "DISKXFER.*" AS *
| dedup _time, host, device, value
| stats dedup_splitvals=t sum(value) AS value by _time, host
| timechart $span$ avg(value) As iops | trendline sma5(iops) AS trend</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">I/O per sec</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
        <panel>
            <chart>
                <title>Avg % time busy disk over time</title>
                <search depends="$show_disks$ $start_disk_stats_search$">
                    <query>| tstats max("DISKBUSY.value") AS DISKBUSY.value from datamodel=NMON_Data_DISKBUSY where (nodename = DISKBUSY) (host="$host$") groupby _time, "host", "DISKBUSY.device" prestats=true span=1m
| stats dedup_splitvals=t max("DISKBUSY.value") AS DISKBUSY.value by _time, "host", "DISKBUSY.device"
| rename "DISKBUSY.*" AS *
| dedup _time, host, device, value
| stats dedup_splitvals=t avg(value) AS value by _time, host
| timechart $span$ avg(value) As busy_time | trendline sma5(busy_time) AS trend</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">% of time busy</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <row depends="$show_disks$ $start_disk_stats_search$">
        <panel>
            <chart>
                <title>Avg data transfer size over time</title>
                <search depends="$show_disks$ $start_disk_stats_search$">
                    <query>| tstats max("DISKBSIZE.value") AS DISKBSIZE.value from datamodel=NMON_Data_DISKBSIZE where (nodename = DISKBSIZE) (host="$host$") groupby _time, "host", "DISKBSIZE.device" prestats=true span=1m
| stats dedup_splitvals=t max("DISKBSIZE.value") AS DISKBSIZE.value by _time, "host", "DISKBSIZE.device"
| rename "DISKBSIZE.*" AS *
| dedup _time, host, device, value
| stats dedup_splitvals=t sum(value) AS value by _time, host
| timechart $span$ avg(value) As avg_transfer_size | trendline sma5(avg_transfer_size) AS trend</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">KBytes per transfer</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
        <panel>
            <chart>
                <title>Avg read/write data rate (KBytes/sec) over time</title>
                <search depends="$show_disks$ $start_disk_stats_search$">
                    <query>| tstats max("DISKREADWRITE.value") AS value from datamodel=NMON_Data_DISKREADWRITE where (nodename = DISKREADWRITE) (host="$host$") groupby _time, "DISKREADWRITE.type", "host", "DISKREADWRITE.device" prestats=true span=1m | stats dedup_splitvals=t max("DISKREADWRITE.value") AS value by _time, "DISKREADWRITE.type", "host", "DISKREADWRITE.device" | sort limit=0 _time | rename "DISKREADWRITE.type" AS type "host" AS host "DISKREADWRITE.device" AS device | fields _time, type, host, device, value
| eval key=case(type=="DISKREAD", "read", type=="DISKWRITE", "write")
| dedup _time, key, value
| stats sum(value) AS value by _time, key
| timechart $span$ avg(value) As avg_data_rate by key</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">KBytes/sec</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">top</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="height">500</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <row depends="$show_disks$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>End extended Disks stats</h1>
                </div>
            </html>
        </panel>
    </row>

    <row>
        <panel id="mem">
            <title>Memory Statistics</title>

            <chart>
                <search id="MEMtimechart">
                    <query>| tstats max(MEM.mem_used_effective_PCT) AS mem_used_effective_PCT max(MEM.swap_used_effective_PCT) AS swap_used_effective_PCT from datamodel=NMON_Data_MEM where (nodename = MEM) (host=$host$)
groupby _time host prestats=true span=1m
| stats dedup_splitvals=t max(MEM.mem_used_effective_PCT) AS mem_used_effective_PCT max(MEM.swap_used_effective_PCT) AS swap_used_effective_PCT by _time, host
| timechart $span$ dedup_splitvals=t avg(mem_used_effective_PCT) AS mem_used_PCT, avg(swap_used_effective_PCT) AS swap_used_PCT</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">350</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">Percentage (%)</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.maximumNumber">100</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>

        <panel id="process">
            <title>Top 20 processes CPU Statistics</title>

            <chart rejects="$show_null_top$">
                <search id="TOPtimechart" depends="$start_top_searches$">
                    <query>| tstats
max("TOP_ALLOS.pct_CPU") AS pct_CPU from datamodel=NMON_Data_TOP.TOP_ALLOS where (nodename = TOP_ALLOS) (host=$host$)
groupby _time, host, "TOP_ALLOS.logical_cpus","TOP_ALLOS.virtual_cpus", "TOP_ALLOS.Command", "TOP_ALLOS.PID" prestats=true span=1m
| bucket _time span=1m
| stats dedup_splitvals=t
max("TOP_ALLOS.pct_CPU") AS pct_CPU by _time, host, "TOP_ALLOS.logical_cpus", "TOP_ALLOS.virtual_cpus", "TOP_ALLOS.Command", "TOP_ALLOS.PID"
| rename "TOP_ALLOS.logical_cpus" AS logical_cpus, "TOP_ALLOS.virtual_cpus" AS virtual_cpus, "TOP_ALLOS.Command" AS Command, "TOP_ALLOS.PID" AS PID
| fields host, logical_cpus, virtual_cpus, Command, PID, pct_CPU
| eval limit=(logical_cpus*100)
| where (pct_CPU&lt;=limit)
| eval smt_threads=(logical_cpus/virtual_cpus)
| eval pct_CPU=case(isnum(smt_threads) AND smt_threads>="2", pct_CPU*1.2, isnum(smt_threads) AND smt_threads>="4", pct_CPU*1.4, isnum(smt_threads), pct_CPU)
| stats sum(pct_CPU) As pct_CPU,last(logical_cpus) As logical_cpus by _time,Command
| eval usage_per_core=(pct_CPU/100) | stats sum(usage_per_core) As usage_per_core by _time,Command
| timechart $span$ useother=f limit="20" max(usage_per_core) as "CPU Usage per core" by Command</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.nullValueMode">0</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">350</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisTitleY.text">Logical Core</option>
                <option name="refresh.display">none</option>
            </chart>

            <html depends="$show_null_top$">
                <p style="color:blue;margin-left:30px;font-size:14px">Search returned no results, TOP collection (processes activity) has not been activated or no processes were captured due to lack of activity</p>
            </html>

        </panel>
    </row>

    <!-- ######################################### Active Buttons #########################################  -->

    <row>
        <panel>
            <html>
                <div class="custom-sub-nav" style="text-align: center;">
                    <button class="button2_lowpadding glow" data-token-name="show_memory" data-alt-label="HIDE EXTENDED MEMORY STATS" data-token-value="true">SHOW EXTENDED MEMORY STATS</button>
                </div>
            </html>
        </panel>
        <panel>
            <html>
                <div class="custom-sub-nav" style="text-align: center;">
                    <button class="button2_lowpadding glow" data-token-name="show_processes" data-alt-label="HIDE EXTENDED PROCESSES STATS" data-token-value="true">SHOW EXTENDED PROCESSES STATS</button>
                </div>
            </html>
        </panel>
    </row>

    <!-- ######################################### Memory #########################################  -->

    <row depends="$show_memory$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>Start extended Memory stats</h1>
                </div>
            </html>
        </panel>
    </row>

    <search id="linux_memory_stats" depends="$show_memory$ $is_Linux$">
        <query>| tstats `memory_linux_dm(max)` from datamodel=NMON_Data_MEM where (nodename = MEM.Linux) (host=$host$)
groupby _time host prestats=true span=1m
| stats dedup_splitvals=t `memory_linux_dm(max)` by _time, host
| timechart $span$ dedup_splitvals=t avg(*) AS *</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>

    <search id="AIX_mem_memory_stats" depends="$show_memory$ $is_AIX$">
        <query>| tstats max("MEM.allOS_Real_total_MB") AS Real_total_MB max("MEM.allOS_Real_used_MB") AS Real_used_MB
max("MEM.allOS_Virtual_total_MB") AS Virtual_total_MB max("MEM.allOS_Virtual_used_MB") AS Virtual_used_MB
from datamodel=NMON_Data_MEM where (nodename = MEM) (host=$host$) groupby _time, "MEM.frameID", host prestats=true span=1m
| stats dedup_splitvals=t max("MEM.allOS_Real_total_MB") AS Real_total_MB max("MEM.allOS_Real_used_MB") AS Real_used_MB
max("MEM.allOS_Virtual_total_MB") AS Virtual_total_MB max("MEM.allOS_Virtual_used_MB") AS Virtual_used_MB by _time,host
| timechart $span$ avg(Real_total_MB) AS Real_total_MB avg(Real_used_MB) AS Real_used_MB
avg(Virtual_total_MB) AS Virtual_total_MB avg(Virtual_used_MB) AS Virtual_used_MB</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>

    <search id="AIX_memnew_memory_stats" depends="$show_memory$ $is_AIX$">
        <query>| tstats
max("MEMNEW.Free_PCT") AS Free_PCT max("MEMNEW.FScache_PCT") AS FScache_PCT max("MEMNEW.memused_PCT") AS memused_PCT
max("MEMNEW.Process_PCT") AS Process_PCT max("MEMNEW.System_PCT") AS System_PCT from datamodel=NMON_Data_MEMNEW
where (nodename = MEMNEW) (host=$host$) groupby _time, host prestats=true span=1m
| stats max("MEMNEW.Free_PCT") AS Free_PCT max("MEMNEW.FScache_PCT") AS FScache_PCT max("MEMNEW.memused_PCT") AS memused_PCT
max("MEMNEW.Process_PCT") AS Process_PCT max("MEMNEW.System_PCT") AS System_PCT by _time,host
| timechart $span$
avg(Free_PCT) AS Free_PCT avg(FScache_PCT) AS FScache_PCT avg(memused_PCT) AS memused_PCT
avg(Process_PCT) AS Process_PCT avg(System_PCT) AS System_PCT</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>

    <search id="Solaris_MEM_real" depends="$show_memory$ $is_Solaris$">
        <query>| tstats
max("MEM.memused") AS memused_MB max("MEM.memfree") AS memfree_MB max("MEM.memtotal") AS memtotal_MB
from datamodel=NMON_Data_MEM where (nodename = MEM) (host=$host$)
groupby _time, host prestats=true span=1m
| stats max("MEM.memused") AS memused_MB max("MEM.memfree") AS memfree_MB max("MEM.memtotal") AS memtotal_MB by _time, host
| timechart $span$
avg(memused_MB) AS memused_MB avg(memfree_MB) AS memfree_MB avg(memtotal_MB) AS memtotal_MB</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>

    <search id="Solaris_MEM_swap" depends="$show_memory$ $is_Solaris$">
        <query>| tstats
max("MEM.swapused") AS swapused_MB max("MEM.swapfree") AS swapfree_MB max("MEM.swaptotal") AS swaptotal_MB
from datamodel=NMON_Data_MEM where (nodename = MEM) (host=$host$)
groupby _time, "MEM.frameID", host prestats=true span=1m
| stats max("MEM.swapused") AS swapused_MB max("MEM.swapfree") AS swapfree_MB max("MEM.swaptotal") AS swaptotal_MB by _time, host
| timechart $span$
avg(swapused_MB) AS swapused_MB avg(swapfree_MB) AS swapfree_MB avg(swaptotal_MB) AS swaptotal_MB</query>
        <earliest>$timerange.earliest$</earliest>
        <latest>$timerange.latest$</latest>
        <refresh>$refresh$</refresh>
        <refreshType>delay</refreshType>
    </search>


    <row depends="$show_memory$">
        <panel>
            <chart depends="$is_Linux$">
                <title>Memory usage (MB) by main metrics</title>
                <search base="linux_memory_stats">
                    <query>fields _time, *mem_free_MB*, *mem_cached_MB*, *mem_buffers_MB*, *mem_used_effective_MB*, *mem_total_MB*</query>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">500</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">volume (MB)</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.overlayFields">mem_total_MB</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.fieldColors">{"mem_total_MB": 0xe50000}</option>
                <option name="refresh.display">none</option>
            </chart>
            <chart depends="$is_AIX$">
                <title>AIX % memory allocation by category</title>
                <search base="AIX_memnew_memory_stats">
                    <query>fields _time,Free_PCT,FScache_PCT,Process_PCT,System_PCT</query>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">500</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">Percentage (%)</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.maximumNumber">100</option>
                <option name="refresh.display">none</option>
            </chart>
            <chart depends="$is_Solaris$">
                <title>Solaris memory usage (MB)</title>
                <search base="Solaris_MEM_real">
                    <query>fields _time,memfree_MB,memused_MB,memtotal_MB</query>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">500</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">Megabytes (MB)</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.chart.overlayFields">memtotal_MB</option>
                <option name="charting.fieldColors">{"memtotal_MB": 0xe50000}</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>

        <panel>
            <chart depends="$is_Linux$">
                <title>Swap effective used/cached/free/global (MB)</title>
                <search base="linux_memory_stats">
                    <query>fields _time, *swap_free_MB*, *swap_used_effective_MB*, *swap_cached_MB*, *swap_total_MB*</query>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">500</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">volume (MB)</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.overlayFields">swap_total_MB</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.fieldColors">{"swap_total_MB": 0xe50000}</option>
                <option name="refresh.display">none</option>
            </chart>
            <chart depends="$is_AIX$">
                <title>AIX paging Space usage (MB)</title>
                <search base="AIX_mem_memory_stats">
                    <query>fields _time,Virtual_total_MB,Virtual_used_MB</query>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">500</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">Megabytes (MB)</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisTitleY.text">Virtual_total_MB</option>
                <option name="charting.chart.overlayFields">Virtual_total_MB</option>
                <option name="charting.fieldColors">{"Virtual_total_MB": 0xe50000}</option>
                <option name="refresh.display">none</option>
            </chart>
            <chart depends="$is_Solaris$">
                <title>Solaris swap usage (MB)</title>
                <search base="Solaris_MEM_swap">
                    <query>fields _time,swapfree_MB,swapused_MB,swaptotal_MB</query>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">stacked</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">500</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">Megabytes (MB)</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.chart.overlayFields">swaptotal_MB</option>
                <option name="charting.fieldColors">{"swaptotal_MB": 0xe50000}</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>

    <row depends="$show_memory$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>End extended Memory stats</h1>
                </div>
            </html>
        </panel>
    </row>

    <!-- ######################################### Processes #########################################  -->

    <row depends="$show_processes$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>Start extended processes stats</h1>
                </div>
            </html>
        </panel>
    </row>

    <row depends="$show_processes$">
        <panel>

            <single>
                <search base="TOPSearch">
                    <query>head 1 | fields Command</query>
                </search>
                <option name="drilldown">none</option>
                <option name="underLabel">TOP Process</option>
                <option name="numberPrecision">0.00</option>
                <option name="unit">Command</option>
                <option name="unitPosition">before</option>
                <option name="refresh.display">none</option>
            </single>

            <single>
                <search base="TOPSearch">
                    <query>head 1 | fields avg_usage_per_core</query>
                </search>
                <option name="drilldown">none</option>
                <option name="underLabel">Average Conso for this Command</option>
                <option name="numberPrecision">0.00</option>
                <option name="unit">core conso</option>
                <option name="unitPosition">before</option>
                <option name="refresh.display">none</option>
            </single>

            <single>
                <search base="TOPSearch">
                    <query>head 1 | fields max_usage_per_core</query>
                </search>
                <option name="drilldown">none</option>
                <option name="underLabel">Max Conso for this Command</option>
                <option name="numberPrecision">0.00</option>
                <option name="unit">core conso</option>
                <option name="unitPosition">before</option>
                <option name="refresh.display">none</option>
            </single>

        </panel>
    </row>

    <row depends="$show_processes$">

        <!-- Table stats of CPU processes usage -->

        <panel>
            <table depends="$is_Linux$">
                <title>Table stats: CPU Usage in logical core per Command invocation</title>
                <search depends="$is_Linux$ $show_processes$ $start_top_searches$">
                    <query>| tstats max("TOP_Linux.pct_CPU") AS pct_CPU from datamodel=NMON_Data_TOP.TOP_Linux
where (nodename = TOP_Linux) (host=$host$)
groupby _time, "TOP_Linux.frameID", host, "TOP_Linux.logical_cpus", "TOP_Linux.Command", "TOP_Linux.PID" prestats=true span=1m
| stats dedup_splitvals=t max("TOP_Linux.pct_CPU") AS pct_CPU by _time, "TOP_Linux.frameID", host, "TOP_Linux.logical_cpus", "TOP_Linux.Command", "TOP_Linux.PID"
| rename "TOP_Linux.frameID" AS frameID, "TOP_Linux.logical_cpus" AS logical_cpus "TOP_Linux.Command" AS Command "TOP_Linux.PID" AS PID
| eval limit=(logical_cpus*100) | where (pct_CPU&lt;=limit)
| stats sum(pct_CPU) As pct_CPU,last(logical_cpus) As logical_cpus by _time,frameID,host,Command
| eval usage_per_core=(pct_CPU/100)
| stats sum(usage_per_core) As value by _time,frameID,host,Command
| eval frameID=if(isnull(frameID), "aggreg", frameID)
| stats max(value) as "max CPU usage per core", avg(value) as "avg CPU usage per core", sparkline(max(value)) As sparkline by Command
| foreach *CPU* [ eval &lt;&lt;FIELD&gt;&gt;=round('&lt;&lt;FIELD&gt;&gt;', 3) ]
| sort - "max CPU usage per core"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="wrap">true</option>
                <option name="rowNumbers">false</option>
                <option name="dataOverlayMode">none</option>
                <option name="drilldown">cell</option>
                <option name="count">10</option>
                <option name="refresh.display">none</option>
                <!-- Set sparkline options here; make sure that field matches field name of the search results -->
                <format type="sparkline" field="sparkline">
                    <option name="lineColor">#5379af</option>
                    <option name="fillColor">#CCDDFF</option>
                    <option name="lineWidth">1</option>
                    <option name="height">25</option>
                </format>
            </table>
            <table depends="$is_AIX$">
                <title>Table stats: CPU Usage in logical core per Command invocation</title>
                <search depends="$is_AIX$ $show_processes$ $start_top_searches$">
                    <query>| tstats max("TOP_AIX.pct_CPU") AS pct_CPU from datamodel=NMON_Data_TOP
where (nodename = TOP_AIX) (host=$host$)
groupby _time, "TOP_AIX.frameID", host, "TOP_AIX.logical_cpus", "TOP_AIX.virtual_cpus", "TOP_AIX.Command", "TOP_AIX.PID" prestats=true span=1m
| stats dedup_splitvals=t max("TOP_AIX.pct_CPU") AS pct_CPU by _time, "TOP_AIX.frameID", host, "TOP_AIX.logical_cpus", "TOP_AIX.virtual_cpus", "TOP_AIX.Command", "TOP_AIX.PID"
| rename "TOP_AIX.frameID" AS frameID, "TOP_AIX.logical_cpus" AS logical_cpus, "TOP_AIX.virtual_cpus" AS virtual_cpus, "TOP_AIX.Command" AS Command "TOP_AIX.PID" AS PID
| eval limit=(logical_cpus*100) | where (pct_CPU&lt;=limit)
| eval smt_threads=(logical_cpus/virtual_cpus) | eval pct_CPU=case(isnum(smt_threads) AND smt_threads&gt;="2", pct_CPU*1.2, isnum(smt_threads) AND smt_threads&gt;="4", pct_CPU*1.4, isnum(smt_threads), pct_CPU)
| stats sum(pct_CPU) As pct_CPU,last(logical_cpus) As logical_cpus by _time,frameID,host,Command
| eval usage_per_core=(pct_CPU/100)
| stats sum(usage_per_core) As value by _time,frameID,host,Command
| eval frameID=if(isnull(frameID), "aggreg", frameID)
| stats max(value) as "max CPU usage per core", avg(value) as "avg CPU usage per core", sparkline(max(value)) As sparkline by Command
| foreach *CPU* [ eval &lt;&lt;FIELD&gt;&gt;=round('&lt;&lt;FIELD&gt;&gt;', 3) ]
| sort - "max CPU usage per core"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="wrap">true</option>
                <option name="rowNumbers">false</option>
                <option name="dataOverlayMode">none</option>
                <option name="drilldown">cell</option>
                <option name="count">10</option>
                <option name="refresh.display">none</option>
                <!-- Set sparkline options here; make sure that field matches field name of the search results -->
                <format type="sparkline" field="sparkline">
                    <option name="lineColor">#5379af</option>
                    <option name="fillColor">#CCDDFF</option>
                    <option name="lineWidth">1</option>
                    <option name="height">25</option>
                </format>
            </table>
            <table depends="$is_Solaris$">
                <title>Table stats: CPU Usage in logical core per Command invocation</title>
                <search depends="$is_Solaris$ $show_processes$ $start_top_searches$">
                    <query>| tstats max("TOP_Solaris.pct_CPU") AS pct_CPU from datamodel=NMON_Data_TOP.TOP_Solaris
where (nodename = TOP_Solaris) (host=$host$)
groupby _time, "TOP_Solaris.frameID", host, "TOP_Solaris.logical_cpus", "TOP_Solaris.Command", "TOP_Solaris.PID" prestats=true span=1m
| stats dedup_splitvals=t max("TOP_Solaris.pct_CPU") AS pct_CPU by _time, "TOP_Solaris.frameID", host, "TOP_Solaris.logical_cpus", "TOP_Solaris.Command", "TOP_Solaris.PID"
| rename "TOP_Solaris.frameID" AS frameID "TOP_Solaris.logical_cpus" AS logical_cpus "TOP_Solaris.Command" AS Command "TOP_Solaris.PID" AS PID
| eval limit=(logical_cpus*100) | where (pct_CPU&lt;=limit)
| stats sum(pct_CPU) As pct_CPU,last(logical_cpus) As logical_cpus by _time,frameID,host,Command
| eval usage_per_core=(pct_CPU/100)
| stats sum(usage_per_core) As value by _time,frameID,host,Command
| eval frameID=if(isnull(frameID), "aggreg", frameID)
| stats max(value) as "max CPU usage per core", avg(value) as "avg CPU usage per core", sparkline(max(value)) As sparkline by Command
| foreach *CPU* [ eval &lt;&lt;FIELD&gt;&gt;=round('&lt;&lt;FIELD&gt;&gt;', 3) ]
| sort - "max CPU usage per core"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="wrap">true</option>
                <option name="rowNumbers">false</option>
                <option name="dataOverlayMode">none</option>
                <option name="drilldown">cell</option>
                <option name="count">10</option>
                <option name="refresh.display">none</option>
                <!-- Set sparkline options here; make sure that field matches field name of the search results -->
                <format type="sparkline" field="sparkline">
                    <option name="lineColor">#5379af</option>
                    <option name="fillColor">#CCDDFF</option>
                    <option name="lineWidth">1</option>
                    <option name="height">25</option>
                </format>
            </table>
        </panel>

        <!-- Table stats of Memory processes usage -->

        <panel>
            <table depends="$is_Linux$">
                <title>Table stats: Memory Usage per command invocation</title>
                <search depends="$is_Linux$ $show_processes$ $start_top_searches$">
                    <query>| tstats max("TOP_Linux.ResSet") AS ResSet from datamodel=NMON_Data_TOP.TOP_Linux
where (nodename = TOP_Linux) (host=$host$)
groupby _time, host, "TOP_Linux.logical_cpus", "TOP_Linux.Command", "TOP_Linux.PID" prestats=true span=1m
| stats dedup_splitvals=t max("TOP_Linux.ResSet") AS ResSet by _time, host, "TOP_Linux.logical_cpus", "TOP_Linux.Command", "TOP_Linux.PID"
| rename "TOP_Linux.logical_cpus" AS logical_cpus "TOP_Linux.Command" AS Command "TOP_Linux.PID" AS PID
| eval Used_Mem_MB=((ResSet)/1024)
| stats sum(Used_Mem_MB) As value by _time,Command
| stats max(value) as "max memory usage (MB)", avg(value) as "avg memory usage (MB)", sparkline(max(value)) as sparkline by Command
| foreach *MB* [ eval &lt;&lt;FIELD&gt;&gt;=round('&lt;&lt;FIELD&gt;&gt;', 0) ]
| sort - "max memory usage (MB)"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="wrap">true</option>
                <option name="rowNumbers">false</option>
                <option name="dataOverlayMode">none</option>
                <option name="drilldown">cell</option>
                <option name="count">10</option>
                <option name="refresh.display">none</option>
                <!-- Set sparkline options here; make sure that field matches field name of the search results -->
                <format type="sparkline" field="sparkline">
                    <option name="lineColor">#5379af</option>
                    <option name="fillColor">#CCDDFF</option>
                    <option name="lineWidth">1</option>
                    <option name="height">25</option>
                </format>
            </table>
            <table depends="$is_AIX$">
                <title>Table stats: Memory Usage per command invocation</title>
                <search depends="$is_AIX$ $show_processes$ $start_top_searches$">
                    <query>| tstats max("TOP_AIX.ResText") AS ResText max("TOP_AIX.ResData") AS ResData from datamodel=NMON_Data_TOP where (nodename = TOP_AIX) (host=$host$) groupby _time, "TOP_AIX.frameID", host, "TOP_AIX.Command", "TOP_AIX.PID" prestats=true span=1m
| stats dedup_splitvals=t max("TOP_AIX.ResText") AS ResText max("TOP_AIX.ResData") AS ResData by _time, "TOP_AIX.frameID", host, "TOP_AIX.Command", "TOP_AIX.PID"
| rename "TOP_AIX.*" AS *
| eval Used_Mem_MB=((ResData+ResText)/1024)
| stats sum(Used_Mem_MB) As value by _time,frameID,host,Command
| stats max(value) as max_Used_Mem_MB, avg(value) as avg_Used_Mem_MB, sparkline(max(value)) as sparkline by Command | eval max_Used_Mem_MB=round(max_Used_Mem_MB,2) | eval avg_Used_Mem_MB=round(avg_Used_Mem_MB,2)
| sort - "avg_Used_Mem_MB"
| rename max_Used_Mem_MB AS "max memory usage (MB)", avg_Used_Mem_MB AS "avg memory usage (MB)"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="wrap">true</option>
                <option name="rowNumbers">false</option>
                <option name="dataOverlayMode">none</option>
                <option name="drilldown">cell</option>
                <option name="count">10</option>
                <option name="refresh.display">none</option>
                <!-- Set sparkline options here; make sure that field matches field name of the search results -->
                <format type="sparkline" field="sparkline">
                    <option name="lineColor">#5379af</option>
                    <option name="fillColor">#CCDDFF</option>
                    <option name="lineWidth">1</option>
                    <option name="height">25</option>
                </format>
            </table>
            <table depends="$is_Solaris$">
                <title>Table stats: Physical Memory Usage per command invocation</title>
                <search depends="$is_Solaris$ $show_processes$ $start_top_searches$">
                    <query>| tstats max("TOP_Solaris.ResSize") AS ResSize from datamodel=NMON_Data_TOP.TOP_Solaris
where (nodename = TOP_Solaris) (host=$host$)
groupby _time, "TOP_Solaris.frameID", host, "TOP_Solaris.logical_cpus", "TOP_Solaris.Command", "TOP_Solaris.PID" prestats=true span=1m
| stats dedup_splitvals=t max("TOP_Solaris.ResSize") AS ResSize by _time, "TOP_Solaris.frameID", host, "TOP_Solaris.logical_cpus", "TOP_Solaris.Command", "TOP_Solaris.PID"
| rename "TOP_Solaris.frameID" AS frameID "TOP_Solaris.logical_cpus" AS logical_cpus "TOP_Solaris.Command" AS Command "TOP_Solaris.PID" AS PID
| eval Phys_Mem_MB=round(((ResSize)/1024),2)
| stats sum(Phys_Mem_MB) As value by _time,frameID,host,Command
| stats max(value) as "max memory usage (MB)", avg(value) as "avg memory usage (MB)", sparkline(max(value)) as sparkline by Command
| foreach *MB* [ eval &lt;&lt;FIELD&gt;&gt;=round('&lt;&lt;FIELD&gt;&gt;', 0) ]
| sort - "max memory usage (MB)"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="wrap">true</option>
                <option name="rowNumbers">false</option>
                <option name="dataOverlayMode">none</option>
                <option name="drilldown">cell</option>
                <option name="count">10</option>
                <option name="refresh.display">none</option>
                <!-- Set sparkline options here; make sure that field matches field name of the search results -->
                <format type="sparkline" field="sparkline">
                    <option name="lineColor">#5379af</option>
                    <option name="fillColor">#CCDDFF</option>
                    <option name="lineWidth">1</option>
                    <option name="height">25</option>
                </format>
            </table>
        </panel>
    </row>

    <row depends="$show_processes$">
        <panel>
            <html>
                <div class="dashseparator">
                    <h1>End extended processes stats</h1>
                </div>
            </html>
        </panel>
    </row>

    <row>
        <panel id="network">
            <title>Inbound/Outbound network traffic</title>
            <chart>
                <search>
                    <query>| tstats max("NET_Data_types.value") AS NET_Data_types.value from datamodel=NMON_Data_NET
where (nodename = NET_Data_types.NET) (host="$host$") (NET_Data_types.device!="*lo*")
groupby _time, host, "NET_Data_types.device" prestats=true span=1m
| stats dedup_splitvals=t max("NET_Data_types.value") AS NET_Data_types.value by _time, host, "NET_Data_types.device"
| rename "NET_Data_types.*" AS *
| eval value=round((value),2)
| eval traffic_type=case(match(device, ".+read.+"), "Inbound", match(device, ".+write.+"), "Outbound")
| eval value=case(traffic_type="Outbound", "-" . value, traffic_type="Inbound", value)
| timechart $span$ avg(value) as value by traffic_type</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <sampleRatio>1</sampleRatio>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.text">KBps</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">area</option>
                <option name="charting.chart.bubbleMaximumSize">50</option>
                <option name="charting.chart.bubbleMinimumSize">10</option>
                <option name="charting.chart.bubbleSizeBy">area</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">350</option>
                <option name="charting.axisTitleX.text">Time</option>
            </chart>
        </panel>
    </row>

    <row>
        <panel id="fs_df_storage" depends="$start_df_storage_search$">
            <title>File System usage statistics (external DF_STORAGE collection)</title>
            <table id="tablebar">
                <search depends="$start_df_storage_search$">
                    <query>| tstats latest(JFS.storage) AS storage, latest(JFS.storage_free) AS storage_free, latest(JFS.storage_used) AS storage_used, latest(JFS.storage_free_percent) AS storage_free_percent, latest(JFS.storage_used_percent) AS storage_used_percent from datamodel=NMON_Data_JFS where (nodename = JFS.DF_STORAGE) (host=$host$) groupby JFS.mount prestats=true
| stats dedup_splitvals=t latest(JFS.storage) AS storage, latest(JFS.storage_free) AS storage_free, latest(JFS.storage_used) AS storage_used, latest(JFS.storage_free_percent) AS storage_free_percent, latest(JFS.storage_used_percent) AS storage_used_percent by JFS.mount
| sort limit=0 mount
| rename "JFS.mount" AS "mount"
| fields mount, storage, storage_free,storage_used,storage_free_percent,storage_used_percent
| foreach storage, storage_free,storage_used [ eval &lt;&lt;FIELD&gt;&gt; = round('&lt;&lt;FIELD&gt;&gt;'/1024, 2) ]
| foreach storage*percent [ eval &lt;&lt;FIELD&gt;&gt; = round('&lt;&lt;FIELD&gt;&gt;', 2) ]
| rename storage as "storage (GB)", storage_free as "storage free (GB)", storage_used as "storage used (GB)", storage_free_percent as "storage free (%)", storage_used_percent as "storage used (%)"
| eval UsedPct=if(isnum('storage used (%)'), 'storage used (%)', 0 )
| fields mount, "storage (GB)", "storage free (GB)", "storage used (GB)", "storage free (%)", "storage used (%)", UsedPct
| appendpipe [ stats sum("storage (GB)") as "storage (GB)", sum("storage free (GB)") as "storage free (GB)", sum("storage used (GB)") as "storage used (GB)" ]
| eval "storage free (%)" = if(isnull('storage free (%)'), (('storage free (GB)'/'storage (GB)')*100), 'storage free (%)'), "storage used (%)" = if(isnull('storage used (%)'), (('storage used (GB)'/'storage (GB)')*100), 'storage used (%)'), UsedPct = if(isnull(UsedPct), 'storage used (%)', UsedPct)
| fillnull value="*** TOTAL GB / AVERAGE % ****" mount
| foreach storage*%* UsedPct [ eval &lt;&lt;FIELD&gt;&gt; = round('&lt;&lt;FIELD&gt;&gt;', 2) ]</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="wrap">true</option>
                <option name="rowNumbers">false</option>
                <option name="dataOverlayMode">none</option>
                <option name="drilldown">row</option>
                <option name="count">10</option>
                <option name="refresh.display">none</option>
            </table>
        </panel>
        <panel id="fs_jfs" depends="$start_jfs_storage_search$">
            <title>File System Percent utilization (internal JFSFILE collection)</title>
            <table id="tablebar2">
                <search depends="$start_jfs_storage_search$">
                    <query>| tstats max("JFS.value") AS JFS.value from datamodel=NMON_Data_JFS
where (nodename = JFS.JFSFILE) (JFS.value&gt;=0) (host=$host$) groupby _time, host, "JFS.device" prestats=true
| stats dedup_splitvals=t max("JFS.value") AS JFS.value by _time, "JFS.device"
| rename "JFS.device" AS device, "JFS.value" AS value
| stats max(value) AS max_value, avg(value) AS avg_value, min(value) AS min_value, latest(value) AS UsedPct by "device"
| sort limit=0 device | rename device AS "Mount point"
| eval value=round(value,2)
| fields "Mount point",max_value, avg_value, min_value, UsedPct | eval avg_value=round(avg_value,2)
| rename max_value AS "Max value in period (%)", avg_value AS "Average value in period (%)", min_value AS "Min value in Period (%)"</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="wrap">true</option>
                <option name="rowNumbers">false</option>
                <option name="dataOverlayMode">none</option>
                <option name="drilldown">row</option>
                <option name="count">10</option>
                <option name="refresh.display">none</option>
            </table>
        </panel>
    </row>

    <!-- ######################################### Active Buttons #########################################  -->

    <row>
        <panel depends="$start_df_storage_search$">
            <html>
                <div class="custom-sub-nav" style="text-align: center;">
                    <button class="button2_lowpadding glow" data-token-name="show_df_storage_overtime" data-alt-label="HIDE FILE-SYSTEMS OVER TIME" data-token-value="true">SHOW FILE-SYSTEMS EVOLUTION OVER TIME</button>
                </div>
            </html>
        </panel>
        <panel depends="$start_jfs_storage_search$">
            <html>
                <div class="custom-sub-nav" style="text-align: center;">
                    <button class="button2_lowpadding glow" data-token-name="show_jfs_storage_overtime" data-alt-label="HIDE FILE-SYSTEMS OVER TIME" data-token-value="true">SHOW FILE-SYSTEMS EVOLUTION OVER TIME</button>
                </div>
            </html>
        </panel>
    </row>

    <!-- ######################################### filesystem over time #########################################  -->

    <row depends="$start_df_storage_search$ $show_df_storage_overtime$">
        <panel>
            <title>File systems utilization evolution over time</title>

            <input type="text" token="df_storage_mount">
              <label>mount</label>
              <default>*</default>
            </input>

            <input type="dropdown" token="df_storage_monitor">
                <label>Monitor:</label>
                <choice value="storage">storage (volume size)</choice>
                <choice value="storage_free">storage_free (volume free)</choice>
                <choice value="storage_used">storage_used (volume used)</choice>
                <choice value="storage_free_percent">storage_free_percent (%)</choice>
                <choice value="storage_used_percent">storage_used_percent (%)</choice>
                <default>storage_used_percent</default>
                <change>
                    <condition value="storage">
                        <unset token="form.df_storage_monitor_unit"></unset>
                        <set token="df_storage_show_unit">true</set>
                        <unset token="df_storage_monitor_max_chart"></unset>
                    </condition>
                    <condition value="storage_free">
                        <unset token="form.df_storage_monitor_unit"></unset>
                        <set token="df_storage_show_unit">true</set>
                        <unset token="df_storage_monitor_max_chart"></unset>
                    </condition>
                    <condition value="storage_used">
                        <unset token="form.df_storage_monitor_unit"></unset>
                        <set token="df_storage_show_unit">true</set>
                        <unset token="df_storage_monitor_max_chart"></unset>
                    </condition>
                    <condition value="storage_free_percent">
                        <set token="df_storage_unit">%</set>
                        <unset token="df_storage_show_unit"></unset>
                        <set token="df_storage_monitor_max_chart">101</set>
                    </condition>
                    <condition value="storage_used_percent">
                        <set token="form.df_storage_monitor_unit">pct</set>
                        <set token="df_storage_monitor_max_chart">101</set>
                        <unset token="df_storage_show_unit"></unset>
                    </condition>
                </change>
            </input>

            <input type="dropdown" token="df_storage_monitor_unit" depends="$df_storage_show_unit$">
                <label>Unit:</label>
                <choice value="MB">MB</choice>
                <choice value="GB">GB</choice>
                <choice value="TB">TB</choice>
                <default>GB</default>
                <change>
                    <condition value="MB">
                        <set token="df_storage_unit_math">value</set>
                        <set token="df_storage_unit_legend">MB</set>
                    </condition>
                    <condition value="GB">
                        <set token="df_storage_unit_math">value/1024</set>
                        <set token="df_storage_unit_legend">GB</set>
                    </condition>
                    <condition value="TB">
                        <set token="df_storage_unit_math">value/1024/1204</set>
                        <set token="df_storage_unit_legend">TB</set>
                    </condition>
                    <condition value="pct">
                        <set token="df_storage_unit_math">value</set>
                        <set token="df_storage_unit_legend">pct</set>
                    </condition>
                </change>
            </input>

            <chart>
                <search depends="$show_df_storage_overtime$">
                    <query>| tstats latest(JFS.$df_storage_monitor$) AS value from datamodel=NMON_Data_JFS where (nodename = JFS.DF_STORAGE) (host=$host$) (JFS.mount="$df_storage_mount$") groupby _time, JFS.mount prestats=true $span$
| stats dedup_splitvals=t latest(JFS.$df_storage_monitor$) AS value by _time, JFS.mount
| sort limit=0 _time
| rename "JFS.mount" AS "mount" | eval value=$df_storage_unit_math$
| timechart $span$ latest(value) as $df_storage_monitor$ by mount</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
                <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
                <option name="charting.axisTitleX.visibility">collapsed</option>
                <option name="charting.axisTitleY.text">$df_storage_unit_legend$</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisTitleY2.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.axisY2.enabled">0</option>
                <option name="charting.axisY2.scale">inherit</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.nullValueMode">gaps</option>
                <option name="charting.chart.showDataLabels">none</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">none</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">bottom</option>
                <option name="height">500</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.maximumNumber">$df_storage_monitor_max_chart$</option>
            </chart>
        </panel>

    </row>

    <row depends="$show_jfs_storage_overtime$ $show_jfs_storage_overtime$">
        <panel>
            <title>File systems utilization evolution over time</title>

            <input type="text" token="fsfilter" searchWhenChanged="true">
                <label>Filter FileSystems by pattern:</label>
                <default>*</default>
                <prefix>JFS.device="</prefix>
                <suffix>"</suffix>
            </input>

            <chart>
                <search depends="$show_jfs_storage_overtime$">
                    <query>| tstats max("JFS.value") AS JFS.value from datamodel=NMON_Data_JFS
where (nodename = JFS.JFSFILE) (JFS.value&gt;=0) (host=$host$) ($fsfilter$) groupby _time, host, "JFS.device" prestats=true span=1m
| stats dedup_splitvals=t max("JFS.value") AS JFS.value by _time, host, "JFS.device"
| rename "JFS.*" AS *
| timechart $span$ limit=0 useother=f max(value) As value by device</query>
                    <earliest>$timerange.earliest$</earliest>
                    <latest>$timerange.latest$</latest>
                    <refresh>$refresh$</refresh>
                    <refreshType>delay</refreshType>
                </search>
                <option name="charting.axisTitleX.visibility">visible</option>
                <option name="charting.axisTitleY.visibility">visible</option>
                <option name="charting.axisX.scale">linear</option>
                <option name="charting.axisY.scale">linear</option>
                <option name="charting.chart">line</option>
                <option name="charting.chart.nullValueMode">connect</option>
                <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
                <option name="charting.chart.stackMode">default</option>
                <option name="charting.chart.style">shiny</option>
                <option name="charting.drilldown">all</option>
                <option name="charting.layout.splitSeries">0</option>
                <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
                <option name="charting.legend.placement">$charting.legend.placement$</option>
                <option name="height">500</option>
                <option name="charting.axisTitleX.text">Time</option>
                <option name="charting.axisTitleY.text">% Used</option>
                <option name="charting.axisY.minimumNumber">0</option>
                <option name="charting.axisY.maximumNumber">100</option>
                <option name="refresh.display">none</option>
            </chart>
        </panel>
    </row>
    
</form>
